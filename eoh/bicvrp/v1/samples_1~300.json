[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route segment relocation with adaptive route merging, intelligently balancing distance reduction and makespan minimization by dynamically adjusting segment sizes and merge priorities based on demand and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4551591486070361,
            4.601474553346634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route segment relocation with adaptive route merging, intelligently balancing distance reduction and makespan minimization by dynamically adjusting segment sizes and merge priorities based on demand and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4551591486070361,
            4.601474553346634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route segment relocation with adaptive route merging, intelligently balancing distance reduction and makespan minimization by dynamically adjusting segment sizes and merge priorities based on demand and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4551591486070361,
            4.601474553346634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Adaptive segment relocation with demand-aware merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a segment to relocate\n        start = random.randint(1, len(route) - 2)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end+1]\n        segment_demand = np.sum(demand[segment])\n\n        # Find best insertion point in another route\n        best_route_idx = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j]\n            if np.sum(demand[candidate_route]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost\n                prev_node = candidate_route[pos-1]\n                next_node = candidate_route[pos]\n                current_cost = distance_matrix[prev_node][next_node]\n                new_cost = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_cost:\n                    best_cost = cost_diff\n                    best_route_idx = j\n                    best_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_route_idx != -1:\n            # Remove segment from original route\n            new_solution[i] = np.concatenate([route[:start], route[end+1:]])\n            # Insert into new route\n            candidate_route = new_solution[best_route_idx]\n            new_route = np.concatenate([\n                candidate_route[:best_pos],\n                segment,\n                candidate_route[best_pos:]\n            ])\n            new_solution[best_route_idx] = new_route\n\n    # Additional: Adaptive route merging for makespan reduction\n    if len(new_solution) > 1:\n        # Sort routes by makespan (descending)\n        sorted_routes = sorted(new_solution, key=lambda r: -np.sum(distance_matrix[r[:-1], r[1:]]))\n\n        for i in range(len(sorted_routes)-1):\n            for j in range(i+1, len(sorted_routes)):\n                route1 = sorted_routes[i]\n                route2 = sorted_routes[j]\n\n                if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                    # Calculate potential makespan reduction\n                    current_makespan = max(\n                        np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                        np.sum(distance_matrix[route2[:-1], route2[1:]])\n                    )\n\n                    # Try merging route2 into route1\n                    merged_route = np.concatenate([\n                        route1[:-1],  # exclude last depot of route1\n                        route2[1:]    # exclude first depot of route2\n                    ])\n\n                    merged_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                    if merged_makespan < current_makespan:\n                        # Update the solution\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A hybrid local search strategy combining route fragmentation and segment insertion with capacity-aware swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.7951163252414595,
            1.834746092557907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A hybrid local search strategy combining route fragmentation and segment insertion with capacity-aware swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.7951163252414595,
            1.834746092557907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A hybrid local search strategy combining route fragmentation and segment insertion with capacity-aware swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.7951163252414595,
            1.834746092557907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Fragment the route into smaller segments\n    segments = []\n    current_segment = [route[0]]\n    current_load = 0\n    for node in route[1:-1]:\n        if current_load + demand[node] <= capacity:\n            current_segment.append(node)\n            current_load += demand[node]\n        else:\n            current_segment.append(0)\n            segments.append(current_segment)\n            current_segment = [0, node]\n            current_load = demand[node]\n    current_segment.append(0)\n    segments.append(current_segment)\n\n    # Randomly select a segment to move\n    if len(segments) > 1:\n        segment_idx = np.random.randint(1, len(segments))\n        segment = segments.pop(segment_idx)\n\n        # Try to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i != route_idx:\n                # Check if the segment can be inserted without exceeding capacity\n                total_load = sum(demand[node] for node in selected_solution[i])\n                segment_load = sum(demand[node] for node in segment[1:-1])\n                if total_load + segment_load <= capacity:\n                    # Insert the segment into the existing route\n                    insert_pos = np.random.randint(1, len(selected_solution[i]))\n                    new_route = np.concatenate([selected_solution[i][:insert_pos], segment[1:-1], selected_solution[i][insert_pos:]])\n                    selected_solution[i] = new_route\n                    break\n        else:\n            # Create a new route if no suitable insertion found\n            selected_solution.append(segment)\n\n    # Apply a capacity-aware swap to balance makespan and distance\n    for i in range(len(selected_solution)):\n        route = selected_solution[i]\n        if len(route) > 3:\n            # Find two nodes that can be swapped without exceeding capacity\n            for _ in range(10):  # Try up to 10 random swaps\n                a, b = np.random.choice(range(1, len(route)-1), 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if the swap maintains capacity constraints\n                segment_a = route[a:b]\n                segment_b = route[b:a]\n                if (sum(demand[node] for node in segment_a) + sum(demand[node] for node in route[:a]) <= capacity and\n                    sum(demand[node] for node in segment_b) + sum(demand[node] for node in route[b:]) <= capacity):\n                    # Perform the swap\n                    new_route = np.concatenate([route[:a], segment_b, route[a:b], segment_a, route[b:]])\n                    selected_solution[i] = new_route\n                    break\n\n    # Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel \"route-splitting and merging\" operator to generate a neighbor solution by intelligently merging or splitting routes while ensuring feasibility through capacity and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, (dist, makespan) in archive:\n        if selected_solution is None or (dist < selected_solution[1][0] and makespan > selected_solution[1][1]):\n            selected_solution = (sol, (dist, makespan))\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Merge routes if their total demand is within capacity\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge route_j into route_i\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution = [route for idx, route in enumerate(new_solution) if idx != j]\n        else:\n            # Split one of the routes at a random position\n            route_to_split = random.choice([route_i, route_j])\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            split_route1 = route_to_split[:split_pos + 1]\n            split_route2 = np.concatenate([[0], route_to_split[split_pos:-1], [0]])\n\n            # Replace the original route with the split routes\n            if np.array_equal(route_to_split, route_i):\n                new_solution[i] = split_route1\n                new_solution.insert(i + 1, split_route2)\n            else:\n                new_solution[j] = split_route1\n                new_solution.insert(j + 1, split_route2)\n\n    # Ensure all routes are feasible (demand constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7553518515535755,
            0.32622796297073364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, (dist, makespan) in archive:\n        if selected_solution is None or (dist < selected_solution[1][0] and makespan > selected_solution[1][1]):\n            selected_solution = (sol, (dist, makespan))\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Merge routes if their total demand is within capacity\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge route_j into route_i\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution = [route for idx, route in enumerate(new_solution) if idx != j]\n        else:\n            # Split one of the routes at a random position\n            route_to_split = random.choice([route_i, route_j])\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            split_route1 = route_to_split[:split_pos + 1]\n            split_route2 = np.concatenate([[0], route_to_split[split_pos:-1], [0]])\n\n            # Replace the original route with the split routes\n            if np.array_equal(route_to_split, route_i):\n                new_solution[i] = split_route1\n                new_solution.insert(i + 1, split_route2)\n            else:\n                new_solution[j] = split_route1\n                new_solution.insert(j + 1, split_route2)\n\n    # Ensure all routes are feasible (demand constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel \"route-splitting and merging\" operator to generate a neighbor solution by intelligently merging or splitting routes while ensuring feasibility through capacity and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, (dist, makespan) in archive:\n        if selected_solution is None or (dist < selected_solution[1][0] and makespan > selected_solution[1][1]):\n            selected_solution = (sol, (dist, makespan))\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Merge routes if their total demand is within capacity\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge route_j into route_i\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution = [route for idx, route in enumerate(new_solution) if idx != j]\n        else:\n            # Split one of the routes at a random position\n            route_to_split = random.choice([route_i, route_j])\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            split_route1 = route_to_split[:split_pos + 1]\n            split_route2 = np.concatenate([[0], route_to_split[split_pos:-1], [0]])\n\n            # Replace the original route with the split routes\n            if np.array_equal(route_to_split, route_i):\n                new_solution[i] = split_route1\n                new_solution.insert(i + 1, split_route2)\n            else:\n                new_solution[j] = split_route1\n                new_solution.insert(j + 1, split_route2)\n\n    # Ensure all routes are feasible (demand constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7553518515535755,
            0.32622796297073364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, (dist, makespan) in archive:\n        if selected_solution is None or (dist < selected_solution[1][0] and makespan > selected_solution[1][1]):\n            selected_solution = (sol, (dist, makespan))\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or split\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Merge routes if their total demand is within capacity\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge route_j into route_i\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            new_solution = [route for idx, route in enumerate(new_solution) if idx != j]\n        else:\n            # Split one of the routes at a random position\n            route_to_split = random.choice([route_i, route_j])\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            split_route1 = route_to_split[:split_pos + 1]\n            split_route2 = np.concatenate([[0], route_to_split[split_pos:-1], [0]])\n\n            # Replace the original route with the split routes\n            if np.array_equal(route_to_split, route_i):\n                new_solution[i] = split_route1\n                new_solution.insert(i + 1, split_route2)\n            else:\n                new_solution[j] = split_route1\n                new_solution.insert(j + 1, split_route2)\n\n    # Ensure all routes are feasible (demand constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route splitting, customer reallocation, and makespan-aware 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        route_demand = sum(demand[node] for node in route[1:-1])\n        return route_demand <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider splitting if route has more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Customer reallocation (move a random customer to a random route)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Only if route has more than one customer\n            customer_pos = random.randint(1, len(route1)-2)\n            customer = route1[customer_pos]\n\n            # Try to insert into another route\n            route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n            route2 = new_solution[route2_idx]\n\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                if is_feasible(new_route):\n                    cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                if is_feasible(new_route1) and is_feasible(new_route2):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Step 3: Makespan-aware 2-opt (optimize the longest route)\n    if len(new_solution) > 1:\n        # Find the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        route = new_solution[longest_route_idx]\n\n        # Perform 2-opt on the longest route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    if j == i+1:\n                        continue  # Skip adjacent nodes\n                    # Try reversing the segment\n                    new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n                    if is_feasible(new_route):\n                        # Calculate cost change\n                        old_cost = (distance_matrix[route[i-1]][route[i]] +\n                                   distance_matrix[route[j]][route[j+1]])\n                        new_cost = (distance_matrix[route[i-1]][route[j]] +\n                                   distance_matrix[route[i]][route[j+1]])\n                        if new_cost < old_cost:\n                            route = new_route\n                            improved = True\n                            break\n                if improved:\n                    break\n            if improved:\n                new_solution[longest_route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.5135733726272925,
            3.9537331759929657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        route_demand = sum(demand[node] for node in route[1:-1])\n        return route_demand <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider splitting if route has more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Customer reallocation (move a random customer to a random route)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Only if route has more than one customer\n            customer_pos = random.randint(1, len(route1)-2)\n            customer = route1[customer_pos]\n\n            # Try to insert into another route\n            route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n            route2 = new_solution[route2_idx]\n\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                if is_feasible(new_route):\n                    cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                if is_feasible(new_route1) and is_feasible(new_route2):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Step 3: Makespan-aware 2-opt (optimize the longest route)\n    if len(new_solution) > 1:\n        # Find the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        route = new_solution[longest_route_idx]\n\n        # Perform 2-opt on the longest route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    if j == i+1:\n                        continue  # Skip adjacent nodes\n                    # Try reversing the segment\n                    new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n                    if is_feasible(new_route):\n                        # Calculate cost change\n                        old_cost = (distance_matrix[route[i-1]][route[i]] +\n                                   distance_matrix[route[j]][route[j+1]])\n                        new_cost = (distance_matrix[route[i-1]][route[j]] +\n                                   distance_matrix[route[i]][route[j+1]])\n                        if new_cost < old_cost:\n                            route = new_route\n                            improved = True\n                            break\n                if improved:\n                    break\n            if improved:\n                new_solution[longest_route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route segment reversal and inter-route customer swaps to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(sorted_archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segment reversal and inter-route customer swaps\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Apply route segment reversal (2-opt variant)\n        if len(route1) > 3:\n            i, j = sorted(np.random.choice(range(1, len(route1)-1), size=2, replace=False))\n            reversed_segment = route1[i:j+1][::-1]\n            candidate_route = np.concatenate([route1[:i], reversed_segment, route1[j+1:]])\n            if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                route1[:] = candidate_route\n\n        # Apply inter-route customer swap\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check feasibility after swap\n            if (np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8840872615615576,
            1.7813679575920105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(sorted_archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segment reversal and inter-route customer swaps\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Apply route segment reversal (2-opt variant)\n        if len(route1) > 3:\n            i, j = sorted(np.random.choice(range(1, len(route1)-1), size=2, replace=False))\n            reversed_segment = route1[i:j+1][::-1]\n            candidate_route = np.concatenate([route1[:i], reversed_segment, route1[j+1:]])\n            if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                route1[:] = candidate_route\n\n        # Apply inter-route customer swap\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check feasibility after swap\n            if (np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route segment reversal and inter-route customer swaps to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(sorted_archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segment reversal and inter-route customer swaps\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Apply route segment reversal (2-opt variant)\n        if len(route1) > 3:\n            i, j = sorted(np.random.choice(range(1, len(route1)-1), size=2, replace=False))\n            reversed_segment = route1[i:j+1][::-1]\n            candidate_route = np.concatenate([route1[:i], reversed_segment, route1[j+1:]])\n            if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                route1[:] = candidate_route\n\n        # Apply inter-route customer swap\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check feasibility after swap\n            if (np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8840872615615576,
            1.7813679575920105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(sorted_archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segment reversal and inter-route customer swaps\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Apply route segment reversal (2-opt variant)\n        if len(route1) > 3:\n            i, j = sorted(np.random.choice(range(1, len(route1)-1), size=2, replace=False))\n            reversed_segment = route1[i:j+1][::-1]\n            candidate_route = np.concatenate([route1[:i], reversed_segment, route1[j+1:]])\n            if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                route1[:] = candidate_route\n\n        # Apply inter-route customer swap\n        if len(route1) > 2 and len(route2) > 2:\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check feasibility after swap\n            if (np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of makespan and distance improvement potential, then applies a novel \"route segment reallocation and inversion\" operator that intelligently reassigns customer segments between routes while respecting capacity constraints and optionally inverts segments to reduce travel distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)  # Prioritize makespan but consider distance\n    selected_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_index][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reallocation and inversion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check capacity constraint for route2\n            segment_demand = np.sum(demand[segment])\n            if np.sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Optionally invert the segment\n                if random.random() < 0.5:\n                    segment = segment[::-1]\n\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8337848209893847,
            0.9521255493164062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)  # Prioritize makespan but consider distance\n    selected_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_index][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reallocation and inversion\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check capacity constraint for route2\n            segment_demand = np.sum(demand[segment])\n            if np.sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Optionally invert the segment\n                if random.random() < 0.5:\n                    segment = segment[::-1]\n\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: Route Swap + Node Insertion\n    # Step 1: Randomly select two routes from the solution\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Step 2: Try to swap a segment from route_i to route_j and vice versa\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Select a segment from route_i (excluding depot)\n            start_i = np.random.randint(1, len(route_i) - 2)\n            end_i = np.random.randint(start_i + 1, len(route_i) - 1)\n            segment_i = route_i[start_i:end_i]\n\n            # Check if swapping segment_i to route_j is feasible\n            if sum(demand[segment_i]) <= capacity:\n                # Remove segment_i from route_i\n                new_route_i = np.concatenate([route_i[:start_i], route_i[end_i:]])\n                # Insert segment_i into route_j at a random position\n                pos_j = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Ensure the new routes are valid (start and end with depot)\n                new_solution[i] = np.concatenate([[0], new_route_i[1:], [0]])\n                new_solution[j] = np.concatenate([[0], new_route_j[1:], [0]])\n\n    # Step 3: Try to move a node from one route to another\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 3:\n            # Select a node from route_i (excluding depot)\n            node_pos = np.random.randint(1, len(route_i) - 1)\n            node = route_i[node_pos]\n\n            # Check if moving the node to route_j is feasible\n            if demand[node] <= capacity - sum(demand[route_j[1:-1]]):\n                # Remove the node from route_i\n                new_route_i = np.concatenate([route_i[:node_pos], route_i[node_pos+1:]])\n                # Insert the node into route_j at a random position\n                pos_j = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:pos_j], [node], route_j[pos_j:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Ensure the new routes are valid (start and end with depot)\n                new_solution[i] = np.concatenate([[0], new_route_i[1:], [0]])\n                new_solution[j] = np.concatenate([[0], new_route_j[1:], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6488830173293967,
            0.4845091700553894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: Route Swap + Node Insertion\n    # Step 1: Randomly select two routes from the solution\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Step 2: Try to swap a segment from route_i to route_j and vice versa\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Select a segment from route_i (excluding depot)\n            start_i = np.random.randint(1, len(route_i) - 2)\n            end_i = np.random.randint(start_i + 1, len(route_i) - 1)\n            segment_i = route_i[start_i:end_i]\n\n            # Check if swapping segment_i to route_j is feasible\n            if sum(demand[segment_i]) <= capacity:\n                # Remove segment_i from route_i\n                new_route_i = np.concatenate([route_i[:start_i], route_i[end_i:]])\n                # Insert segment_i into route_j at a random position\n                pos_j = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Ensure the new routes are valid (start and end with depot)\n                new_solution[i] = np.concatenate([[0], new_route_i[1:], [0]])\n                new_solution[j] = np.concatenate([[0], new_route_j[1:], [0]])\n\n    # Step 3: Try to move a node from one route to another\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 3:\n            # Select a node from route_i (excluding depot)\n            node_pos = np.random.randint(1, len(route_i) - 1)\n            node = route_i[node_pos]\n\n            # Check if moving the node to route_j is feasible\n            if demand[node] <= capacity - sum(demand[route_j[1:-1]]):\n                # Remove the node from route_i\n                new_route_i = np.concatenate([route_i[:node_pos], route_i[node_pos+1:]])\n                # Insert the node into route_j at a random position\n                pos_j = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:pos_j], [node], route_j[pos_j:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Ensure the new routes are valid (start and end with depot)\n                new_solution[i] = np.concatenate([[0], new_route_i[1:], [0]])\n                new_solution[j] = np.concatenate([[0], new_route_j[1:], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reallocation, and adaptive 2-opt with a capacity-aware insertion heuristic to balance distance and makespan reduction, ensuring feasibility and intelligent selection of promising solutions from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-based reallocation + adaptive 2-opt\n    for _ in range(3):  # Repeat for 3 iterations\n        # Step 1: Route splitting - split long routes into two if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider routes with enough customers\n                split_pos = random.randint(2, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Demand-based reallocation - move customers between routes\n        for _ in range(2):  # Try 2 reallocations\n            if len(new_solution) < 2:\n                break\n\n            route1, route2 = random.sample(new_solution, 2)\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select a customer from route1\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Find best insertion position in route2\n            min_increase = float('inf')\n            best_pos = -1\n            for pos in range(1, len(route2)):\n                new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[route2[pos-1]][customer] +\n                                   distance_matrix[customer][route2[pos]] -\n                                   distance_matrix[route2[pos-1]][route2[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the move\n                route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                # Update solution\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route1):\n                        new_solution[i] = route1\n                    if np.array_equal(new_solution[i], route2):\n                        new_solution[i] = route2\n\n        # Step 3: Adaptive 2-opt - apply to the longest route\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        for _ in range(5):  # Try 5 2-opt moves\n            i, j = sorted(random.sample(range(1, len(longest_route) - 1), 2))\n            new_route = np.concatenate([longest_route[:i],\n                                      longest_route[i:j][::-1],\n                                      longest_route[j:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                longest_route = new_route\n\n        new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.6004699482624866,
            6.4757832288742065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting + demand-based reallocation + adaptive 2-opt\n    for _ in range(3):  # Repeat for 3 iterations\n        # Step 1: Route splitting - split long routes into two if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider routes with enough customers\n                split_pos = random.randint(2, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Demand-based reallocation - move customers between routes\n        for _ in range(2):  # Try 2 reallocations\n            if len(new_solution) < 2:\n                break\n\n            route1, route2 = random.sample(new_solution, 2)\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select a customer from route1\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Find best insertion position in route2\n            min_increase = float('inf')\n            best_pos = -1\n            for pos in range(1, len(route2)):\n                new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[route2[pos-1]][customer] +\n                                   distance_matrix[customer][route2[pos]] -\n                                   distance_matrix[route2[pos-1]][route2[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the move\n                route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                # Update solution\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route1):\n                        new_solution[i] = route1\n                    if np.array_equal(new_solution[i], route2):\n                        new_solution[i] = route2\n\n        # Step 3: Adaptive 2-opt - apply to the longest route\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        for _ in range(5):  # Try 5 2-opt moves\n            i, j = sorted(random.sample(range(1, len(longest_route) - 1), 2))\n            new_route = np.concatenate([longest_route[:i],\n                                      longest_route[i:j][::-1],\n                                      longest_route[j:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                longest_route = new_route\n\n        new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high total distance and low makespan (indicating potential for improvement), then applies a hybrid local search combining route fragmentation and inter-route insertion to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_idx = min(int(0.3 * len(archive_sorted)), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation and inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes for fragmentation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a feasible split point in route1\n        split_pos = random.randint(1, len(route1) - 2)\n        split_demand = np.sum(demand[route1[:split_pos + 1]])\n        if split_demand <= capacity:\n            # Split route1 into two parts\n            new_route1 = route1[:split_pos + 1]\n            new_route2 = route1[split_pos:]\n\n            # Try to insert new_route2 into route2\n            best_pos = -1\n            best_improvement = 0\n            for i in range(1, len(route2)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate([route2[:i], new_route2[1:-1], route2[i:]])]) <= capacity:\n                    # Calculate improvement in total distance\n                    old_dist = distance_matrix[route2[i-1], route2[i]]\n                    new_dist = distance_matrix[route2[i-1], new_route2[1]] + distance_matrix[new_route2[-2], route2[i]]\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = np.concatenate([route2[:best_pos], new_route2[1:-1], route2[best_pos:]])\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6766682829802488,
            2.537883162498474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_idx = min(int(0.3 * len(archive_sorted)), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation and inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes for fragmentation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find a feasible split point in route1\n        split_pos = random.randint(1, len(route1) - 2)\n        split_demand = np.sum(demand[route1[:split_pos + 1]])\n        if split_demand <= capacity:\n            # Split route1 into two parts\n            new_route1 = route1[:split_pos + 1]\n            new_route2 = route1[split_pos:]\n\n            # Try to insert new_route2 into route2\n            best_pos = -1\n            best_improvement = 0\n            for i in range(1, len(route2)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate([route2[:i], new_route2[1:-1], route2[i:]])]) <= capacity:\n                    # Calculate improvement in total distance\n                    old_dist = distance_matrix[route2[i-1], route2[i]]\n                    new_dist = distance_matrix[route2[i-1], new_route2[1]] + distance_matrix[new_route2[-2], route2[i]]\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = np.concatenate([route2[:best_pos], new_route2[1:-1], route2[best_pos:]])\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{Our algorithm selects a solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route merging and intra-route 3-opt swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge two routes if possible, then apply 3-opt on each route\n    if len(new_solution) > 1:\n        # Try to merge two routes\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge by connecting the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Apply 3-opt on each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select 3 random segments to swap\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Generate all possible permutations of these segments\n            segments = [route[:a], route[a:b], route[b:c], route[c:-1]]\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2], segments[3], [0]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], [0]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], [0]]),\n                np.concatenate([segments[0], segments[2], segments[3], segments[1], [0]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], [0]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], [0]])\n            ]\n            # Find the best permutation that doesn't exceed capacity\n            best_route = route\n            best_cost = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1))\n            for perm in permutations:\n                cost = sum(distance_matrix[perm[j], perm[j+1]] for j in range(len(perm)-1))\n                if cost < best_cost and sum(demand[perm[1:-1]]) <= capacity:\n                    best_route = perm\n                    best_cost = cost\n            new_solution[i] = best_route\n\n    return new_solution\n\n",
        "score": [
            -0.48500695900108237,
            9.281264245510101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: merge two routes if possible, then apply 3-opt on each route\n    if len(new_solution) > 1:\n        # Try to merge two routes\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge by connecting the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Apply 3-opt on each route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select 3 random segments to swap\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Generate all possible permutations of these segments\n            segments = [route[:a], route[a:b], route[b:c], route[c:-1]]\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2], segments[3], [0]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], [0]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], [0]]),\n                np.concatenate([segments[0], segments[2], segments[3], segments[1], [0]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], [0]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], [0]])\n            ]\n            # Find the best permutation that doesn't exceed capacity\n            best_route = route\n            best_cost = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1))\n            for perm in permutations:\n                cost = sum(distance_matrix[perm[j], perm[j+1]] for j in range(len(perm)-1))\n                if cost < best_cost and sum(demand[perm[1:-1]]) <= capacity:\n                    best_route = perm\n                    best_cost = cost\n            new_solution[i] = best_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy() if archive_sorted else archive[0][0].copy()\n\n    # Hybrid local search: route swap followed by demand-aware relocation\n    if len(base_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i].copy(), base_solution[j].copy()\n\n        # Swap entire routes if feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            base_solution[i], base_solution[j] = route2, route1\n\n        # Demand-aware relocation: move high-demand nodes to routes with remaining capacity\n        for route in base_solution:\n            route_demand = np.sum(demand[route[1:-1]])\n            remaining_capacity = capacity - route_demand\n            if remaining_capacity <= 0:\n                continue\n\n            # Find nodes in other routes that can be moved here\n            for other_route in base_solution:\n                if len(other_route) <= 2:\n                    continue\n                for k in range(1, len(other_route)-1):\n                    node = other_route[k]\n                    if demand[node] <= remaining_capacity:\n                        # Insert node into current route\n                        best_pos = 1\n                        min_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1], node] +\n                                   distance_matrix[node, route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                        route = np.insert(route, best_pos, node)\n                        other_route = np.delete(other_route, k)\n                        remaining_capacity -= demand[node]\n                        break\n\n    return base_solution\n\n",
        "score": [
            -0.7568461810020854,
            4.713647723197937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy() if archive_sorted else archive[0][0].copy()\n\n    # Hybrid local search: route swap followed by demand-aware relocation\n    if len(base_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i].copy(), base_solution[j].copy()\n\n        # Swap entire routes if feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n            base_solution[i], base_solution[j] = route2, route1\n\n        # Demand-aware relocation: move high-demand nodes to routes with remaining capacity\n        for route in base_solution:\n            route_demand = np.sum(demand[route[1:-1]])\n            remaining_capacity = capacity - route_demand\n            if remaining_capacity <= 0:\n                continue\n\n            # Find nodes in other routes that can be moved here\n            for other_route in base_solution:\n                if len(other_route) <= 2:\n                    continue\n                for k in range(1, len(other_route)-1):\n                    node = other_route[k]\n                    if demand[node] <= remaining_capacity:\n                        # Insert node into current route\n                        best_pos = 1\n                        min_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1], node] +\n                                   distance_matrix[node, route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                        route = np.insert(route, best_pos, node)\n                        other_route = np.delete(other_route, k)\n                        remaining_capacity -= demand[node]\n                        break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then applies a hybrid local search that combines route splitting, customer reallocation, and adaptive 2-opt to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route splitting: Split long routes into smaller ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Don't split if route is too short\n            split_point = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_point+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Customer reallocation: Try to move customers between routes\n    for _ in range(2):  # Try a few times\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a random customer from route1\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Try to insert into route2\n        best_pos = -1\n        best_increase = float('inf')\n\n        for pos in range(1, len(route2)-1):\n            # Calculate new route2 with customer inserted\n            new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n\n            # Check capacity\n            if np.sum(demand[new_route2[1:-1]]) > capacity:\n                continue\n\n            # Calculate distance increase\n            prev_node = route2[pos-1]\n            next_node = route2[pos]\n            original_dist = distance_matrix[prev_node][next_node]\n            new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n            increase = new_dist - original_dist\n\n            if increase < best_increase:\n                best_increase = increase\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the move\n            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n            new_solution[route2_idx] = new_route2\n\n            # Remove from original route\n            new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n            new_solution[route1_idx] = new_route1\n            break\n\n    # 3. Adaptive 2-opt: Perform 2-opt on the longest route\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Need at least 4 nodes to perform 2-opt\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(longest_route)-3)\n            j = random.randint(i+1, len(longest_route)-2)\n\n            # Create new route by reversing the segment between i and j\n            new_route = np.concatenate([\n                longest_route[:i],\n                longest_route[j:i-1:-1],\n                longest_route[j+1:]\n            ])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.758934170741837,
            1.224592000246048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route splitting: Split long routes into smaller ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Don't split if route is too short\n            split_point = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_point+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Customer reallocation: Try to move customers between routes\n    for _ in range(2):  # Try a few times\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a random customer from route1\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Try to insert into route2\n        best_pos = -1\n        best_increase = float('inf')\n\n        for pos in range(1, len(route2)-1):\n            # Calculate new route2 with customer inserted\n            new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n\n            # Check capacity\n            if np.sum(demand[new_route2[1:-1]]) > capacity:\n                continue\n\n            # Calculate distance increase\n            prev_node = route2[pos-1]\n            next_node = route2[pos]\n            original_dist = distance_matrix[prev_node][next_node]\n            new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n            increase = new_dist - original_dist\n\n            if increase < best_increase:\n                best_increase = increase\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the move\n            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n            new_solution[route2_idx] = new_route2\n\n            # Remove from original route\n            new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n            new_solution[route1_idx] = new_route1\n            break\n\n    # 3. Adaptive 2-opt: Perform 2-opt on the longest route\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Need at least 4 nodes to perform 2-opt\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(longest_route)-3)\n            j = random.randint(i+1, len(longest_route)-2)\n\n            # Create new route by reversing the segment between i and j\n            new_route = np.concatenate([\n                longest_route[:i],\n                longest_route[j:i-1:-1],\n                longest_route[j+1:]\n            ])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a hybrid approach combining route segmentation and demand-aware relocation, then generates a neighbor by intelligently merging or splitting routes while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: route segmentation + demand-aware relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into parts with similar demand\n        demands = demand[route[1:-1]]  # Exclude depot\n        cumulative_demands = np.cumsum(demands)\n        split_points = []\n        current_load = 0\n        for i in range(len(cumulative_demands)):\n            if cumulative_demands[i] - current_load > capacity * 0.7:  # Split when load exceeds 70% capacity\n                split_points.append(i)\n                current_load = cumulative_demands[i]\n\n        # Split route into segments\n        segments = []\n        prev_idx = 0\n        for split in split_points:\n            segments.append(route[prev_idx + 1:split + 2])  # Include depot at start/end\n            prev_idx = split\n        segments.append(route[prev_idx + 1:])\n\n        # Relocate segments to other routes or merge with nearby routes\n        for seg in segments:\n            if len(seg) <= 1:\n                continue\n\n            # Try to merge with existing routes\n            merged = False\n            for i, candidate_route in enumerate(new_solution):\n                if np.sum(demand[candidate_route[1:-1]]) + np.sum(demand[seg[1:-1]]) <= capacity:\n                    # Insert segment into candidate route at best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(candidate_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[candidate_route[pos-1], seg[1]] +\n                               distance_matrix[seg[-2], candidate_route[pos]] -\n                               distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert segment\n                    new_route = np.concatenate((candidate_route[:best_pos], seg[1:-1], candidate_route[best_pos:]))\n                    new_solution[i] = new_route\n                    merged = True\n                    break\n\n            if not merged:\n                # Create new route if not merged\n                new_solution.append(np.concatenate(([0], seg[1:-1], [0])))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Add missing customers to new routes\n        missing_customers = list(missing_customers)\n        random.shuffle(missing_customers)\n        current_route = [0]\n        current_load = 0\n        for customer in missing_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "score": [
            -0.49460260872853157,
            5.960471212863922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: route segmentation + demand-aware relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into parts with similar demand\n        demands = demand[route[1:-1]]  # Exclude depot\n        cumulative_demands = np.cumsum(demands)\n        split_points = []\n        current_load = 0\n        for i in range(len(cumulative_demands)):\n            if cumulative_demands[i] - current_load > capacity * 0.7:  # Split when load exceeds 70% capacity\n                split_points.append(i)\n                current_load = cumulative_demands[i]\n\n        # Split route into segments\n        segments = []\n        prev_idx = 0\n        for split in split_points:\n            segments.append(route[prev_idx + 1:split + 2])  # Include depot at start/end\n            prev_idx = split\n        segments.append(route[prev_idx + 1:])\n\n        # Relocate segments to other routes or merge with nearby routes\n        for seg in segments:\n            if len(seg) <= 1:\n                continue\n\n            # Try to merge with existing routes\n            merged = False\n            for i, candidate_route in enumerate(new_solution):\n                if np.sum(demand[candidate_route[1:-1]]) + np.sum(demand[seg[1:-1]]) <= capacity:\n                    # Insert segment into candidate route at best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(candidate_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[candidate_route[pos-1], seg[1]] +\n                               distance_matrix[seg[-2], candidate_route[pos]] -\n                               distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert segment\n                    new_route = np.concatenate((candidate_route[:best_pos], seg[1:-1], candidate_route[best_pos:]))\n                    new_solution[i] = new_route\n                    merged = True\n                    break\n\n            if not merged:\n                # Create new route if not merged\n                new_solution.append(np.concatenate(([0], seg[1:-1], [0])))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Add missing customers to new routes\n        missing_customers = list(missing_customers)\n        random.shuffle(missing_customers)\n        current_route = [0]\n        current_load = 0\n        for customer in missing_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    best_makespan_solution = archive[0][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in best_makespan_solution]\n\n    # Randomly select two routes to merge (if possible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging the routes is feasible in terms of capacity\n        total_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2)\n        if total_demand <= capacity:\n            # Merge the routes by removing the depot from the second route and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Randomly select a route to reinsert customers (if possible)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Remove all customers from the route (except depot)\n        customers = route[1:-1]\n        new_solution[route_idx] = np.array([0, 0])\n\n        # Reinsert customers one by one into the best feasible position\n        for customer in customers:\n            best_pos = 1\n            best_cost = float('inf')\n\n            # Evaluate all possible insertion positions\n            for i in range(1, len(new_solution[route_idx])):\n                # Insert customer at position i\n                new_route = np.insert(new_solution[route_idx], i, customer)\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route) <= capacity:\n                    # Calculate the additional distance\n                    cost = distance_matrix[new_route[i-1]][customer] + distance_matrix[customer][new_route[i+1]] - distance_matrix[new_route[i-1]][new_route[i+1]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            # Insert the customer at the best position\n            new_solution[route_idx] = np.insert(new_solution[route_idx], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.44027239684990177,
            6.039101779460907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    best_makespan_solution = archive[0][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in best_makespan_solution]\n\n    # Randomly select two routes to merge (if possible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging the routes is feasible in terms of capacity\n        total_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2)\n        if total_demand <= capacity:\n            # Merge the routes by removing the depot from the second route and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Randomly select a route to reinsert customers (if possible)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Remove all customers from the route (except depot)\n        customers = route[1:-1]\n        new_solution[route_idx] = np.array([0, 0])\n\n        # Reinsert customers one by one into the best feasible position\n        for customer in customers:\n            best_pos = 1\n            best_cost = float('inf')\n\n            # Evaluate all possible insertion positions\n            for i in range(1, len(new_solution[route_idx])):\n                # Insert customer at position i\n                new_route = np.insert(new_solution[route_idx], i, customer)\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route) <= capacity:\n                    # Calculate the additional distance\n                    cost = distance_matrix[new_route[i-1]][customer] + distance_matrix[customer][new_route[i+1]] - distance_matrix[new_route[i-1]][new_route[i+1]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            # Insert the customer at the best position\n            new_solution[route_idx] = np.insert(new_solution[route_idx], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route merging, segment relocation, and capacity-aware 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.7 * (obj[0] / max(o[0] for _, o in archive)) + 0.3 * (obj[1] / max(o[1] for _, o in archive))\n              for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Randomly choose one of the following operations:\n    operation = random.choice(['merge', 'relocate', 'capacity_2opt'])\n\n    if operation == 'merge':\n        # Merge two routes if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            # Check if merging is feasible\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    elif operation == 'relocate':\n        # Relocate a segment from one route to another\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) > 3:  # Ensure there's a segment to relocate\n                # Select a random segment from route1\n                start = random.randint(1, len(route1) - 3)\n                end = random.randint(start + 1, len(route1) - 2)\n                segment = route1[start:end]\n                # Check if relocating the segment to route2 is feasible\n                if np.sum(demand[segment]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    # Relocate the segment to route2\n                    new_route1 = np.concatenate([route1[:start], route1[end:]])\n                    new_route2 = np.concatenate([route2[:-1], segment, [0]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n    elif operation == 'capacity_2opt':\n        # Capacity-aware 2-opt with demand checks\n        for route in new_solution:\n            if len(route) > 4:  # At least 3 customers to perform 2-opt\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                # Reverse the segment between i and j\n                new_segment = route[i:j+1][::-1]\n                # Check if the new segment is feasible\n                if np.sum(demand[new_segment]) <= capacity:\n                    new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n                    route[:] = new_route\n\n    # Ensure all routes are valid (start and end at depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot.\")\n\n    return new_solution\n\n",
        "score": [
            -0.4815785418274526,
            5.446223616600037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.7 * (obj[0] / max(o[0] for _, o in archive)) + 0.3 * (obj[1] / max(o[1] for _, o in archive))\n              for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Randomly choose one of the following operations:\n    operation = random.choice(['merge', 'relocate', 'capacity_2opt'])\n\n    if operation == 'merge':\n        # Merge two routes if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            # Check if merging is feasible\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    elif operation == 'relocate':\n        # Relocate a segment from one route to another\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) > 3:  # Ensure there's a segment to relocate\n                # Select a random segment from route1\n                start = random.randint(1, len(route1) - 3)\n                end = random.randint(start + 1, len(route1) - 2)\n                segment = route1[start:end]\n                # Check if relocating the segment to route2 is feasible\n                if np.sum(demand[segment]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    # Relocate the segment to route2\n                    new_route1 = np.concatenate([route1[:start], route1[end:]])\n                    new_route2 = np.concatenate([route2[:-1], segment, [0]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n    elif operation == 'capacity_2opt':\n        # Capacity-aware 2-opt with demand checks\n        for route in new_solution:\n            if len(route) > 4:  # At least 3 customers to perform 2-opt\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                # Reverse the segment between i and j\n                new_segment = route[i:j+1][::-1]\n                # Check if the new segment is feasible\n                if np.sum(demand[new_segment]) <= capacity:\n                    new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n                    route[:] = new_route\n\n    # Ensure all routes are valid (start and end at depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot.\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive with a high total distance-to-makespan ratio, then applies a hybrid local search combining route splitting, customer reallocation, and a novel \"demand-balanced\" 2-opt variant to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-6), reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search steps:\n    # 1. Route splitting: Split long routes into shorter ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Only consider long routes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:-1] + [0]\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # 2. Customer reallocation: Try moving customers between routes\n    for _ in range(3):  # Limit attempts\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:  # Skip empty or minimal routes\n            continue\n\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Find target route\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        while target_route_idx == route1_idx:\n            target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n\n        # Try inserting customer into target route\n        for pos in range(1, len(target_route)):\n            new_target = np.insert(target_route, pos, customer)\n            new_route1 = np.delete(route1, customer_idx)\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_target[1:-1]]) <= capacity and\n                np.sum(demand[new_route1[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[target_route_idx] = new_target\n                break\n\n    # 3. Demand-balanced 2-opt: Modified 2-opt considering demand balance\n    for route in new_solution:\n        if len(route) <= 4:\n            continue\n\n        # Select two non-adjacent edges\n        i = random.randint(1, len(route)-3)\n        j = random.randint(i+1, len(route)-2)\n\n        # Create new route by reversing the segment between i and j\n        new_route = np.concatenate([\n            route[:i],\n            route[i:j+1][::-1],\n            route[j+1:]\n        ])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.700552283288467,
            1.9245817363262177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-6), reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search steps:\n    # 1. Route splitting: Split long routes into shorter ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 5:  # Only consider long routes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:-1] + [0]\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # 2. Customer reallocation: Try moving customers between routes\n    for _ in range(3):  # Limit attempts\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:  # Skip empty or minimal routes\n            continue\n\n        customer_idx = random.randint(1, len(route1)-2)\n        customer = route1[customer_idx]\n\n        # Find target route\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        while target_route_idx == route1_idx:\n            target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n\n        # Try inserting customer into target route\n        for pos in range(1, len(target_route)):\n            new_target = np.insert(target_route, pos, customer)\n            new_route1 = np.delete(route1, customer_idx)\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_target[1:-1]]) <= capacity and\n                np.sum(demand[new_route1[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[target_route_idx] = new_target\n                break\n\n    # 3. Demand-balanced 2-opt: Modified 2-opt considering demand balance\n    for route in new_solution:\n        if len(route) <= 4:\n            continue\n\n        # Select two non-adjacent edges\n        i = random.randint(1, len(route)-3)\n        j = random.randint(i+1, len(route)-2)\n\n        # Create new route by reversing the segment between i and j\n        new_route = np.concatenate([\n            route[:i],\n            route[i:j+1][::-1],\n            route[j+1:]\n        ])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route segment swaps with demand-balanced route splits, ensuring feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced splits\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for potential swap or split\n    route1_idx, route2_idx = random.sample(range(n_routes), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Try to swap a segment between routes\n    def is_feasible(route, total_demand):\n        return total_demand <= capacity\n\n    # Find a feasible segment to swap\n    for i in range(1, len(route1) - 1):\n        for j in range(1, len(route2) - 1):\n            # Check if swapping segments is feasible\n            segment1 = route1[i:]\n            segment2 = route2[j:]\n\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            if is_feasible(route1[:-len(segment1)] + segment2, sum(demand[node] for node in route1[:-len(segment1)]) + demand2) and \\\n               is_feasible(route2[:-len(segment2)] + segment1, sum(demand[node] for node in route2[:-len(segment2)]) + demand1):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                return new_solution\n\n    # If swap fails, try demand-balanced split\n    for route_idx in [route1_idx, route2_idx]:\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            demand_first = sum(demand[node] for node in first_part)\n            demand_second = sum(demand[node] for node in second_part)\n\n            if is_feasible(first_part, demand_first) and is_feasible(second_part, demand_second):\n                new_solution[route_idx] = first_part\n                new_solution = np.append(new_solution, [second_part], axis=0)\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.68651826016987,
            0.2866681218147278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced splits\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for potential swap or split\n    route1_idx, route2_idx = random.sample(range(n_routes), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Try to swap a segment between routes\n    def is_feasible(route, total_demand):\n        return total_demand <= capacity\n\n    # Find a feasible segment to swap\n    for i in range(1, len(route1) - 1):\n        for j in range(1, len(route2) - 1):\n            # Check if swapping segments is feasible\n            segment1 = route1[i:]\n            segment2 = route2[j:]\n\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            if is_feasible(route1[:-len(segment1)] + segment2, sum(demand[node] for node in route1[:-len(segment1)]) + demand2) and \\\n               is_feasible(route2[:-len(segment2)] + segment1, sum(demand[node] for node in route2[:-len(segment2)]) + demand1):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                return new_solution\n\n    # If swap fails, try demand-balanced split\n    for route_idx in [route1_idx, route2_idx]:\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            demand_first = sum(demand[node] for node in first_part)\n            demand_second = sum(demand[node] for node in second_part)\n\n            if is_feasible(first_part, demand_first) and is_feasible(second_part, demand_second):\n                new_solution[route_idx] = first_part\n                new_solution = np.append(new_solution, [second_part], axis=0)\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route segment swaps with demand-balanced route splits, ensuring feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced splits\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for potential swap or split\n    route1_idx, route2_idx = random.sample(range(n_routes), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Try to swap a segment between routes\n    def is_feasible(route, total_demand):\n        return total_demand <= capacity\n\n    # Find a feasible segment to swap\n    for i in range(1, len(route1) - 1):\n        for j in range(1, len(route2) - 1):\n            # Check if swapping segments is feasible\n            segment1 = route1[i:]\n            segment2 = route2[j:]\n\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            if is_feasible(route1[:-len(segment1)] + segment2, sum(demand[node] for node in route1[:-len(segment1)]) + demand2) and \\\n               is_feasible(route2[:-len(segment2)] + segment1, sum(demand[node] for node in route2[:-len(segment2)]) + demand1):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                return new_solution\n\n    # If swap fails, try demand-balanced split\n    for route_idx in [route1_idx, route2_idx]:\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            demand_first = sum(demand[node] for node in first_part)\n            demand_second = sum(demand[node] for node in second_part)\n\n            if is_feasible(first_part, demand_first) and is_feasible(second_part, demand_second):\n                new_solution[route_idx] = first_part\n                new_solution = np.append(new_solution, [second_part], axis=0)\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.68651826016987,
            0.2866681218147278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swaps and demand-balanced splits\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes for potential swap or split\n    route1_idx, route2_idx = random.sample(range(n_routes), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Try to swap a segment between routes\n    def is_feasible(route, total_demand):\n        return total_demand <= capacity\n\n    # Find a feasible segment to swap\n    for i in range(1, len(route1) - 1):\n        for j in range(1, len(route2) - 1):\n            # Check if swapping segments is feasible\n            segment1 = route1[i:]\n            segment2 = route2[j:]\n\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            if is_feasible(route1[:-len(segment1)] + segment2, sum(demand[node] for node in route1[:-len(segment1)]) + demand2) and \\\n               is_feasible(route2[:-len(segment2)] + segment1, sum(demand[node] for node in route2[:-len(segment2)]) + demand1):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                return new_solution\n\n    # If swap fails, try demand-balanced split\n    for route_idx in [route1_idx, route2_idx]:\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            demand_first = sum(demand[node] for node in first_part)\n            demand_second = sum(demand[node] for node in second_part)\n\n            if is_feasible(first_part, demand_first) and is_feasible(second_part, demand_second):\n                new_solution[route_idx] = first_part\n                new_solution = np.append(new_solution, [second_part], axis=0)\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This function selects a promising solution from the archive by identifying those with the lowest total distance or makespan, then applies a hybrid local search combining route swapping and partial re-optimization to generate a feasible neighbor solution while respecting vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping and partial re-optimization\n    if len(new_solution) >= 2:\n        # Step 1: Select two random routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Swap segments between the two routes\n        if len(route1) > 2 and len(route2) > 2:\n            # Randomly select segments to swap\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg2_start = np.random.randint(1, len(route2) - 1)\n\n            # Ensure capacity constraints are not violated\n            seg1_demand = sum(demand[node] for node in route1[seg1_start:-1])\n            seg2_demand = sum(demand[node] for node in route2[seg2_start:-1])\n\n            if seg1_demand + sum(demand[node] for node in route2[1:-1]) - seg2_demand <= capacity and \\\n               seg2_demand + sum(demand[node] for node in route1[1:-1]) - seg1_demand <= capacity:\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:-1], route1[-1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:-1], route2[-1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Partial re-optimization (2-opt within a route)\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random nodes to swap\n            i, j = np.random.choice(len(route) - 2, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n\n            # Check capacity constraint\n            if sum(demand[node] for node in route[i+1:j]) + sum(demand[node] for node in route[j+1:i]) <= capacity:\n                # Reverse the segment\n                route[i+1:j+1] = route[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7719679430447114,
            1.970423549413681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping and partial re-optimization\n    if len(new_solution) >= 2:\n        # Step 1: Select two random routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Swap segments between the two routes\n        if len(route1) > 2 and len(route2) > 2:\n            # Randomly select segments to swap\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg2_start = np.random.randint(1, len(route2) - 1)\n\n            # Ensure capacity constraints are not violated\n            seg1_demand = sum(demand[node] for node in route1[seg1_start:-1])\n            seg2_demand = sum(demand[node] for node in route2[seg2_start:-1])\n\n            if seg1_demand + sum(demand[node] for node in route2[1:-1]) - seg2_demand <= capacity and \\\n               seg2_demand + sum(demand[node] for node in route1[1:-1]) - seg1_demand <= capacity:\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:-1], route1[-1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:-1], route2[-1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Partial re-optimization (2-opt within a route)\n    for route in new_solution:\n        if len(route) > 3:\n            # Select two random nodes to swap\n            i, j = np.random.choice(len(route) - 2, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n\n            # Check capacity constraint\n            if sum(demand[node] for node in route[i+1:j]) + sum(demand[node] for node in route[j+1:i]) <= capacity:\n                # Reverse the segment\n                route[i+1:j+1] = route[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    base_solution = random.choice(archive_sorted[:max(3, len(archive_sorted) // 2)])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Long route candidate\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n        # Step 2: Customer reallocation (move customers between routes)\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:  # Ensure route1 has customers to move\n                    customer_pos = random.randint(1, len(route1) - 2)\n                    customer = route1[customer_pos]\n\n                    # Check if adding customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into route2\n                        insert_pos = random.randint(1, len(route2) - 1)\n                        new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n                        # Remove customer from route1\n                        new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos + 1:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt (focus on long edges)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                # Find the longest edge in the route\n                max_dist = -1\n                split_pos = -1\n                for j in range(len(route) - 1):\n                    dist = distance_matrix[route[j]][route[j + 1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        split_pos = j\n\n                if split_pos != -1:\n                    # Reverse the segment between split_pos and split_pos + 1\n                    new_segment = route[split_pos + 1:split_pos + 2:-1]\n                    new_route = np.concatenate([route[:split_pos + 1], new_segment, route[split_pos + 2:]])\n\n                    # Check feasibility (no capacity check needed since only reordering)\n                    new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7260066345787368,
            3.605656325817108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    base_solution = random.choice(archive_sorted[:max(3, len(archive_sorted) // 2)])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Long route candidate\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n        # Step 2: Customer reallocation (move customers between routes)\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:  # Ensure route1 has customers to move\n                    customer_pos = random.randint(1, len(route1) - 2)\n                    customer = route1[customer_pos]\n\n                    # Check if adding customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into route2\n                        insert_pos = random.randint(1, len(route2) - 1)\n                        new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n                        # Remove customer from route1\n                        new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos + 1:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Adaptive 2-opt (focus on long edges)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                # Find the longest edge in the route\n                max_dist = -1\n                split_pos = -1\n                for j in range(len(route) - 1):\n                    dist = distance_matrix[route[j]][route[j + 1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        split_pos = j\n\n                if split_pos != -1:\n                    # Reverse the segment between split_pos and split_pos + 1\n                    new_segment = route[split_pos + 1:split_pos + 2:-1]\n                    new_route = np.concatenate([route[:split_pos + 1], new_segment, route[split_pos + 2:]])\n\n                    # Check feasibility (no capacity check needed since only reordering)\n                    new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The algorithm selects a promising solution from the archive using a tournament selection based on a weighted objective score, then applies a hybrid local search combining route merging, intra-route 3-opt, and demand-balanced route splitting to improve both distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Prefer solutions with lower combined objective\n    base_solution = selected[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging, 3-opt, and demand-balanced splitting\n    if len(new_solution) > 1:\n        # Try route merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:  # Avoid trivial routes\n            # Check if merging is feasible\n            total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Find best merge points\n                best_merge = None\n                min_increase = float('inf')\n\n                for k in range(1, len(route_i)-1):\n                    for l in range(1, len(route_j)-1):\n                        # Calculate distance increase\n                        increase = (distance_matrix[route_i[k-1]][route_j[l]] +\n                                   distance_matrix[route_j[l]][route_i[k]] +\n                                   distance_matrix[route_j[l-1]][route_i[k]] +\n                                   distance_matrix[route_i[k-1]][route_j[l]] -\n                                   distance_matrix[route_i[k-1]][route_i[k]] -\n                                   distance_matrix[route_j[l-1]][route_j[l]])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_merge = (k, l)\n\n                if best_merge:\n                    k, l = best_merge\n                    # Merge routes\n                    merged_route = np.concatenate([\n                        route_i[:k],\n                        route_j[l:],\n                        route_j[:l],\n                        route_i[k:]\n                    ])\n                    # Remove duplicates and depot\n                    merged_route = np.unique(merged_route)\n                    merged_route = np.concatenate([[0], merged_route[1:-1], [0]])\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(merged_route)\n\n    # Apply 3-opt to each route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5:  # Only apply if route is long enough\n            # Select 3 random points (excluding depots)\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt moves\n            best_move = None\n            min_increase = float('inf')\n\n            # Try all 8 possible 3-opt moves\n            for move in [\n                # Original order: a-b-c\n                (a, b, c),\n                # Reverse a-b: a-b-reverse-c\n                (a, b, c, True, False, False),\n                # Reverse b-c: a-reverse-b-c\n                (a, b, c, False, True, False),\n                # Reverse a-b and b-c: a-b-reverse-b-c\n                (a, b, c, True, True, False),\n                # Reverse a-b-c: reverse-a-b-reverse-c\n                (a, b, c, True, False, True),\n                # Reverse a-b and a-b-c: reverse-a-b-c\n                (a, b, c, True, True, True),\n                # Reverse b-c and a-b-c: a-reverse-b-reverse-c\n                (a, b, c, False, True, True),\n                # Reverse a-b, b-c, and a-b-c: reverse-a-b-reverse-b-c\n                (a, b, c, True, True, True)\n            ]:\n                if len(move) == 3:\n                    # Original order\n                    new_route = route.copy()\n                else:\n                    # Apply reversals\n                    new_route = route.copy()\n                    if move[3]:  # Reverse a-b\n                        new_route[a:b+1] = new_route[a:b+1][::-1]\n                    if move[4]:  # Reverse b-c\n                        new_route[b:c+1] = new_route[b:c+1][::-1]\n                    if move[5]:  # Reverse a-b-c\n                        new_route[a:c+1] = new_route[a:c+1][::-1]\n\n                # Calculate distance increase\n                increase = (distance_matrix[new_route[a-1]][new_route[a]] +\n                           distance_matrix[new_route[b-1]][new_route[b]] +\n                           distance_matrix[new_route[c-1]][new_route[c]] -\n                           distance_matrix[route[a-1]][route[a]] -\n                           distance_matrix[route[b-1]][route[b]] -\n                           distance_matrix[route[c-1]][route[c]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_move = new_route\n\n            if best_move is not None:\n                new_solution[route_idx] = best_move\n\n    # Apply demand-balanced route splitting\n    for route in new_solution:\n        if len(route) > 5:  # Only split long routes\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.8:  # Only split if route is over 80% capacity\n                # Find best split point\n                best_split = None\n                best_balance = float('inf')\n\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    balance = abs(current_demand - (total_demand - current_demand))\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = i\n\n                if best_split and best_split < len(route)-2:\n                    # Split the route\n                    new_route1 = np.concatenate([[0], route[1:best_split+1], [0]])\n                    new_route2 = np.concatenate([[0], route[best_split+1:-1], [0]])\n\n                    # Check capacity constraints\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        # Replace the original route with the two new routes\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                        new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n",
        "score": [
            -0.44920276388597635,
            5.825684875249863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Prefer solutions with lower combined objective\n    base_solution = selected[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging, 3-opt, and demand-balanced splitting\n    if len(new_solution) > 1:\n        # Try route merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:  # Avoid trivial routes\n            # Check if merging is feasible\n            total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Find best merge points\n                best_merge = None\n                min_increase = float('inf')\n\n                for k in range(1, len(route_i)-1):\n                    for l in range(1, len(route_j)-1):\n                        # Calculate distance increase\n                        increase = (distance_matrix[route_i[k-1]][route_j[l]] +\n                                   distance_matrix[route_j[l]][route_i[k]] +\n                                   distance_matrix[route_j[l-1]][route_i[k]] +\n                                   distance_matrix[route_i[k-1]][route_j[l]] -\n                                   distance_matrix[route_i[k-1]][route_i[k]] -\n                                   distance_matrix[route_j[l-1]][route_j[l]])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_merge = (k, l)\n\n                if best_merge:\n                    k, l = best_merge\n                    # Merge routes\n                    merged_route = np.concatenate([\n                        route_i[:k],\n                        route_j[l:],\n                        route_j[:l],\n                        route_i[k:]\n                    ])\n                    # Remove duplicates and depot\n                    merged_route = np.unique(merged_route)\n                    merged_route = np.concatenate([[0], merged_route[1:-1], [0]])\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(merged_route)\n\n    # Apply 3-opt to each route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5:  # Only apply if route is long enough\n            # Select 3 random points (excluding depots)\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt moves\n            best_move = None\n            min_increase = float('inf')\n\n            # Try all 8 possible 3-opt moves\n            for move in [\n                # Original order: a-b-c\n                (a, b, c),\n                # Reverse a-b: a-b-reverse-c\n                (a, b, c, True, False, False),\n                # Reverse b-c: a-reverse-b-c\n                (a, b, c, False, True, False),\n                # Reverse a-b and b-c: a-b-reverse-b-c\n                (a, b, c, True, True, False),\n                # Reverse a-b-c: reverse-a-b-reverse-c\n                (a, b, c, True, False, True),\n                # Reverse a-b and a-b-c: reverse-a-b-c\n                (a, b, c, True, True, True),\n                # Reverse b-c and a-b-c: a-reverse-b-reverse-c\n                (a, b, c, False, True, True),\n                # Reverse a-b, b-c, and a-b-c: reverse-a-b-reverse-b-c\n                (a, b, c, True, True, True)\n            ]:\n                if len(move) == 3:\n                    # Original order\n                    new_route = route.copy()\n                else:\n                    # Apply reversals\n                    new_route = route.copy()\n                    if move[3]:  # Reverse a-b\n                        new_route[a:b+1] = new_route[a:b+1][::-1]\n                    if move[4]:  # Reverse b-c\n                        new_route[b:c+1] = new_route[b:c+1][::-1]\n                    if move[5]:  # Reverse a-b-c\n                        new_route[a:c+1] = new_route[a:c+1][::-1]\n\n                # Calculate distance increase\n                increase = (distance_matrix[new_route[a-1]][new_route[a]] +\n                           distance_matrix[new_route[b-1]][new_route[b]] +\n                           distance_matrix[new_route[c-1]][new_route[c]] -\n                           distance_matrix[route[a-1]][route[a]] -\n                           distance_matrix[route[b-1]][route[b]] -\n                           distance_matrix[route[c-1]][route[c]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_move = new_route\n\n            if best_move is not None:\n                new_solution[route_idx] = best_move\n\n    # Apply demand-balanced route splitting\n    for route in new_solution:\n        if len(route) > 5:  # Only split long routes\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.8:  # Only split if route is over 80% capacity\n                # Find best split point\n                best_split = None\n                best_balance = float('inf')\n\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    balance = abs(current_demand - (total_demand - current_demand))\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = i\n\n                if best_split and best_split < len(route)-2:\n                    # Split the route\n                    new_route1 = np.concatenate([[0], route[1:best_split+1], [0]])\n                    new_route2 = np.concatenate([[0], route[best_split+1:-1], [0]])\n\n                    # Check capacity constraints\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        # Replace the original route with the two new routes\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                        new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i]) + np.sum(demand[route_j])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route_j into route_i at the closest feasible position\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(1, len(route_i)):\n                # Insert route_j before route_i[pos]\n                merged_route = np.concatenate([route_i[:pos], route_j[1:-1], route_i[pos:]])\n                # Check capacity constraint\n                if np.sum(demand[merged_route]) <= capacity:\n                    # Calculate insertion cost\n                    cost = distance_matrix[route_i[pos-1], route_j[1]] + distance_matrix[route_j[-2], route_i[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n            # Perform the merge\n            merged_route = np.concatenate([route_i[:best_pos], route_j[1:-1], route_i[best_pos:]])\n            new_solution[i] = merged_route\n            new_solution = [route for k, route in enumerate(new_solution) if k != j]\n\n    # Customer reallocation: Move customers between routes for better balance\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = np.random.choice(len(route) - 2) + 1  # Skip depot\n            customer = route[customer_idx]\n            # Find the best route to insert this customer (excluding its current route)\n            best_route_idx = -1\n            best_pos = -1\n            min_cost = float('inf')\n            for r_idx, candidate_route in enumerate(new_solution):\n                if np.array_equal(candidate_route, route):\n                    continue\n                # Check if adding the customer exceeds capacity\n                if np.sum(demand[candidate_route]) + demand[customer] > capacity:\n                    continue\n                # Find the best insertion position\n                for pos in range(1, len(candidate_route)):\n                    # Calculate insertion cost\n                    cost = distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_route_idx = r_idx\n                        best_pos = pos\n            # Perform the move if beneficial\n            if best_route_idx != -1:\n                # Remove from current route\n                route = np.delete(route, customer_idx)\n                # Insert into new route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.8235258844111967,
            4.354319870471954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i]) + np.sum(demand[route_j])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route_j into route_i at the closest feasible position\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(1, len(route_i)):\n                # Insert route_j before route_i[pos]\n                merged_route = np.concatenate([route_i[:pos], route_j[1:-1], route_i[pos:]])\n                # Check capacity constraint\n                if np.sum(demand[merged_route]) <= capacity:\n                    # Calculate insertion cost\n                    cost = distance_matrix[route_i[pos-1], route_j[1]] + distance_matrix[route_j[-2], route_i[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n            # Perform the merge\n            merged_route = np.concatenate([route_i[:best_pos], route_j[1:-1], route_i[best_pos:]])\n            new_solution[i] = merged_route\n            new_solution = [route for k, route in enumerate(new_solution) if k != j]\n\n    # Customer reallocation: Move customers between routes for better balance\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = np.random.choice(len(route) - 2) + 1  # Skip depot\n            customer = route[customer_idx]\n            # Find the best route to insert this customer (excluding its current route)\n            best_route_idx = -1\n            best_pos = -1\n            min_cost = float('inf')\n            for r_idx, candidate_route in enumerate(new_solution):\n                if np.array_equal(candidate_route, route):\n                    continue\n                # Check if adding the customer exceeds capacity\n                if np.sum(demand[candidate_route]) + demand[customer] > capacity:\n                    continue\n                # Find the best insertion position\n                for pos in range(1, len(candidate_route)):\n                    # Calculate insertion cost\n                    cost = distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_route_idx = r_idx\n                        best_pos = pos\n            # Perform the move if beneficial\n            if best_route_idx != -1:\n                # Remove from current route\n                route = np.delete(route, customer_idx)\n                # Insert into new route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware swaps, and capacity-constrained route merging to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1) for _, obj in archive]  # Higher weight for better solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting - Split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route at a time\n\n    # Step 2: Customer Reinsertion with Demand-Aware Swaps\n    for _ in range(2):  # Perform 2 reinsertion attempts\n        # Select a random route and customer to move\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has only depot and one customer\n            continue\n\n        # Remove a random customer (not depot)\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                prev_node = other_route[pos-1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert customer\n            new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n            new_solution[other_route_idx] = new_other_route\n            new_solution[route_idx] = new_route\n            break  # Only move one customer at a time\n\n    # Step 3: Capacity-Constrained Route Merging\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 50):  # Arbitrary limit to prevent too long routes\n\n                # Calculate merging cost\n                cost_without_merge = (sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)) +\n                                    sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1)))\n\n                # Try merging in both directions\n                merged_route1 = np.concatenate([route1[:-1], route2[1:]])\n                merged_route2 = np.concatenate([route2[:-1], route1[1:]])\n\n                cost1 = sum(distance_matrix[merged_route1[k]][merged_route1[k+1]] for k in range(len(merged_route1)-1))\n                cost2 = sum(distance_matrix[merged_route2[k]][merged_route2[k+1]] for k in range(len(merged_route2)-1))\n\n                if cost1 < cost_without_merge and cost1 < cost2:\n                    new_solution[i] = merged_route1\n                    del new_solution[j]\n                    break\n                elif cost2 < cost_without_merge:\n                    new_solution[j] = merged_route2\n                    del new_solution[i]\n                    break\n        else:\n            continue\n        break\n\n    return new_solution\n\n",
        "score": [
            -0.4887769401589147,
            1.6312245428562164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1) for _, obj in archive]  # Higher weight for better solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route Splitting - Split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route at a time\n\n    # Step 2: Customer Reinsertion with Demand-Aware Swaps\n    for _ in range(2):  # Perform 2 reinsertion attempts\n        # Select a random route and customer to move\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has only depot and one customer\n            continue\n\n        # Remove a random customer (not depot)\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                prev_node = other_route[pos-1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert customer\n            new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n            new_solution[other_route_idx] = new_other_route\n            new_solution[route_idx] = new_route\n            break  # Only move one customer at a time\n\n    # Step 3: Capacity-Constrained Route Merging\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 50):  # Arbitrary limit to prevent too long routes\n\n                # Calculate merging cost\n                cost_without_merge = (sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)) +\n                                    sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1)))\n\n                # Try merging in both directions\n                merged_route1 = np.concatenate([route1[:-1], route2[1:]])\n                merged_route2 = np.concatenate([route2[:-1], route1[1:]])\n\n                cost1 = sum(distance_matrix[merged_route1[k]][merged_route1[k+1]] for k in range(len(merged_route1)-1))\n                cost2 = sum(distance_matrix[merged_route2[k]][merged_route2[k+1]] for k in range(len(merged_route2)-1))\n\n                if cost1 < cost_without_merge and cost1 < cost2:\n                    new_solution[i] = merged_route1\n                    del new_solution[j]\n                    break\n                elif cost2 < cost_without_merge:\n                    new_solution[j] = merged_route2\n                    del new_solution[i]\n                    break\n        else:\n            continue\n        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A hybrid local search strategy combining route splitting, inter-route node insertion, and demand-aware swaps to balance distance and makespan objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, demand-aware insertion, and inter-route swaps\n    if len(new_solution) > 1:\n        # Route splitting: split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure it's not just depot-depot\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If splitting violates capacity, try demand-aware insertion\n                for i in range(1, len(longest_route)-1):\n                    node = longest_route[i]\n                    # Try inserting into another route\n                    for j in range(len(new_solution)):\n                        if j != longest_route_idx:\n                            temp_route = np.insert(new_solution[j], -1, node)\n                            if sum(demand[temp_route[1:-1]]) <= capacity:\n                                new_solution[j] = temp_route\n                                new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                                break\n    else:\n        # If only one route, try to split it\n        route = new_solution[0]\n        if len(route) > 3:\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [new_route1, new_route2]\n\n    # Inter-route demand-aware swaps to balance makespan\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit iterations to avoid excessive computation\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Try swapping nodes between routes\n            for pos1 in range(1, len(route1)-1):\n                for pos2 in range(1, len(route2)-1):\n                    node1, node2 = route1[pos1], route2[pos2]\n                    new_route1 = np.concatenate([route1[:pos1], [node2], route1[pos1+1:]])\n                    new_route2 = np.concatenate([route2[:pos2], [node1], route2[pos2+1:]])\n\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.689870768182917,
            2.058406412601471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, demand-aware insertion, and inter-route swaps\n    if len(new_solution) > 1:\n        # Route splitting: split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure it's not just depot-depot\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If splitting violates capacity, try demand-aware insertion\n                for i in range(1, len(longest_route)-1):\n                    node = longest_route[i]\n                    # Try inserting into another route\n                    for j in range(len(new_solution)):\n                        if j != longest_route_idx:\n                            temp_route = np.insert(new_solution[j], -1, node)\n                            if sum(demand[temp_route[1:-1]]) <= capacity:\n                                new_solution[j] = temp_route\n                                new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                                break\n    else:\n        # If only one route, try to split it\n        route = new_solution[0]\n        if len(route) > 3:\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [new_route1, new_route2]\n\n    # Inter-route demand-aware swaps to balance makespan\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit iterations to avoid excessive computation\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Try swapping nodes between routes\n            for pos1 in range(1, len(route1)-1):\n                for pos2 in range(1, len(route2)-1):\n                    node1, node2 = route1[pos1], route2[pos2]\n                    new_route1 = np.concatenate([route1[:pos1], [node2], route1[pos1+1:]])\n                    new_route2 = np.concatenate([route2[:pos2], [node1], route2[pos2+1:]])\n\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Rebalance by moving customers between parts\n        for _ in range(3):  # Limit iterations for efficiency\n            # Randomly select a customer from part1 and part2\n            if len(part1) > 2 and len(part2) > 2:\n                c1 = np.random.choice(part1[1:-1])\n                c2 = np.random.choice(part2[1:-1])\n\n                # Check capacity constraints\n                if (sum(demand[part1]) - demand[c1] + demand[c2] <= capacity and\n                    sum(demand[part2]) - demand[c2] + demand[c1] <= capacity):\n                    # Swap customers\n                    part1[np.where(part1 == c1)] = c2\n                    part2[np.where(part2 == c2)] = c1\n\n        # Reconstruct the route\n        new_solution[i] = np.concatenate([part1, part2[1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8033095557710613,
            4.326273292303085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Rebalance by moving customers between parts\n        for _ in range(3):  # Limit iterations for efficiency\n            # Randomly select a customer from part1 and part2\n            if len(part1) > 2 and len(part2) > 2:\n                c1 = np.random.choice(part1[1:-1])\n                c2 = np.random.choice(part2[1:-1])\n\n                # Check capacity constraints\n                if (sum(demand[part1]) - demand[c1] + demand[c2] <= capacity and\n                    sum(demand[part2]) - demand[c2] + demand[c1] <= capacity):\n                    # Swap customers\n                    part1[np.where(part1 == c1)] = c2\n                    part2[np.where(part2 == c2)] = c1\n\n        # Reconstruct the route\n        new_solution[i] = np.concatenate([part1, part2[1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route splitting, customer insertion, and inter-route relocation to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting, customer insertion, and inter-route relocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting - split a long route into two if possible\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Ensure route has at least 3 nodes (0, customer, 0)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer insertion - move a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        to_route_idx = random.randint(0, len(new_solution) - 1)\n        if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 2:\n            from_route = new_solution[from_route_idx]\n            to_route = new_solution[to_route_idx]\n\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Check capacity constraint for new routes\n            new_from_route = np.delete(from_route, customer_idx)\n            new_to_route = np.insert(to_route, -1, customer)\n\n            demand_from = np.sum(demand[new_from_route[1:-1]])\n            demand_to = np.sum(demand[new_to_route[1:-1]])\n            if demand_from <= capacity and demand_to <= capacity:\n                new_solution[from_route_idx] = new_from_route\n                new_solution[to_route_idx] = new_to_route\n\n    # Step 3: Inter-route relocation - relocate a customer between two routes\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx and len(new_solution[route1_idx]) > 2:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select a customer from route1 and a position in route2\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n            pos_in_route2 = random.randint(1, len(route2) - 1)\n\n            # Check capacity constraints\n            new_route1 = np.delete(route1, customer_idx)\n            new_route2 = np.insert(route2, pos_in_route2, customer)\n\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6430638657179281,
            0.6312462389469147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting, customer insertion, and inter-route relocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting - split a long route into two if possible\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Ensure route has at least 3 nodes (0, customer, 0)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer insertion - move a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        to_route_idx = random.randint(0, len(new_solution) - 1)\n        if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 2:\n            from_route = new_solution[from_route_idx]\n            to_route = new_solution[to_route_idx]\n\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_idx]\n\n            # Check capacity constraint for new routes\n            new_from_route = np.delete(from_route, customer_idx)\n            new_to_route = np.insert(to_route, -1, customer)\n\n            demand_from = np.sum(demand[new_from_route[1:-1]])\n            demand_to = np.sum(demand[new_to_route[1:-1]])\n            if demand_from <= capacity and demand_to <= capacity:\n                new_solution[from_route_idx] = new_from_route\n                new_solution[to_route_idx] = new_to_route\n\n    # Step 3: Inter-route relocation - relocate a customer between two routes\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx and len(new_solution[route1_idx]) > 2:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select a customer from route1 and a position in route2\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n            pos_in_route2 = random.randint(1, len(route2) - 1)\n\n            # Check capacity constraints\n            new_route1 = np.delete(route1, customer_idx)\n            new_route2 = np.insert(route2, pos_in_route2, customer)\n\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The algorithm selects a high-potential solution from the archive using a combined metric of normalized distance and makespan, then applies a hybrid local search combining route splitting, customer insertion, and inter-route swaps with feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes, reinsert customers, and swap between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # If route has more than just depot and one customer\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            route1 = route[:split_pos + 1]\n            route2 = [0] + route[split_pos:-1]\n\n            # Check feasibility of split routes\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[i] = route1\n                new_solution.append(route2)\n\n    # Reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reinsert\n            excess_demand = np.sum(demand[route[1:-1]]) - capacity\n            customers = route[1:-1]\n            to_remove = []\n            current_demand = 0\n            for c in customers:\n                if current_demand + demand[c] <= excess_demand:\n                    to_remove.append(c)\n                    current_demand += demand[c]\n                else:\n                    break\n\n            # Remove customers and reinsert into other routes\n            for c in to_remove:\n                route.remove(c)\n                # Find the best route to insert the customer\n                best_route = -1\n                best_pos = -1\n                best_increase = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    other_route = new_solution[j]\n                    for pos in range(1, len(other_route)):\n                        # Insert customer c between pos-1 and pos\n                        new_route = np.insert(other_route, pos, c)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate distance increase\n                            dist_before = distance_matrix[new_route[pos-1], new_route[pos]] + distance_matrix[new_route[pos], new_route[pos+1]]\n                            dist_after = distance_matrix[new_route[pos-1], c] + distance_matrix[c, new_route[pos+1]]\n                            increase = dist_after - dist_before\n                            if increase < best_increase:\n                                best_increase = increase\n                                best_route = j\n                                best_pos = pos\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, c)\n\n    # Inter-route swaps to improve distance\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select two random routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Select two random customers from each route\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n        pos1 = np.random.randint(1, len(route1)-1)\n        pos2 = np.random.randint(1, len(route2)-1)\n        c1 = route1[pos1]\n        c2 = route2[pos2]\n\n        # Swap the customers\n        new_route1 = route1.copy()\n        new_route1[pos1] = c2\n        new_route2 = route2.copy()\n        new_route2[pos2] = c1\n\n        # Check feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Calculate distance change\n            old_dist = (distance_matrix[route1[pos1-1], c1] + distance_matrix[c1, route1[pos1+1]] +\n                        distance_matrix[route2[pos2-1], c2] + distance_matrix[c2, route2[pos2+1]])\n            new_dist = (distance_matrix[route1[pos1-1], c2] + distance_matrix[c2, route1[pos1+1]] +\n                        distance_matrix[route2[pos2-1], c1] + distance_matrix[c1, route2[pos2+1]])\n            if new_dist < old_dist:\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8123684218481235,
            3.0352501273155212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes, reinsert customers, and swap between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # If route has more than just depot and one customer\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            route1 = route[:split_pos + 1]\n            route2 = [0] + route[split_pos:-1]\n\n            # Check feasibility of split routes\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[i] = route1\n                new_solution.append(route2)\n\n    # Reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reinsert\n            excess_demand = np.sum(demand[route[1:-1]]) - capacity\n            customers = route[1:-1]\n            to_remove = []\n            current_demand = 0\n            for c in customers:\n                if current_demand + demand[c] <= excess_demand:\n                    to_remove.append(c)\n                    current_demand += demand[c]\n                else:\n                    break\n\n            # Remove customers and reinsert into other routes\n            for c in to_remove:\n                route.remove(c)\n                # Find the best route to insert the customer\n                best_route = -1\n                best_pos = -1\n                best_increase = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    other_route = new_solution[j]\n                    for pos in range(1, len(other_route)):\n                        # Insert customer c between pos-1 and pos\n                        new_route = np.insert(other_route, pos, c)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate distance increase\n                            dist_before = distance_matrix[new_route[pos-1], new_route[pos]] + distance_matrix[new_route[pos], new_route[pos+1]]\n                            dist_after = distance_matrix[new_route[pos-1], c] + distance_matrix[c, new_route[pos+1]]\n                            increase = dist_after - dist_before\n                            if increase < best_increase:\n                                best_increase = increase\n                                best_route = j\n                                best_pos = pos\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, c)\n\n    # Inter-route swaps to improve distance\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select two random routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Select two random customers from each route\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n        pos1 = np.random.randint(1, len(route1)-1)\n        pos2 = np.random.randint(1, len(route2)-1)\n        c1 = route1[pos1]\n        c2 = route2[pos2]\n\n        # Swap the customers\n        new_route1 = route1.copy()\n        new_route1[pos1] = c2\n        new_route2 = route2.copy()\n        new_route2[pos2] = c1\n\n        # Check feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Calculate distance change\n            old_dist = (distance_matrix[route1[pos1-1], c1] + distance_matrix[c1, route1[pos1+1]] +\n                        distance_matrix[route2[pos2-1], c2] + distance_matrix[c2, route2[pos2+1]])\n            new_dist = (distance_matrix[route1[pos1-1], c2] + distance_matrix[c2, route1[pos1+1]] +\n                        distance_matrix[route2[pos2-1], c1] + distance_matrix[c1, route2[pos2+1]])\n            if new_dist < old_dist:\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with the longest makespan, then applies a hybrid local search combining route-shaking, k-opt swaps, and inter-route insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route-shaking, k-opt, and inter-route insertion\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route-shaking - randomly perturb a route by moving a segment\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Ensure enough nodes to shake\n                start_pos = np.random.randint(1, len(route)-3)\n                end_pos = np.random.randint(start_pos+1, len(route)-1)\n                segment = route[start_pos:end_pos]\n                new_route = np.concatenate([route[:start_pos], route[end_pos:], segment])\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 2: k-opt swap (k=3) - improve a single route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                i, j, k = sorted(np.random.choice(range(1, len(route)-1), 3, replace=False))\n                new_route = np.concatenate([route[:i], route[j:k+1], route[i:j], route[k+1:]])\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 3: Inter-route insertion - move a segment between routes\n        if len(new_solution) > 1:\n            src_route_idx, dst_route_idx = np.random.choice(len(new_solution), 2, replace=False)\n            src_route = new_solution[src_route_idx]\n            dst_route = new_solution[dst_route_idx]\n            if len(src_route) > 3 and len(dst_route) > 2:\n                start_pos = np.random.randint(1, len(src_route)-2)\n                end_pos = np.random.randint(start_pos+1, len(src_route)-1)\n                segment = src_route[start_pos:end_pos]\n                if np.sum(demand[segment]) <= capacity - np.sum(demand[dst_route]):\n                    new_src_route = np.concatenate([src_route[:start_pos], src_route[end_pos:]])\n                    new_dst_route = np.concatenate([dst_route[:1], segment, dst_route[1:]])\n                    new_solution[src_route_idx] = new_src_route\n                    new_solution[dst_route_idx] = new_dst_route\n\n    return new_solution\n\n",
        "score": [
            -0.7197985232928601,
            7.851407617330551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route-shaking, k-opt, and inter-route insertion\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route-shaking - randomly perturb a route by moving a segment\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Ensure enough nodes to shake\n                start_pos = np.random.randint(1, len(route)-3)\n                end_pos = np.random.randint(start_pos+1, len(route)-1)\n                segment = route[start_pos:end_pos]\n                new_route = np.concatenate([route[:start_pos], route[end_pos:], segment])\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 2: k-opt swap (k=3) - improve a single route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                i, j, k = sorted(np.random.choice(range(1, len(route)-1), 3, replace=False))\n                new_route = np.concatenate([route[:i], route[j:k+1], route[i:j], route[k+1:]])\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 3: Inter-route insertion - move a segment between routes\n        if len(new_solution) > 1:\n            src_route_idx, dst_route_idx = np.random.choice(len(new_solution), 2, replace=False)\n            src_route = new_solution[src_route_idx]\n            dst_route = new_solution[dst_route_idx]\n            if len(src_route) > 3 and len(dst_route) > 2:\n                start_pos = np.random.randint(1, len(src_route)-2)\n                end_pos = np.random.randint(start_pos+1, len(src_route)-1)\n                segment = src_route[start_pos:end_pos]\n                if np.sum(demand[segment]) <= capacity - np.sum(demand[dst_route]):\n                    new_src_route = np.concatenate([src_route[:start_pos], src_route[end_pos:]])\n                    new_dst_route = np.concatenate([dst_route[:1], segment, dst_route[1:]])\n                    new_solution[src_route_idx] = new_src_route\n                    new_solution[dst_route_idx] = new_dst_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search that combines route splitting, customer reallocation, and capacity-aware edge swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swaps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has at least one customer\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        customer = random.choice(route1[1:-1])\n        route1 = np.delete(route1, np.where(route1 == customer))\n\n        # Find a target route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route1_idx:\n            continue\n        target_route = new_solution[target_route_idx]\n\n        # Insert customer at best position in target route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(target_route)):\n            new_route = np.insert(target_route, pos, customer)\n            cost = distance_matrix[new_route[pos-1]][customer] + distance_matrix[customer][new_route[pos+1]] - distance_matrix[new_route[pos-1]][new_route[pos+1]]\n            if cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                best_cost = cost\n                best_pos = pos\n\n        if best_cost < float('inf'):\n            new_route = np.insert(target_route, best_pos, customer)\n            new_solution[target_route_idx] = new_route\n            new_solution[route1_idx] = route1\n\n    # Step 3: Edge swaps with capacity check\n    for _ in range(3):  # Try a few swaps\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Perform the swap\n        new_route = route.copy()\n        new_route[i:j] = route[i:j][::-1]\n\n        # Check capacity\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n",
        "score": [
            -0.648414177437318,
            2.551441967487335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swaps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has at least one customer\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Step 2: Customer reallocation - move customers between routes\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        customer = random.choice(route1[1:-1])\n        route1 = np.delete(route1, np.where(route1 == customer))\n\n        # Find a target route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route1_idx:\n            continue\n        target_route = new_solution[target_route_idx]\n\n        # Insert customer at best position in target route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(target_route)):\n            new_route = np.insert(target_route, pos, customer)\n            cost = distance_matrix[new_route[pos-1]][customer] + distance_matrix[customer][new_route[pos+1]] - distance_matrix[new_route[pos-1]][new_route[pos+1]]\n            if cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                best_cost = cost\n                best_pos = pos\n\n        if best_cost < float('inf'):\n            new_route = np.insert(target_route, best_pos, customer)\n            new_solution[target_route_idx] = new_route\n            new_solution[route1_idx] = route1\n\n    # Step 3: Edge swaps with capacity check\n    for _ in range(3):  # Try a few swaps\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Perform the swap\n        new_route = route.copy()\n        new_route[i:j] = route[i:j][::-1]\n\n        # Check capacity\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid Local Search: Route Merging with 2-opt-like improvements\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Merge adjacent routes if total demand allows (to reduce makespan)\n        merged = False\n        for i in range(len(selected_solution)):\n            if i == len(selected_solution) - 1:\n                break\n            route1 = selected_solution[i]\n            route2 = selected_solution[i + 1]\n            if sum(demand[r] for r in route1[1:-1]) + sum(demand[r] for r in route2[1:-1]) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                merged = True\n                break\n\n        if not merged:\n            # Apply 2-opt-like improvement on the current route\n            improved_route = route.copy()\n            for _ in range(5):  # Limited iterations for efficiency\n                a, b = sorted(random.sample(range(1, len(improved_route) - 1), 2))\n                new_route = np.concatenate([improved_route[:a], improved_route[b:a-1:-1], improved_route[b+1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    improved_route = new_route\n            new_solution.append(improved_route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = all_customers - served\n\n    # Add missing customers to the longest route (to balance makespan)\n    if missing:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]].sum()) for route in new_solution])\n        new_route = new_solution[longest_route_idx].copy()\n        for node in missing:\n            if sum(demand[new_route[1:-1]]) + demand[node] <= capacity:\n                # Insert at the position that minimizes additional distance\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(new_route)):\n                    cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i]] - distance_matrix[new_route[i-1], new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                new_route = np.insert(new_route, best_pos, node)\n        new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5836782048361537,
            6.220951706171036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid Local Search: Route Merging with 2-opt-like improvements\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Merge adjacent routes if total demand allows (to reduce makespan)\n        merged = False\n        for i in range(len(selected_solution)):\n            if i == len(selected_solution) - 1:\n                break\n            route1 = selected_solution[i]\n            route2 = selected_solution[i + 1]\n            if sum(demand[r] for r in route1[1:-1]) + sum(demand[r] for r in route2[1:-1]) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                merged = True\n                break\n\n        if not merged:\n            # Apply 2-opt-like improvement on the current route\n            improved_route = route.copy()\n            for _ in range(5):  # Limited iterations for efficiency\n                a, b = sorted(random.sample(range(1, len(improved_route) - 1), 2))\n                new_route = np.concatenate([improved_route[:a], improved_route[b:a-1:-1], improved_route[b+1:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    improved_route = new_route\n            new_solution.append(improved_route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = all_customers - served\n\n    # Add missing customers to the longest route (to balance makespan)\n    if missing:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]].sum()) for route in new_solution])\n        new_route = new_solution[longest_route_idx].copy()\n        for node in missing:\n            if sum(demand[new_route[1:-1]]) + demand[node] <= capacity:\n                # Insert at the position that minimizes additional distance\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(new_route)):\n                    cost = distance_matrix[new_route[i-1], node] + distance_matrix[node, new_route[i]] - distance_matrix[new_route[i-1], new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n                new_route = np.insert(new_route, best_pos, node)\n        new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid of Pareto dominance and diversity, then applies a novel route-merging operator that intelligently combines segments from different routes while ensuring feasibility, followed by a capacity-aware route-splitting to refine the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_sol = max(archive, key=lambda x: (x[1][1], -x[1][0]))[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: Route-merging followed by capacity-aware route-splitting\n    if len(new_solution) > 1:\n        # Step 1: Route-merging - combine two routes into one if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        merged_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if merged_demand <= capacity:\n            # Create merged route (without depots)\n            merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n            # Randomly insert depot at a valid position\n            split_pos = random.randint(1, len(merged_route))\n            new_route = np.concatenate([[0], merged_route[:split_pos], [0], merged_route[split_pos:], [0]])\n            # Replace the two routes with the merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(new_route)\n\n    # Step 2: Capacity-aware route-splitting - split overloaded routes\n    for i, route in enumerate(new_solution):\n        current_demand = sum(demand[route[1:-1]])\n        if current_demand > capacity:\n            # Find a split point that minimizes the increase in total distance\n            best_split = 1\n            best_increase = float('inf')\n            for split_pos in range(1, len(route)-1):\n                part1 = route[:split_pos+1]\n                part2 = np.concatenate([[0], route[split_pos:-1]])\n                increase = (distance_matrix[part1[-2]][0] + distance_matrix[0][part2[1]] -\n                            distance_matrix[part1[-2]][part1[-1]])\n                if increase < best_increase:\n                    best_increase = increase\n                    best_split = split_pos\n            # Perform the split\n            part1 = route[:best_split+1]\n            part2 = np.concatenate([[0], route[best_split:-1]])\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n    return new_solution\n\n",
        "score": [
            -0.738338984446085,
            0.728039026260376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_sol = max(archive, key=lambda x: (x[1][1], -x[1][0]))[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: Route-merging followed by capacity-aware route-splitting\n    if len(new_solution) > 1:\n        # Step 1: Route-merging - combine two routes into one if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        merged_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if merged_demand <= capacity:\n            # Create merged route (without depots)\n            merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n            # Randomly insert depot at a valid position\n            split_pos = random.randint(1, len(merged_route))\n            new_route = np.concatenate([[0], merged_route[:split_pos], [0], merged_route[split_pos:], [0]])\n            # Replace the two routes with the merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(new_route)\n\n    # Step 2: Capacity-aware route-splitting - split overloaded routes\n    for i, route in enumerate(new_solution):\n        current_demand = sum(demand[route[1:-1]])\n        if current_demand > capacity:\n            # Find a split point that minimizes the increase in total distance\n            best_split = 1\n            best_increase = float('inf')\n            for split_pos in range(1, len(route)-1):\n                part1 = route[:split_pos+1]\n                part2 = np.concatenate([[0], route[split_pos:-1]])\n                increase = (distance_matrix[part1[-2]][0] + distance_matrix[0][part2[1]] -\n                            distance_matrix[part1[-2]][part1[-1]])\n                if increase < best_increase:\n                    best_increase = increase\n                    best_split = split_pos\n            # Perform the split\n            part1 = route[:best_split+1]\n            part2 = np.concatenate([[0], route[best_split:-1]])\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The algorithm selects a promising solution from the archive by considering both objective values (total distance and makespan), then applies a hybrid local search operator that combines route splitting, customer reallocation, and partial route reversal to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions where makespan dominates total distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting, customer reallocation, and partial route reversal\n    for _ in range(3):  # Perform multiple iterations for robustness\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break  # Skip if only one route exists\n\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random customer\n        if len(route) > 3:  # Ensure route has at least one customer to split\n            split_pos = np.random.randint(1, len(route) - 1)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            # Check capacity constraints for the split\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n\n        # Step 3: Randomly reallocate a customer from one route to another\n        if len(new_solution) >= 2:\n            from_route_idx = np.random.randint(0, len(new_solution))\n            to_route_idx = np.random.randint(0, len(new_solution))\n            if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 3:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                # Select a random customer from from_route\n                customer_idx = np.random.randint(1, len(from_route) - 1)\n                customer = from_route[customer_idx]\n\n                # Insert customer into to_route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    new_to_route = np.insert(to_route, pos, customer)\n                    if np.sum(demand[new_to_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[to_route[pos - 1]][customer] + distance_matrix[customer][to_route[pos]] - distance_matrix[to_route[pos - 1]][to_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_to_route = np.insert(to_route, best_pos, customer)\n                    new_solution[to_route_idx] = new_to_route\n                    new_solution[from_route_idx] = np.delete(from_route, customer_idx)\n\n        # Step 4: Randomly reverse a segment of a route\n        if len(new_solution) >= 1:\n            route_to_reverse = new_solution[np.random.randint(0, len(new_solution))]\n            if len(route_to_reverse) > 4:  # Ensure route has enough nodes to reverse\n                start = np.random.randint(1, len(route_to_reverse) - 2)\n                end = np.random.randint(start + 1, len(route_to_reverse) - 1)\n                reversed_segment = route_to_reverse[start:end][::-1]\n                route_to_reverse[start:end] = reversed_segment\n\n    # Ensure no empty routes remain\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7636048850932268,
            1.7460690438747406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions where makespan dominates total distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting, customer reallocation, and partial route reversal\n    for _ in range(3):  # Perform multiple iterations for robustness\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break  # Skip if only one route exists\n\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts at a random customer\n        if len(route) > 3:  # Ensure route has at least one customer to split\n            split_pos = np.random.randint(1, len(route) - 1)\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            # Check capacity constraints for the split\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n\n        # Step 3: Randomly reallocate a customer from one route to another\n        if len(new_solution) >= 2:\n            from_route_idx = np.random.randint(0, len(new_solution))\n            to_route_idx = np.random.randint(0, len(new_solution))\n            if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 3:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                # Select a random customer from from_route\n                customer_idx = np.random.randint(1, len(from_route) - 1)\n                customer = from_route[customer_idx]\n\n                # Insert customer into to_route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    new_to_route = np.insert(to_route, pos, customer)\n                    if np.sum(demand[new_to_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[to_route[pos - 1]][customer] + distance_matrix[customer][to_route[pos]] - distance_matrix[to_route[pos - 1]][to_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_to_route = np.insert(to_route, best_pos, customer)\n                    new_solution[to_route_idx] = new_to_route\n                    new_solution[from_route_idx] = np.delete(from_route, customer_idx)\n\n        # Step 4: Randomly reverse a segment of a route\n        if len(new_solution) >= 1:\n            route_to_reverse = new_solution[np.random.randint(0, len(new_solution))]\n            if len(route_to_reverse) > 4:  # Ensure route has enough nodes to reverse\n                start = np.random.randint(1, len(route_to_reverse) - 2)\n                end = np.random.randint(start + 1, len(route_to_reverse) - 1)\n                reversed_segment = route_to_reverse[start:end][::-1]\n                route_to_reverse[start:end] = reversed_segment\n\n    # Ensure no empty routes remain\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Apply a hybrid local search: split the longest route into two parts and reinsert nodes from the split\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos]\n    part2 = longest_route[split_pos:]\n\n    # Reinsert nodes from part2 into part1 while maintaining feasibility\n    new_route = part1.tolist()\n    for node in part2[1:-1]:  # Skip depot\n        best_pos = 1\n        min_increase = float('inf')\n        for i in range(1, len(new_route)):\n            temp_route = new_route[:i] + [node] + new_route[i:]\n            temp_demand = sum(demand[temp_route[1:-1]])\n            if temp_demand <= capacity:\n                cost_increase = distance_matrix[temp_route[i-1], node] + distance_matrix[node, temp_route[i]] - distance_matrix[temp_route[i-1], temp_route[i]]\n                if cost_increase < min_increase:\n                    min_increase = cost_increase\n                    best_pos = i\n        new_route.insert(best_pos, node)\n\n    # Update the solution with the new route\n    selected_solution[longest_route_idx] = np.array(new_route)\n\n    # Check if the new route is feasible\n    if sum(demand[new_route[1:-1]]) > capacity:\n        # If not, revert to the original route\n        selected_solution[longest_route_idx] = longest_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7351583896952225,
            0.6436938643455505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Apply a hybrid local search: split the longest route into two parts and reinsert nodes from the split\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos]\n    part2 = longest_route[split_pos:]\n\n    # Reinsert nodes from part2 into part1 while maintaining feasibility\n    new_route = part1.tolist()\n    for node in part2[1:-1]:  # Skip depot\n        best_pos = 1\n        min_increase = float('inf')\n        for i in range(1, len(new_route)):\n            temp_route = new_route[:i] + [node] + new_route[i:]\n            temp_demand = sum(demand[temp_route[1:-1]])\n            if temp_demand <= capacity:\n                cost_increase = distance_matrix[temp_route[i-1], node] + distance_matrix[node, temp_route[i]] - distance_matrix[temp_route[i-1], temp_route[i]]\n                if cost_increase < min_increase:\n                    min_increase = cost_increase\n                    best_pos = i\n        new_route.insert(best_pos, node)\n\n    # Update the solution with the new route\n    selected_solution[longest_route_idx] = np.array(new_route)\n\n    # Check if the new route is feasible\n    if sum(demand[new_route[1:-1]]) > capacity:\n        # If not, revert to the original route\n        selected_solution[longest_route_idx] = longest_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate((route[:split_idx + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_idx:]))\n\n            # Check feasibility for new routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Relocate a random customer from one route to another\n    if len(new_solution) > 1:\n        source_route_idx = np.random.randint(len(new_solution))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:\n            # Select a random customer to relocate\n            customer_idx = np.random.randint(1, len(source_route) - 1)\n            customer = source_route[customer_idx]\n\n            # Find a target route that can accommodate the customer\n            for j in range(len(new_solution)):\n                if j != source_route_idx:\n                    target_route = new_solution[j]\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the target route at a random position\n                        insert_pos = np.random.randint(1, len(target_route))\n                        new_route = np.insert(target_route, insert_pos, customer)\n                        new_solution[j] = new_route\n\n                        # Remove the customer from the source route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6519437299527764,
            0.5046661496162415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate((route[:split_idx + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_idx:]))\n\n            # Check feasibility for new routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Relocate a random customer from one route to another\n    if len(new_solution) > 1:\n        source_route_idx = np.random.randint(len(new_solution))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:\n            # Select a random customer to relocate\n            customer_idx = np.random.randint(1, len(source_route) - 1)\n            customer = source_route[customer_idx]\n\n            # Find a target route that can accommodate the customer\n            for j in range(len(new_solution)):\n                if j != source_route_idx:\n                    target_route = new_solution[j]\n                    if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the target route at a random position\n                        insert_pos = np.random.randint(1, len(target_route))\n                        new_route = np.insert(target_route, insert_pos, customer)\n                        new_solution[j] = new_route\n\n                        # Remove the customer from the source route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify routes with low utilization (capacity < 50%)\n    low_util_routes = []\n    for i, route in enumerate(new_solution):\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand < capacity * 0.5:\n            low_util_routes.append(i)\n\n    # Step 2: Merge low-utilization routes if possible\n    if len(low_util_routes) >= 2:\n        route1_idx = low_util_routes[0]\n        route2_idx = low_util_routes[1]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to merge by inserting route2 into route1\n        merged_route = route1[:-1] + route2[1:]\n        merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n        if merged_demand <= capacity:\n            new_solution[route1_idx] = np.array(merged_route)\n            new_solution.pop(route2_idx)\n\n    # Step 3: Relocate customers from long routes to shorter ones\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the shortest route\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to relocate a customer from the longest to the shortest route\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            # Check if moving this customer to the shortest route is feasible\n            new_shortest_route = np.insert(shortest_route, -1, customer)\n            new_shortest_demand = sum(demand[node] for node in new_shortest_route[1:-1])\n\n            if new_shortest_demand <= capacity:\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = np.delete(longest_route, i)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7117121780870592,
            0.7344590425491333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify routes with low utilization (capacity < 50%)\n    low_util_routes = []\n    for i, route in enumerate(new_solution):\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand < capacity * 0.5:\n            low_util_routes.append(i)\n\n    # Step 2: Merge low-utilization routes if possible\n    if len(low_util_routes) >= 2:\n        route1_idx = low_util_routes[0]\n        route2_idx = low_util_routes[1]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to merge by inserting route2 into route1\n        merged_route = route1[:-1] + route2[1:]\n        merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n        if merged_demand <= capacity:\n            new_solution[route1_idx] = np.array(merged_route)\n            new_solution.pop(route2_idx)\n\n    # Step 3: Relocate customers from long routes to shorter ones\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the shortest route\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to relocate a customer from the longest to the shortest route\n        for i in range(1, len(longest_route) - 1):\n            customer = longest_route[i]\n            # Check if moving this customer to the shortest route is feasible\n            new_shortest_route = np.insert(shortest_route, -1, customer)\n            new_shortest_demand = sum(demand[node] for node in new_shortest_route[1:-1])\n\n            if new_shortest_demand <= capacity:\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = np.delete(longest_route, i)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Hybrid local search: Split and Rebalance\n        if len(selected_route) > 3:  # Ensure route can be split\n            # Find split point that balances demand and distance\n            split_point = len(selected_route) // 2\n            total_demand = sum(demand[selected_route[1:-1]])\n            half_demand = total_demand / 2\n\n            current_demand = 0\n            for i in range(1, len(selected_route)-1):\n                current_demand += demand[selected_route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n\n            # Split the route into two parts\n            route1 = selected_route[:split_point+1] + [0]\n            route2 = [0] + selected_route[split_point+1:]\n\n            # Check feasibility of new routes\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.7650636802793804,
            0.27696070075035095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Hybrid local search: Split and Rebalance\n        if len(selected_route) > 3:  # Ensure route can be split\n            # Find split point that balances demand and distance\n            split_point = len(selected_route) // 2\n            total_demand = sum(demand[selected_route[1:-1]])\n            half_demand = total_demand / 2\n\n            current_demand = 0\n            for i in range(1, len(selected_route)-1):\n                current_demand += demand[selected_route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n\n            # Split the route into two parts\n            route1 = selected_route[:split_point+1] + [0]\n            route2 = [0] + selected_route[split_point+1:]\n\n            # Check feasibility of new routes\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.append(route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Hybrid local search: Split and Rebalance\n        if len(selected_route) > 3:  # Ensure route can be split\n            # Find split point that balances demand and distance\n            split_point = len(selected_route) // 2\n            total_demand = sum(demand[selected_route[1:-1]])\n            half_demand = total_demand / 2\n\n            current_demand = 0\n            for i in range(1, len(selected_route)-1):\n                current_demand += demand[selected_route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n\n            # Split the route into two parts\n            route1 = selected_route[:split_point+1] + [0]\n            route2 = [0] + selected_route[split_point+1:]\n\n            # Check feasibility of new routes\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.7650636802793804,
            0.27696070075035095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Hybrid local search: Split and Rebalance\n        if len(selected_route) > 3:  # Ensure route can be split\n            # Find split point that balances demand and distance\n            split_point = len(selected_route) // 2\n            total_demand = sum(demand[selected_route[1:-1]])\n            half_demand = total_demand / 2\n\n            current_demand = 0\n            for i in range(1, len(selected_route)-1):\n                current_demand += demand[selected_route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n\n            # Split the route into two parts\n            route1 = selected_route[:split_point+1] + [0]\n            route2 = [0] + selected_route[split_point+1:]\n\n            # Check feasibility of new routes\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.append(route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route splitting, inter-route swapping, and demand-aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search operators\n    # Operator 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Operator 2: Inter-route swapping (swap segments between routes)\n    if len(new_solution) >= 2:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:seg1_start],\n                route2[seg2_start:seg2_end],\n                route1[seg1_end:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:seg2_start],\n                route1[seg1_start:seg1_end],\n                route2[seg2_end:]\n            ])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    # Operator 3: Demand-aware node reinsertion (move nodes between routes)\n    # Select a random node to move\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) > 0:\n        node_to_move = random.choice(list(all_nodes))\n\n        # Find the route containing the node\n        source_route_idx = -1\n        node_pos = -1\n        for i, route in enumerate(new_solution):\n            if node_to_move in route:\n                source_route_idx = i\n                node_pos = np.where(route == node_to_move)[0][0]\n                break\n\n        if source_route_idx != -1:\n            # Remove the node from its current route\n            source_route = new_solution[source_route_idx]\n            new_source_route = np.concatenate([\n                source_route[:node_pos],\n                source_route[node_pos+1:]\n            ])\n            new_solution[source_route_idx] = new_source_route\n\n            # Find the best position to insert the node into another route\n            best_cost = float('inf')\n            best_route_idx = -1\n            best_insert_pos = -1\n\n            for i, route in enumerate(new_solution):\n                if i == source_route_idx:\n                    continue\n\n                # Check if adding the node exceeds capacity\n                if np.sum(demand[route[1:-1]]) + demand[node_to_move] > capacity:\n                    continue\n\n                # Evaluate insertion positions\n                for pos in range(1, len(route)):\n                    # Insert node and calculate the cost change\n                    new_route = np.concatenate([\n                        route[:pos],\n                        [node_to_move],\n                        route[pos:]\n                    ])\n\n                    # Calculate the new distance\n                    prev_node = new_route[pos-1]\n                    next_node = new_route[pos+1]\n                    original_dist = distance_matrix[prev_node][next_node]\n                    new_dist = (distance_matrix[prev_node][node_to_move] +\n                                distance_matrix[node_to_move][next_node])\n\n                    cost_change = new_dist - original_dist\n\n                    if cost_change < best_cost:\n                        best_cost = cost_change\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_best_route = np.concatenate([\n                    best_route[:best_insert_pos],\n                    [node_to_move],\n                    best_route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_best_route\n\n    return new_solution\n\n",
        "score": [
            -0.8773698776954547,
            6.96139457821846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search operators\n    # Operator 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Operator 2: Inter-route swapping (swap segments between routes)\n    if len(new_solution) >= 2:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[r1]\n        route2 = new_solution[r2]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:seg1_start],\n                route2[seg2_start:seg2_end],\n                route1[seg1_end:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:seg2_start],\n                route1[seg1_start:seg1_end],\n                route2[seg2_end:]\n            ])\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n    # Operator 3: Demand-aware node reinsertion (move nodes between routes)\n    # Select a random node to move\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) > 0:\n        node_to_move = random.choice(list(all_nodes))\n\n        # Find the route containing the node\n        source_route_idx = -1\n        node_pos = -1\n        for i, route in enumerate(new_solution):\n            if node_to_move in route:\n                source_route_idx = i\n                node_pos = np.where(route == node_to_move)[0][0]\n                break\n\n        if source_route_idx != -1:\n            # Remove the node from its current route\n            source_route = new_solution[source_route_idx]\n            new_source_route = np.concatenate([\n                source_route[:node_pos],\n                source_route[node_pos+1:]\n            ])\n            new_solution[source_route_idx] = new_source_route\n\n            # Find the best position to insert the node into another route\n            best_cost = float('inf')\n            best_route_idx = -1\n            best_insert_pos = -1\n\n            for i, route in enumerate(new_solution):\n                if i == source_route_idx:\n                    continue\n\n                # Check if adding the node exceeds capacity\n                if np.sum(demand[route[1:-1]]) + demand[node_to_move] > capacity:\n                    continue\n\n                # Evaluate insertion positions\n                for pos in range(1, len(route)):\n                    # Insert node and calculate the cost change\n                    new_route = np.concatenate([\n                        route[:pos],\n                        [node_to_move],\n                        route[pos:]\n                    ])\n\n                    # Calculate the new distance\n                    prev_node = new_route[pos-1]\n                    next_node = new_route[pos+1]\n                    original_dist = distance_matrix[prev_node][next_node]\n                    new_dist = (distance_matrix[prev_node][node_to_move] +\n                                distance_matrix[node_to_move][next_node])\n\n                    cost_change = new_dist - original_dist\n\n                    if cost_change < best_cost:\n                        best_cost = cost_change\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_best_route = np.concatenate([\n                    best_route[:best_insert_pos],\n                    [node_to_move],\n                    best_route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_best_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The algorithm selects a solution from the archive based on the Pareto front, then applies a hybrid local search combining route splitting, customer insertion, and route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: route splitting, customer insertion, and route merging\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route if possible (reduce makespan)\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = [0] + route[split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n        else:\n            new_solution.append(route.copy())\n\n        # Randomly insert a customer from another route\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route = random.choice([r for r in new_solution if r is not route and len(r) > 3])\n            if other_route is not None:\n                # Select a random customer from other_route\n                customer_idx = random.randint(1, len(other_route) - 2)\n                customer = other_route[customer_idx]\n\n                # Find best insertion point in current route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route)):\n                    # Insert customer between route[i-1] and route[i]\n                    new_route = np.concatenate([route[:i], [customer], route[i:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[route[i-1], customer] + distance_matrix[customer, route[i]] - distance_matrix[route[i-1], route[i]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                if best_cost < float('inf'):\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution.append(new_route)\n                    # Remove customer from other_route\n                    other_route = np.delete(other_route, customer_idx)\n                    if len(other_route) > 2:  # Ensure route remains valid\n                        new_solution.append(other_route)\n                    else:\n                        new_solution.remove(other_route)\n\n    # Merge routes if possible (reduce total distance)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Try to merge route1 into route2\n            best_merge = None\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)):\n                for j in range(1, len(route1)):\n                    # Insert route1 after route2[i] and before route2[i+1]\n                    merged_route = np.concatenate([route2[:i], route1[1:-1], route2[i:]])\n                    if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[i-1], route1[1]] +\n                                distance_matrix[route1[-2], route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = merged_route\n\n            if best_merge is not None:\n                new_solution[route2_idx] = best_merge\n                new_solution.pop(route1_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.6535052809127531,
            6.208096206188202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: route splitting, customer insertion, and route merging\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route if possible (reduce makespan)\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = [0] + route[split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n        else:\n            new_solution.append(route.copy())\n\n        # Randomly insert a customer from another route\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route = random.choice([r for r in new_solution if r is not route and len(r) > 3])\n            if other_route is not None:\n                # Select a random customer from other_route\n                customer_idx = random.randint(1, len(other_route) - 2)\n                customer = other_route[customer_idx]\n\n                # Find best insertion point in current route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route)):\n                    # Insert customer between route[i-1] and route[i]\n                    new_route = np.concatenate([route[:i], [customer], route[i:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[route[i-1], customer] + distance_matrix[customer, route[i]] - distance_matrix[route[i-1], route[i]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                if best_cost < float('inf'):\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution.append(new_route)\n                    # Remove customer from other_route\n                    other_route = np.delete(other_route, customer_idx)\n                    if len(other_route) > 2:  # Ensure route remains valid\n                        new_solution.append(other_route)\n                    else:\n                        new_solution.remove(other_route)\n\n    # Merge routes if possible (reduce total distance)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Try to merge route1 into route2\n            best_merge = None\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)):\n                for j in range(1, len(route1)):\n                    # Insert route1 after route2[i] and before route2[i+1]\n                    merged_route = np.concatenate([route2[:i], route1[1:-1], route2[i:]])\n                    if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[i-1], route1[1]] +\n                                distance_matrix[route1[-2], route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = merged_route\n\n            if best_merge is not None:\n                new_solution[route2_idx] = best_merge\n                new_solution.pop(route1_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment longest route and reinsert nodes with demand-aware placement\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([len(route) - 1 for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two segments\n        split_pos = len(longest_route) // 2\n        segment1 = longest_route[:split_pos]\n        segment2 = longest_route[split_pos:]\n\n        # Reinsert nodes from segment2 into the solution with demand-aware placement\n        for node in segment2[1:-1]:  # Exclude depots\n            best_route_idx = -1\n            best_insert_pos = -1\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue  # Skip the original route\n                for pos in range(1, len(route)):\n                    # Check capacity constraint\n                    if sum(demand[route[1:pos]]) + demand[node] <= capacity:\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1], node] +\n                                        distance_matrix[node, route[pos]] -\n                                        distance_matrix[route[pos-1], route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n            if best_route_idx != -1:\n                # Insert node into the best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, node)\n                # Remove from original route\n                new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == node))\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.63472351373438,
            10.226606100797653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment longest route and reinsert nodes with demand-aware placement\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([len(route) - 1 for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two segments\n        split_pos = len(longest_route) // 2\n        segment1 = longest_route[:split_pos]\n        segment2 = longest_route[split_pos:]\n\n        # Reinsert nodes from segment2 into the solution with demand-aware placement\n        for node in segment2[1:-1]:  # Exclude depots\n            best_route_idx = -1\n            best_insert_pos = -1\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue  # Skip the original route\n                for pos in range(1, len(route)):\n                    # Check capacity constraint\n                    if sum(demand[route[1:pos]]) + demand[node] <= capacity:\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route[pos-1], node] +\n                                        distance_matrix[node, route[pos]] -\n                                        distance_matrix[route[pos-1], route[pos]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n            if best_route_idx != -1:\n                # Insert node into the best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, node)\n                # Remove from original route\n                new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == node))\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = sorted(archive, key=lambda x: x[1][1])[:3]\n    selected_solution = random.choice(selected_solution)[0].copy()\n\n    # Apply a hybrid local search operator: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = random.randint(1, len(route)-2)\n        part1 = route[:split_point]\n        part2 = route[split_point:]\n\n        # Check if both parts are feasible\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    # Find the longest and shortest routes\n    longest_route = max(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n    shortest_route = min(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n    if len(longest_route) > 3 and len(shortest_route) > 3:\n        # Try to move a customer from longest to shortest route\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            # Check if moving this customer to the shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Create new routes with the customer moved\n                new_longest = np.concatenate([longest_route[:i], longest_route[i+1:]])\n                new_shortest = np.concatenate([shortest_route[:-1], [customer], [0]])\n                # Replace in solution\n                new_solution = [r for r in new_solution if not np.array_equal(r, longest_route) and not np.array_equal(r, shortest_route)]\n                new_solution.append(new_longest)\n                new_solution.append(new_shortest)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7432702869685108,
            1.0436614751815796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = sorted(archive, key=lambda x: x[1][1])[:3]\n    selected_solution = random.choice(selected_solution)[0].copy()\n\n    # Apply a hybrid local search operator: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = random.randint(1, len(route)-2)\n        part1 = route[:split_point]\n        part2 = route[split_point:]\n\n        # Check if both parts are feasible\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reallocate customers between routes to balance makespan\n    # Find the longest and shortest routes\n    longest_route = max(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n    shortest_route = min(new_solution, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n    if len(longest_route) > 3 and len(shortest_route) > 3:\n        # Try to move a customer from longest to shortest route\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            # Check if moving this customer to the shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Create new routes with the customer moved\n                new_longest = np.concatenate([longest_route[:i], longest_route[i+1:]])\n                new_shortest = np.concatenate([shortest_route[:-1], [customer], [0]])\n                # Replace in solution\n                new_solution = [r for r in new_solution if not np.array_equal(r, longest_route) and not np.array_equal(r, shortest_route)]\n                new_solution.append(new_longest)\n                new_solution.append(new_shortest)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The algorithm intelligently selects a solution with high potential for improvement by prioritizing those with long makespans or high total distances, then applies a hybrid local search combining route merging and partial 2-opt with demand-aware insertion to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)  # Sort by makespan then total distance\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + demand-aware partial 2-opt\n    if len(new_solution) > 1:\n        # Try merging two routes if possible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting route2 into route1\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = np.array(merged_route, dtype=int)\n                new_solution.pop(route2_idx)\n                return new_solution\n\n    # If merging failed, apply demand-aware partial 2-opt\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Select two random segments (excluding depots)\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            segment1 = route[i:j+1]\n            segment2 = route[j+1:len(route)-1]\n\n            # Check demand feasibility\n            if np.sum(demand[segment1]) + np.sum(demand[segment2]) <= capacity:\n                # Reverse the segments\n                new_route = np.concatenate([route[:i], segment1[::-1], segment2, route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.9359724892795251,
            1.1597477495670319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)  # Sort by makespan then total distance\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + demand-aware partial 2-opt\n    if len(new_solution) > 1:\n        # Try merging two routes if possible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting route2 into route1\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = np.array(merged_route, dtype=int)\n                new_solution.pop(route2_idx)\n                return new_solution\n\n    # If merging failed, apply demand-aware partial 2-opt\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Select two random segments (excluding depots)\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            segment1 = route[i:j+1]\n            segment2 = route[j+1:len(route)-1]\n\n            # Check demand feasibility\n            if np.sum(demand[segment1]) + np.sum(demand[segment2]) <= capacity:\n                # Reverse the segments\n                new_route = np.concatenate([route[:i], segment1[::-1], segment2, route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The algorithm intelligently selects a solution with high potential for improvement by prioritizing those with long makespans or high total distances, then applies a hybrid local search combining route merging and partial 2-opt with demand-aware insertion to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)  # Sort by makespan then total distance\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + demand-aware partial 2-opt\n    if len(new_solution) > 1:\n        # Try merging two routes if possible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting route2 into route1\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = np.array(merged_route, dtype=int)\n                new_solution.pop(route2_idx)\n                return new_solution\n\n    # If merging failed, apply demand-aware partial 2-opt\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Select two random segments (excluding depots)\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            segment1 = route[i:j+1]\n            segment2 = route[j+1:len(route)-1]\n\n            # Check demand feasibility\n            if np.sum(demand[segment1]) + np.sum(demand[segment2]) <= capacity:\n                # Reverse the segments\n                new_route = np.concatenate([route[:i], segment1[::-1], segment2, route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.9359724892795251,
            1.1597477495670319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]), reverse=True)  # Sort by makespan then total distance\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + demand-aware partial 2-opt\n    if len(new_solution) > 1:\n        # Try merging two routes if possible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Try inserting route2 into route1\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = np.array(merged_route, dtype=int)\n                new_solution.pop(route2_idx)\n                return new_solution\n\n    # If merging failed, apply demand-aware partial 2-opt\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Select two random segments (excluding depots)\n            i, j = sorted(random.sample(range(1, len(route)-2), 2))\n            segment1 = route[i:j+1]\n            segment2 = route[j+1:len(route)-1]\n\n            # Check demand feasibility\n            if np.sum(demand[segment1]) + np.sum(demand[segment2]) <= capacity:\n                # Reverse the segments\n                new_route = np.concatenate([route[:i], segment1[::-1], segment2, route[-1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route balancing and insertion heuristic\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Step 1: Identify long segments and split them\n        max_segment = 0\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            segment_length = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if segment_length > max_segment:\n                max_segment = segment_length\n                split_pos = j\n\n        if split_pos > 0:\n            # Split the route at the longest segment\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                continue\n\n        # Step 2: If no good split, try reinserting high-demand nodes\n        demands = demand[route[1:-1]]\n        high_demand_nodes = route[1:-1][demands > capacity * 0.7]\n        if len(high_demand_nodes) > 0:\n            node_to_move = np.random.choice(high_demand_nodes)\n            # Find best insertion point in another route\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n                target_route = new_solution[j]\n                if np.sum(demand[target_route[1:-1]]) + demand[node_to_move] > capacity:\n                    continue\n                # Try inserting at all possible positions\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    new_route = np.insert(target_route, pos, node_to_move)\n                    cost = (distance_matrix[new_route[pos-1]][node_to_move] +\n                            distance_matrix[node_to_move][new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1]][new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                if best_cost < float('inf'):\n                    new_route = np.insert(target_route, best_pos, node_to_move)\n                    new_solution[j] = new_route\n                    # Remove from original route\n                    original_pos = np.where(route == node_to_move)[0][0]\n                    new_solution[i] = np.delete(route, original_pos)\n                    break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if len(route) > 2 and np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.7499538110861995,
            2.231392979621887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route balancing and insertion heuristic\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Step 1: Identify long segments and split them\n        max_segment = 0\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            segment_length = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if segment_length > max_segment:\n                max_segment = segment_length\n                split_pos = j\n\n        if split_pos > 0:\n            # Split the route at the longest segment\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                continue\n\n        # Step 2: If no good split, try reinserting high-demand nodes\n        demands = demand[route[1:-1]]\n        high_demand_nodes = route[1:-1][demands > capacity * 0.7]\n        if len(high_demand_nodes) > 0:\n            node_to_move = np.random.choice(high_demand_nodes)\n            # Find best insertion point in another route\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n                target_route = new_solution[j]\n                if np.sum(demand[target_route[1:-1]]) + demand[node_to_move] > capacity:\n                    continue\n                # Try inserting at all possible positions\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    new_route = np.insert(target_route, pos, node_to_move)\n                    cost = (distance_matrix[new_route[pos-1]][node_to_move] +\n                            distance_matrix[node_to_move][new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1]][new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                if best_cost < float('inf'):\n                    new_route = np.insert(target_route, best_pos, node_to_move)\n                    new_solution[j] = new_route\n                    # Remove from original route\n                    original_pos = np.where(route == node_to_move)[0][0]\n                    new_solution[i] = np.delete(route, original_pos)\n                    break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if len(route) > 2 and np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Check if the route has enough customers to perform a meaningful operation\n    if len(route) <= 3:\n        return base_solution  # No meaningful operation possible\n\n    # Split the route into two parts and reverse a segment to create a new route\n    split_pos = np.random.randint(1, len(route) - 1)\n    new_route = np.concatenate([route[:split_pos], route[split_pos:][::-1]])\n\n    # Check feasibility: ensure the new route does not exceed capacity\n    route_demand = np.sum(demand[new_route[1:-1]])\n    if route_demand > capacity:\n        return base_solution  # Revert if infeasible\n\n    # Update the solution with the new route\n    new_solution = [r.copy() for r in base_solution]\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7154830811958667,
            0.12681058049201965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Check if the route has enough customers to perform a meaningful operation\n    if len(route) <= 3:\n        return base_solution  # No meaningful operation possible\n\n    # Split the route into two parts and reverse a segment to create a new route\n    split_pos = np.random.randint(1, len(route) - 1)\n    new_route = np.concatenate([route[:split_pos], route[split_pos:][::-1]])\n\n    # Check feasibility: ensure the new route does not exceed capacity\n    route_demand = np.sum(demand[new_route[1:-1]])\n    if route_demand > capacity:\n        return base_solution  # Revert if infeasible\n\n    # Update the solution with the new route\n    new_solution = [r.copy() for r in base_solution]\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Check if the route has enough customers to perform a meaningful operation\n    if len(route) <= 3:\n        return base_solution  # No meaningful operation possible\n\n    # Split the route into two parts and reverse a segment to create a new route\n    split_pos = np.random.randint(1, len(route) - 1)\n    new_route = np.concatenate([route[:split_pos], route[split_pos:][::-1]])\n\n    # Check feasibility: ensure the new route does not exceed capacity\n    route_demand = np.sum(demand[new_route[1:-1]])\n    if route_demand > capacity:\n        return base_solution  # Revert if infeasible\n\n    # Update the solution with the new route\n    new_solution = [r.copy() for r in base_solution]\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7154830811958667,
            0.12681058049201965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Check if the route has enough customers to perform a meaningful operation\n    if len(route) <= 3:\n        return base_solution  # No meaningful operation possible\n\n    # Split the route into two parts and reverse a segment to create a new route\n    split_pos = np.random.randint(1, len(route) - 1)\n    new_route = np.concatenate([route[:split_pos], route[split_pos:][::-1]])\n\n    # Check feasibility: ensure the new route does not exceed capacity\n    route_demand = np.sum(demand[new_route[1:-1]])\n    if route_demand > capacity:\n        return base_solution  # Revert if infeasible\n\n    # Update the solution with the new route\n    new_solution = [r.copy() for r in base_solution]\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Remove the two routes and add the merged one\n            new_solution = np.delete(new_solution, [route1_idx, route2_idx], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n\n            # Reallocate customers with high demand to reduce makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Find the most demanding customer in the route\n                    customers = route[1:-1]\n                    if len(customers) > 0:\n                        most_demanding = max(customers, key=lambda x: demand[x])\n\n                        # Try to move this customer to another route if possible\n                        for other_route in new_solution:\n                            if (other_route is not route and\n                                sum(demand[other_route[1:-1]]) + demand[most_demanding] <= capacity):\n                                # Insert the customer into the other route\n                                other_route = np.insert(other_route, -1, most_demanding)\n                                route = np.delete(route, np.where(route == most_demanding)[0])\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.6980288852996793,
            0.6208813190460205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Remove the two routes and add the merged one\n            new_solution = np.delete(new_solution, [route1_idx, route2_idx], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n\n            # Reallocate customers with high demand to reduce makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Find the most demanding customer in the route\n                    customers = route[1:-1]\n                    if len(customers) > 0:\n                        most_demanding = max(customers, key=lambda x: demand[x])\n\n                        # Try to move this customer to another route if possible\n                        for other_route in new_solution:\n                            if (other_route is not route and\n                                sum(demand[other_route[1:-1]]) + demand[most_demanding] <= capacity):\n                                # Insert the customer into the other route\n                                other_route = np.insert(other_route, -1, most_demanding)\n                                route = np.delete(route, np.where(route == most_demanding)[0])\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: swap a segment of the route with a segment from another route\n    if len(base_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != route_idx])\n        other_route = base_solution[other_route_idx].copy()\n\n        # Find feasible segments to swap\n        feasible_segments = []\n        for i in range(1, len(route) - 1):\n            for j in range(1, len(other_route) - 1):\n                segment1 = route[i:j]\n                segment2 = other_route[i:j]\n                if (sum(demand[segment1]) + sum(demand[segment2]) <= 2 * capacity and\n                    sum(demand[segment1]) <= capacity and sum(demand[segment2]) <= capacity):\n                    feasible_segments.append((i, j, segment1, segment2))\n\n        if feasible_segments:\n            i, j, segment1, segment2 = feasible_segments[np.random.randint(len(feasible_segments))]\n            new_route = np.concatenate([route[:i], segment2, route[j:]])\n            new_other_route = np.concatenate([other_route[:i], segment1, other_route[j:]])\n\n            # Update the solution\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            new_solution[other_route_idx] = new_other_route\n\n            # Ensure feasibility by checking all routes\n            for r in new_solution:\n                if sum(demand[r[1:-1]]) > capacity:\n                    return base_solution  # Revert if infeasible\n\n            return new_solution\n\n    # If no valid swap, apply a 2-opt within the selected route\n    if len(route) > 3:\n        i, j = sorted(np.random.choice(range(1, len(route) - 1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.5502268318448167,
            3.500348448753357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: swap a segment of the route with a segment from another route\n    if len(base_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != route_idx])\n        other_route = base_solution[other_route_idx].copy()\n\n        # Find feasible segments to swap\n        feasible_segments = []\n        for i in range(1, len(route) - 1):\n            for j in range(1, len(other_route) - 1):\n                segment1 = route[i:j]\n                segment2 = other_route[i:j]\n                if (sum(demand[segment1]) + sum(demand[segment2]) <= 2 * capacity and\n                    sum(demand[segment1]) <= capacity and sum(demand[segment2]) <= capacity):\n                    feasible_segments.append((i, j, segment1, segment2))\n\n        if feasible_segments:\n            i, j, segment1, segment2 = feasible_segments[np.random.randint(len(feasible_segments))]\n            new_route = np.concatenate([route[:i], segment2, route[j:]])\n            new_other_route = np.concatenate([other_route[:i], segment1, other_route[j:]])\n\n            # Update the solution\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            new_solution[other_route_idx] = new_other_route\n\n            # Ensure feasibility by checking all routes\n            for r in new_solution:\n                if sum(demand[r[1:-1]]) > capacity:\n                    return base_solution  # Revert if infeasible\n\n            return new_solution\n\n    # If no valid swap, apply a 2-opt within the selected route\n    if len(route) > 3:\n        i, j = sorted(np.random.choice(range(1, len(route) - 1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = new_route\n            return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware route splitting to generate a feasible neighbor solution while balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (1 / (x[1][0] + 1e-6)) * (x[1][1] + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if merging reduces total distance while not increasing makespan too much\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if k in [i, j] else route for k, route in enumerate(new_solution) if k not in [i, j]]\n            new_solution.append(merged_route)\n\n    # 2. Customer reallocation: Move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = np.random.choice(range(1, len(route)-1))\n            customer = route[customer_idx]\n\n            # Find target route with capacity and makespan considerations\n            for target_route in new_solution:\n                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential makespan change\n                    original_makespan = max([distance_matrix[route[0], route[-1]] for route in new_solution])\n                    new_route = np.insert(target_route, -1, customer)\n                    new_route = np.insert(new_route, 1, customer)\n                    temp_solution = [new_route if r is target_route else r for r in new_solution]\n                    new_makespan = max([distance_matrix[r[0], r[-1]] for r in temp_solution])\n\n                    if new_makespan <= 1.1 * original_makespan:  # Allow slight makespan increase\n                        new_solution = temp_solution\n                        break\n\n    # 3. Capacity-aware route splitting: Split overloaded routes\n    for route_idx, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find split point that balances capacity\n            split_pos = 1\n            current_load = 0\n            for i in range(1, len(route)-1):\n                current_load += demand[route[i]]\n                if current_load > capacity:\n                    split_pos = i\n                    break\n\n            # Create new route from split point\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reinsert missing customers\n        missing = all_customers - served_customers\n        for customer in missing:\n            # Find route with available capacity\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.insert(route, -1, customer)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8377322981943494,
            4.574491381645203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (1 / (x[1][0] + 1e-6)) * (x[1][1] + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if merging reduces total distance while not increasing makespan too much\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if k in [i, j] else route for k, route in enumerate(new_solution) if k not in [i, j]]\n            new_solution.append(merged_route)\n\n    # 2. Customer reallocation: Move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a customer to move\n            customer_idx = np.random.choice(range(1, len(route)-1))\n            customer = route[customer_idx]\n\n            # Find target route with capacity and makespan considerations\n            for target_route in new_solution:\n                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate potential makespan change\n                    original_makespan = max([distance_matrix[route[0], route[-1]] for route in new_solution])\n                    new_route = np.insert(target_route, -1, customer)\n                    new_route = np.insert(new_route, 1, customer)\n                    temp_solution = [new_route if r is target_route else r for r in new_solution]\n                    new_makespan = max([distance_matrix[r[0], r[-1]] for r in temp_solution])\n\n                    if new_makespan <= 1.1 * original_makespan:  # Allow slight makespan increase\n                        new_solution = temp_solution\n                        break\n\n    # 3. Capacity-aware route splitting: Split overloaded routes\n    for route_idx, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find split point that balances capacity\n            split_pos = 1\n            current_load = 0\n            for i in range(1, len(route)-1):\n                current_load += demand[route[i]]\n                if current_load > capacity:\n                    split_pos = i\n                    break\n\n            # Create new route from split point\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reinsert missing customers\n        missing = all_customers - served_customers\n        for customer in missing:\n            # Find route with available capacity\n            for route in new_solution:\n                if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.insert(route, -1, customer)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel hybrid local search operator combines route segmentation, demand-aware node swaps, and adaptive insertion to balance distance and makespan reduction while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segmentation, demand-aware swaps, and adaptive insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Segmentation - Split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = np.random.randint(1, len(route)-2)\n            segment1 = route[:split_pos+1]\n            segment2 = route[split_pos:]\n\n            # Check capacity constraints for both segments\n            if (np.sum(demand[segment1[1:-1]]) <= capacity) and (np.sum(demand[segment2[1:-1]]) <= capacity):\n                new_solution[i] = segment1\n                new_solution.append(segment2)\n\n    # Step 2: Demand-Aware Node Swaps - Swap nodes between routes if demand allows\n    for _ in range(2):  # Try a few swaps\n        if len(new_solution) < 2:\n            break\n\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[r1], new_solution[r2]\n\n        # Find a node in route1 to move to route2\n        for node_pos in range(1, len(route1)-1):\n            node = route1[node_pos]\n            remaining_demand_r1 = np.sum(demand[route1[1:-1]]) - demand[node]\n            new_demand_r2 = np.sum(demand[route2[1:-1]]) + demand[node]\n\n            if remaining_demand_r1 <= capacity and new_demand_r2 <= capacity:\n                # Insert node into route2 at best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    increase = (distance_matrix[route2[pos-1]][node] +\n                                distance_matrix[node][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the swap\n                new_route2 = np.insert(route2, best_pos, node)\n                new_route1 = np.delete(route1, node_pos)\n\n                # Update solution\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n                break\n\n    # Step 3: Adaptive Insertion - Move nodes between routes to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        makespans = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_idx = np.argmax(makespans)\n        shortest_idx = np.argmin(makespans)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to move a node from longest to shortest route\n            for node_pos in range(1, len(longest_route)-1):\n                node = longest_route[node_pos]\n                remaining_demand_long = np.sum(demand[longest_route[1:-1]]) - demand[node]\n                new_demand_short = np.sum(demand[shortest_route[1:-1]]) + demand[node]\n\n                if remaining_demand_long <= capacity and new_demand_short <= capacity:\n                    # Find best insertion position in shortest route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[pos-1]][node] +\n                                    distance_matrix[node][shortest_route[pos]] -\n                                    distance_matrix[shortest_route[pos-1]][shortest_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the move\n                    new_shortest = np.insert(shortest_route, best_pos, node)\n                    new_longest = np.delete(longest_route, node_pos)\n\n                    # Update solution\n                    new_solution[shortest_idx] = new_shortest\n                    new_solution[longest_idx] = new_longest\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7995118221243552,
            1.9666589498519897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segmentation, demand-aware swaps, and adaptive insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Segmentation - Split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = np.random.randint(1, len(route)-2)\n            segment1 = route[:split_pos+1]\n            segment2 = route[split_pos:]\n\n            # Check capacity constraints for both segments\n            if (np.sum(demand[segment1[1:-1]]) <= capacity) and (np.sum(demand[segment2[1:-1]]) <= capacity):\n                new_solution[i] = segment1\n                new_solution.append(segment2)\n\n    # Step 2: Demand-Aware Node Swaps - Swap nodes between routes if demand allows\n    for _ in range(2):  # Try a few swaps\n        if len(new_solution) < 2:\n            break\n\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[r1], new_solution[r2]\n\n        # Find a node in route1 to move to route2\n        for node_pos in range(1, len(route1)-1):\n            node = route1[node_pos]\n            remaining_demand_r1 = np.sum(demand[route1[1:-1]]) - demand[node]\n            new_demand_r2 = np.sum(demand[route2[1:-1]]) + demand[node]\n\n            if remaining_demand_r1 <= capacity and new_demand_r2 <= capacity:\n                # Insert node into route2 at best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    increase = (distance_matrix[route2[pos-1]][node] +\n                                distance_matrix[node][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the swap\n                new_route2 = np.insert(route2, best_pos, node)\n                new_route1 = np.delete(route1, node_pos)\n\n                # Update solution\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n                break\n\n    # Step 3: Adaptive Insertion - Move nodes between routes to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        makespans = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_idx = np.argmax(makespans)\n        shortest_idx = np.argmin(makespans)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to move a node from longest to shortest route\n            for node_pos in range(1, len(longest_route)-1):\n                node = longest_route[node_pos]\n                remaining_demand_long = np.sum(demand[longest_route[1:-1]]) - demand[node]\n                new_demand_short = np.sum(demand[shortest_route[1:-1]]) + demand[node]\n\n                if remaining_demand_long <= capacity and new_demand_short <= capacity:\n                    # Find best insertion position in shortest route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[pos-1]][node] +\n                                    distance_matrix[node][shortest_route[pos]] -\n                                    distance_matrix[shortest_route[pos-1]][shortest_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the move\n                    new_shortest = np.insert(shortest_route, best_pos, node)\n                    new_longest = np.delete(longest_route, node_pos)\n\n                    # Update solution\n                    new_solution[shortest_idx] = new_shortest\n                    new_solution[longest_idx] = new_longest\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # If the route has at least 4 nodes (to allow meaningful segment swaps)\n    if len(selected_route) >= 4:\n        # Randomly select two non-adjacent segments within the route\n        split1 = np.random.randint(1, len(selected_route) - 3)\n        split2 = np.random.randint(split1 + 2, len(selected_route) - 1)\n\n        # Extract the two segments\n        segment1 = selected_route[split1:split2]\n        segment2 = selected_route[split2:]\n\n        # Reverse the order of the segments\n        reversed_segment1 = segment1[::-1]\n        reversed_segment2 = segment2[::-1]\n\n        # Check feasibility for both reversed segments\n        def is_feasible(segment):\n            total_demand = sum(demand[node] for node in segment)\n            return total_demand <= capacity\n\n        if is_feasible(reversed_segment1) and is_feasible(reversed_segment2):\n            # Apply the reversal\n            new_route = np.concatenate([selected_route[:split1], reversed_segment1, reversed_segment2])\n            new_solution[route_idx] = new_route\n\n    # Also consider merging two routes if possible\n    if len(new_solution) > 1:\n        # Randomly select two routes to attempt merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging route1 into route2 (excluding depots)\n        merged_route = np.concatenate([route1[1:-1], route2])\n        if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n            # Replace the two routes with the merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7158061638551421,
            0.35546261072158813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # If the route has at least 4 nodes (to allow meaningful segment swaps)\n    if len(selected_route) >= 4:\n        # Randomly select two non-adjacent segments within the route\n        split1 = np.random.randint(1, len(selected_route) - 3)\n        split2 = np.random.randint(split1 + 2, len(selected_route) - 1)\n\n        # Extract the two segments\n        segment1 = selected_route[split1:split2]\n        segment2 = selected_route[split2:]\n\n        # Reverse the order of the segments\n        reversed_segment1 = segment1[::-1]\n        reversed_segment2 = segment2[::-1]\n\n        # Check feasibility for both reversed segments\n        def is_feasible(segment):\n            total_demand = sum(demand[node] for node in segment)\n            return total_demand <= capacity\n\n        if is_feasible(reversed_segment1) and is_feasible(reversed_segment2):\n            # Apply the reversal\n            new_route = np.concatenate([selected_route[:split1], reversed_segment1, reversed_segment2])\n            new_solution[route_idx] = new_route\n\n    # Also consider merging two routes if possible\n    if len(new_solution) > 1:\n        # Randomly select two routes to attempt merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging route1 into route2 (excluding depots)\n        merged_route = np.concatenate([route1[1:-1], route2])\n        if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n            # Replace the two routes with the merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{My novel algorithm performs a hybrid local search by combining route fragmentation with demand-aware insertion, followed by a makespan-balancing swap operator to improve both total distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][0] - s[1][1] for s in archive])  # Prioritize solutions with large distance-makespan difference\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation + demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select a route for fragmentation\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n\n        if len(frag_route) > 4:  # Ensure there's enough nodes to split\n            split_pos = random.randint(2, len(frag_route) - 3)  # Avoid splitting at the start/end\n\n            # Split the route into two parts\n            part1 = frag_route[:split_pos + 1]\n            part2 = frag_route[split_pos:]\n\n            # Remove the original route and add the two new parts\n            new_solution.pop(frag_route_idx)\n            new_solution.append(part1)\n            new_solution.append(part2)\n\n            # Demand-aware insertion of nodes from the split route\n            for node in part2[1:-1]:  # Skip depot nodes\n                best_route = None\n                best_pos = -1\n                best_cost = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    current_demand = sum(demand[route[1:-1]]) + demand[node]\n                    if current_demand > capacity:\n                        continue  # Skip routes that would exceed capacity\n\n                    # Find the best insertion position in this route\n                    for pos in range(1, len(route) - 1):\n                        # Calculate insertion cost (distance increase)\n                        cost = (distance_matrix[route[pos-1], node] +\n                                distance_matrix[node, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n                if best_route is not None:\n                    # Insert the node in the best route\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Makespan-balancing swap operator\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        longest_route = new_solution[longest_idx]\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to transfer a node from longest to shortest route\n        for node in longest_route[1:-1]:  # Skip depot nodes\n            new_demand = sum(demand[shortest_route[1:-1]]) + demand[node]\n            if new_demand <= capacity:\n                # Find best insertion position in shortest route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(shortest_route) - 1):\n                    cost = (distance_matrix[shortest_route[pos-1], node] +\n                            distance_matrix[node, shortest_route[pos]] -\n                            distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform the transfer\n                new_solution[shortest_idx] = np.insert(shortest_route, best_pos, node)\n                new_solution[longest_idx] = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Check if the longest route is now empty (remove if it is)\n                if len(new_solution[longest_idx]) <= 2:\n                    new_solution.pop(longest_idx)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.583605343496169,
            2.441628873348236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][0] - s[1][1] for s in archive])  # Prioritize solutions with large distance-makespan difference\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation + demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select a route for fragmentation\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n\n        if len(frag_route) > 4:  # Ensure there's enough nodes to split\n            split_pos = random.randint(2, len(frag_route) - 3)  # Avoid splitting at the start/end\n\n            # Split the route into two parts\n            part1 = frag_route[:split_pos + 1]\n            part2 = frag_route[split_pos:]\n\n            # Remove the original route and add the two new parts\n            new_solution.pop(frag_route_idx)\n            new_solution.append(part1)\n            new_solution.append(part2)\n\n            # Demand-aware insertion of nodes from the split route\n            for node in part2[1:-1]:  # Skip depot nodes\n                best_route = None\n                best_pos = -1\n                best_cost = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    current_demand = sum(demand[route[1:-1]]) + demand[node]\n                    if current_demand > capacity:\n                        continue  # Skip routes that would exceed capacity\n\n                    # Find the best insertion position in this route\n                    for pos in range(1, len(route) - 1):\n                        # Calculate insertion cost (distance increase)\n                        cost = (distance_matrix[route[pos-1], node] +\n                                distance_matrix[node, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n                if best_route is not None:\n                    # Insert the node in the best route\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Makespan-balancing swap operator\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        longest_route = new_solution[longest_idx]\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to transfer a node from longest to shortest route\n        for node in longest_route[1:-1]:  # Skip depot nodes\n            new_demand = sum(demand[shortest_route[1:-1]]) + demand[node]\n            if new_demand <= capacity:\n                # Find best insertion position in shortest route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(shortest_route) - 1):\n                    cost = (distance_matrix[shortest_route[pos-1], node] +\n                            distance_matrix[node, shortest_route[pos]] -\n                            distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform the transfer\n                new_solution[shortest_idx] = np.insert(shortest_route, best_pos, node)\n                new_solution[longest_idx] = np.delete(longest_route, np.where(longest_route == node)[0][0])\n\n                # Check if the longest route is now empty (remove if it is)\n                if len(new_solution[longest_idx]) <= 2:\n                    new_solution.pop(longest_idx)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm combines a route-segment relocation operator with a capacity-aware demand balancing heuristic to intelligently reassign segments of routes while preserving feasibility, aiming to reduce both total distance and makespan by optimizing route structure and load distribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route-segment relocation with demand balancing\n    if len(new_solution) > 1:\n        # Randomly select a route and a segment to relocate\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure the route has enough nodes to relocate a segment\n            # Select a random segment (excluding depot nodes)\n            start_idx = random.randint(1, len(route) - 3)\n            end_idx = random.randint(start_idx + 1, len(route) - 2)\n            segment = route[start_idx:end_idx]\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best route to insert the segment (minimizing distance increase)\n            best_route_idx = -1\n            best_insert_pos = -1\n            min_increase = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                candidate_demand = np.sum(demand[candidate_route[1:-1]])  # Exclude depots\n                if candidate_demand + segment_demand > capacity:\n                    continue\n\n                # Try inserting the segment at all possible positions\n                for pos in range(1, len(candidate_route)):\n                    # Calculate distance increase\n                    prev_node = candidate_route[pos - 1]\n                    next_node = candidate_route[pos]\n                    segment_start = segment[0]\n                    segment_end = segment[-1]\n\n                    increase = (distance_matrix[prev_node][segment_start] +\n                               distance_matrix[segment_end][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n            # Perform the relocation if beneficial\n            if best_route_idx != -1:\n                # Remove segment from original route\n                new_solution[route_idx] = np.concatenate([\n                    route[:start_idx],\n                    route[end_idx:]\n                ])\n\n                # Insert segment into best route\n                best_route = new_solution[best_route_idx]\n                new_solution[best_route_idx] = np.concatenate([\n                    best_route[:best_insert_pos],\n                    segment,\n                    best_route[best_insert_pos:]\n                ])\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.3597523524768367,
            0.9539327323436737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route-segment relocation with demand balancing\n    if len(new_solution) > 1:\n        # Randomly select a route and a segment to relocate\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure the route has enough nodes to relocate a segment\n            # Select a random segment (excluding depot nodes)\n            start_idx = random.randint(1, len(route) - 3)\n            end_idx = random.randint(start_idx + 1, len(route) - 2)\n            segment = route[start_idx:end_idx]\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best route to insert the segment (minimizing distance increase)\n            best_route_idx = -1\n            best_insert_pos = -1\n            min_increase = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                candidate_demand = np.sum(demand[candidate_route[1:-1]])  # Exclude depots\n                if candidate_demand + segment_demand > capacity:\n                    continue\n\n                # Try inserting the segment at all possible positions\n                for pos in range(1, len(candidate_route)):\n                    # Calculate distance increase\n                    prev_node = candidate_route[pos - 1]\n                    next_node = candidate_route[pos]\n                    segment_start = segment[0]\n                    segment_end = segment[-1]\n\n                    increase = (distance_matrix[prev_node][segment_start] +\n                               distance_matrix[segment_end][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n            # Perform the relocation if beneficial\n            if best_route_idx != -1:\n                # Remove segment from original route\n                new_solution[route_idx] = np.concatenate([\n                    route[:start_idx],\n                    route[end_idx:]\n                ])\n\n                # Insert segment into best route\n                best_route = new_solution[best_route_idx]\n                new_solution[best_route_idx] = np.concatenate([\n                    best_route[:best_insert_pos],\n                    segment,\n                    best_route[best_insert_pos:]\n                ])\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Randomly select a segment to split or reallocate\n        if len(route) > 3:  # Ensure there's room to modify\n            split_idx = np.random.randint(1, len(route) - 2)\n            segment = route[split_idx:-1]\n            remaining_route = route[:split_idx] + [0]\n\n            # Check if the segment can form a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_solution.append(segment)\n                new_solution.append(remaining_route)\n            else:\n                # If not, try reallocating customers to existing routes\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[:-1]]) + np.sum(demand[segment]) <= capacity:\n                        new_solution[i] = np.concatenate([r[:-1], segment, [0]])\n                        break\n                else:\n                    new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Ensure all routes are feasible and depot constraints are met\n    for i in range(len(new_solution)):\n        if np.sum(demand[new_solution[i][1:-1]]) > capacity:\n            # If a route exceeds capacity, split it further\n            split_idx = np.argmax(np.cumsum(demand[new_solution[i][1:-1]]) > capacity) + 1\n            new_solution.append(np.concatenate([[0], new_solution[i][split_idx:], [0]]))\n            new_solution[i] = np.concatenate([new_solution[i][:split_idx], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7189791357806155,
            0.8578352928161621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Randomly select a segment to split or reallocate\n        if len(route) > 3:  # Ensure there's room to modify\n            split_idx = np.random.randint(1, len(route) - 2)\n            segment = route[split_idx:-1]\n            remaining_route = route[:split_idx] + [0]\n\n            # Check if the segment can form a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_solution.append(segment)\n                new_solution.append(remaining_route)\n            else:\n                # If not, try reallocating customers to existing routes\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[:-1]]) + np.sum(demand[segment]) <= capacity:\n                        new_solution[i] = np.concatenate([r[:-1], segment, [0]])\n                        break\n                else:\n                    new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Ensure all routes are feasible and depot constraints are met\n    for i in range(len(new_solution)):\n        if np.sum(demand[new_solution[i][1:-1]]) > capacity:\n            # If a route exceeds capacity, split it further\n            split_idx = np.argmax(np.cumsum(demand[new_solution[i][1:-1]]) > capacity) + 1\n            new_solution.append(np.concatenate([[0], new_solution[i][split_idx:], [0]]))\n            new_solution[i] = np.concatenate([new_solution[i][:split_idx], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx]\n\n    # Apply a novel local search: \"Route Segmentation and Reassembly\"\n    if len(route) > 4:  # Ensure the route has enough nodes to split\n        # Split the route into two segments at a random position\n        split_pos = np.random.randint(2, len(route) - 2)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate the total demand for each segment\n        demand1 = sum(demand[node] for node in segment1)\n        demand2 = sum(demand[node] for node in segment2)\n\n        # Check if splitting is feasible (both segments respect capacity)\n        if demand1 <= capacity and demand2 <= capacity:\n            # Reassemble the segments into new routes\n            new_solution = [r.copy() for r in selected_solution]\n            new_solution[route_idx] = segment1\n            new_solution.append(segment2)\n\n            # Ensure the new solution is feasible\n            for r in new_solution:\n                if sum(demand[node] for node in r) > capacity:\n                    return selected_solution  # Revert if infeasible\n\n            return new_solution\n\n    # If no improvement or infeasible, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.6874847790146973,
            0.45081400871276855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx]\n\n    # Apply a novel local search: \"Route Segmentation and Reassembly\"\n    if len(route) > 4:  # Ensure the route has enough nodes to split\n        # Split the route into two segments at a random position\n        split_pos = np.random.randint(2, len(route) - 2)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate the total demand for each segment\n        demand1 = sum(demand[node] for node in segment1)\n        demand2 = sum(demand[node] for node in segment2)\n\n        # Check if splitting is feasible (both segments respect capacity)\n        if demand1 <= capacity and demand2 <= capacity:\n            # Reassemble the segments into new routes\n            new_solution = [r.copy() for r in selected_solution]\n            new_solution[route_idx] = segment1\n            new_solution.append(segment2)\n\n            # Ensure the new solution is feasible\n            for r in new_solution:\n                if sum(demand[node] for node in r) > capacity:\n                    return selected_solution  # Revert if infeasible\n\n            return new_solution\n\n    # If no improvement or infeasible, return the original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging, segment relocation, and capacity-aware swapping to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if their total demand is within capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n    # 2. Segment relocation: Move a random segment from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a segment to move\n            start, end = sorted(random.sample(range(1, len(src_route) - 1), 2))\n            segment = src_route[start:end]\n            segment_demand = sum(demand[segment])\n\n            # Find a target route with enough capacity\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == src_route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n                if sum(demand[target_route[1:-1]]) + segment_demand <= capacity:\n                    # Insert segment into target route\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_target_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n                    new_src_route = np.concatenate([src_route[:start], src_route[end:]])\n\n                    # Update solution\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    # 3. Capacity-aware swapping: Swap customers between routes if demands allow\n    if len(new_solution) > 1:\n        route_a_idx, route_b_idx = random.sample(range(len(new_solution)), 2)\n        route_a, route_b = new_solution[route_a_idx], new_solution[route_b_idx]\n\n        if len(route_a) > 2 and len(route_b) > 2:\n            a_pos = random.randint(1, len(route_a) - 2)\n            b_pos = random.randint(1, len(route_b) - 2)\n            customer_a, customer_b = route_a[a_pos], route_b[b_pos]\n\n            # Check capacity constraints after swap\n            if (sum(demand[route_a[1:-1]]) - demand[customer_a] + demand[customer_b] <= capacity and\n                sum(demand[route_b[1:-1]]) - demand[customer_b] + demand[customer_a] <= capacity):\n                # Perform swap\n                route_a[a_pos], route_b[b_pos] = route_b[b_pos], route_a[a_pos]\n                new_solution[route_a_idx] = route_a\n                new_solution[route_b_idx] = route_b\n\n    # Convert back to list of numpy arrays (as required by the problem statement)\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.5348589637383003,
            0.9006438553333282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if their total demand is within capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n    # 2. Segment relocation: Move a random segment from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a segment to move\n            start, end = sorted(random.sample(range(1, len(src_route) - 1), 2))\n            segment = src_route[start:end]\n            segment_demand = sum(demand[segment])\n\n            # Find a target route with enough capacity\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == src_route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n                if sum(demand[target_route[1:-1]]) + segment_demand <= capacity:\n                    # Insert segment into target route\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_target_route = np.concatenate([target_route[:insert_pos], segment, target_route[insert_pos:]])\n                    new_src_route = np.concatenate([src_route[:start], src_route[end:]])\n\n                    # Update solution\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    # 3. Capacity-aware swapping: Swap customers between routes if demands allow\n    if len(new_solution) > 1:\n        route_a_idx, route_b_idx = random.sample(range(len(new_solution)), 2)\n        route_a, route_b = new_solution[route_a_idx], new_solution[route_b_idx]\n\n        if len(route_a) > 2 and len(route_b) > 2:\n            a_pos = random.randint(1, len(route_a) - 2)\n            b_pos = random.randint(1, len(route_b) - 2)\n            customer_a, customer_b = route_a[a_pos], route_b[b_pos]\n\n            # Check capacity constraints after swap\n            if (sum(demand[route_a[1:-1]]) - demand[customer_a] + demand[customer_b] <= capacity and\n                sum(demand[route_b[1:-1]]) - demand[customer_b] + demand[customer_a] <= capacity):\n                # Perform swap\n                route_a[a_pos], route_b[b_pos] = route_b[b_pos], route_a[a_pos]\n                new_solution[route_a_idx] = route_a\n                new_solution[route_b_idx] = route_b\n\n    # Convert back to list of numpy arrays (as required by the problem statement)\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Reallocate customers between routes to balance makespan\n            for k in range(len(new_solution)):\n                current_route = new_solution[k]\n                if len(current_route) > 3:  # If route has more than just depot-depot\n                    # Randomly select a customer to move to another route\n                    customer_idx = np.random.choice(range(1, len(current_route)-1))\n                    customer = current_route[customer_idx]\n\n                    # Find a target route where adding the customer is feasible\n                    for l in range(len(new_solution)):\n                        if l != k:\n                            target_route = new_solution[l]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert customer into target route\n                                new_solution[l] = np.insert(target_route, -1, customer)\n                                new_solution[k] = np.delete(current_route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.7873142961191708,
            0.7051700949668884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Reallocate customers between routes to balance makespan\n            for k in range(len(new_solution)):\n                current_route = new_solution[k]\n                if len(current_route) > 3:  # If route has more than just depot-depot\n                    # Randomly select a customer to move to another route\n                    customer_idx = np.random.choice(range(1, len(current_route)-1))\n                    customer = current_route[customer_idx]\n\n                    # Find a target route where adding the customer is feasible\n                    for l in range(len(new_solution)):\n                        if l != k:\n                            target_route = new_solution[l]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert customer into target route\n                                new_solution[l] = np.insert(target_route, -1, customer)\n                                new_solution[k] = np.delete(current_route, customer_idx)\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The algorithm selects a high-quality solution from the archive, then applies a hybrid local search combining route splitting, customer reallocation, and inter-route 2-opt with capacity checks to generate a neighbor solution with improved multi-objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search steps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into shorter ones\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer Reallocation - Move customers between routes\n    for _ in range(3):  # Try multiple reallocations\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:  # Only consider routes with customers to remove\n                cust_idx = random.randint(1, len(route1)-2)\n                customer = route1[cust_idx]\n\n                # Try inserting into route2\n                for pos in range(1, len(route2)):\n                    new_route2 = np.insert(route2, pos, customer)\n                    if np.sum(demand[new_route2[1:-1]]) <= capacity:\n                        new_route1 = np.delete(route1, cust_idx)\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Step 3: Inter-route 2-opt with capacity checks\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select two edges from each route\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7450536491824423,
            1.5603789985179901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search steps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into shorter ones\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer Reallocation - Move customers between routes\n    for _ in range(3):  # Try multiple reallocations\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:  # Only consider routes with customers to remove\n                cust_idx = random.randint(1, len(route1)-2)\n                customer = route1[cust_idx]\n\n                # Try inserting into route2\n                for pos in range(1, len(route2)):\n                    new_route2 = np.insert(route2, pos, customer)\n                    if np.sum(demand[new_route2[1:-1]]) <= capacity:\n                        new_route1 = np.delete(route1, cust_idx)\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Step 3: Inter-route 2-opt with capacity checks\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select two edges from each route\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reinsertion with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to reinsert\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        segment = route[start:end]\n\n        # Remove the segment from the route\n        modified_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into a different route or a new one\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment]) > capacity:\n                continue  # Skip if capacity exceeded\n\n            # Find the best insertion point in the other route\n            min_cost = float('inf')\n            best_pos = 1\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost (distance increase)\n                cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], other_route[pos]] -\n                        distance_matrix[other_route[pos-1], other_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Insert the segment\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n            inserted = True\n            break\n\n        if not inserted:\n            # If not inserted, try to create a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n\n        # Add the modified route back\n        if len(modified_route) > 2:  # Ensure it's not just [0,0]\n            new_solution.append(modified_route)\n\n    # Remove empty routes and ensure all customers are served\n    final_solution = []\n    served_customers = set()\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n            served_customers.update(route[1:-1])\n\n    # Add any unserved customers to new routes\n    all_customers = set(range(1, len(demand)))\n    unserved = all_customers - served_customers\n    while unserved:\n        new_route = [0]\n        current_load = 0\n        for customer in list(unserved):\n            if current_load + demand[customer] <= capacity:\n                new_route.append(customer)\n                unserved.remove(customer)\n                current_load += demand[customer]\n        new_route.append(0)\n        if len(new_route) > 2:\n            final_solution.append(np.array(new_route))\n\n    return final_solution\n\n",
        "score": [
            -0.879650396242661,
            3.8652684688568115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reinsertion with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to reinsert\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        segment = route[start:end]\n\n        # Remove the segment from the route\n        modified_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into a different route or a new one\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment]) > capacity:\n                continue  # Skip if capacity exceeded\n\n            # Find the best insertion point in the other route\n            min_cost = float('inf')\n            best_pos = 1\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost (distance increase)\n                cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], other_route[pos]] -\n                        distance_matrix[other_route[pos-1], other_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Insert the segment\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n            inserted = True\n            break\n\n        if not inserted:\n            # If not inserted, try to create a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n\n        # Add the modified route back\n        if len(modified_route) > 2:  # Ensure it's not just [0,0]\n            new_solution.append(modified_route)\n\n    # Remove empty routes and ensure all customers are served\n    final_solution = []\n    served_customers = set()\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n            served_customers.update(route[1:-1])\n\n    # Add any unserved customers to new routes\n    all_customers = set(range(1, len(demand)))\n    unserved = all_customers - served_customers\n    while unserved:\n        new_route = [0]\n        current_load = 0\n        for customer in list(unserved):\n            if current_load + demand[customer] <= capacity:\n                new_route.append(customer)\n                unserved.remove(customer)\n                current_load += demand[customer]\n        new_route.append(0)\n        if len(new_route) > 2:\n            final_solution.append(np.array(new_route))\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting with demand-aware swaps\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            # Check if merging routes i and j is feasible\n            if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity:\n                # Merge routes i and j\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                new_solution = [route for k, route in enumerate(new_solution) if k not in {i, j}]\n                new_solution.append(merged_route)\n                # Perform demand-aware swaps within the merged route\n                for _ in range(3):  # Limit swaps to avoid excessive computation\n                    a, b = np.random.choice(len(merged_route)-2, size=2, replace=False) + 1\n                    if a > b: a, b = b, a\n                    if sum(demand[merged_route[a:b+1]]) <= capacity:\n                        merged_route[a:b+1] = merged_route[a:b+1][::-1]\n                # Split the merged route if it's too long\n                if len(merged_route) > 10:  # Arbitrary threshold\n                    split_pos = len(merged_route) // 2\n                    new_solution.append(np.concatenate([merged_route[:split_pos+1], [0]]))\n                    new_solution[-2] = np.concatenate([merged_route[split_pos:], [0]])\n    return new_solution\n\n",
        "score": [
            -0.8706039350848793,
            4.492984473705292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting with demand-aware swaps\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            # Check if merging routes i and j is feasible\n            if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity:\n                # Merge routes i and j\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                new_solution = [route for k, route in enumerate(new_solution) if k not in {i, j}]\n                new_solution.append(merged_route)\n                # Perform demand-aware swaps within the merged route\n                for _ in range(3):  # Limit swaps to avoid excessive computation\n                    a, b = np.random.choice(len(merged_route)-2, size=2, replace=False) + 1\n                    if a > b: a, b = b, a\n                    if sum(demand[merged_route[a:b+1]]) <= capacity:\n                        merged_route[a:b+1] = merged_route[a:b+1][::-1]\n                # Split the merged route if it's too long\n                if len(merged_route) > 10:  # Arbitrary threshold\n                    split_pos = len(merged_route) // 2\n                    new_solution.append(np.concatenate([merged_route[:split_pos+1], [0]]))\n                    new_solution[-2] = np.concatenate([merged_route[split_pos:], [0]])\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route segmentation, demand-aware node swaps, and capacity-preserving merges to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: segment routes, swap nodes, merge feasible routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Segment route into two parts\n            split_point = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Try swapping nodes between parts if demands allow\n            for j in range(1, len(part1) - 1):\n                for k in range(1, len(part2) - 1):\n                    if demand[part1[j]] + demand[part2[k]] <= capacity:\n                        # Swap nodes\n                        part1[j], part2[k] = part2[k], part1[j]\n                        # Check feasibility\n                        if (np.sum(demand[part1[1:-1]]) <= capacity and\n                            np.sum(demand[part2[1:-1]]) <= capacity):\n                            new_route = np.concatenate([part1, part2[1:]])\n                            new_solution[i] = new_route\n                            break\n                        else:\n                            # Revert swap\n                            part1[j], part2[k] = part2[k], part1[j]\n\n    # Try merging two routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 <= len(distance_matrix)):\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.3626126728855218,
            3.0522347688674927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: segment routes, swap nodes, merge feasible routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Segment route into two parts\n            split_point = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Try swapping nodes between parts if demands allow\n            for j in range(1, len(part1) - 1):\n                for k in range(1, len(part2) - 1):\n                    if demand[part1[j]] + demand[part2[k]] <= capacity:\n                        # Swap nodes\n                        part1[j], part2[k] = part2[k], part1[j]\n                        # Check feasibility\n                        if (np.sum(demand[part1[1:-1]]) <= capacity and\n                            np.sum(demand[part2[1:-1]]) <= capacity):\n                            new_route = np.concatenate([part1, part2[1:]])\n                            new_solution[i] = new_route\n                            break\n                        else:\n                            # Revert swap\n                            part1[j], part2[k] = part2[k], part1[j]\n\n    # Try merging two routes if feasible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 <= len(distance_matrix)):\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Ensure capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try reallocating customers to other routes\n            for customer in part2[1:-1]:\n                best_route = None\n                min_increase = float('inf')\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate the increase in distance if customer is added to this route\n                        last_node = r[-2]\n                        new_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0]\n                        if new_distance < min_increase:\n                            min_increase = new_distance\n                            best_route = i\n\n                if best_route is not None:\n                    # Insert customer into the best route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n                else:\n                    # If no feasible route found, keep customer in original route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7579564986935088,
            0.7396417260169983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Ensure capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try reallocating customers to other routes\n            for customer in part2[1:-1]:\n                best_route = None\n                min_increase = float('inf')\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate the increase in distance if customer is added to this route\n                        last_node = r[-2]\n                        new_distance = distance_matrix[last_node][customer] + distance_matrix[customer][0]\n                        if new_distance < min_increase:\n                            min_increase = new_distance\n                            best_route = i\n\n                if best_route is not None:\n                    # Insert customer into the best route\n                    new_solution[best_route] = np.append(new_solution[best_route][:-1], [customer, 0])\n                else:\n                    # If no feasible route found, keep customer in original route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting operation, then a demand-balancing swap\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Route-splitting: Split the route at a point where the cumulative demand exceeds capacity\n        current_demand = 0\n        split_point = 1\n        for i in range(1, len(route) - 1):\n            current_demand += demand[route[i]]\n            if current_demand > capacity:\n                split_point = i\n                break\n\n        # Split the route into two parts\n        if split_point > 1:\n            part1 = np.concatenate(([0], route[1:split_point], [0]))\n            part2 = np.concatenate(([0], route[split_point:], [0]))\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Demand-balancing swap: Swap nodes between routes to balance demand\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            route_i = new_solution[i]\n            if len(route_i) <= 2:\n                continue\n\n            for j in range(i + 1, len(new_solution)):\n                route_j = new_solution[j]\n                if len(route_j) <= 2:\n                    continue\n\n                # Find a node in route_i that can be swapped with a node in route_j\n                for k in range(1, len(route_i) - 1):\n                    node_i = route_i[k]\n                    demand_i = demand[node_i]\n\n                    for l in range(1, len(route_j) - 1):\n                        node_j = route_j[l]\n                        demand_j = demand[node_j]\n\n                        # Check if swapping would keep both routes feasible\n                        new_demand_i = sum(demand[route_i[1:-1]]) - demand_i + demand_j\n                        new_demand_j = sum(demand[route_j[1:-1]]) - demand_j + demand_i\n\n                        if new_demand_i <= capacity and new_demand_j <= capacity:\n                            # Perform the swap\n                            new_route_i = route_i.copy()\n                            new_route_i[k] = node_j\n                            new_route_j = route_j.copy()\n                            new_route_j[l] = node_i\n\n                            # Update the solution\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743436361155261,
            7.707589000463486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting operation, then a demand-balancing swap\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Route-splitting: Split the route at a point where the cumulative demand exceeds capacity\n        current_demand = 0\n        split_point = 1\n        for i in range(1, len(route) - 1):\n            current_demand += demand[route[i]]\n            if current_demand > capacity:\n                split_point = i\n                break\n\n        # Split the route into two parts\n        if split_point > 1:\n            part1 = np.concatenate(([0], route[1:split_point], [0]))\n            part2 = np.concatenate(([0], route[split_point:], [0]))\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route.copy())\n\n    # Demand-balancing swap: Swap nodes between routes to balance demand\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            route_i = new_solution[i]\n            if len(route_i) <= 2:\n                continue\n\n            for j in range(i + 1, len(new_solution)):\n                route_j = new_solution[j]\n                if len(route_j) <= 2:\n                    continue\n\n                # Find a node in route_i that can be swapped with a node in route_j\n                for k in range(1, len(route_i) - 1):\n                    node_i = route_i[k]\n                    demand_i = demand[node_i]\n\n                    for l in range(1, len(route_j) - 1):\n                        node_j = route_j[l]\n                        demand_j = demand[node_j]\n\n                        # Check if swapping would keep both routes feasible\n                        new_demand_i = sum(demand[route_i[1:-1]]) - demand_i + demand_j\n                        new_demand_j = sum(demand[route_j[1:-1]]) - demand_j + demand_i\n\n                        if new_demand_i <= capacity and new_demand_j <= capacity:\n                            # Perform the swap\n                            new_route_i = route_i.copy()\n                            new_route_i[k] = node_j\n                            new_route_j = route_j.copy()\n                            new_route_j[l] = node_i\n\n                            # Update the solution\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with route splitting and merging\n    if len(route) > 4:  # Ensure the route has enough nodes to apply 2-opt\n        i, j = np.random.choice(range(1, len(route) - 2), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = new_route\n    else:\n        # If the route is too short, try merging it with another route\n        if len(selected_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx].copy()\n            # Try to merge the two routes\n            merged_route = np.concatenate([route[:-1], other_route[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = merged_route\n                selected_solution.pop(other_route_idx)\n\n    return selected_solution\n\n",
        "score": [
            -0.47501545213776947,
            0.6220678687095642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with route splitting and merging\n    if len(route) > 4:  # Ensure the route has enough nodes to apply 2-opt\n        i, j = np.random.choice(range(1, len(route) - 2), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = new_route\n    else:\n        # If the route is too short, try merging it with another route\n        if len(selected_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx].copy()\n            # Try to merge the two routes\n            merged_route = np.concatenate([route[:-1], other_route[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = merged_route\n                selected_solution.pop(other_route_idx)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined score of total distance and makespan, then applies a hybrid local search operator that combines route splitting, customer reinsertion, and route merging to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def score(solution):\n        total_distance, makespan = solution[1]\n        return total_distance + 0.5 * makespan  # Weighted score\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split, reinsert, and merge\n    if len(new_solution) > 1:\n        # Split a route into two\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure it can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.pop(route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Reinsert a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure there's a customer to remove\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert into another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx != from_route_idx:\n                    to_route = new_solution[to_route_idx]\n                    for insert_pos in range(1, len(to_route)):\n                        # Create a new route with insertion\n                        new_route = np.concatenate([\n                            to_route[:insert_pos],\n                            [customer],\n                            to_route[insert_pos:]\n                        ])\n                        # Check feasibility\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Update routes\n                            new_solution[from_route_idx] = np.concatenate([\n                                from_route[:customer_pos],\n                                from_route[customer_pos + 1:]\n                            ])\n                            new_solution[to_route_idx] = new_route\n                            break\n\n    # Merge two routes if possible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7913185744107342,
            2.0606038570404053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def score(solution):\n        total_distance, makespan = solution[1]\n        return total_distance + 0.5 * makespan  # Weighted score\n\n    selected = min(archive, key=score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split, reinsert, and merge\n    if len(new_solution) > 1:\n        # Split a route into two\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure it can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution.pop(route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Reinsert a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure there's a customer to remove\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert into another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx != from_route_idx:\n                    to_route = new_solution[to_route_idx]\n                    for insert_pos in range(1, len(to_route)):\n                        # Create a new route with insertion\n                        new_route = np.concatenate([\n                            to_route[:insert_pos],\n                            [customer],\n                            to_route[insert_pos:]\n                        ])\n                        # Check feasibility\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Update routes\n                            new_solution[from_route_idx] = np.concatenate([\n                                from_route[:customer_pos],\n                                from_route[customer_pos + 1:]\n                            ])\n                            new_solution[to_route_idx] = new_route\n                            break\n\n    # Merge two routes if possible\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    # Step 1: Identify the two longest routes (excluding depot)\n    route_lengths = [(i, len(route) - 2) for i, route in enumerate(new_solution)]\n    route_lengths.sort(key=lambda x: x[1], reverse=True)\n    if len(route_lengths) < 2:\n        return new_solution\n\n    longest_route_idx, _ = route_lengths[0]\n    second_longest_route_idx, _ = route_lengths[1]\n\n    # Step 2: Merge the two longest routes by reinserting customers from the second longest into the longest\n    longest_route = new_solution[longest_route_idx].copy()\n    second_longest_route = new_solution[second_longest_route_idx].copy()\n\n    # Remove the second longest route from the solution\n    new_solution.pop(second_longest_route_idx)\n\n    # Try to reinsert customers from the second longest route into the longest route\n    customers_to_insert = second_longest_route[1:-1]  # Exclude depots\n    for customer in customers_to_insert:\n        # Find the best insertion position in the longest route\n        best_pos = 1  # Default to first position\n        best_cost_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Calculate cost increase for inserting at position i\n            prev_node = longest_route[i-1]\n            next_node = longest_route[i]\n            new_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n            if new_cost < best_cost_increase:\n                best_pos = i\n                best_cost_increase = new_cost\n\n        # Insert the customer if capacity is not exceeded\n        if sum(demand[longest_route[1:best_pos]] + demand[customer]) <= capacity:\n            longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Update the longest route in the solution\n    new_solution[longest_route_idx] = longest_route\n\n    # Step 3: Perform a 2-opt* move on the longest route to further improve it\n    longest_route = new_solution[longest_route_idx].copy()\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(longest_route)-2):\n            for j in range(i+1, len(longest_route)-1):\n                # Check if swapping edges i and j improves the route\n                a, b, c, d = longest_route[i-1], longest_route[i], longest_route[j], longest_route[j+1]\n                current_cost = distance_matrix[a, b] + distance_matrix[c, d]\n                new_cost = distance_matrix[a, c] + distance_matrix[b, d]\n\n                if new_cost < current_cost:\n                    # Perform the swap\n                    longest_route[i:j+1] = longest_route[j:i-1:-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.8471286526581348,
            7.7243930995464325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    # Step 1: Identify the two longest routes (excluding depot)\n    route_lengths = [(i, len(route) - 2) for i, route in enumerate(new_solution)]\n    route_lengths.sort(key=lambda x: x[1], reverse=True)\n    if len(route_lengths) < 2:\n        return new_solution\n\n    longest_route_idx, _ = route_lengths[0]\n    second_longest_route_idx, _ = route_lengths[1]\n\n    # Step 2: Merge the two longest routes by reinserting customers from the second longest into the longest\n    longest_route = new_solution[longest_route_idx].copy()\n    second_longest_route = new_solution[second_longest_route_idx].copy()\n\n    # Remove the second longest route from the solution\n    new_solution.pop(second_longest_route_idx)\n\n    # Try to reinsert customers from the second longest route into the longest route\n    customers_to_insert = second_longest_route[1:-1]  # Exclude depots\n    for customer in customers_to_insert:\n        # Find the best insertion position in the longest route\n        best_pos = 1  # Default to first position\n        best_cost_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Calculate cost increase for inserting at position i\n            prev_node = longest_route[i-1]\n            next_node = longest_route[i]\n            new_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n            if new_cost < best_cost_increase:\n                best_pos = i\n                best_cost_increase = new_cost\n\n        # Insert the customer if capacity is not exceeded\n        if sum(demand[longest_route[1:best_pos]] + demand[customer]) <= capacity:\n            longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Update the longest route in the solution\n    new_solution[longest_route_idx] = longest_route\n\n    # Step 3: Perform a 2-opt* move on the longest route to further improve it\n    longest_route = new_solution[longest_route_idx].copy()\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(longest_route)-2):\n            for j in range(i+1, len(longest_route)-1):\n                # Check if swapping edges i and j improves the route\n                a, b, c, d = longest_route[i-1], longest_route[i], longest_route[j], longest_route[j+1]\n                current_cost = distance_matrix[a, b] + distance_matrix[c, d]\n                new_cost = distance_matrix[a, c] + distance_matrix[b, d]\n\n                if new_cost < current_cost:\n                    # Perform the swap\n                    longest_route[i:j+1] = longest_route[j:i-1:-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The algorithm selects a solution with high total distance or makespan from the archive, then applies a hybrid local search combining route splitting, intra-route 2-opt, and inter-route node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Deep copy the solution to avoid modifying the original\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: 1. Route splitting, 2. Intra-route 2-opt, 3. Inter-route node swapping\n    def is_feasible(route):\n        route_demand = sum(demand[route[1:-1]])\n        return route_demand <= capacity\n\n    # 1. Route splitting: Split long routes into two if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Intra-route 2-opt: Apply to a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route)-2), 2))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n\n    # 3. Inter-route node swapping: Swap two nodes between two random routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 2 and len(route2) > 2:\n            node1 = random.randint(1, len(route1)-2)\n            node2 = random.randint(1, len(route2)-2)\n            # Check feasibility after swapping\n            if (sum(demand[route1[1:-1]]) - demand[route1[node1]] + demand[route2[node2]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[node2]] + demand[route1[node1]] <= capacity):\n                # Perform the swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1], new_route2[node2] = new_route2[node2], new_route1[node1]\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7233374462654775,
            0.8189052939414978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Deep copy the solution to avoid modifying the original\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: 1. Route splitting, 2. Intra-route 2-opt, 3. Inter-route node swapping\n    def is_feasible(route):\n        route_demand = sum(demand[route[1:-1]])\n        return route_demand <= capacity\n\n    # 1. Route splitting: Split long routes into two if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # 2. Intra-route 2-opt: Apply to a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b = sorted(random.sample(range(1, len(route)-2), 2))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n\n    # 3. Inter-route node swapping: Swap two nodes between two random routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 2 and len(route2) > 2:\n            node1 = random.randint(1, len(route1)-2)\n            node2 = random.randint(1, len(route2)-2)\n            # Check feasibility after swapping\n            if (sum(demand[route1[1:-1]]) - demand[route1[node1]] + demand[route2[node2]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[node2]] + demand[route1[node1]] <= capacity):\n                # Perform the swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1], new_route2[node2] = new_route2[node2], new_route1[node1]\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] / obj[1] for _, obj in archive])  # Balance between distance and makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n            # Attempt to reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only reallocate if route has customers to move\n                    for _ in range(2):  # Limited attempts to avoid excessive computation\n                        # Randomly select a customer to move\n                        candidate_idx = np.random.randint(1, len(route)-1)\n                        candidate = route[candidate_idx]\n\n                        # Find the best insertion point in another route\n                        best_route = None\n                        best_insert_pos = -1\n                        min_increase = float('inf')\n\n                        for other_route in new_solution:\n                            if other_route is route:\n                                continue\n                            if sum(demand[other_route[1:-1]]) + demand[candidate] > capacity:\n                                continue\n\n                            # Try inserting at all possible positions\n                            for pos in range(1, len(other_route)):\n                                new_demand = sum(demand[other_route[1:pos]]) + demand[candidate]\n                                if new_demand <= capacity:\n                                    # Calculate the increase in total distance\n                                    prev_node = other_route[pos-1]\n                                    next_node = other_route[pos]\n                                    increase = (distance_matrix[prev_node][candidate] +\n                                              distance_matrix[candidate][next_node] -\n                                              distance_matrix[prev_node][next_node])\n\n                                    if increase < min_increase:\n                                        min_increase = increase\n                                        best_route = other_route\n                                        best_insert_pos = pos\n\n                        # Perform the best insertion if found\n                        if best_route is not None:\n                            best_route = np.insert(best_route, best_insert_pos, candidate)\n                            route = np.delete(route, candidate_idx)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7931040930645049,
            0.6647366285324097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] / obj[1] for _, obj in archive])  # Balance between distance and makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n            # Attempt to reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only reallocate if route has customers to move\n                    for _ in range(2):  # Limited attempts to avoid excessive computation\n                        # Randomly select a customer to move\n                        candidate_idx = np.random.randint(1, len(route)-1)\n                        candidate = route[candidate_idx]\n\n                        # Find the best insertion point in another route\n                        best_route = None\n                        best_insert_pos = -1\n                        min_increase = float('inf')\n\n                        for other_route in new_solution:\n                            if other_route is route:\n                                continue\n                            if sum(demand[other_route[1:-1]]) + demand[candidate] > capacity:\n                                continue\n\n                            # Try inserting at all possible positions\n                            for pos in range(1, len(other_route)):\n                                new_demand = sum(demand[other_route[1:pos]]) + demand[candidate]\n                                if new_demand <= capacity:\n                                    # Calculate the increase in total distance\n                                    prev_node = other_route[pos-1]\n                                    next_node = other_route[pos]\n                                    increase = (distance_matrix[prev_node][candidate] +\n                                              distance_matrix[candidate][next_node] -\n                                              distance_matrix[prev_node][next_node])\n\n                                    if increase < min_increase:\n                                        min_increase = increase\n                                        best_route = other_route\n                                        best_insert_pos = pos\n\n                        # Perform the best insertion if found\n                        if best_route is not None:\n                            best_route = np.insert(best_route, best_insert_pos, candidate)\n                            route = np.delete(route, candidate_idx)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: route merging and splitting with demand-aware relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot to customer back to depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try relocating a customer to another route\n            feasible = False\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Try inserting the customer into another route\n                for other_route in selected_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    for j in range(1, len(other_route)):\n                        # Insert customer into other_route at position j\n                        temp_route = np.insert(other_route, j, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Remove customer from original route\n                            temp_original = np.delete(route, i)\n                            if np.sum(demand[temp_original[1:-1]]) <= capacity:\n                                # Update routes\n                                new_solution.append(temp_route.copy())\n                                new_solution.append(temp_original.copy())\n                                feasible = True\n                                break\n                    if feasible:\n                        break\n                if feasible:\n                    break\n            if not feasible:\n                new_solution.append(route.copy())\n\n    # Remove duplicate routes and ensure depot consistency\n    unique_routes = []\n    for route in new_solution:\n        if len(route) > 2 and not any(np.array_equal(route, r) for r in unique_routes):\n            unique_routes.append(route.copy())\n\n    return unique_routes\n\n",
        "score": [
            -0.7689639988005794,
            1.4145019948482513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: route merging and splitting with demand-aware relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot to customer back to depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try relocating a customer to another route\n            feasible = False\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Try inserting the customer into another route\n                for other_route in selected_solution:\n                    if np.array_equal(other_route, route):\n                        continue\n                    for j in range(1, len(other_route)):\n                        # Insert customer into other_route at position j\n                        temp_route = np.insert(other_route, j, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Remove customer from original route\n                            temp_original = np.delete(route, i)\n                            if np.sum(demand[temp_original[1:-1]]) <= capacity:\n                                # Update routes\n                                new_solution.append(temp_route.copy())\n                                new_solution.append(temp_original.copy())\n                                feasible = True\n                                break\n                    if feasible:\n                        break\n                if feasible:\n                    break\n            if not feasible:\n                new_solution.append(route.copy())\n\n    # Remove duplicate routes and ensure depot consistency\n    unique_routes = []\n    for route in new_solution:\n        if len(route) > 2 and not any(np.array_equal(route, r) for r in unique_routes):\n            unique_routes.append(route.copy())\n\n    return unique_routes\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to split or optimize\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Hybrid local search: Split route at a high-demand node and reinsert into new routes\n    if len(selected_route) > 3:  # Ensure route can be split\n        # Find the node with the highest demand to split at\n        demands = demand[selected_route[1:-1]]  # Exclude depot\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n\n        # Split the route into two parts\n        part1 = selected_route[:split_idx + 1]  # Includes depot\n        part2 = selected_route[split_idx:]  # Includes depot\n\n        # Check capacity constraints\n        if (demand[part1[1:-1]].sum() <= capacity) and (demand[part2[1:-1]].sum() <= capacity):\n            # Replace the original route with the two new parts\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n        else:\n            # If split violates capacity, perform a 2-opt within the route\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(range(1, len(selected_route) - 2), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Reverse the segment between i and j\n            reversed_segment = selected_route[i:j+1][::-1]\n            new_route = np.concatenate([selected_route[:i], reversed_segment, selected_route[j+1:]])\n            if demand[new_route[1:-1]].sum() <= capacity:\n                new_solution[route_idx] = new_route\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6611402158223272,
            0.18442070484161377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to split or optimize\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Hybrid local search: Split route at a high-demand node and reinsert into new routes\n    if len(selected_route) > 3:  # Ensure route can be split\n        # Find the node with the highest demand to split at\n        demands = demand[selected_route[1:-1]]  # Exclude depot\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n\n        # Split the route into two parts\n        part1 = selected_route[:split_idx + 1]  # Includes depot\n        part2 = selected_route[split_idx:]  # Includes depot\n\n        # Check capacity constraints\n        if (demand[part1[1:-1]].sum() <= capacity) and (demand[part2[1:-1]].sum() <= capacity):\n            # Replace the original route with the two new parts\n            new_solution = base_solution.copy()\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n        else:\n            # If split violates capacity, perform a 2-opt within the route\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(range(1, len(selected_route) - 2), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Reverse the segment between i and j\n            reversed_segment = selected_route[i:j+1][::-1]\n            new_route = np.concatenate([selected_route[:i], reversed_segment, selected_route[j+1:]])\n            if demand[new_route[1:-1]].sum() <= capacity:\n                new_solution[route_idx] = new_route\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0]  # Prioritize solutions with high makespan-to-distance ratio\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes if feasible, then perform segment reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible point\n            best_insert_pos = 0\n            min_insert_cost = float('inf')\n            for pos in range(1, len(route1)):\n                cost = distance_matrix[route1[pos-1], route2[1]] + distance_matrix[route2[-2], route1[pos]] - distance_matrix[route1[pos-1], route1[pos]]\n                if cost < min_insert_cost:\n                    min_insert_cost = cost\n                    best_insert_pos = pos\n\n            # Insert route2 into route1\n            merged_route = np.concatenate((route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]))\n            new_solution[i] = merged_route\n            del new_solution[j]  # Remove the merged route\n\n    # Perform segment reversal on a randomly selected route to reduce makespan\n    if new_solution:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough nodes for reversal\n            # Randomly select a segment to reverse\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n            reversed_segment = segment[::-1]\n\n            # Check feasibility of reversed segment\n            if sum(demand[node] for node in reversed_segment) <= capacity:\n                new_route = np.concatenate((route[:start], reversed_segment, route[end:]))\n                new_solution[route_idx] = new_route\n\n    # Reallocate customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Skip routes with only depot and one customer\n            # Randomly select a customer to reallocate\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Find the best route to insert the customer (minimizing makespan increase)\n            best_route_idx = -1\n            min_makespan_increase = float('inf')\n            for i, candidate_route in enumerate(new_solution):\n                if i != route_idx and sum(demand[node] for node in candidate_route[1:-1]) + demand[customer] <= capacity:\n                    # Calculate makespan increase for each possible insertion position\n                    for pos in range(1, len(candidate_route)):\n                        cost_increase = (distance_matrix[candidate_route[pos-1], customer] +\n                                        distance_matrix[customer, candidate_route[pos]] -\n                                        distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                        if cost_increase < min_makespan_increase:\n                            min_makespan_increase = cost_increase\n                            best_route_idx = i\n\n            if best_route_idx != -1:\n                # Insert customer into the best route\n                candidate_route = new_solution[best_route_idx]\n                best_pos = np.argmin([distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]] for pos in range(1, len(candidate_route))])\n                new_route = np.concatenate((candidate_route[:best_pos], [customer], candidate_route[best_pos:]))\n                new_solution[best_route_idx] = new_route\n                # Remove customer from original route\n                new_solution[route_idx] = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.7072614864422302,
            4.348407566547394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0]  # Prioritize solutions with high makespan-to-distance ratio\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes if feasible, then perform segment reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1 at the closest possible point\n            best_insert_pos = 0\n            min_insert_cost = float('inf')\n            for pos in range(1, len(route1)):\n                cost = distance_matrix[route1[pos-1], route2[1]] + distance_matrix[route2[-2], route1[pos]] - distance_matrix[route1[pos-1], route1[pos]]\n                if cost < min_insert_cost:\n                    min_insert_cost = cost\n                    best_insert_pos = pos\n\n            # Insert route2 into route1\n            merged_route = np.concatenate((route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]))\n            new_solution[i] = merged_route\n            del new_solution[j]  # Remove the merged route\n\n    # Perform segment reversal on a randomly selected route to reduce makespan\n    if new_solution:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route has enough nodes for reversal\n            # Randomly select a segment to reverse\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n            reversed_segment = segment[::-1]\n\n            # Check feasibility of reversed segment\n            if sum(demand[node] for node in reversed_segment) <= capacity:\n                new_route = np.concatenate((route[:start], reversed_segment, route[end:]))\n                new_solution[route_idx] = new_route\n\n    # Reallocate customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Skip routes with only depot and one customer\n            # Randomly select a customer to reallocate\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Find the best route to insert the customer (minimizing makespan increase)\n            best_route_idx = -1\n            min_makespan_increase = float('inf')\n            for i, candidate_route in enumerate(new_solution):\n                if i != route_idx and sum(demand[node] for node in candidate_route[1:-1]) + demand[customer] <= capacity:\n                    # Calculate makespan increase for each possible insertion position\n                    for pos in range(1, len(candidate_route)):\n                        cost_increase = (distance_matrix[candidate_route[pos-1], customer] +\n                                        distance_matrix[customer, candidate_route[pos]] -\n                                        distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                        if cost_increase < min_makespan_increase:\n                            min_makespan_increase = cost_increase\n                            best_route_idx = i\n\n            if best_route_idx != -1:\n                # Insert customer into the best route\n                candidate_route = new_solution[best_route_idx]\n                best_pos = np.argmin([distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]] for pos in range(1, len(candidate_route))])\n                new_route = np.concatenate((candidate_route[:best_pos], [customer], candidate_route[best_pos:]))\n                new_solution[best_route_idx] = new_route\n                # Remove customer from original route\n                new_solution[route_idx] = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two parts\n        longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Step 2: Attempt to reinsert customers from the split routes into other routes\n        for route in [new_route1, new_route2]:\n            if len(route) > 2:  # If route has customers\n                for customer in route[1:-1]:\n                    # Try inserting into other routes\n                    for i, candidate_route in enumerate(new_solution):\n                        if i != longest_route_idx and np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = (distance_matrix[candidate_route[pos-1], customer] +\n                                       distance_matrix[customer, candidate_route[pos]] -\n                                       distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                            # Insert customer\n                            candidate_route = np.insert(candidate_route, best_pos, customer)\n                            new_solution[i] = candidate_route\n                            route = np.delete(route, np.where(route == customer)[0][0])\n                            break\n\n        # Update the split routes\n        new_solution[longest_route_idx] = new_route1\n        if len(new_route2) > 2:\n            new_solution.append(new_route2)\n        else:\n            new_solution[longest_route_idx] = new_route1\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "score": [
            -0.725262359570935,
            2.596277564764023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two parts\n        longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Step 2: Attempt to reinsert customers from the split routes into other routes\n        for route in [new_route1, new_route2]:\n            if len(route) > 2:  # If route has customers\n                for customer in route[1:-1]:\n                    # Try inserting into other routes\n                    for i, candidate_route in enumerate(new_solution):\n                        if i != longest_route_idx and np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = (distance_matrix[candidate_route[pos-1], customer] +\n                                       distance_matrix[customer, candidate_route[pos]] -\n                                       distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                            # Insert customer\n                            candidate_route = np.insert(candidate_route, best_pos, customer)\n                            new_solution[i] = candidate_route\n                            route = np.delete(route, np.where(route == customer)[0][0])\n                            break\n\n        # Update the split routes\n        new_solution[longest_route_idx] = new_route1\n        if len(new_route2) > 2:\n            new_solution.append(new_route2)\n        else:\n            new_solution[longest_route_idx] = new_route1\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-adaptive 2-opt to generate a high-quality neighbor while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0, 0.5]  # Higher weight for distance to encourage diversity\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution by applying hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Try to reallocate customers between parts\n        for i in range(1, len(part2) - 1):\n            customer = part2[i]\n            if np.sum(demand[part1]) + demand[customer] <= capacity:\n                part1 = np.append(part1, customer)\n                part2 = np.delete(part2, i)\n                break\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Apply capacity-adaptive 2-opt on random routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Find feasible 2-opt swap\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:i]]) + demand[route2[j]] <= capacity and\n                    np.sum(demand[route2[1:j]]) + demand[route1[i]] <= capacity):\n                    # Perform swap\n                    new_route1 = np.concatenate([route1[:i], [route2[j]], route1[i+1:]])\n                    new_route2 = np.concatenate([route2[:j], [route1[i]], route2[j+1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7751586038324019,
            0.968284010887146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0, 0.5]  # Higher weight for distance to encourage diversity\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution by applying hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Try to reallocate customers between parts\n        for i in range(1, len(part2) - 1):\n            customer = part2[i]\n            if np.sum(demand[part1]) + demand[customer] <= capacity:\n                part1 = np.append(part1, customer)\n                part2 = np.delete(part2, i)\n                break\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Apply capacity-adaptive 2-opt on random routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Find feasible 2-opt swap\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:i]]) + demand[route2[j]] <= capacity and\n                    np.sum(demand[route2[1:j]]) + demand[route1[i]] <= capacity):\n                    # Perform swap\n                    new_route1 = np.concatenate([route1[:i], [route2[j]], route1[i+1:]])\n                    new_route2 = np.concatenate([route2[:j], [route1[i]], route2[j+1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combination of route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 1: Split the route at a random point if it's too long\n        if np.sum(demand[route[1:-1]]) > 0.7 * capacity:\n            split_pos = np.random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # Step 2: Reallocate a random customer to another route if possible\n        if len(new_solution) > 1 and len(route) > 3:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n            other_route_idx = np.random.randint(0, len(new_solution))\n            if other_route_idx != i and np.sum(demand[new_solution[other_route_idx][1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from current route\n                new_route = np.concatenate((route[:customer_pos], route[customer_pos+1:]))\n                new_solution[i] = new_route\n\n                # Insert customer into another route\n                insert_pos = np.random.randint(1, len(new_solution[other_route_idx]))\n                new_other_route = np.concatenate((\n                    new_solution[other_route_idx][:insert_pos],\n                    [customer],\n                    new_solution[other_route_idx][insert_pos:]\n                ))\n                new_solution[other_route_idx] = new_other_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7466251302330114,
            0.6295290887355804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combination of route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Step 1: Split the route at a random point if it's too long\n        if np.sum(demand[route[1:-1]]) > 0.7 * capacity:\n            split_pos = np.random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # Step 2: Reallocate a random customer to another route if possible\n        if len(new_solution) > 1 and len(route) > 3:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n            other_route_idx = np.random.randint(0, len(new_solution))\n            if other_route_idx != i and np.sum(demand[new_solution[other_route_idx][1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from current route\n                new_route = np.concatenate((route[:customer_pos], route[customer_pos+1:]))\n                new_solution[i] = new_route\n\n                # Insert customer into another route\n                insert_pos = np.random.randint(1, len(new_solution[other_route_idx]))\n                new_other_route = np.concatenate((\n                    new_solution[other_route_idx][:insert_pos],\n                    [customer],\n                    new_solution[other_route_idx][insert_pos:]\n                ))\n                new_solution[other_route_idx] = new_other_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted trade-off between total distance and makespan, then applies a hybrid local search combining route segment reversal and customer reallocation to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives for selection\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n\n        # Weighted score (prioritize balanced solutions)\n        scores = []\n        for i in range(len(archive)):\n            normalized_dist = (distances[i] - min_dist) / (max_dist - min_dist + 1e-10)\n            normalized_make = (makespans[i] - min_make) / (max_make - min_make + 1e-10)\n            score = 0.4 * normalized_dist + 0.6 * normalized_make  # Higher weight for makespan\n            scores.append(score)\n\n        # Select solution with lowest score (best trade-off)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reversal + customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse a segment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least 3 nodes (depot, customer, depot)\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            route[start:end+1] = route[start:end+1][::-1]\n\n        # Step 2: Attempt to reallocate a customer from the longest route to another route\n        longest_route_idx = np.argmax([distance_matrix[route[-1], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 2:  # At least one customer\n            customer_idx = random.randint(1, len(longest_route) - 2)\n            customer = longest_route[customer_idx]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != longest_route_idx and np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert and remove from original route\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    new_solution[longest_route_idx] = np.delete(longest_route, customer_idx)\n                    break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Reinsert missing customers into routes with capacity\n    for customer in missing_customers:\n        inserted = False\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    cost = (distance_matrix[route[pos-1], customer] +\n                            distance_matrix[customer, route[pos]] -\n                            distance_matrix[route[pos-1], route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route = np.insert(route, best_pos, customer)\n                new_solution[i] = new_route\n                inserted = True\n                break\n        if not inserted:\n            # Create new route if no existing route can accommodate\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.3511585911295732,
            1.1103812754154205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives for selection\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n\n        # Weighted score (prioritize balanced solutions)\n        scores = []\n        for i in range(len(archive)):\n            normalized_dist = (distances[i] - min_dist) / (max_dist - min_dist + 1e-10)\n            normalized_make = (makespans[i] - min_make) / (max_make - min_make + 1e-10)\n            score = 0.4 * normalized_dist + 0.6 * normalized_make  # Higher weight for makespan\n            scores.append(score)\n\n        # Select solution with lowest score (best trade-off)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segment reversal + customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse a segment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least 3 nodes (depot, customer, depot)\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            route[start:end+1] = route[start:end+1][::-1]\n\n        # Step 2: Attempt to reallocate a customer from the longest route to another route\n        longest_route_idx = np.argmax([distance_matrix[route[-1], 0] for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 2:  # At least one customer\n            customer_idx = random.randint(1, len(longest_route) - 2)\n            customer = longest_route[customer_idx]\n\n            # Try to insert into another route\n            for i, route in enumerate(new_solution):\n                if i != longest_route_idx and np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert and remove from original route\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    new_solution[longest_route_idx] = np.delete(longest_route, customer_idx)\n                    break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Reinsert missing customers into routes with capacity\n    for customer in missing_customers:\n        inserted = False\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    cost = (distance_matrix[route[pos-1], customer] +\n                            distance_matrix[customer, route[pos]] -\n                            distance_matrix[route[pos-1], route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route = np.insert(route, best_pos, customer)\n                new_solution[i] = new_route\n                inserted = True\n                break\n        if not inserted:\n            # Create new route if no existing route can accommodate\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshaping\" operator that intelligently redistributes customers between routes while minimizing both distance and makespan, ensuring feasibility and generating high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Route merging with capacity check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    # 2. Customer reinsertion with makespan consideration\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try inserting into another route\n            for other_route in new_solution:\n                if np.array_equal(other_route, route):\n                    continue\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point (minimizing additional distance)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, customer_pos)\n                    break\n\n            # Update routes in solution\n            new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n            if len(route) > 2:\n                new_solution.append(route)\n\n    # 3. Route reshaping operator (novel transformation)\n    if len(new_solution) > 1:\n        # Select a route to reshape\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure route has customers to move\n            # Randomly select a segment of customers to move\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end+1]\n\n            # Try to insert segment into another route\n            for other_route in new_solution:\n                if np.array_equal(other_route, route):\n                    continue\n                if sum(demand[other_route[1:-1]]) + sum(demand[segment]) <= capacity:\n                    # Find best insertion point (minimizing makespan increase)\n                    best_pos = 1\n                    min_makespan_increase = float('inf')\n                    current_makespan = sum(distance_matrix[other_route[k], other_route[k+1]] for k in range(len(other_route)-1))\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate makespan if inserted here\n                        new_route = np.insert(other_route, pos, segment)\n                        new_makespan = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n                        makespan_increase = new_makespan - current_makespan\n\n                        if makespan_increase < min_makespan_increase:\n                            min_makespan_increase = makespan_increase\n                            best_pos = pos\n\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, segment)\n                    route = np.delete(route, slice(start, end+1))\n                    break\n\n            # Update routes in solution\n            new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n            if len(route) > 2:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7781039918995087,
            1.3436588048934937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Route merging with capacity check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    # 2. Customer reinsertion with makespan consideration\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Try inserting into another route\n            for other_route in new_solution:\n                if np.array_equal(other_route, route):\n                    continue\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point (minimizing additional distance)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, customer_pos)\n                    break\n\n            # Update routes in solution\n            new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n            if len(route) > 2:\n                new_solution.append(route)\n\n    # 3. Route reshaping operator (novel transformation)\n    if len(new_solution) > 1:\n        # Select a route to reshape\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure route has customers to move\n            # Randomly select a segment of customers to move\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end+1]\n\n            # Try to insert segment into another route\n            for other_route in new_solution:\n                if np.array_equal(other_route, route):\n                    continue\n                if sum(demand[other_route[1:-1]]) + sum(demand[segment]) <= capacity:\n                    # Find best insertion point (minimizing makespan increase)\n                    best_pos = 1\n                    min_makespan_increase = float('inf')\n                    current_makespan = sum(distance_matrix[other_route[k], other_route[k+1]] for k in range(len(other_route)-1))\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate makespan if inserted here\n                        new_route = np.insert(other_route, pos, segment)\n                        new_makespan = sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1))\n                        makespan_increase = new_makespan - current_makespan\n\n                        if makespan_increase < min_makespan_increase:\n                            min_makespan_increase = makespan_increase\n                            best_pos = pos\n\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, segment)\n                    route = np.delete(route, slice(start, end+1))\n                    break\n\n            # Update routes in solution\n            new_solution = [r for r in new_solution if len(r) > 2]  # Remove empty routes\n            if len(route) > 2:\n                new_solution.append(route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and route shuffling to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge routes, reinsert customers, and shuffle routes\n    new_solution = selected_solution.copy()\n\n    # Step 1: Merge two routes if feasible (randomly select two routes)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge routes by concatenating\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Reinsert customers from the longest route to others if feasible\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Remove customers from the longest route and reinsert into other routes\n        customers_to_reinsert = longest_route[1:-1].copy()\n        new_solution.pop(longest_route_idx)\n\n        for customer in customers_to_reinsert:\n            # Try to insert into the first feasible route\n            inserted = False\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position (minimum increase in distance)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = (distance_matrix[route[pos-1], customer] +\n                                   distance_matrix[customer, route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Insert customer\n                    route = np.insert(route, best_pos, customer)\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Step 3: Shuffle routes to balance makespan and distance\n    random.shuffle(new_solution)\n\n    # Ensure feasibility (should be redundant due to checks, but added for safety)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution during local search.\")\n\n    return new_solution\n\n",
        "score": [
            -0.7352248210722465,
            2.03749018907547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge routes, reinsert customers, and shuffle routes\n    new_solution = selected_solution.copy()\n\n    # Step 1: Merge two routes if feasible (randomly select two routes)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge routes by concatenating\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Reinsert customers from the longest route to others if feasible\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Remove customers from the longest route and reinsert into other routes\n        customers_to_reinsert = longest_route[1:-1].copy()\n        new_solution.pop(longest_route_idx)\n\n        for customer in customers_to_reinsert:\n            # Try to insert into the first feasible route\n            inserted = False\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position (minimum increase in distance)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = (distance_matrix[route[pos-1], customer] +\n                                   distance_matrix[customer, route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    # Insert customer\n                    route = np.insert(route, best_pos, customer)\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Step 3: Shuffle routes to balance makespan and distance\n    random.shuffle(new_solution)\n\n    # Ensure feasibility (should be redundant due to checks, but added for safety)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution during local search.\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by combining a random selection with a makespan-based heuristic, then applies a hybrid local search operator that merges routes with the shortest distance and splits routes with the longest distance to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (second objective) to find solutions with high potential\n        archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n        # Randomly select from top 30% or all if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_solution = random.choice(selection_pool)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge shortest routes and split longest routes\n    if len(new_solution) > 1:\n        # Find the shortest route (candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Find the longest route (candidate for splitting)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to merge shortest route into another route\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx and i != longest_route_idx:\n                candidate_route = new_solution[i]\n                # Check if merging is feasible (capacity constraint)\n                total_demand = sum(demand[node] for node in shortest_route[1:-1]) + sum(demand[node] for node in candidate_route[1:-1])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([candidate_route[:-1], shortest_route[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[shortest_route_idx]\n                    break\n\n        # Try to split longest route\n        if len(new_solution) < len(selected_solution) + 1:  # Only split if merging was successful\n            split_point = len(longest_route) // 2\n            part1 = longest_route[:split_point + 1]\n            part2 = longest_route[split_point:]\n\n            # Check capacity constraints for both parts\n            demand_part1 = sum(demand[node] for node in part1[1:-1])\n            demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[longest_route_idx] = part1\n                new_solution.append(part2)\n\n    return new_solution\n\n",
        "score": [
            -0.7363120023389413,
            0.5332044959068298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (second objective) to find solutions with high potential\n        archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n        # Randomly select from top 30% or all if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_solution = random.choice(selection_pool)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge shortest routes and split longest routes\n    if len(new_solution) > 1:\n        # Find the shortest route (candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Find the longest route (candidate for splitting)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to merge shortest route into another route\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx and i != longest_route_idx:\n                candidate_route = new_solution[i]\n                # Check if merging is feasible (capacity constraint)\n                total_demand = sum(demand[node] for node in shortest_route[1:-1]) + sum(demand[node] for node in candidate_route[1:-1])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([candidate_route[:-1], shortest_route[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[shortest_route_idx]\n                    break\n\n        # Try to split longest route\n        if len(new_solution) < len(selected_solution) + 1:  # Only split if merging was successful\n            split_point = len(longest_route) // 2\n            part1 = longest_route[:split_point + 1]\n            part2 = longest_route[split_point:]\n\n            # Check capacity constraints for both parts\n            demand_part1 = sum(demand[node] for node in part1[1:-1])\n            demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                new_solution[longest_route_idx] = part1\n                new_solution.append(part2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A hybrid local search algorithm that combines route fragmentation with adaptive customer reassignment to balance travel distance and makespan by intelligently splitting and merging routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random point (not the depot)\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = [0] + selected_route[split_point + 1:]\n\n        # Check capacity feasibility for both parts\n        first_demand = sum(demand[node] for node in first_part if node != 0)\n        second_demand = sum(demand[node] for node in second_part if node != 0)\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n        else:\n            # If splitting violates capacity, try to reassign customers to other routes\n            for node in selected_route[1:-1]:\n                if demand[node] > capacity:\n                    continue  # Skip nodes that exceed capacity alone\n\n                # Find the best route to insert the node (minimizing additional distance)\n                best_route_idx = -1\n                best_insert_pos = -1\n                min_additional_distance = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == route_idx:\n                        continue  # Skip the original route\n\n                    for j in range(1, len(route)):\n                        # Try inserting the node between route[j-1] and route[j]\n                        new_distance = (distance_matrix[route[j-1]][node] +\n                                        distance_matrix[node][route[j]] -\n                                        distance_matrix[route[j-1]][route[j]])\n\n                        if new_distance < min_additional_distance:\n                            current_demand = sum(demand[n] for n in route if n != 0)\n                            if current_demand + demand[node] <= capacity:\n                                best_route_idx = i\n                                best_insert_pos = j\n                                min_additional_distance = new_distance\n\n                if best_route_idx != -1:\n                    # Insert the node into the best route\n                    new_solution[best_route_idx].insert(best_insert_pos, node)\n                    # Remove the node from the original route\n                    selected_route.remove(node)\n\n            # Update the original route (may be empty)\n            new_solution[route_idx] = selected_route if len(selected_route) > 2 else []\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9185041413636,
            0.21488386392593384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Split the route into two parts at a random point (not the depot)\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = [0] + selected_route[split_point + 1:]\n\n        # Check capacity feasibility for both parts\n        first_demand = sum(demand[node] for node in first_part if node != 0)\n        second_demand = sum(demand[node] for node in second_part if node != 0)\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n        else:\n            # If splitting violates capacity, try to reassign customers to other routes\n            for node in selected_route[1:-1]:\n                if demand[node] > capacity:\n                    continue  # Skip nodes that exceed capacity alone\n\n                # Find the best route to insert the node (minimizing additional distance)\n                best_route_idx = -1\n                best_insert_pos = -1\n                min_additional_distance = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == route_idx:\n                        continue  # Skip the original route\n\n                    for j in range(1, len(route)):\n                        # Try inserting the node between route[j-1] and route[j]\n                        new_distance = (distance_matrix[route[j-1]][node] +\n                                        distance_matrix[node][route[j]] -\n                                        distance_matrix[route[j-1]][route[j]])\n\n                        if new_distance < min_additional_distance:\n                            current_demand = sum(demand[n] for n in route if n != 0)\n                            if current_demand + demand[node] <= capacity:\n                                best_route_idx = i\n                                best_insert_pos = j\n                                min_additional_distance = new_distance\n\n                if best_route_idx != -1:\n                    # Insert the node into the best route\n                    new_solution[best_route_idx].insert(best_insert_pos, node)\n                    # Remove the node from the original route\n                    selected_route.remove(node)\n\n            # Update the original route (may be empty)\n            new_solution[route_idx] = selected_route if len(selected_route) > 2 else []\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted objective score, then applies a hybrid local search combining route segmentation and demand-aware insertion to generate a feasible neighbor solution while balancing distance and makespan minimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Segment the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Try to merge segments with other routes or reinsert nodes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            # Check if we can insert segment2 into another route\n            other_route = new_solution[j]\n            temp_route = np.concatenate([other_route[:-1], segment2[1:]])\n            if np.sum(demand[temp_route]) <= capacity:\n                new_solution[i] = segment1\n                new_solution[j] = temp_route\n                break\n\n        # If no merge occurred, try demand-aware reinsertion\n        if new_solution[i] is route:  # No change\n            # Remove a random node and reinsert it into the same route\n            if len(route) > 3:\n                pos = np.random.randint(1, len(route) - 1)\n                node = route[pos]\n                new_route = np.concatenate([route[:pos], route[pos+1:]])\n                # Find best insertion position in the same route\n                best_pos = 1\n                best_cost = float('inf')\n                for k in range(1, len(new_route)):\n                    temp_route = np.concatenate([new_route[:k], [node], new_route[k:]])\n                    cost = distance_matrix[temp_route[k-1], node] + distance_matrix[node, temp_route[k+1]] - distance_matrix[temp_route[k-1], temp_route[k+1]]\n                    if cost < best_cost and np.sum(demand[temp_route]) <= capacity:\n                        best_cost = cost\n                        best_pos = k\n                new_route = np.concatenate([new_route[:best_pos], [node], new_route[best_pos:]])\n                new_solution[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n        if len(new_solution[i]) == 2 and new_solution[i][0] == 0 and new_solution[i][1] == 0:\n            new_solution[i] = np.array([0])  # Empty route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n",
        "score": [
            -0.5612030505113375,
            4.149076879024506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Segment the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Try to merge segments with other routes or reinsert nodes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            # Check if we can insert segment2 into another route\n            other_route = new_solution[j]\n            temp_route = np.concatenate([other_route[:-1], segment2[1:]])\n            if np.sum(demand[temp_route]) <= capacity:\n                new_solution[i] = segment1\n                new_solution[j] = temp_route\n                break\n\n        # If no merge occurred, try demand-aware reinsertion\n        if new_solution[i] is route:  # No change\n            # Remove a random node and reinsert it into the same route\n            if len(route) > 3:\n                pos = np.random.randint(1, len(route) - 1)\n                node = route[pos]\n                new_route = np.concatenate([route[:pos], route[pos+1:]])\n                # Find best insertion position in the same route\n                best_pos = 1\n                best_cost = float('inf')\n                for k in range(1, len(new_route)):\n                    temp_route = np.concatenate([new_route[:k], [node], new_route[k:]])\n                    cost = distance_matrix[temp_route[k-1], node] + distance_matrix[node, temp_route[k+1]] - distance_matrix[temp_route[k-1], temp_route[k+1]]\n                    if cost < best_cost and np.sum(demand[temp_route]) <= capacity:\n                        best_cost = cost\n                        best_pos = k\n                new_route = np.concatenate([new_route[:best_pos], [node], new_route[best_pos:]])\n                new_solution[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n        if len(new_solution[i]) == 2 and new_solution[i][0] == 0 and new_solution[i][1] == 0:\n            new_solution[i] = np.array([0])  # Empty route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Apply a hybrid local search: combine route splitting and customer relocation\n    if len(selected_route) > 3:  # Ensure route has customers to split\n        # Split the route into two parts at a random customer\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints for the new routes\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # If splitting violates capacity, try relocating a customer\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                # Try to insert the customer into another route\n                for j in range(len(new_solution)):\n                    if j != route_idx:\n                        temp_route = new_solution[j].copy()\n                        for k in range(1, len(temp_route)):\n                            # Insert customer into temp_route\n                            temp_route_inserted = np.insert(temp_route, k, customer)\n                            temp_demand = np.sum(demand[temp_route_inserted[1:-1]])\n                            if temp_demand <= capacity:\n                                # Update routes\n                                new_solution[j] = temp_route_inserted\n                                new_solution[route_idx] = np.delete(selected_route, i)\n                                if len(new_solution[route_idx]) == 2:  # If route becomes empty, remove it\n                                    new_solution.pop(route_idx)\n                                return new_solution\n    else:\n        # If route is too short, try relocating its customers\n        for i in range(1, len(selected_route) - 1):\n            customer = selected_route[i]\n            for j in range(len(new_solution)):\n                if j != route_idx:\n                    temp_route = new_solution[j].copy()\n                    for k in range(1, len(temp_route)):\n                        temp_route_inserted = np.insert(temp_route, k, customer)\n                        temp_demand = np.sum(demand[temp_route_inserted[1:-1]])\n                        if temp_demand <= capacity:\n                            new_solution[j] = temp_route_inserted\n                            new_solution[route_idx] = np.delete(selected_route, i)\n                            if len(new_solution[route_idx]) == 2:\n                                new_solution.pop(route_idx)\n                            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7858659506529364,
            0.43424490094184875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Apply a hybrid local search: combine route splitting and customer relocation\n    if len(selected_route) > 3:  # Ensure route has customers to split\n        # Split the route into two parts at a random customer\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints for the new routes\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n        else:\n            # If splitting violates capacity, try relocating a customer\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                # Try to insert the customer into another route\n                for j in range(len(new_solution)):\n                    if j != route_idx:\n                        temp_route = new_solution[j].copy()\n                        for k in range(1, len(temp_route)):\n                            # Insert customer into temp_route\n                            temp_route_inserted = np.insert(temp_route, k, customer)\n                            temp_demand = np.sum(demand[temp_route_inserted[1:-1]])\n                            if temp_demand <= capacity:\n                                # Update routes\n                                new_solution[j] = temp_route_inserted\n                                new_solution[route_idx] = np.delete(selected_route, i)\n                                if len(new_solution[route_idx]) == 2:  # If route becomes empty, remove it\n                                    new_solution.pop(route_idx)\n                                return new_solution\n    else:\n        # If route is too short, try relocating its customers\n        for i in range(1, len(selected_route) - 1):\n            customer = selected_route[i]\n            for j in range(len(new_solution)):\n                if j != route_idx:\n                    temp_route = new_solution[j].copy()\n                    for k in range(1, len(temp_route)):\n                        temp_route_inserted = np.insert(temp_route, k, customer)\n                        temp_demand = np.sum(demand[temp_route_inserted[1:-1]])\n                        if temp_demand <= capacity:\n                            new_solution[j] = temp_route_inserted\n                            new_solution[route_idx] = np.delete(selected_route, i)\n                            if len(new_solution[route_idx]) == 2:\n                                new_solution.pop(route_idx)\n                            return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for sol, obj in archive])  # Prefer high makespan solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge two routes if feasible, otherwise split or relocate\n    if len(new_solution) > 1:\n        # Try merging two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check feasibility\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution.pop(max(i, j))\n            new_solution[min(i, j)] = merged_route\n            return new_solution\n\n        # If merging fails, try splitting a route\n        split_idx = np.random.randint(1, len(route1) - 1)\n        split_route1 = route1[:split_idx + 1] + [0]\n        split_route2 = [0] + route1[split_idx + 1:]\n\n        # Check feasibility of splits\n        demand1, demand2 = np.sum(demand[split_route1[1:-1]]), np.sum(demand[split_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = split_route1\n            new_solution.insert(i + 1, split_route2)\n            return new_solution\n\n    # If no merge/split works, perform demand-aware relocation\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has nodes to relocate\n            # Find a node to relocate (prefer high-demand nodes)\n            node_idx = np.random.choice(np.where(demand[route[1:-1]] > capacity / 2)[0])\n            node = route[node_idx + 1]  # +1 to skip depot\n\n            # Find best insertion position in another route\n            best_route = None\n            best_pos = 0\n            best_cost = float('inf')\n\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                for pos in range(1, len(other_route)):\n                    # Insert node at position pos\n                    candidate_route = np.insert(other_route, pos, node)\n                    total_demand = np.sum(demand[candidate_route[1:-1]])\n                    if total_demand <= capacity:\n                        # Evaluate insertion cost (distance increase)\n                        cost = (distance_matrix[other_route[pos-1], node] +\n                               distance_matrix[node, other_route[pos]] -\n                               distance_matrix[other_route[pos-1], other_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = other_route\n                            best_pos = pos\n\n            if best_route is not None:\n                # Perform relocation\n                route = np.delete(route, node_idx + 1)\n                best_route = np.insert(best_route, best_pos, node)\n                break  # Only perform one relocation per call\n\n    return new_solution\n\n",
        "score": [
            -0.6933326288602537,
            0.37630701065063477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for sol, obj in archive])  # Prefer high makespan solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge two routes if feasible, otherwise split or relocate\n    if len(new_solution) > 1:\n        # Try merging two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check feasibility\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution.pop(max(i, j))\n            new_solution[min(i, j)] = merged_route\n            return new_solution\n\n        # If merging fails, try splitting a route\n        split_idx = np.random.randint(1, len(route1) - 1)\n        split_route1 = route1[:split_idx + 1] + [0]\n        split_route2 = [0] + route1[split_idx + 1:]\n\n        # Check feasibility of splits\n        demand1, demand2 = np.sum(demand[split_route1[1:-1]]), np.sum(demand[split_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = split_route1\n            new_solution.insert(i + 1, split_route2)\n            return new_solution\n\n    # If no merge/split works, perform demand-aware relocation\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has nodes to relocate\n            # Find a node to relocate (prefer high-demand nodes)\n            node_idx = np.random.choice(np.where(demand[route[1:-1]] > capacity / 2)[0])\n            node = route[node_idx + 1]  # +1 to skip depot\n\n            # Find best insertion position in another route\n            best_route = None\n            best_pos = 0\n            best_cost = float('inf')\n\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                for pos in range(1, len(other_route)):\n                    # Insert node at position pos\n                    candidate_route = np.insert(other_route, pos, node)\n                    total_demand = np.sum(demand[candidate_route[1:-1]])\n                    if total_demand <= capacity:\n                        # Evaluate insertion cost (distance increase)\n                        cost = (distance_matrix[other_route[pos-1], node] +\n                               distance_matrix[node, other_route[pos]] -\n                               distance_matrix[other_route[pos-1], other_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = other_route\n                            best_pos = pos\n\n            if best_route is not None:\n                # Perform relocation\n                route = np.delete(route, node_idx + 1)\n                best_route = np.insert(best_route, best_pos, node)\n                break  # Only perform one relocation per call\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Segment the route into two parts at a random point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    first_part = selected_route[:split_point + 1]\n    second_part = selected_route[split_point:]\n\n    # Check if the split is feasible (demand constraint)\n    first_demand = sum(demand[node] for node in first_part if node != 0)\n    second_demand = sum(demand[node] for node in second_part if node != 0)\n\n    if first_demand <= capacity and second_demand <= capacity:\n        # Update the solution with the split\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try demand-aware insertion from one route to another\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            target_route = new_solution[i].copy()\n            for node in selected_route[1:-1]:\n                # Try inserting the node into the target route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    # Insert node at position pos\n                    candidate_route = np.insert(target_route, pos, node)\n                    candidate_demand = sum(demand[n] for n in candidate_route if n != 0)\n                    if candidate_demand <= capacity:\n                        # Calculate the cost of the candidate route\n                        cost = sum(distance_matrix[candidate_route[j-1]][candidate_route[j]] for j in range(1, len(candidate_route)))\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                if best_pos != 1:\n                    # Perform the best insertion\n                    target_route = np.insert(target_route, best_pos, node)\n                    new_solution[i] = target_route\n                    # Remove the node from the original route\n                    selected_route = np.delete(selected_route, np.where(selected_route == node)[0][0])\n                    new_solution[route_idx] = selected_route\n\n    return new_solution\n\n",
        "score": [
            -0.8711360851955172,
            0.17231228947639465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(new_solution))\n    selected_route = new_solution[route_idx].copy()\n\n    # Segment the route into two parts at a random point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    first_part = selected_route[:split_point + 1]\n    second_part = selected_route[split_point:]\n\n    # Check if the split is feasible (demand constraint)\n    first_demand = sum(demand[node] for node in first_part if node != 0)\n    second_demand = sum(demand[node] for node in second_part if node != 0)\n\n    if first_demand <= capacity and second_demand <= capacity:\n        # Update the solution with the split\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try demand-aware insertion from one route to another\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            target_route = new_solution[i].copy()\n            for node in selected_route[1:-1]:\n                # Try inserting the node into the target route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    # Insert node at position pos\n                    candidate_route = np.insert(target_route, pos, node)\n                    candidate_demand = sum(demand[n] for n in candidate_route if n != 0)\n                    if candidate_demand <= capacity:\n                        # Calculate the cost of the candidate route\n                        cost = sum(distance_matrix[candidate_route[j-1]][candidate_route[j]] for j in range(1, len(candidate_route)))\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                if best_pos != 1:\n                    # Perform the best insertion\n                    target_route = np.insert(target_route, best_pos, node)\n                    new_solution[i] = target_route\n                    # Remove the node from the original route\n                    selected_route = np.delete(selected_route, np.where(selected_route == node)[0][0])\n                    new_solution[route_idx] = selected_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The proposed algorithm intelligently selects a solution from the archive based on a combined metric of normalized objective values, then applies a hybrid local search combining route segmentation, demand-aware node reinsertion, and makespan-balancing perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def get_score(sol_obj):\n        total_dist, makespan = sol_obj\n        # Normalize objectives (assuming archive contains non-dominated solutions)\n        max_dist = max(s[1][0] for s in archive)\n        max_makespan = max(s[1][1] for s in archive)\n        if max_dist == 0 or max_makespan == 0:\n            return 0\n        return (total_dist / max_dist) + (makespan / max_makespan)\n\n    selected = min(archive, key=lambda x: get_score(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: 1. Route segmentation + 2. Demand-aware reinsertion + 3. Makespan balancing\n    for _ in range(3):  # Repeat for better exploration\n        # 1. Route segmentation: Split long routes into segments\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only process routes with enough nodes\n                split_idx = np.random.randint(1, len(route)-2)\n                new_route1 = route[:split_idx+1]\n                new_route2 = route[split_idx:]\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # 2. Demand-aware reinsertion: Move nodes between routes based on demand balance\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only process non-trivial routes\n                # Select a random node to move\n                node_idx = np.random.randint(1, len(route)-1)\n                node = route[node_idx]\n                # Find target routes that can accommodate the node\n                candidates = []\n                for j in range(len(new_solution)):\n                    if i != j and (np.sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity):\n                        candidates.append(j)\n                if candidates:\n                    target_route_idx = np.random.choice(candidates)\n                    # Insert node into target route (random position)\n                    target_route = new_solution[target_route_idx]\n                    insert_pos = np.random.randint(1, len(target_route))\n                    new_solution[target_route_idx] = np.insert(target_route, insert_pos, node)\n                    # Remove from original route\n                    new_solution[i] = np.delete(route, node_idx)\n                    break  # Only move one node per iteration\n\n        # 3. Makespan balancing: Swap nodes between routes to balance makespans\n        if len(new_solution) > 1:\n            # Get route lengths\n            lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_idx = np.argmax(lengths)\n            shortest_idx = np.argmin(lengths)\n            if lengths[longest_idx] > lengths[shortest_idx] * 1.2:  # Significant imbalance\n                longest_route = new_solution[longest_idx]\n                shortest_route = new_solution[shortest_idx]\n                # Try to move a node from longest to shortest\n                for node_pos in range(1, len(longest_route)-1):\n                    node = longest_route[node_pos]\n                    if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                        np.sum(demand[longest_route[1:-1]]) - demand[node] <= capacity):\n                        # Insert into shortest route\n                        insert_pos = np.random.randint(1, len(shortest_route))\n                        new_solution[shortest_idx] = np.insert(shortest_route, insert_pos, node)\n                        # Remove from longest route\n                        new_solution[longest_idx] = np.delete(longest_route, node_pos)\n                        break\n\n    # Ensure all routes are valid (start/end with depot and non-empty)\n    valid_solution = []\n    for route in new_solution:\n        if len(route) > 2 and route[0] == 0 and route[-1] == 0:\n            valid_solution.append(route)\n    # If no valid routes, return original\n    if not valid_solution:\n        return base_solution\n\n    return valid_solution\n\n",
        "score": [
            -0.6669247496878057,
            4.093325704336166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def get_score(sol_obj):\n        total_dist, makespan = sol_obj\n        # Normalize objectives (assuming archive contains non-dominated solutions)\n        max_dist = max(s[1][0] for s in archive)\n        max_makespan = max(s[1][1] for s in archive)\n        if max_dist == 0 or max_makespan == 0:\n            return 0\n        return (total_dist / max_dist) + (makespan / max_makespan)\n\n    selected = min(archive, key=lambda x: get_score(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: 1. Route segmentation + 2. Demand-aware reinsertion + 3. Makespan balancing\n    for _ in range(3):  # Repeat for better exploration\n        # 1. Route segmentation: Split long routes into segments\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only process routes with enough nodes\n                split_idx = np.random.randint(1, len(route)-2)\n                new_route1 = route[:split_idx+1]\n                new_route2 = route[split_idx:]\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # 2. Demand-aware reinsertion: Move nodes between routes based on demand balance\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only process non-trivial routes\n                # Select a random node to move\n                node_idx = np.random.randint(1, len(route)-1)\n                node = route[node_idx]\n                # Find target routes that can accommodate the node\n                candidates = []\n                for j in range(len(new_solution)):\n                    if i != j and (np.sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity):\n                        candidates.append(j)\n                if candidates:\n                    target_route_idx = np.random.choice(candidates)\n                    # Insert node into target route (random position)\n                    target_route = new_solution[target_route_idx]\n                    insert_pos = np.random.randint(1, len(target_route))\n                    new_solution[target_route_idx] = np.insert(target_route, insert_pos, node)\n                    # Remove from original route\n                    new_solution[i] = np.delete(route, node_idx)\n                    break  # Only move one node per iteration\n\n        # 3. Makespan balancing: Swap nodes between routes to balance makespans\n        if len(new_solution) > 1:\n            # Get route lengths\n            lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_idx = np.argmax(lengths)\n            shortest_idx = np.argmin(lengths)\n            if lengths[longest_idx] > lengths[shortest_idx] * 1.2:  # Significant imbalance\n                longest_route = new_solution[longest_idx]\n                shortest_route = new_solution[shortest_idx]\n                # Try to move a node from longest to shortest\n                for node_pos in range(1, len(longest_route)-1):\n                    node = longest_route[node_pos]\n                    if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                        np.sum(demand[longest_route[1:-1]]) - demand[node] <= capacity):\n                        # Insert into shortest route\n                        insert_pos = np.random.randint(1, len(shortest_route))\n                        new_solution[shortest_idx] = np.insert(shortest_route, insert_pos, node)\n                        # Remove from longest route\n                        new_solution[longest_idx] = np.delete(longest_route, node_pos)\n                        break\n\n    # Ensure all routes are valid (start/end with depot and non-empty)\n    valid_solution = []\n    for route in new_solution:\n        if len(route) > 2 and route[0] == 0 and route[-1] == 0:\n            valid_solution.append(route)\n    # If no valid routes, return original\n    if not valid_solution:\n        return base_solution\n\n    return valid_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This function selects a non-dominated solution from the archive, applies a hybrid local search combining route splitting and customer reinsertion with capacity-aware swaps to balance distance and makespan objectives, and returns the improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated.append(archive[i])\n\n    if not non_dominated:\n        selected = archive[0][0].copy()\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n        selected = non_dominated[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: route splitting and customer reinsertion with capacity-aware swaps\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with customers\n            # Split the route into two parts\n            split_point = np.random.randint(1, len(route)-1)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1[1:-1]])\n            demand2 = np.sum(demand[part2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Create new routes\n                new_route1 = part1\n                new_route2 = part2\n\n                # Try to improve by swapping customers between routes\n                improved = False\n                for i in range(1, len(new_route1)-1):\n                    for j in range(1, len(new_route2)-1):\n                        # Calculate new demands\n                        new_demand1 = demand1 - demand[new_route1[i]] + demand[new_route2[j]]\n                        new_demand2 = demand2 - demand[new_route2[j]] + demand[new_route1[i]]\n\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            # Calculate distance change\n                            old_dist = (distance_matrix[new_route1[i-1], new_route1[i]] +\n                                      distance_matrix[new_route1[i], new_route1[i+1]] +\n                                      distance_matrix[new_route2[j-1], new_route2[j]] +\n                                      distance_matrix[new_route2[j], new_route2[j+1]])\n\n                            new_dist = (distance_matrix[new_route1[i-1], new_route2[j]] +\n                                       distance_matrix[new_route2[j], new_route1[i+1]] +\n                                       distance_matrix[new_route2[j-1], new_route1[i]] +\n                                       distance_matrix[new_route1[i], new_route2[j+1]])\n\n                            if new_dist < old_dist:\n                                # Perform swap\n                                new_route1[i], new_route2[j] = new_route2[j], new_route1[i]\n                                improved = True\n                                break\n                    if improved:\n                        break\n\n                # Update the solution\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.6864429765316972,
            4.543266177177429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated.append(archive[i])\n\n    if not non_dominated:\n        selected = archive[0][0].copy()\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n        selected = non_dominated[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: route splitting and customer reinsertion with capacity-aware swaps\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with customers\n            # Split the route into two parts\n            split_point = np.random.randint(1, len(route)-1)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1[1:-1]])\n            demand2 = np.sum(demand[part2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Create new routes\n                new_route1 = part1\n                new_route2 = part2\n\n                # Try to improve by swapping customers between routes\n                improved = False\n                for i in range(1, len(new_route1)-1):\n                    for j in range(1, len(new_route2)-1):\n                        # Calculate new demands\n                        new_demand1 = demand1 - demand[new_route1[i]] + demand[new_route2[j]]\n                        new_demand2 = demand2 - demand[new_route2[j]] + demand[new_route1[i]]\n\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            # Calculate distance change\n                            old_dist = (distance_matrix[new_route1[i-1], new_route1[i]] +\n                                      distance_matrix[new_route1[i], new_route1[i+1]] +\n                                      distance_matrix[new_route2[j-1], new_route2[j]] +\n                                      distance_matrix[new_route2[j], new_route2[j+1]])\n\n                            new_dist = (distance_matrix[new_route1[i-1], new_route2[j]] +\n                                       distance_matrix[new_route2[j], new_route1[i+1]] +\n                                       distance_matrix[new_route2[j-1], new_route1[i]] +\n                                       distance_matrix[new_route1[i], new_route2[j+1]])\n\n                            if new_dist < old_dist:\n                                # Perform swap\n                                new_route1[i], new_route2[j] = new_route2[j], new_route1[i]\n                                improved = True\n                                break\n                    if improved:\n                        break\n\n                # Update the solution\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining route splitting, demand-based relocations, and a novel \"route fusion\" operator to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def selection_score(sol):\n        total_dist, makespan = sol[1]\n        return 0.6 * total_dist + 0.4 * makespan\n\n    selected = min(archive, key=selection_score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # 1. Route splitting: Split long routes into two\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # 2. Demand-based relocation: Move high-demand customers to less loaded routes\n    high_demand_nodes = np.where(demand > capacity * 0.3)[0][1:]  # Exclude depot\n    for node in high_demand_nodes:\n        for route in new_solution:\n            if node in route[1:-1]:\n                # Find the least loaded route that can accommodate this node\n                route_loads = [sum(demand[r[1:-1]]) for r in new_solution]\n                min_load_route = min(zip(route_loads, new_solution), key=lambda x: x[0])[1]\n\n                if min_load_route is not route and (sum(demand[min_load_route[1:-1]]) + demand[node]) <= capacity:\n                    # Remove from current route\n                    route_idx = np.where(route == node)[0][0]\n                    new_route = np.delete(route, route_idx)\n                    # Insert into new route (greedy position)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(min_load_route)):\n                        temp_route = np.insert(min_load_route, pos, node)\n                        if is_feasible(temp_route):\n                            cost = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    new_min_route = np.insert(min_load_route, best_pos, node)\n                    if is_feasible(new_min_route):\n                        # Update routes\n                        new_solution[new_solution.index(route)] = new_route\n                        new_solution[new_solution.index(min_load_route)] = new_min_route\n                    break\n\n    # 3. Route fusion: Combine short routes that can be merged\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) + len(route2) - 3 <= 10:  # Keep routes reasonable length\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                if is_feasible(merged):\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7251869608661222,
            7.808663159608841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def selection_score(sol):\n        total_dist, makespan = sol[1]\n        return 0.6 * total_dist + 0.4 * makespan\n\n    selected = min(archive, key=selection_score)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # 1. Route splitting: Split long routes into two\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # 2. Demand-based relocation: Move high-demand customers to less loaded routes\n    high_demand_nodes = np.where(demand > capacity * 0.3)[0][1:]  # Exclude depot\n    for node in high_demand_nodes:\n        for route in new_solution:\n            if node in route[1:-1]:\n                # Find the least loaded route that can accommodate this node\n                route_loads = [sum(demand[r[1:-1]]) for r in new_solution]\n                min_load_route = min(zip(route_loads, new_solution), key=lambda x: x[0])[1]\n\n                if min_load_route is not route and (sum(demand[min_load_route[1:-1]]) + demand[node]) <= capacity:\n                    # Remove from current route\n                    route_idx = np.where(route == node)[0][0]\n                    new_route = np.delete(route, route_idx)\n                    # Insert into new route (greedy position)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(min_load_route)):\n                        temp_route = np.insert(min_load_route, pos, node)\n                        if is_feasible(temp_route):\n                            cost = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    new_min_route = np.insert(min_load_route, best_pos, node)\n                    if is_feasible(new_min_route):\n                        # Update routes\n                        new_solution[new_solution.index(route)] = new_route\n                        new_solution[new_solution.index(min_load_route)] = new_min_route\n                    break\n\n    # 3. Route fusion: Combine short routes that can be merged\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1, route2 = new_solution[i], new_solution[j]\n            if len(route1) + len(route2) - 3 <= 10:  # Keep routes reasonable length\n                merged = np.concatenate([route1[:-1], route2[1:]])\n                if is_feasible(merged):\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n\n    # Step 1: Route Merging - Combine two routes if merging reduces makespan\n    if len(selected_solution) > 1:\n        route1, route2 = selected_solution[0], selected_solution[1]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if sum(demand[merged_route]) <= capacity:\n            selected_solution[0] = merged_route\n            selected_solution.pop(1)\n\n    # Step 2: Customer Reallocation - Move customers between routes to balance makespan\n    for route in selected_solution:\n        if len(route) > 3:\n            # Extract a customer from the middle and try to place in another route\n            customer = np.random.choice(route[1:-1])\n            for other_route in selected_solution:\n                if other_route is not route and sum(demand[other_route]) + demand[customer] <= capacity:\n                    route = route[route != customer]\n                    other_route = np.insert(other_route, -1, customer)\n                    break\n\n    # Step 3: Hybrid 2-opt - Apply 2-opt within each route, but also consider inter-route swaps\n    for i, route in enumerate(selected_solution):\n        if len(route) > 4:\n            # Standard 2-opt within route\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if sum(demand[new_route]) <= capacity:\n                selected_solution[i] = new_route\n            # Inter-route swap if possible\n            if len(selected_solution) > 1 and i < len(selected_solution)-1:\n                other_route = selected_solution[i+1]\n                if len(other_route) > 3:\n                    swap_cust = np.random.choice(route[1:-1])\n                    swap_pos = np.random.randint(1, len(other_route)-1)\n                    if sum(demand[other_route]) - demand[other_route[swap_pos]] + demand[swap_cust] <= capacity:\n                        route[route == swap_cust] = other_route[swap_pos]\n                        other_route[swap_pos] = swap_cust\n\n    return selected_solution\n\n",
        "score": [
            -0.7882466206969959,
            5.205377131700516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0].copy()\n\n    # Step 1: Route Merging - Combine two routes if merging reduces makespan\n    if len(selected_solution) > 1:\n        route1, route2 = selected_solution[0], selected_solution[1]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if sum(demand[merged_route]) <= capacity:\n            selected_solution[0] = merged_route\n            selected_solution.pop(1)\n\n    # Step 2: Customer Reallocation - Move customers between routes to balance makespan\n    for route in selected_solution:\n        if len(route) > 3:\n            # Extract a customer from the middle and try to place in another route\n            customer = np.random.choice(route[1:-1])\n            for other_route in selected_solution:\n                if other_route is not route and sum(demand[other_route]) + demand[customer] <= capacity:\n                    route = route[route != customer]\n                    other_route = np.insert(other_route, -1, customer)\n                    break\n\n    # Step 3: Hybrid 2-opt - Apply 2-opt within each route, but also consider inter-route swaps\n    for i, route in enumerate(selected_solution):\n        if len(route) > 4:\n            # Standard 2-opt within route\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if sum(demand[new_route]) <= capacity:\n                selected_solution[i] = new_route\n            # Inter-route swap if possible\n            if len(selected_solution) > 1 and i < len(selected_solution)-1:\n                other_route = selected_solution[i+1]\n                if len(other_route) > 3:\n                    swap_cust = np.random.choice(route[1:-1])\n                    swap_pos = np.random.randint(1, len(other_route)-1)\n                    if sum(demand[other_route]) - demand[other_route[swap_pos]] + demand[swap_cust] <= capacity:\n                        route[route == swap_cust] = other_route[swap_pos]\n                        other_route[swap_pos] = swap_cust\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: apply route-splitting and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Cross-route insertion: move a random customer from one route to another\n    if len(new_solution) > 1:\n        route1_idx = np.random.randint(0, len(new_solution))\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:\n            # Select a random customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_idx]\n\n            # Try to insert into another route\n            for i in range(len(new_solution)):\n                if i == route1_idx:\n                    continue\n                route2 = new_solution[i]\n                # Find insertion position with minimal increase in distance\n                min_increase = float('inf')\n                best_pos = -1\n                for j in range(1, len(route2)):\n                    # Calculate increase in distance\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Check capacity constraint\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Insert and remove from original route\n                    new_route2 = np.insert(route2, best_pos, customer)\n                    new_solution[i] = new_route2\n                    new_solution[route1_idx] = np.delete(route1, customer_idx)\n                    break\n\n    # Intra-route 2-opt for each route\n    optimized_solution = []\n    for route in new_solution:\n        if len(route) <= 3:\n            optimized_solution.append(route)\n            continue\n\n        # Perform 2-opt on the route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    if new_dist < current_dist:\n                        # Reverse the segment between i and j\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        optimized_solution.append(route)\n\n    return optimized_solution\n\n",
        "score": [
            -0.7862141456473708,
            2.861744910478592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: apply route-splitting and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route)-1)\n        part1 = route[:split_idx+1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Cross-route insertion: move a random customer from one route to another\n    if len(new_solution) > 1:\n        route1_idx = np.random.randint(0, len(new_solution))\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:\n            # Select a random customer from route1 (not depot)\n            customer_idx = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_idx]\n\n            # Try to insert into another route\n            for i in range(len(new_solution)):\n                if i == route1_idx:\n                    continue\n                route2 = new_solution[i]\n                # Find insertion position with minimal increase in distance\n                min_increase = float('inf')\n                best_pos = -1\n                for j in range(1, len(route2)):\n                    # Calculate increase in distance\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Check capacity constraint\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Insert and remove from original route\n                    new_route2 = np.insert(route2, best_pos, customer)\n                    new_solution[i] = new_route2\n                    new_solution[route1_idx] = np.delete(route1, customer_idx)\n                    break\n\n    # Intra-route 2-opt for each route\n    optimized_solution = []\n    for route in new_solution:\n        if len(route) <= 3:\n            optimized_solution.append(route)\n            continue\n\n        # Perform 2-opt on the route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    if new_dist < current_dist:\n                        # Reverse the segment between i and j\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        optimized_solution.append(route)\n\n    return optimized_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A hybrid local search operator that combines route splitting, customer reassignment, and intra-route 2-opt with demand-aware swaps to balance distance and makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][1] for s in archive])  # Select solution with highest makespan\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting, customer reassignment, and demand-aware 2-opt\n    if len(new_solution) > 1 and random.random() < 0.3:  # 30% chance to split a route\n        # Split a long route into two\n        route_idx = np.argmax([len(route) for route in new_solution])\n        route = new_solution[route_idx]\n        split_pos = len(route) // 2\n        new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    elif random.random() < 0.5:  # 50% chance to perform demand-aware customer reassignment\n        # Select two routes and attempt to move a customer from one to the other\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # Ensure route has customers to move\n                # Select a random customer from route1 (excluding depot)\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if adding this customer to route2 violates capacity\n                current_demand_route2 = np.sum(demand[route2[1:-1]])\n                if current_demand_route2 + demand[customer] <= capacity:\n                    # Find best insertion position in route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(route2)):\n                        # Calculate insertion cost (distance increase)\n                        prev_node = route2[i-1]\n                        next_node = route2[i]\n                        cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                    # Insert customer into route2\n                    new_route2 = np.concatenate((route2[:best_pos], [customer], route2[best_pos:]))\n                    new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    else:  # Perform demand-aware 2-opt\n        # Select a random route and apply 2-opt with demand checks\n        if len(new_solution) >= 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Need at least 4 nodes for 2-opt\n                # Select two edges to swap\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n\n                # Check demand feasibility of the new segments\n                segment1 = route[i:j+1]\n                segment2 = route[j:i-1:-1]  # Reverse segment\n\n                # Check if the new segments can be inserted back\n                # This is a simplified check; full feasibility requires more complex validation\n                # For simplicity, we'll assume the swap is feasible if demand constraints are met\n                demand_segment1 = np.sum(demand[segment1[1:-1]])\n                demand_segment2 = np.sum(demand[segment2[1:-1]])\n\n                if demand_segment1 <= capacity and demand_segment2 <= capacity:\n                    # Perform the swap\n                    new_route = np.concatenate((route[:i], segment2, route[j+1:]))\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.4160014773867511,
            0.5893195569515228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([s[1][1] for s in archive])  # Select solution with highest makespan\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting, customer reassignment, and demand-aware 2-opt\n    if len(new_solution) > 1 and random.random() < 0.3:  # 30% chance to split a route\n        # Split a long route into two\n        route_idx = np.argmax([len(route) for route in new_solution])\n        route = new_solution[route_idx]\n        split_pos = len(route) // 2\n        new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    elif random.random() < 0.5:  # 50% chance to perform demand-aware customer reassignment\n        # Select two routes and attempt to move a customer from one to the other\n        if len(new_solution) >= 2:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # Ensure route has customers to move\n                # Select a random customer from route1 (excluding depot)\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if adding this customer to route2 violates capacity\n                current_demand_route2 = np.sum(demand[route2[1:-1]])\n                if current_demand_route2 + demand[customer] <= capacity:\n                    # Find best insertion position in route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(route2)):\n                        # Calculate insertion cost (distance increase)\n                        prev_node = route2[i-1]\n                        next_node = route2[i]\n                        cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                    # Insert customer into route2\n                    new_route2 = np.concatenate((route2[:best_pos], [customer], route2[best_pos:]))\n                    new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    else:  # Perform demand-aware 2-opt\n        # Select a random route and apply 2-opt with demand checks\n        if len(new_solution) >= 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Need at least 4 nodes for 2-opt\n                # Select two edges to swap\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n\n                # Check demand feasibility of the new segments\n                segment1 = route[i:j+1]\n                segment2 = route[j:i-1:-1]  # Reverse segment\n\n                # Check if the new segments can be inserted back\n                # This is a simplified check; full feasibility requires more complex validation\n                # For simplicity, we'll assume the swap is feasible if demand constraints are met\n                demand_segment1 = np.sum(demand[segment1[1:-1]])\n                demand_segment2 = np.sum(demand[segment2[1:-1]])\n\n                if demand_segment1 <= capacity and demand_segment2 <= capacity:\n                    # Perform the swap\n                    new_route = np.concatenate((route[:i], segment2, route[j+1:]))\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{A novel route-splitting and merging strategy that intelligently selects a solution with high makespan variance, then applies a capacity-aware route transformation by splitting long routes and merging short routes to balance the makespan while reducing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find routes with high and low makespan\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n    max_route_idx = np.argmax(route_lengths)\n    min_route_idx = np.argmin(route_lengths)\n\n    # Split the longest route into two parts\n    longest_route = selected_solution[max_route_idx]\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for the split\n    demand_part1 = sum(demand[node] for node in part1 if node != 0)\n    demand_part2 = sum(demand[node] for node in part2 if node != 0)\n\n    if demand_part1 <= capacity and demand_part2 <= capacity:\n        # Replace the longest route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != max_route_idx]\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If split is invalid, try to merge with the shortest route\n        shortest_route = selected_solution[min_route_idx]\n        combined_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n\n        # Check capacity constraint for the merged route\n        demand_combined = sum(demand[node] for node in combined_route if node != 0)\n        if demand_combined <= capacity:\n            # Replace both routes with the merged route\n            new_solution = [route for i, route in enumerate(selected_solution) if i != max_route_idx and i != min_route_idx]\n            new_solution.append(combined_route)\n        else:\n            # If merge is invalid, return the original solution\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8002839655235616,
            0.6456459164619446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Find routes with high and low makespan\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n    max_route_idx = np.argmax(route_lengths)\n    min_route_idx = np.argmin(route_lengths)\n\n    # Split the longest route into two parts\n    longest_route = selected_solution[max_route_idx]\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for the split\n    demand_part1 = sum(demand[node] for node in part1 if node != 0)\n    demand_part2 = sum(demand[node] for node in part2 if node != 0)\n\n    if demand_part1 <= capacity and demand_part2 <= capacity:\n        # Replace the longest route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != max_route_idx]\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If split is invalid, try to merge with the shortest route\n        shortest_route = selected_solution[min_route_idx]\n        combined_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n\n        # Check capacity constraint for the merged route\n        demand_combined = sum(demand[node] for node in combined_route if node != 0)\n        if demand_combined <= capacity:\n            # Replace both routes with the merged route\n            new_solution = [route for i, route in enumerate(selected_solution) if i != max_route_idx and i != min_route_idx]\n            new_solution.append(combined_route)\n        else:\n            # If merge is invalid, return the original solution\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-based customer reinsertion, and adaptive route merging to balance distance and makespan objectives while ensuring feasible solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-based reinsertion + adaptive merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Split route at a random point\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check capacity feasibility for both new routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Demand-based reinsertion: move high-demand customers to shorter routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Find high-demand customers\n            customers = route[1:-1]\n            high_demand_customers = [c for c in customers if demand[c] > capacity * 0.3]\n\n            if high_demand_customers:\n                # Find the shortest route that can accommodate the customer\n                shortest_route_idx = -1\n                min_length = float('inf')\n\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = new_solution[j].tolist()\n                        temp_route.insert(-1, high_demand_customers[0])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            route_length = np.sum([distance_matrix[temp_route[k]][temp_route[k+1]]\n                                                  for k in range(len(temp_route)-1)])\n                            if route_length < min_length:\n                                min_length = route_length\n                                shortest_route_idx = j\n\n                if shortest_route_idx != -1:\n                    # Move the customer\n                    customer_to_move = high_demand_customers[0]\n                    new_solution[i] = np.array([c for c in route if c != customer_to_move])\n                    new_solution[shortest_route_idx] = np.insert(new_solution[shortest_route_idx], -1, customer_to_move)\n                    break\n\n    # Adaptive route merging: combine routes if they can be merged without exceeding capacity\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Calculate potential improvement\n                original_distance = (np.sum([distance_matrix[route1[k]][route1[k+1]]\n                                          for k in range(len(route1)-1)]) +\n                                   np.sum([distance_matrix[route2[k]][route2[k+1]]\n                                          for k in range(len(route2)-1)]))\n                merged_distance = np.sum([distance_matrix[merged_route[k]][merged_route[k+1]]\n                                       for k in range(len(merged_route)-1)])\n\n                if merged_distance < original_distance * 1.1:  # Only merge if significant improvement\n                    new_solution[i] = np.array(merged_route)\n                    del new_solution[j]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7559816541194416,
            3.3800649642944336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-based reinsertion + adaptive merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Split route at a random point\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = [0] + route[split_pos + 1:]\n\n            # Check capacity feasibility for both new routes\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Demand-based reinsertion: move high-demand customers to shorter routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Find high-demand customers\n            customers = route[1:-1]\n            high_demand_customers = [c for c in customers if demand[c] > capacity * 0.3]\n\n            if high_demand_customers:\n                # Find the shortest route that can accommodate the customer\n                shortest_route_idx = -1\n                min_length = float('inf')\n\n                for j in range(len(new_solution)):\n                    if j != i:\n                        temp_route = new_solution[j].tolist()\n                        temp_route.insert(-1, high_demand_customers[0])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            route_length = np.sum([distance_matrix[temp_route[k]][temp_route[k+1]]\n                                                  for k in range(len(temp_route)-1)])\n                            if route_length < min_length:\n                                min_length = route_length\n                                shortest_route_idx = j\n\n                if shortest_route_idx != -1:\n                    # Move the customer\n                    customer_to_move = high_demand_customers[0]\n                    new_solution[i] = np.array([c for c in route if c != customer_to_move])\n                    new_solution[shortest_route_idx] = np.insert(new_solution[shortest_route_idx], -1, customer_to_move)\n                    break\n\n    # Adaptive route merging: combine routes if they can be merged without exceeding capacity\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            merged_route = route1[:-1].tolist() + route2[1:].tolist()\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Calculate potential improvement\n                original_distance = (np.sum([distance_matrix[route1[k]][route1[k+1]]\n                                          for k in range(len(route1)-1)]) +\n                                   np.sum([distance_matrix[route2[k]][route2[k+1]]\n                                          for k in range(len(route2)-1)]))\n                merged_distance = np.sum([distance_matrix[merged_route[k]][merged_route[k+1]]\n                                       for k in range(len(merged_route)-1)])\n\n                if merged_distance < original_distance * 1.1:  # Only merge if significant improvement\n                    new_solution[i] = np.array(merged_route)\n                    del new_solution[j]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting with customer insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try to insert a random customer from part2 into part1 if feasible\n        if len(part2) > 2:\n            customer = np.random.choice(part2[1:-1])\n            if sum(demand[part1]) + demand[customer] <= capacity:\n                part1 = np.insert(part1, -1, customer)\n                part2 = part2[part2 != customer]\n\n        # Update the routes\n        new_solution[i] = part1\n        if len(part2) > 2:\n            new_solution.append(part2)\n\n    # Ensure all customers are served (in case of failed insertions)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Insert missing customers into the route with the least increase in distance\n    for customer in missing_customers:\n        best_route_idx = -1\n        best_pos = -1\n        best_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if sum(demand[route]) + demand[customer] > capacity:\n                continue\n\n            for j in range(len(route) - 1):\n                pos_increase = distance_matrix[route[j], customer] + distance_matrix[customer, route[j+1]] - distance_matrix[route[j], route[j+1]]\n                if pos_increase < best_increase:\n                    best_increase = pos_increase\n                    best_route_idx = i\n                    best_pos = j + 1\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n        else:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6934489938866699,
            10.18869462609291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting with customer insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try to insert a random customer from part2 into part1 if feasible\n        if len(part2) > 2:\n            customer = np.random.choice(part2[1:-1])\n            if sum(demand[part1]) + demand[customer] <= capacity:\n                part1 = np.insert(part1, -1, customer)\n                part2 = part2[part2 != customer]\n\n        # Update the routes\n        new_solution[i] = part1\n        if len(part2) > 2:\n            new_solution.append(part2)\n\n    # Ensure all customers are served (in case of failed insertions)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Insert missing customers into the route with the least increase in distance\n    for customer in missing_customers:\n        best_route_idx = -1\n        best_pos = -1\n        best_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if sum(demand[route]) + demand[customer] > capacity:\n                continue\n\n            for j in range(len(route) - 1):\n                pos_increase = distance_matrix[route[j], customer] + distance_matrix[customer, route[j+1]] - distance_matrix[route[j], route[j+1]]\n                if pos_increase < best_increase:\n                    best_increase = pos_increase\n                    best_route_idx = i\n                    best_pos = j + 1\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n        else:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If the route has more than 3 nodes (depot + at least one customer + depot), attempt a swap or insertion\n    if len(route) > 3:\n        # Randomly select two non-depot nodes to swap\n        i, j = np.random.choice(range(1, len(route)-1), size=2, replace=False)\n        # Perform the swap\n        route[i], route[j] = route[j], route[i]\n\n        # Check capacity constraint\n        if sum(demand[route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = route\n            return selected_solution\n\n        # If swap violates capacity, try reversing a segment\n        i, j = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = new_route\n            return selected_solution\n\n    # If no improvement, try moving a customer to another route\n    if len(selected_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        # Select a random customer from the current route (excluding depots)\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Insert the customer into the other route at a random position\n        insert_pos = np.random.randint(1, len(other_route))\n        new_other_route = np.insert(other_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        # Check capacity constraints\n        if (sum(demand[new_route[1:-1]]) <= capacity and\n            sum(demand[new_other_route[1:-1]]) <= capacity):\n            selected_solution[route_idx] = new_route\n            selected_solution[other_route_idx] = new_other_route\n            return selected_solution\n\n    # If no valid move found, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.770461385965935,
            0.7460062205791473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If the route has more than 3 nodes (depot + at least one customer + depot), attempt a swap or insertion\n    if len(route) > 3:\n        # Randomly select two non-depot nodes to swap\n        i, j = np.random.choice(range(1, len(route)-1), size=2, replace=False)\n        # Perform the swap\n        route[i], route[j] = route[j], route[i]\n\n        # Check capacity constraint\n        if sum(demand[route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = route\n            return selected_solution\n\n        # If swap violates capacity, try reversing a segment\n        i, j = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            selected_solution[route_idx] = new_route\n            return selected_solution\n\n    # If no improvement, try moving a customer to another route\n    if len(selected_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        # Select a random customer from the current route (excluding depots)\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Insert the customer into the other route at a random position\n        insert_pos = np.random.randint(1, len(other_route))\n        new_other_route = np.insert(other_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        # Check capacity constraints\n        if (sum(demand[new_route[1:-1]]) <= capacity and\n            sum(demand[new_other_route[1:-1]]) <= capacity):\n            selected_solution[route_idx] = new_route\n            selected_solution[other_route_idx] = new_other_route\n            return selected_solution\n\n    # If no valid move found, return the original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search that combines route truncation and inter-route insertion with capacity-aware swaps to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Route truncation and inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to move\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx]\n\n        # Remove the segment from the current route\n        new_route = np.concatenate([route[:start_idx], route[end_idx:]])\n\n        # Try to insert the segment into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            target_route = new_solution[j]\n            # Check if the target route can accommodate the segment\n            segment_demand = np.sum(demand[segment])\n            current_capacity = np.sum(demand[target_route[1:-1]])  # Exclude depot\n\n            if current_capacity + segment_demand <= capacity:\n                # Find the best insertion point in the target route\n                best_insertion = -1\n                min_increase = float('inf')\n\n                for k in range(1, len(target_route)):\n                    # Insert segment between k and k+1\n                    new_target = np.concatenate([target_route[:k], segment, target_route[k:]])\n                    new_distance = (distance_matrix[target_route[k-1], segment[0]] +\n                                   np.sum(distance_matrix[segment[:-1], segment[1:]]) +\n                                   distance_matrix[segment[-1], target_route[k]] -\n                                   distance_matrix[target_route[k-1], target_route[k]])\n\n                    if new_distance < min_increase:\n                        min_increase = new_distance\n                        best_insertion = k\n\n                if best_insertion != -1:\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[j] = new_target_route\n                    new_solution[i] = new_route\n                    break\n\n    # Step 2: Capacity-aware swaps between routes\n    for _ in range(3):  # Limit the number of swaps\n        # Select two distinct routes\n        routes_indices = list(range(len(new_solution)))\n        random.shuffle(routes_indices)\n        route1_idx, route2_idx = routes_indices[:2]\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from each route\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check capacity constraints\n        demand1 = demand[cust1]\n        demand2 = demand[cust2]\n\n        current_capacity1 = np.sum(demand[route1[1:-1]])\n        current_capacity2 = np.sum(demand[route2[1:-1]])\n\n        if (current_capacity1 - demand1 + demand2 <= capacity and\n            current_capacity2 - demand2 + demand1 <= capacity):\n\n            # Perform the swap\n            new_route1 = route1.copy()\n            new_route1[cust1_idx] = cust2\n\n            new_route2 = route2.copy()\n            new_route2[cust2_idx] = cust1\n\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6435645592806729,
            5.656690329313278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Route truncation and inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to move\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx]\n\n        # Remove the segment from the current route\n        new_route = np.concatenate([route[:start_idx], route[end_idx:]])\n\n        # Try to insert the segment into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            target_route = new_solution[j]\n            # Check if the target route can accommodate the segment\n            segment_demand = np.sum(demand[segment])\n            current_capacity = np.sum(demand[target_route[1:-1]])  # Exclude depot\n\n            if current_capacity + segment_demand <= capacity:\n                # Find the best insertion point in the target route\n                best_insertion = -1\n                min_increase = float('inf')\n\n                for k in range(1, len(target_route)):\n                    # Insert segment between k and k+1\n                    new_target = np.concatenate([target_route[:k], segment, target_route[k:]])\n                    new_distance = (distance_matrix[target_route[k-1], segment[0]] +\n                                   np.sum(distance_matrix[segment[:-1], segment[1:]]) +\n                                   distance_matrix[segment[-1], target_route[k]] -\n                                   distance_matrix[target_route[k-1], target_route[k]])\n\n                    if new_distance < min_increase:\n                        min_increase = new_distance\n                        best_insertion = k\n\n                if best_insertion != -1:\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[j] = new_target_route\n                    new_solution[i] = new_route\n                    break\n\n    # Step 2: Capacity-aware swaps between routes\n    for _ in range(3):  # Limit the number of swaps\n        # Select two distinct routes\n        routes_indices = list(range(len(new_solution)))\n        random.shuffle(routes_indices)\n        route1_idx, route2_idx = routes_indices[:2]\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from each route\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check capacity constraints\n        demand1 = demand[cust1]\n        demand2 = demand[cust2]\n\n        current_capacity1 = np.sum(demand[route1[1:-1]])\n        current_capacity2 = np.sum(demand[route2[1:-1]])\n\n        if (current_capacity1 - demand1 + demand2 <= capacity and\n            current_capacity2 - demand2 + demand1 <= capacity):\n\n            # Perform the swap\n            new_route1 = route1.copy()\n            new_route1[cust1_idx] = cust2\n\n            new_route2 = route2.copy()\n            new_route2[cust2_idx] = cust1\n\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and structural diversity, then applies a hybrid local search combining route merging, intra-route relocations with capacity checks, and inter-route swaps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with good balance between objectives and high diversity\n        selected_idx = random.choices(\n            range(len(archive)),\n            weights=[1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive],\n            k=1\n        )[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine multiple operations\n    if len(new_solution) > 1:\n        # 1. Try merging two compatible routes\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                if (sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity and\n                    distance_matrix[new_solution[i][-2]][new_solution[j][1]] + distance_matrix[new_solution[j][-2]][0] <=\n                    distance_matrix[new_solution[i][-2]][0] + distance_matrix[new_solution[j][1]][0]):\n                    merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    # 2. Perform intra-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Find a random customer to relocate\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Find best insertion position in the same route\n        best_pos = -1\n        best_cost = float('inf')\n        for pos in range(1, len(route)):\n            if pos == customer_pos or pos == customer_pos + 1:\n                continue\n\n            # Calculate new cost if inserted at pos\n            prev_node = route[pos - 1]\n            next_node = route[pos] if pos < len(route) - 1 else 0\n            new_cost = (distance_matrix[prev_node][customer] +\n                        distance_matrix[customer][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n            if new_cost < best_cost:\n                best_pos = pos\n                best_cost = new_cost\n\n        if best_pos != -1 and best_pos != customer_pos and best_pos != customer_pos + 1:\n            # Perform relocation\n            new_route = route.copy()\n            new_route = np.concatenate([new_route[:customer_pos], new_route[customer_pos+1:]])\n            new_route = np.insert(new_route, best_pos, customer)\n            new_solution[route_idx] = new_route\n\n    # 3. Try inter-route swaps if possible\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route1[cust1_pos] = cust2\n                new_route2 = route2.copy()\n                new_route2[cust2_pos] = cust1\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Convert back to list of numpy arrays\n    return [np.array(route) for route in new_solution]\n\n",
        "score": [
            -0.36161536399092126,
            2.7987568974494934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with good balance between objectives and high diversity\n        selected_idx = random.choices(\n            range(len(archive)),\n            weights=[1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive],\n            k=1\n        )[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine multiple operations\n    if len(new_solution) > 1:\n        # 1. Try merging two compatible routes\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                if (sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity and\n                    distance_matrix[new_solution[i][-2]][new_solution[j][1]] + distance_matrix[new_solution[j][-2]][0] <=\n                    distance_matrix[new_solution[i][-2]][0] + distance_matrix[new_solution[j][1]][0]):\n                    merged = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    # 2. Perform intra-route relocation with capacity checks\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Find a random customer to relocate\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Find best insertion position in the same route\n        best_pos = -1\n        best_cost = float('inf')\n        for pos in range(1, len(route)):\n            if pos == customer_pos or pos == customer_pos + 1:\n                continue\n\n            # Calculate new cost if inserted at pos\n            prev_node = route[pos - 1]\n            next_node = route[pos] if pos < len(route) - 1 else 0\n            new_cost = (distance_matrix[prev_node][customer] +\n                        distance_matrix[customer][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n            if new_cost < best_cost:\n                best_pos = pos\n                best_cost = new_cost\n\n        if best_pos != -1 and best_pos != customer_pos and best_pos != customer_pos + 1:\n            # Perform relocation\n            new_route = route.copy()\n            new_route = np.concatenate([new_route[:customer_pos], new_route[customer_pos+1:]])\n            new_route = np.insert(new_route, best_pos, customer)\n            new_solution[route_idx] = new_route\n\n    # 3. Try inter-route swaps if possible\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1] <= capacity):\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route1[cust1_pos] = cust2\n                new_route2 = route2.copy()\n                new_route2[cust2_pos] = cust1\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Convert back to list of numpy arrays\n    return [np.array(route) for route in new_solution]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Identify segments where demand is below capacity (potential insertion points)\n    route_demand = np.cumsum([demand[node] for node in route[1:-1]])\n    feasible_segments = [i for i in range(len(route_demand)) if route_demand[i] <= capacity]\n\n    if not feasible_segments:\n        return selected_solution  # No feasible segments to modify\n\n    # Select a random feasible segment to split and reinsert\n    split_pos = np.random.choice(feasible_segments)\n    split_node = route[split_pos + 1]  # +1 because route starts with 0\n\n    # Remove the split node from the route\n    new_route = np.delete(route, split_pos + 1)\n\n    # Find the best insertion point for the split node in another route or as a new route\n    best_insertion = None\n    min_increase = float('inf')\n\n    for i in range(len(selected_solution)):\n        if i == route_idx:\n            continue  # Skip the same route\n        candidate_route = selected_solution[i].copy()\n        candidate_demand = sum(demand[node] for node in candidate_route[1:-1])\n\n        if candidate_demand + demand[split_node] > capacity:\n            continue  # Skip if adding the node exceeds capacity\n\n        # Evaluate all possible insertion positions in the candidate route\n        for pos in range(1, len(candidate_route)):\n            # Insert the node and check feasibility\n            new_candidate = np.insert(candidate_route, pos, split_node)\n            new_demand = sum(demand[node] for node in new_candidate[1:-1])\n            if new_demand > capacity:\n                continue\n\n            # Calculate the increase in total distance\n            prev_node = candidate_route[pos - 1]\n            next_node = candidate_route[pos]\n            old_dist = distance_matrix[prev_node, next_node]\n            new_dist = distance_matrix[prev_node, split_node] + distance_matrix[split_node, next_node]\n\n            if new_dist - old_dist < min_increase:\n                min_increase = new_dist - old_dist\n                best_insertion = (i, pos, split_node)\n\n    if best_insertion is not None:\n        # Apply the best insertion\n        route_idx_to_insert, pos_to_insert, node_to_insert = best_insertion\n        selected_solution[route_idx_to_insert] = np.insert(selected_solution[route_idx_to_insert], pos_to_insert, node_to_insert)\n        # Remove the node from the original route\n        original_pos = np.where(selected_solution[route_idx] == node_to_insert)[0][0]\n        selected_solution[route_idx] = np.delete(selected_solution[route_idx], original_pos)\n\n    return selected_solution\n\n",
        "score": [
            -0.7364679981610449,
            3.5200158953666687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Identify segments where demand is below capacity (potential insertion points)\n    route_demand = np.cumsum([demand[node] for node in route[1:-1]])\n    feasible_segments = [i for i in range(len(route_demand)) if route_demand[i] <= capacity]\n\n    if not feasible_segments:\n        return selected_solution  # No feasible segments to modify\n\n    # Select a random feasible segment to split and reinsert\n    split_pos = np.random.choice(feasible_segments)\n    split_node = route[split_pos + 1]  # +1 because route starts with 0\n\n    # Remove the split node from the route\n    new_route = np.delete(route, split_pos + 1)\n\n    # Find the best insertion point for the split node in another route or as a new route\n    best_insertion = None\n    min_increase = float('inf')\n\n    for i in range(len(selected_solution)):\n        if i == route_idx:\n            continue  # Skip the same route\n        candidate_route = selected_solution[i].copy()\n        candidate_demand = sum(demand[node] for node in candidate_route[1:-1])\n\n        if candidate_demand + demand[split_node] > capacity:\n            continue  # Skip if adding the node exceeds capacity\n\n        # Evaluate all possible insertion positions in the candidate route\n        for pos in range(1, len(candidate_route)):\n            # Insert the node and check feasibility\n            new_candidate = np.insert(candidate_route, pos, split_node)\n            new_demand = sum(demand[node] for node in new_candidate[1:-1])\n            if new_demand > capacity:\n                continue\n\n            # Calculate the increase in total distance\n            prev_node = candidate_route[pos - 1]\n            next_node = candidate_route[pos]\n            old_dist = distance_matrix[prev_node, next_node]\n            new_dist = distance_matrix[prev_node, split_node] + distance_matrix[split_node, next_node]\n\n            if new_dist - old_dist < min_increase:\n                min_increase = new_dist - old_dist\n                best_insertion = (i, pos, split_node)\n\n    if best_insertion is not None:\n        # Apply the best insertion\n        route_idx_to_insert, pos_to_insert, node_to_insert = best_insertion\n        selected_solution[route_idx_to_insert] = np.insert(selected_solution[route_idx_to_insert], pos_to_insert, node_to_insert)\n        # Remove the node from the original route\n        original_pos = np.where(selected_solution[route_idx] == node_to_insert)[0][0]\n        selected_solution[route_idx] = np.delete(selected_solution[route_idx], original_pos)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The algorithm selects a solution with high potential for improvement by prioritizing those with high makespan values, then applies a hybrid local search combining route fragmentation and cross-route insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Fragmentation + Cross-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Split the route at a random point (excluding depot)\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n\n            # Attempt cross-route insertion for the second part\n            for i in range(len(new_solution)):\n                if i != route_idx and i != route_idx + 1:\n                    target_route = new_solution[i].copy()\n                    for j in range(1, len(part2) - 1):\n                        # Try inserting each customer from part2 into target_route\n                        candidate = np.insert(target_route, -1, part2[j])\n                        candidate_demand = np.sum(demand[candidate[1:-1]])\n                        if candidate_demand <= capacity:\n                            # Calculate the change in distance\n                            old_dist = distance_matrix[target_route[-2], target_route[-1]]\n                            new_dist = distance_matrix[target_route[-2], part2[j]] + distance_matrix[part2[j], target_route[-1]]\n                            if new_dist <= old_dist:\n                                new_solution[i] = candidate\n                                part2 = np.delete(part2, j)\n                                break\n\n            # Update the fragmented part if any insertions were made\n            if len(part2) > 2:\n                new_solution[route_idx + 1] = part2\n\n    return new_solution\n\n",
        "score": [
            -0.6924458191802958,
            2.8691388368606567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Fragmentation + Cross-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Split the route at a random point (excluding depot)\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = part1\n            new_solution.insert(route_idx + 1, part2)\n\n            # Attempt cross-route insertion for the second part\n            for i in range(len(new_solution)):\n                if i != route_idx and i != route_idx + 1:\n                    target_route = new_solution[i].copy()\n                    for j in range(1, len(part2) - 1):\n                        # Try inserting each customer from part2 into target_route\n                        candidate = np.insert(target_route, -1, part2[j])\n                        candidate_demand = np.sum(demand[candidate[1:-1]])\n                        if candidate_demand <= capacity:\n                            # Calculate the change in distance\n                            old_dist = distance_matrix[target_route[-2], target_route[-1]]\n                            new_dist = distance_matrix[target_route[-2], part2[j]] + distance_matrix[part2[j], target_route[-1]]\n                            if new_dist <= old_dist:\n                                new_solution[i] = candidate\n                                part2 = np.delete(part2, j)\n                                break\n\n            # Update the fragmented part if any insertions were made\n            if len(part2) > 2:\n                new_solution[route_idx + 1] = part2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a hybrid local search that combines 2-opt with route merging and splitting to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with route merging/splitting\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try merging routes if feasible\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Check if merging improves makespan or distance\n            old_makespan = max(np.sum(distance_matrix[route_i[:-1], route_i[1:]]),\n                              np.sum(distance_matrix[route_j[:-1], route_j[1:]]))\n            new_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n            if new_makespan <= old_makespan:\n                new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n                new_solution.append(merged_route)\n                continue\n\n        # Try 2-opt within a route\n        for route_idx in [i, j]:\n            route = new_solution[route_idx]\n            if len(route) <= 4:  # Skip if route is too short\n                continue\n            # Select two non-depot nodes\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a], route[a:b+1][::-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6948397378134259,
            1.237286537885666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with route merging/splitting\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try merging routes if feasible\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Check if merging improves makespan or distance\n            old_makespan = max(np.sum(distance_matrix[route_i[:-1], route_i[1:]]),\n                              np.sum(distance_matrix[route_j[:-1], route_j[1:]]))\n            new_makespan = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n            if new_makespan <= old_makespan:\n                new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n                new_solution.append(merged_route)\n                continue\n\n        # Try 2-opt within a route\n        for route_idx in [i, j]:\n            route = new_solution[route_idx]\n            if len(route) <= 4:  # Skip if route is too short\n                continue\n            # Select two non-depot nodes\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a], route[a:b+1][::-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The new algorithm combines a route-splitting heuristic with a demand-aware relocation operator to generate high-quality neighbors by intelligently splitting long routes and relocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting Heuristic\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find the most distant customer from the depot in this route\n        max_dist = -1\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[0][route[j]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        if split_pos == -1:\n            continue\n\n        # Split the route at split_pos\n        new_route1 = route[:split_pos+1]\n        new_route2 = [0] + route[split_pos+1:]\n\n        # Validate capacity constraints\n        if np.sum(demand[new_route1[1:-1]]) > capacity or np.sum(demand[new_route2[1:-1]]) > capacity:\n            continue\n\n        # Update the solution\n        new_solution[i] = new_route1\n        new_solution.append(new_route2)\n\n    # Step 2: Demand-Aware Relocation Operator\n    for _ in range(2):  # Perform 2 random relocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:  # Skip empty routes\n            continue\n\n        # Select a random customer from route1 and route2\n        cust1 = random.choice(route1[1:-1])\n        cust2 = random.choice(route2[1:-1])\n\n        # Try to swap the customers\n        new_route1 = route1.copy()\n        new_route1[new_route1 == cust1] = cust2\n\n        new_route2 = route2.copy()\n        new_route2[new_route2 == cust2] = cust1\n\n        # Validate capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) > capacity or\n            np.sum(demand[new_route2[1:-1]]) > capacity):\n            continue\n\n        # Update the solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7228344824733066,
            0.5967048108577728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting Heuristic\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find the most distant customer from the depot in this route\n        max_dist = -1\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[0][route[j]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        if split_pos == -1:\n            continue\n\n        # Split the route at split_pos\n        new_route1 = route[:split_pos+1]\n        new_route2 = [0] + route[split_pos+1:]\n\n        # Validate capacity constraints\n        if np.sum(demand[new_route1[1:-1]]) > capacity or np.sum(demand[new_route2[1:-1]]) > capacity:\n            continue\n\n        # Update the solution\n        new_solution[i] = new_route1\n        new_solution.append(new_route2)\n\n    # Step 2: Demand-Aware Relocation Operator\n    for _ in range(2):  # Perform 2 random relocations\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:  # Skip empty routes\n            continue\n\n        # Select a random customer from route1 and route2\n        cust1 = random.choice(route1[1:-1])\n        cust2 = random.choice(route2[1:-1])\n\n        # Try to swap the customers\n        new_route1 = route1.copy()\n        new_route1[new_route1 == cust1] = cust2\n\n        new_route2 = route2.copy()\n        new_route2[new_route2 == cust2] = cust1\n\n        # Validate capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) > capacity or\n            np.sum(demand[new_route2[1:-1]]) > capacity):\n            continue\n\n        # Update the solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random customer\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    new_route1 = np.concatenate([longest_route[:split_idx + 1], [0]])\n    new_route2 = np.concatenate([[0], longest_route[split_idx:]])\n\n    # Check capacity constraints for the split routes\n    if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n        selected_solution[longest_route_idx] = new_route1\n        selected_solution.insert(longest_route_idx + 1, new_route2)\n    else:\n        # If split violates capacity, perform a customer reallocation instead\n        # Move a random customer from the longest route to another feasible route\n        customer_to_move = longest_route[np.random.randint(1, len(longest_route) - 1)]\n        for i, route in enumerate(selected_solution):\n            if i != longest_route_idx and (sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity):\n                # Insert the customer at the nearest position in the target route\n                insertion_costs = distance_matrix[route[:-1], customer_to_move] + distance_matrix[customer_to_move, route[1:]] - distance_matrix[route[:-1], route[1:]]\n                best_insert_pos = np.argmin(insertion_costs)\n                selected_solution[i] = np.insert(route, best_insert_pos + 1, customer_to_move)\n                longest_route = np.delete(longest_route, np.where(longest_route == customer_to_move)[0])\n                selected_solution[longest_route_idx] = longest_route\n                break\n\n    return selected_solution\n\n",
        "score": [
            -0.7673903010118184,
            0.5728742182254791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random customer\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    new_route1 = np.concatenate([longest_route[:split_idx + 1], [0]])\n    new_route2 = np.concatenate([[0], longest_route[split_idx:]])\n\n    # Check capacity constraints for the split routes\n    if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n        selected_solution[longest_route_idx] = new_route1\n        selected_solution.insert(longest_route_idx + 1, new_route2)\n    else:\n        # If split violates capacity, perform a customer reallocation instead\n        # Move a random customer from the longest route to another feasible route\n        customer_to_move = longest_route[np.random.randint(1, len(longest_route) - 1)]\n        for i, route in enumerate(selected_solution):\n            if i != longest_route_idx and (sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity):\n                # Insert the customer at the nearest position in the target route\n                insertion_costs = distance_matrix[route[:-1], customer_to_move] + distance_matrix[customer_to_move, route[1:]] - distance_matrix[route[:-1], route[1:]]\n                best_insert_pos = np.argmin(insertion_costs)\n                selected_solution[i] = np.insert(route, best_insert_pos + 1, customer_to_move)\n                longest_route = np.delete(longest_route, np.where(longest_route == customer_to_move)[0])\n                selected_solution[longest_route_idx] = longest_route\n                break\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the lowest makespan or total distance, then applies a hybrid local search combining route splitting, customer reinsertion, and distance-based swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route into two parts and reinsert customers\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from part2 into part1 if feasible\n        for customer in part2[1:-1]:\n            if demand[customer] <= (capacity - sum(demand[part1[1:-1]])):\n                part1 = np.insert(part1, -1, customer)\n            else:\n                # If not feasible, try to find a better insertion point\n                best_pos = -1\n                min_increase = float('inf')\n                for pos in range(1, len(part1)):\n                    temp_route = np.insert(part1, pos, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[temp_route[pos-1], customer] + distance_matrix[customer, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                if best_pos != -1:\n                    part1 = np.insert(part1, best_pos, customer)\n\n        # Step 2: Perform distance-based swaps within the route\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]] > distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]:\n                    if sum(demand[route[i:j+1]]) <= capacity:\n                        route[i:j+1] = route[j:i-1:-1]\n\n        # Update the route\n        new_solution[route_idx] = part1\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7715156019871086,
            6.258822053670883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route into two parts and reinsert customers\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from part2 into part1 if feasible\n        for customer in part2[1:-1]:\n            if demand[customer] <= (capacity - sum(demand[part1[1:-1]])):\n                part1 = np.insert(part1, -1, customer)\n            else:\n                # If not feasible, try to find a better insertion point\n                best_pos = -1\n                min_increase = float('inf')\n                for pos in range(1, len(part1)):\n                    temp_route = np.insert(part1, pos, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        increase = distance_matrix[temp_route[pos-1], customer] + distance_matrix[customer, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                if best_pos != -1:\n                    part1 = np.insert(part1, best_pos, customer)\n\n        # Step 2: Perform distance-based swaps within the route\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]] > distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]:\n                    if sum(demand[route[i:j+1]]) <= capacity:\n                        route[i:j+1] = route[j:i-1:-1]\n\n        # Update the route\n        new_solution[route_idx] = part1\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid approach combining route-length-based selection and makespan-based diversification, then applies a novel \"route-splitting and merging\" operator that intelligently redistributes customers between routes while ensuring feasibility and reducing both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to merge the two routes if capacity allows\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[combined_route[1:-1]])\n\n        if total_demand <= capacity:\n            # Check if merging reduces makespan\n            new_route_length = sum(distance_matrix[combined_route[i], combined_route[i+1]] for i in range(len(combined_route)-1))\n            old_lengths = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) + \\\n                          sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n\n            if new_route_length < old_lengths:\n                # Replace the two routes with the merged route\n                new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n                new_solution.append(combined_route)\n        else:\n            # If merging is not possible, try to split a route\n            if len(route1) > 3:  # Ensure route can be split\n                split_pos = random.randint(1, len(route1)-2)\n                split_route1 = route1[:split_pos+1]\n                split_route2 = np.concatenate([[0], route1[split_pos:]])\n\n                if sum(demand[split_route1[1:-1]]) <= capacity and sum(demand[split_route2[1:-1]]) <= capacity:\n                    new_solution = [r for i, r in enumerate(new_solution) if i != route1_idx]\n                    new_solution.extend([split_route1, split_route2])\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Rebuild the route if capacity is violated\n            customers = route[1:-1]\n            new_routes = []\n            current_route = [0]\n            current_load = 0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n            new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n            new_solution.extend(new_routes)\n\n    return new_solution\n\n",
        "score": [
            -0.7512136158175725,
            0.42180389165878296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route-splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to merge the two routes if capacity allows\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[combined_route[1:-1]])\n\n        if total_demand <= capacity:\n            # Check if merging reduces makespan\n            new_route_length = sum(distance_matrix[combined_route[i], combined_route[i+1]] for i in range(len(combined_route)-1))\n            old_lengths = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) + \\\n                          sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n\n            if new_route_length < old_lengths:\n                # Replace the two routes with the merged route\n                new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n                new_solution.append(combined_route)\n        else:\n            # If merging is not possible, try to split a route\n            if len(route1) > 3:  # Ensure route can be split\n                split_pos = random.randint(1, len(route1)-2)\n                split_route1 = route1[:split_pos+1]\n                split_route2 = np.concatenate([[0], route1[split_pos:]])\n\n                if sum(demand[split_route1[1:-1]]) <= capacity and sum(demand[split_route2[1:-1]]) <= capacity:\n                    new_solution = [r for i, r in enumerate(new_solution) if i != route1_idx]\n                    new_solution.extend([split_route1, split_route2])\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Rebuild the route if capacity is violated\n            customers = route[1:-1]\n            new_routes = []\n            current_route = [0]\n            current_load = 0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n            new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n            new_solution.extend(new_routes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random selection favoring lower total distance and makespan, then applies a hybrid local search combining route splitting and inter-route insertion to generate a neighbor solution while ensuring feasibility through demand and capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and inter-route insertion\n    if len(new_solution) > 1:\n        # Select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n\n        if len(split_route) > 3:  # Ensure route has enough nodes to split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = split_route[:split_pos + 1]\n            new_route2 = split_route[split_pos:]\n\n            # Check capacity feasibility for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Replace the original route with the two new routes\n                new_solution[split_route_idx] = new_route1\n                new_solution.insert(split_route_idx + 1, new_route2)\n\n                # Attempt inter-route insertion to improve the split\n                for _ in range(2):  # Try a few times\n                    target_route_idx = random.choice([i for i in range(len(new_solution)) if i != split_route_idx])\n                    target_route = new_solution[target_route_idx]\n\n                    # Select a node from the first new route (not depot)\n                    if len(new_route1) > 2:\n                        node_to_move = random.choice(new_route1[1:-1])\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for i in range(1, len(target_route)):\n                            # Check capacity constraint\n                            if np.sum(demand[target_route[1:i]]) + demand[node_to_move] <= capacity:\n                                # Calculate distance increase\n                                dist_increase = (distance_matrix[target_route[i-1]][node_to_move] +\n                                               distance_matrix[node_to_move][target_route[i]] -\n                                               distance_matrix[target_route[i-1]][target_route[i]])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = i\n\n                        if min_increase < float('inf'):\n                            # Perform the insertion\n                            new_route1 = np.delete(new_route1, np.where(new_route1 == node_to_move))\n                            target_route = np.insert(target_route, best_pos, node_to_move)\n                            new_solution[split_route_idx] = new_route1\n                            new_solution[target_route_idx] = target_route\n\n    return new_solution\n\n",
        "score": [
            -0.8122716717910691,
            0.6853246688842773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and inter-route insertion\n    if len(new_solution) > 1:\n        # Select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n\n        if len(split_route) > 3:  # Ensure route has enough nodes to split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = split_route[:split_pos + 1]\n            new_route2 = split_route[split_pos:]\n\n            # Check capacity feasibility for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Replace the original route with the two new routes\n                new_solution[split_route_idx] = new_route1\n                new_solution.insert(split_route_idx + 1, new_route2)\n\n                # Attempt inter-route insertion to improve the split\n                for _ in range(2):  # Try a few times\n                    target_route_idx = random.choice([i for i in range(len(new_solution)) if i != split_route_idx])\n                    target_route = new_solution[target_route_idx]\n\n                    # Select a node from the first new route (not depot)\n                    if len(new_route1) > 2:\n                        node_to_move = random.choice(new_route1[1:-1])\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for i in range(1, len(target_route)):\n                            # Check capacity constraint\n                            if np.sum(demand[target_route[1:i]]) + demand[node_to_move] <= capacity:\n                                # Calculate distance increase\n                                dist_increase = (distance_matrix[target_route[i-1]][node_to_move] +\n                                               distance_matrix[node_to_move][target_route[i]] -\n                                               distance_matrix[target_route[i-1]][target_route[i]])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = i\n\n                        if min_increase < float('inf'):\n                            # Perform the insertion\n                            new_route1 = np.delete(new_route1, np.where(new_route1 == node_to_move))\n                            target_route = np.insert(target_route, best_pos, node_to_move)\n                            new_solution[split_route_idx] = new_route1\n                            new_solution[target_route_idx] = target_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to extract\n        start = np.random.randint(1, len(route)-2)\n        end = np.random.randint(start+1, len(route)-1)\n        segment = route[start:end+1]\n\n        # Try to insert the segment into another route\n        inserted = False\n        for i, other_route in enumerate(selected_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment[1:-1]]) > capacity:\n                continue  # Skip if capacity exceeded\n\n            # Find best insertion point in the other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], other_route[pos]] -\n                        distance_matrix[other_route[pos-1], other_route[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert the segment\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution.append(new_route)\n            inserted = True\n            break\n\n        if not inserted:\n            new_solution.append(route)  # Couldn't insert, keep original\n\n    # Remove empty routes and ensure depot connections\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7064868094327028,
            3.6518589556217194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route merging and insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to extract\n        start = np.random.randint(1, len(route)-2)\n        end = np.random.randint(start+1, len(route)-1)\n        segment = route[start:end+1]\n\n        # Try to insert the segment into another route\n        inserted = False\n        for i, other_route in enumerate(selected_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[segment[1:-1]]) > capacity:\n                continue  # Skip if capacity exceeded\n\n            # Find best insertion point in the other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], other_route[pos]] -\n                        distance_matrix[other_route[pos-1], other_route[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert the segment\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution.append(new_route)\n            inserted = True\n            break\n\n        if not inserted:\n            new_solution.append(route)  # Couldn't insert, keep original\n\n    # Remove empty routes and ensure depot connections\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, insertion with demand-aware swaps, and a capacity-constrained 2-opt variant to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search: route splitting, insertion with demand-aware swaps, and capacity-constrained 2-opt\n    for _ in range(2):  # Number of iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Insertion with demand-aware swaps: move a customer to another route if feasible\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Randomly select a customer from the current route (not depot)\n            if len(route) > 2:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Try to insert into another route\n                for pos in range(1, len(other_route)):\n                    new_other_route = np.insert(other_route, pos, customer)\n                    if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                        new_other_route = np.insert(new_other_route, pos, customer)\n                        new_other_route = new_other_route[np.unique(new_other_route, return_index=True)[1]]\n                        new_solution[other_route_idx] = new_other_route\n                        route = np.delete(route, customer_pos)\n                        if len(route) > 2:\n                            new_solution[route_idx] = route\n                        else:\n                            new_solution.pop(route_idx)\n                        break\n\n        # Capacity-constrained 2-opt: swap adjacent customers if feasible\n        if len(route) > 3:\n            i = random.randint(1, len(route) - 3)\n            j = i + 1\n            new_route = route.copy()\n            new_route[i], new_route[j] = new_route[j], new_route[i]\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7030916119896848,
            1.8543729186058044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search: route splitting, insertion with demand-aware swaps, and capacity-constrained 2-opt\n    for _ in range(2):  # Number of iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Insertion with demand-aware swaps: move a customer to another route if feasible\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Randomly select a customer from the current route (not depot)\n            if len(route) > 2:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Try to insert into another route\n                for pos in range(1, len(other_route)):\n                    new_other_route = np.insert(other_route, pos, customer)\n                    if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                        new_other_route = np.insert(new_other_route, pos, customer)\n                        new_other_route = new_other_route[np.unique(new_other_route, return_index=True)[1]]\n                        new_solution[other_route_idx] = new_other_route\n                        route = np.delete(route, customer_pos)\n                        if len(route) > 2:\n                            new_solution[route_idx] = route\n                        else:\n                            new_solution.pop(route_idx)\n                        break\n\n        # Capacity-constrained 2-opt: swap adjacent customers if feasible\n        if len(route) > 3:\n            i = random.randint(1, len(route) - 3)\n            j = i + 1\n            new_route = route.copy()\n            new_route[i], new_route[j] = new_route[j], new_route[i]\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search combining route segmentation, inter-route insertion, and capacity-aware rebalancing to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_total_distance = float('inf')\n    for sol, (total_dist, makespan) in archive:\n        if total_dist < min_total_distance and any(total_dist < d and makespan < m for _, (d, m) in archive):\n            selected_solution = sol\n            min_total_distance = total_dist\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route segmentation + inter-route insertion + capacity rebalancing\n    for _ in range(5):  # Number of iterations\n        # Step 1: Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Segment the route into smaller parts\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 3)\n            segment1 = route[:split_pos]\n            segment2 = route[split_pos:]\n\n            # Step 3: Try to insert segment2 into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check capacity constraint\n                total_demand = np.sum(demand[segment2[1:-1]])\n                if total_demand <= capacity:\n                    # Find best insertion point\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[other_route[pos-1], segment2[1]] +\n                                distance_matrix[segment2[-2], other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Insert segment2 into other_route\n                    new_other_route = np.concatenate([other_route[:best_pos], segment2[1:-1], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n                    new_solution[route_idx] = segment1\n                    break\n\n        # Step 4: Capacity rebalancing (move customers between routes)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find customers to move from route1 to route2\n            for i in range(1, len(route1)-1):\n                customer = route1[i]\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Check if moving improves total distance\n                    old_dist = (distance_matrix[route1[i-1], customer] +\n                                distance_matrix[customer, route1[i+1]] -\n                                distance_matrix[route1[i-1], route1[i+1]])\n                    new_dist = (distance_matrix[route2[-2], customer] +\n                                distance_matrix[customer, route2[-1]] -\n                                distance_matrix[route2[-2], route2[-1]])\n\n                    if new_dist < old_dist:\n                        # Perform the move\n                        new_route1 = np.concatenate([route1[:i], route1[i+1:]])\n                        new_route2 = np.concatenate([route2[:-1], [customer], route2[-1:]])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7834337472785333,
            2.0132093131542206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_total_distance = float('inf')\n    for sol, (total_dist, makespan) in archive:\n        if total_dist < min_total_distance and any(total_dist < d and makespan < m for _, (d, m) in archive):\n            selected_solution = sol\n            min_total_distance = total_dist\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route segmentation + inter-route insertion + capacity rebalancing\n    for _ in range(5):  # Number of iterations\n        # Step 1: Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Segment the route into smaller parts\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 3)\n            segment1 = route[:split_pos]\n            segment2 = route[split_pos:]\n\n            # Step 3: Try to insert segment2 into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check capacity constraint\n                total_demand = np.sum(demand[segment2[1:-1]])\n                if total_demand <= capacity:\n                    # Find best insertion point\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[other_route[pos-1], segment2[1]] +\n                                distance_matrix[segment2[-2], other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Insert segment2 into other_route\n                    new_other_route = np.concatenate([other_route[:best_pos], segment2[1:-1], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n                    new_solution[route_idx] = segment1\n                    break\n\n        # Step 4: Capacity rebalancing (move customers between routes)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find customers to move from route1 to route2\n            for i in range(1, len(route1)-1):\n                customer = route1[i]\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Check if moving improves total distance\n                    old_dist = (distance_matrix[route1[i-1], customer] +\n                                distance_matrix[customer, route1[i+1]] -\n                                distance_matrix[route1[i-1], route1[i+1]])\n                    new_dist = (distance_matrix[route2[-2], customer] +\n                                distance_matrix[customer, route2[-1]] -\n                                distance_matrix[route2[-2], route2[-1]])\n\n                    if new_dist < old_dist:\n                        # Perform the move\n                        new_route1 = np.concatenate([route1[:i], route1[i+1:]])\n                        new_route2 = np.concatenate([route2[:-1], [customer], route2[-1:]])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search that combines route perturbation with capacity-aware insertion heuristics to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution by perturbing the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment to split\n        split_point = random.randint(1, len(route) - 2)\n        segment = route[split_point:-1]  # Exclude the final depot\n\n        # Remove the segment from the original route\n        new_route = np.concatenate([route[:split_point], [0]])\n        new_solution[i] = new_route\n\n        # Try to insert the segment into another route or create a new route\n        inserted = False\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j].copy()\n            current_load = sum(demand[customer] for customer in candidate_route if customer != 0)\n            segment_load = sum(demand[customer] for customer in segment)\n\n            if current_load + segment_load <= capacity:\n                # Find the best insertion point in the candidate route\n                best_insertion = -1\n                best_cost = float('inf')\n                for pos in range(1, len(candidate_route)):\n                    # Insert segment between pos-1 and pos\n                    new_segment = np.concatenate([\n                        candidate_route[:pos],\n                        segment,\n                        candidate_route[pos:]\n                    ])\n                    # Calculate insertion cost (simplified for efficiency)\n                    insertion_cost = (\n                        distance_matrix[candidate_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], candidate_route[pos]] -\n                        distance_matrix[candidate_route[pos-1], candidate_route[pos]]\n                    )\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_insertion = pos\n\n                if best_insertion != -1:\n                    # Perform the insertion\n                    new_segment = np.concatenate([\n                        candidate_route[:best_insertion],\n                        segment,\n                        candidate_route[best_insertion:]\n                    ])\n                    new_solution[j] = new_segment\n                    inserted = True\n                    break\n\n        if not inserted:\n            # If not inserted, try to create a new route\n            if sum(demand[customer] for customer in segment) <= capacity:\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])  # Exclude depots\n    missing_customers = list(all_customers - served_customers)\n\n    # Re-insert missing customers using a simple insertion heuristic\n    for customer in missing_customers:\n        best_route = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_load = sum(demand[c] for c in route[1:-1])\n            if current_load + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                insertion_cost = (\n                    distance_matrix[route[pos-1], customer] +\n                    distance_matrix[customer, route[pos]] -\n                    distance_matrix[route[pos-1], route[pos]]\n                )\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_route = i\n                    best_pos = pos\n\n        if best_route != -1:\n            new_route = np.concatenate([\n                new_solution[best_route][:best_pos],\n                [customer],\n                new_solution[best_route][best_pos:]\n            ])\n            new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6449089811234638,
            5.004475325345993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution by perturbing the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a segment to split\n        split_point = random.randint(1, len(route) - 2)\n        segment = route[split_point:-1]  # Exclude the final depot\n\n        # Remove the segment from the original route\n        new_route = np.concatenate([route[:split_point], [0]])\n        new_solution[i] = new_route\n\n        # Try to insert the segment into another route or create a new route\n        inserted = False\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j].copy()\n            current_load = sum(demand[customer] for customer in candidate_route if customer != 0)\n            segment_load = sum(demand[customer] for customer in segment)\n\n            if current_load + segment_load <= capacity:\n                # Find the best insertion point in the candidate route\n                best_insertion = -1\n                best_cost = float('inf')\n                for pos in range(1, len(candidate_route)):\n                    # Insert segment between pos-1 and pos\n                    new_segment = np.concatenate([\n                        candidate_route[:pos],\n                        segment,\n                        candidate_route[pos:]\n                    ])\n                    # Calculate insertion cost (simplified for efficiency)\n                    insertion_cost = (\n                        distance_matrix[candidate_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], candidate_route[pos]] -\n                        distance_matrix[candidate_route[pos-1], candidate_route[pos]]\n                    )\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_insertion = pos\n\n                if best_insertion != -1:\n                    # Perform the insertion\n                    new_segment = np.concatenate([\n                        candidate_route[:best_insertion],\n                        segment,\n                        candidate_route[best_insertion:]\n                    ])\n                    new_solution[j] = new_segment\n                    inserted = True\n                    break\n\n        if not inserted:\n            # If not inserted, try to create a new route\n            if sum(demand[customer] for customer in segment) <= capacity:\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])  # Exclude depots\n    missing_customers = list(all_customers - served_customers)\n\n    # Re-insert missing customers using a simple insertion heuristic\n    for customer in missing_customers:\n        best_route = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_load = sum(demand[c] for c in route[1:-1])\n            if current_load + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                insertion_cost = (\n                    distance_matrix[route[pos-1], customer] +\n                    distance_matrix[customer, route[pos]] -\n                    distance_matrix[route[pos-1], route[pos]]\n                )\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_route = i\n                    best_pos = pos\n\n        if best_route != -1:\n            new_route = np.concatenate([\n                new_solution[best_route][:best_pos],\n                [customer],\n                new_solution[best_route][best_pos:]\n            ])\n            new_solution[best_route] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route Splitting and Customer Relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity constraints for both new routes\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break\n\n        # If splitting fails, try relocating a customer to another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            for k in range(1, len(route) - 1):\n                customer = route[k]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    insert_pos = np.random.randint(1, len(other_route))\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[j] = new_other_route\n                    # Remove customer from current route\n                    new_solution[i] = np.delete(route, k)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.69077987090916,
            0.1400936245918274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route Splitting and Customer Relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity constraints for both new routes\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = route1\n            new_solution.insert(i + 1, route2)\n            break\n\n        # If splitting fails, try relocating a customer to another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            for k in range(1, len(route) - 1):\n                customer = route[k]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    insert_pos = np.random.randint(1, len(other_route))\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[j] = new_other_route\n                    # Remove customer from current route\n                    new_solution[i] = np.delete(route, k)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route segment swaps with demand-aware route merging to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to find a feasible segment swap\n        for _ in range(10):  # Limit attempts to avoid excessive computation\n            # Select a random segment from each route (excluding depot)\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end+1]\n            seg2 = route2[seg2_start:seg2_end+1]\n\n            # Check capacity constraints for new routes\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end+1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end+1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Apply the swap\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n        # Try demand-aware route merging if possible\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Check if merging is possible\n                total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n                if total_demand <= capacity:\n                    # Try to merge routes by inserting one into the other\n                    for _ in range(5):  # Limit attempts\n                        insert_pos = random.randint(1, len(route_i)-1)\n                        merged_route = np.concatenate([\n                            route_i[:insert_pos],\n                            route_j[1:-1],\n                            route_i[insert_pos:]\n                        ])\n\n                        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6124698205385398,
            3.21195912361145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to find a feasible segment swap\n        for _ in range(10):  # Limit attempts to avoid excessive computation\n            # Select a random segment from each route (excluding depot)\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end+1]\n            seg2 = route2[seg2_start:seg2_end+1]\n\n            # Check capacity constraints for new routes\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end+1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end+1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                # Apply the swap\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n        # Try demand-aware route merging if possible\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Check if merging is possible\n                total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n                if total_demand <= capacity:\n                    # Try to merge routes by inserting one into the other\n                    for _ in range(5):  # Limit attempts\n                        insert_pos = random.randint(1, len(route_i)-1)\n                        merged_route = np.concatenate([\n                            route_i[:insert_pos],\n                            route_j[1:-1],\n                            route_i[insert_pos:]\n                        ])\n\n                        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This function selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search that combines route merging and customer reinsertion to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Remove the selected routes from the solution\n        new_solution = [route for i, route in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n\n        # Combine the two routes (excluding depots)\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n        # Reinsert customers into the merged route while respecting capacity\n        # Use a greedy insertion heuristic to balance distance and makespan\n        customers = merged_route[1:-1]\n        new_route = [0]\n\n        for customer in customers:\n            best_pos = None\n            best_cost = float('inf')\n\n            # Try inserting at all possible positions\n            for i in range(1, len(new_route)):\n                temp_route = np.insert(new_route, i, customer)\n                temp_route = np.append(temp_route, 0)\n\n                # Calculate total distance and current route distance\n                total_dist = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route)-1))\n                current_route_dist = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(i, i+2))\n\n                # Balance between distance and makespan\n                cost = total_dist + 0.5 * current_route_dist\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_pos is not None:\n                new_route.insert(best_pos, customer)\n\n        new_route.append(0)\n        new_route = np.array(new_route)\n\n        # Split the merged route back into feasible sub-routes\n        current_capacity = 0\n        current_route = [0]\n\n        for customer in new_route[1:-1]:\n            if current_capacity + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_capacity = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "score": [
            -0.7391664593480467,
            0.2738865613937378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Remove the selected routes from the solution\n        new_solution = [route for i, route in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n\n        # Combine the two routes (excluding depots)\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n        # Reinsert customers into the merged route while respecting capacity\n        # Use a greedy insertion heuristic to balance distance and makespan\n        customers = merged_route[1:-1]\n        new_route = [0]\n\n        for customer in customers:\n            best_pos = None\n            best_cost = float('inf')\n\n            # Try inserting at all possible positions\n            for i in range(1, len(new_route)):\n                temp_route = np.insert(new_route, i, customer)\n                temp_route = np.append(temp_route, 0)\n\n                # Calculate total distance and current route distance\n                total_dist = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route)-1))\n                current_route_dist = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(i, i+2))\n\n                # Balance between distance and makespan\n                cost = total_dist + 0.5 * current_route_dist\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_pos is not None:\n                new_route.insert(best_pos, customer)\n\n        new_route.append(0)\n        new_route = np.array(new_route)\n\n        # Split the merged route back into feasible sub-routes\n        current_capacity = 0\n        current_route = [0]\n\n        for customer in new_route[1:-1]:\n            if current_capacity + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_capacity = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a novel hybrid local search operator that combines route splitting, customer reinsertion with capacity checks, and partial route swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by total distance and makespan, then select a diverse one\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        candidate_indices = [0, len(archive_sorted) // 2, -1]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        # Step 1: Randomly select a route to modify\n        if len(solution) < 2:\n            selected_route_idx = 0\n        else:\n            selected_route_idx = random.randint(0, len(solution) - 1)\n\n        selected_route = solution[selected_route_idx].copy()\n\n        # Step 2: Split the route at a random point if it has enough customers\n        if len(selected_route) > 4:  # Need at least 3 customers to split (including depot)\n            split_pos = random.randint(2, len(selected_route) - 3)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Check capacity for new routes\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                solution[selected_route_idx] = new_route1\n                solution.append(new_route2)\n                return solution\n\n        # Step 3: If split didn't work, try reinserting customers from another route\n        if len(solution) > 1:\n            other_routes = [i for i in range(len(solution)) if i != selected_route_idx]\n            if other_routes:\n                other_route_idx = random.choice(other_routes)\n                other_route = solution[other_route_idx].copy()\n\n                if len(other_route) > 3:  # Need at least one customer to move\n                    # Select a random customer from the other route\n                    customer_pos = random.randint(1, len(other_route) - 2)\n                    customer = other_route[customer_pos]\n\n                    # Find possible insertion positions in the selected route\n                    possible_positions = []\n                    for i in range(1, len(selected_route)):\n                        # Check capacity constraint\n                        new_route = np.insert(selected_route, i, customer)\n                        total_demand = sum(demand[node] for node in new_route[1:-1])\n                        if total_demand <= capacity:\n                            possible_positions.append(i)\n\n                    if possible_positions:\n                        insert_pos = random.choice(possible_positions)\n                        new_selected_route = np.insert(selected_route, insert_pos, customer)\n                        new_other_route = np.delete(other_route, customer_pos)\n\n                        # Update solution\n                        solution[selected_route_idx] = new_selected_route\n                        solution[other_route_idx] = new_other_route\n\n                        # Remove empty routes\n                        solution = [route for route in solution if len(route) > 2]\n                        return solution\n\n        # Step 4: If reinsertion didn't work, try partial route swapping\n        if len(solution) > 1:\n            other_routes = [i for i in range(len(solution)) if i != selected_route_idx]\n            if other_routes:\n                other_route_idx = random.choice(other_routes)\n                other_route = solution[other_route_idx].copy()\n\n                if len(selected_route) > 3 and len(other_route) > 3:\n                    # Select a segment from each route\n                    seg1_start = random.randint(1, len(selected_route) - 3)\n                    seg1_end = random.randint(seg1_start + 1, len(selected_route) - 2)\n                    seg1 = selected_route[seg1_start:seg1_end]\n\n                    seg2_start = random.randint(1, len(other_route) - 3)\n                    seg2_end = random.randint(seg2_start + 1, len(other_route) - 2)\n                    seg2 = other_route[seg2_start:seg2_end]\n\n                    # Check capacity constraints\n                    def get_new_route(original, removed, added):\n                        new = original.copy()\n                        for node in removed:\n                            idx = np.where(new == node)[0][0]\n                            new = np.delete(new, idx)\n                        for i, node in enumerate(added):\n                            new = np.insert(new, seg1_start + i, node)\n                        return new\n\n                    new_selected = get_new_route(selected_route, seg1, seg2)\n                    new_other = get_new_route(other_route, seg2, seg1)\n\n                    if (check_capacity(new_selected) and check_capacity(new_other)):\n                        solution[selected_route_idx] = new_selected\n                        solution[other_route_idx] = new_other\n                        return solution\n\n        return solution\n\n    new_solution = hybrid_local_search(new_solution)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n",
        "score": [
            -0.7033106506472242,
            0.40223491191864014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by total distance and makespan, then select a diverse one\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        candidate_indices = [0, len(archive_sorted) // 2, -1]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        # Step 1: Randomly select a route to modify\n        if len(solution) < 2:\n            selected_route_idx = 0\n        else:\n            selected_route_idx = random.randint(0, len(solution) - 1)\n\n        selected_route = solution[selected_route_idx].copy()\n\n        # Step 2: Split the route at a random point if it has enough customers\n        if len(selected_route) > 4:  # Need at least 3 customers to split (including depot)\n            split_pos = random.randint(2, len(selected_route) - 3)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Check capacity for new routes\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                solution[selected_route_idx] = new_route1\n                solution.append(new_route2)\n                return solution\n\n        # Step 3: If split didn't work, try reinserting customers from another route\n        if len(solution) > 1:\n            other_routes = [i for i in range(len(solution)) if i != selected_route_idx]\n            if other_routes:\n                other_route_idx = random.choice(other_routes)\n                other_route = solution[other_route_idx].copy()\n\n                if len(other_route) > 3:  # Need at least one customer to move\n                    # Select a random customer from the other route\n                    customer_pos = random.randint(1, len(other_route) - 2)\n                    customer = other_route[customer_pos]\n\n                    # Find possible insertion positions in the selected route\n                    possible_positions = []\n                    for i in range(1, len(selected_route)):\n                        # Check capacity constraint\n                        new_route = np.insert(selected_route, i, customer)\n                        total_demand = sum(demand[node] for node in new_route[1:-1])\n                        if total_demand <= capacity:\n                            possible_positions.append(i)\n\n                    if possible_positions:\n                        insert_pos = random.choice(possible_positions)\n                        new_selected_route = np.insert(selected_route, insert_pos, customer)\n                        new_other_route = np.delete(other_route, customer_pos)\n\n                        # Update solution\n                        solution[selected_route_idx] = new_selected_route\n                        solution[other_route_idx] = new_other_route\n\n                        # Remove empty routes\n                        solution = [route for route in solution if len(route) > 2]\n                        return solution\n\n        # Step 4: If reinsertion didn't work, try partial route swapping\n        if len(solution) > 1:\n            other_routes = [i for i in range(len(solution)) if i != selected_route_idx]\n            if other_routes:\n                other_route_idx = random.choice(other_routes)\n                other_route = solution[other_route_idx].copy()\n\n                if len(selected_route) > 3 and len(other_route) > 3:\n                    # Select a segment from each route\n                    seg1_start = random.randint(1, len(selected_route) - 3)\n                    seg1_end = random.randint(seg1_start + 1, len(selected_route) - 2)\n                    seg1 = selected_route[seg1_start:seg1_end]\n\n                    seg2_start = random.randint(1, len(other_route) - 3)\n                    seg2_end = random.randint(seg2_start + 1, len(other_route) - 2)\n                    seg2 = other_route[seg2_start:seg2_end]\n\n                    # Check capacity constraints\n                    def get_new_route(original, removed, added):\n                        new = original.copy()\n                        for node in removed:\n                            idx = np.where(new == node)[0][0]\n                            new = np.delete(new, idx)\n                        for i, node in enumerate(added):\n                            new = np.insert(new, seg1_start + i, node)\n                        return new\n\n                    new_selected = get_new_route(selected_route, seg1, seg2)\n                    new_other = get_new_route(other_route, seg2, seg1)\n\n                    if (check_capacity(new_selected) and check_capacity(new_other)):\n                        solution[selected_route_idx] = new_selected\n                        solution[other_route_idx] = new_other\n                        return solution\n\n        return solution\n\n    new_solution = hybrid_local_search(new_solution)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The algorithm selects a solution from the archive with a high makespan-to-distance ratio, applies a hybrid local search combining route merging, customer reallocation, and adaptive 2-opt with capacity-aware swaps to balance objectives, ensuring feasibility through demand validation and route splitting.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / (x[1][0] + 1e-6), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, reallocation, and adaptive 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if possible)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = np.delete(new_solution, [i, j], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n\n    # Step 2: Customer reallocation (move random customer to another route)\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure we can remove a customer\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n\n            # Try to insert into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx != source_route_idx:\n                    target_route = new_solution[target_route_idx]\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[target_route[pos-1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos-1], target_route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                    if best_cost < float('inf'):\n                        # Perform the move\n                        new_route = np.insert(target_route, best_pos, customer)\n                        new_solution[target_route_idx] = new_route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    # Step 3: Adaptive 2-opt with capacity awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select random segments\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            c, d = sorted(random.sample(range(1, len(route) - 1), 2))\n\n            # Try all possible 2-opt combinations\n            candidates = [\n                np.concatenate([route[:a], route[b:c+1][::-1], route[d:]]),\n                np.concatenate([route[:a], route[d:c+1][::-1], route[b:]]),\n                np.concatenate([route[:b], route[a:d+1][::-1], route[c:]]),\n                np.concatenate([route[:b], route[d:c+1][::-1], route[a:]])\n            ]\n\n            best_route = route\n            best_cost = float('inf')\n            for candidate in candidates:\n                if np.sum(demand[candidate[1:-1]]) <= capacity:\n                    cost = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = candidate\n\n            new_solution[route_idx] = best_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7279079009482036,
            5.340666651725769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / (x[1][0] + 1e-6), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, reallocation, and adaptive 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if possible)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = np.delete(new_solution, [i, j], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n\n    # Step 2: Customer reallocation (move random customer to another route)\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure we can remove a customer\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n\n            # Try to insert into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx != source_route_idx:\n                    target_route = new_solution[target_route_idx]\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        new_route = np.insert(target_route, pos, customer)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[target_route[pos-1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos-1], target_route[pos]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                    if best_cost < float('inf'):\n                        # Perform the move\n                        new_route = np.insert(target_route, best_pos, customer)\n                        new_solution[target_route_idx] = new_route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    # Step 3: Adaptive 2-opt with capacity awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select random segments\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            c, d = sorted(random.sample(range(1, len(route) - 1), 2))\n\n            # Try all possible 2-opt combinations\n            candidates = [\n                np.concatenate([route[:a], route[b:c+1][::-1], route[d:]]),\n                np.concatenate([route[:a], route[d:c+1][::-1], route[b:]]),\n                np.concatenate([route[:b], route[a:d+1][::-1], route[c:]]),\n                np.concatenate([route[:b], route[d:c+1][::-1], route[a:]])\n            ]\n\n            best_route = route\n            best_cost = float('inf')\n            for candidate in candidates:\n                if np.sum(demand[candidate[1:-1]]) <= capacity:\n                    cost = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = candidate\n\n            new_solution[route_idx] = best_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route merging and split with demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Merge the two routes into one\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check if the merged route is feasible\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # If feasible, replace the two routes with the merged route\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.append(merged_route)\n        else:\n            # If not feasible, perform a demand-aware split\n            total_demand = np.sum(demand[merged_route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for pos in range(1, len(merged_route)-1):\n                current_demand += demand[merged_route[pos]]\n                if current_demand > capacity:\n                    split_pos = pos\n                    break\n\n            # Split the merged route into two feasible routes\n            route_a = np.concatenate([merged_route[:split_pos], [0]])\n            route_b = np.concatenate([[0], merged_route[split_pos:]])\n\n            # Replace the original routes with the split routes\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.extend([route_a, route_b])\n\n    # Demand-aware reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Only consider routes with more than one customer\n            # Randomly select a customer to reinsert\n            reinsert_pos = np.random.randint(1, len(route)-1)\n            customer = route[reinsert_pos]\n\n            # Remove the customer from the route\n            temp_route = np.concatenate([route[:reinsert_pos], route[reinsert_pos+1:]])\n\n            # Find the best position to reinsert the customer in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(temp_route)):\n                new_route = np.concatenate([temp_route[:pos], [customer], temp_route[pos:]])\n                cost = np.sum(distance_matrix[new_route[:-1], new_route[1:]]) + np.sum(distance_matrix[new_route[-1:], new_route[:1]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Reinsert the customer at the best position\n            new_route = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5086520667113444,
            8.419978946447372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route merging and split with demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Merge the two routes into one\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check if the merged route is feasible\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # If feasible, replace the two routes with the merged route\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.append(merged_route)\n        else:\n            # If not feasible, perform a demand-aware split\n            total_demand = np.sum(demand[merged_route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for pos in range(1, len(merged_route)-1):\n                current_demand += demand[merged_route[pos]]\n                if current_demand > capacity:\n                    split_pos = pos\n                    break\n\n            # Split the merged route into two feasible routes\n            route_a = np.concatenate([merged_route[:split_pos], [0]])\n            route_b = np.concatenate([[0], merged_route[split_pos:]])\n\n            # Replace the original routes with the split routes\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.extend([route_a, route_b])\n\n    # Demand-aware reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Only consider routes with more than one customer\n            # Randomly select a customer to reinsert\n            reinsert_pos = np.random.randint(1, len(route)-1)\n            customer = route[reinsert_pos]\n\n            # Remove the customer from the route\n            temp_route = np.concatenate([route[:reinsert_pos], route[reinsert_pos+1:]])\n\n            # Find the best position to reinsert the customer in the same route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(temp_route)):\n                new_route = np.concatenate([temp_route[:pos], [customer], temp_route[pos:]])\n                cost = np.sum(distance_matrix[new_route[:-1], new_route[1:]]) + np.sum(distance_matrix[new_route[-1:], new_route[:1]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Reinsert the customer at the best position\n            new_route = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer relocation with capacity check\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting the segment improves makespan\n        if len(segment) >= 2:\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], segment, [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Relocate a customer from the longest route to another route if possible\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            # Select a random customer to relocate\n            customer_pos = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[customer_pos]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                target_route = new_solution[j]\n                # Try inserting at every possible position\n                for insert_pos in range(1, len(target_route)):\n                    new_route = np.concatenate([target_route[:insert_pos], [customer], target_route[insert_pos:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[j] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([longest_route[:customer_pos], longest_route[customer_pos+1:]])\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6326724029261672,
            2.778039187192917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer relocation with capacity check\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]\n\n        # Check if splitting the segment improves makespan\n        if len(segment) >= 2:\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], segment, [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Relocate a customer from the longest route to another route if possible\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            # Select a random customer to relocate\n            customer_pos = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[customer_pos]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                target_route = new_solution[j]\n                # Try inserting at every possible position\n                for insert_pos in range(1, len(target_route)):\n                    new_route = np.concatenate([target_route[:insert_pos], [customer], target_route[insert_pos:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[j] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([longest_route[:customer_pos], longest_route[customer_pos+1:]])\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route splitting and customer reinsertion with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split parts are feasible\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break  # Only split one route per iteration\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        for node in longest_route[1:-1]:\n            # Try to insert the node into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n                route = new_solution[j]\n                # Find the best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert node at position pos\n                    new_route = np.insert(route, pos, node)\n                    if np.sum(demand[new_route[1:-1]]) > capacity:\n                        continue\n                    # Calculate insertion cost\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                if best_cost != float('inf'):\n                    new_route = np.insert(route, best_pos, node)\n                    new_solution[j] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8256727584311745,
            10.608962416648865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route splitting and customer reinsertion with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split parts are feasible\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break  # Only split one route per iteration\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        for node in longest_route[1:-1]:\n            # Try to insert the node into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n                route = new_solution[j]\n                # Find the best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert node at position pos\n                    new_route = np.insert(route, pos, node)\n                    if np.sum(demand[new_route[1:-1]]) > capacity:\n                        continue\n                    # Calculate insertion cost\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                if best_cost != float('inf'):\n                    new_route = np.insert(route, best_pos, node)\n                    new_solution[j] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and structural diversity, then applies a hybrid local search combining route fragmentation and cross-route insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] * obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and recombine routes\n    if len(new_solution) > 1:\n        # Step 1: Select a route to fragment (longer routes have higher probability)\n        frag_route_idx = random.choices(range(len(new_solution)), weights=[len(route) for route in new_solution], k=1)[0]\n        frag_route = new_solution[frag_route_idx]\n\n        # Step 2: Find a split point that maintains feasibility\n        total_demand = sum(demand[node] for node in frag_route if node != 0)\n        split_pos = 1  # Start after depot\n        current_demand = 0\n        while split_pos < len(frag_route) - 1:\n            current_demand += demand[frag_route[split_pos]]\n            if current_demand > capacity / 2:  # Split at approximately half capacity\n                break\n            split_pos += 1\n\n        # Step 3: Create two new routes from the fragmented parts\n        new_route1 = np.concatenate([frag_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], frag_route[split_pos:]])\n\n        # Step 4: Replace the original route with the two new routes\n        new_solution.pop(frag_route_idx)\n        new_solution.insert(frag_route_idx, new_route2)\n        new_solution.insert(frag_route_idx, new_route1)\n\n        # Step 5: Attempt cross-route insertion to improve makespan\n        for _ in range(2):  # Limit attempts to maintain efficiency\n            # Select a random customer from one route\n            source_route_idx = random.choice(range(len(new_solution)))\n            source_route = new_solution[source_route_idx]\n            if len(source_route) <= 2:  # Skip if route has only depot and one customer\n                continue\n\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n\n            # Try inserting into another route\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != source_route_idx])\n            target_route = new_solution[target_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(target_route)):\n                # Calculate cost of inserting customer at position pos\n                prev_node = target_route[pos-1]\n                next_node = target_route[pos]\n                insertion_cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if insertion_cost < best_cost and sum(demand[node] for node in target_route if node != 0) + demand[customer] <= capacity:\n                    best_cost = insertion_cost\n                    best_pos = pos\n\n            if best_cost < float('inf'):\n                # Perform insertion\n                new_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                new_solution[target_route_idx] = new_route\n                # Remove customer from source route\n                new_solution[source_route_idx] = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.68802385722747,
            2.159527599811554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] * obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and recombine routes\n    if len(new_solution) > 1:\n        # Step 1: Select a route to fragment (longer routes have higher probability)\n        frag_route_idx = random.choices(range(len(new_solution)), weights=[len(route) for route in new_solution], k=1)[0]\n        frag_route = new_solution[frag_route_idx]\n\n        # Step 2: Find a split point that maintains feasibility\n        total_demand = sum(demand[node] for node in frag_route if node != 0)\n        split_pos = 1  # Start after depot\n        current_demand = 0\n        while split_pos < len(frag_route) - 1:\n            current_demand += demand[frag_route[split_pos]]\n            if current_demand > capacity / 2:  # Split at approximately half capacity\n                break\n            split_pos += 1\n\n        # Step 3: Create two new routes from the fragmented parts\n        new_route1 = np.concatenate([frag_route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], frag_route[split_pos:]])\n\n        # Step 4: Replace the original route with the two new routes\n        new_solution.pop(frag_route_idx)\n        new_solution.insert(frag_route_idx, new_route2)\n        new_solution.insert(frag_route_idx, new_route1)\n\n        # Step 5: Attempt cross-route insertion to improve makespan\n        for _ in range(2):  # Limit attempts to maintain efficiency\n            # Select a random customer from one route\n            source_route_idx = random.choice(range(len(new_solution)))\n            source_route = new_solution[source_route_idx]\n            if len(source_route) <= 2:  # Skip if route has only depot and one customer\n                continue\n\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n\n            # Try inserting into another route\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != source_route_idx])\n            target_route = new_solution[target_route_idx]\n\n            # Find best insertion position in target route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(target_route)):\n                # Calculate cost of inserting customer at position pos\n                prev_node = target_route[pos-1]\n                next_node = target_route[pos]\n                insertion_cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if insertion_cost < best_cost and sum(demand[node] for node in target_route if node != 0) + demand[customer] <= capacity:\n                    best_cost = insertion_cost\n                    best_pos = pos\n\n            if best_cost < float('inf'):\n                # Perform insertion\n                new_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                new_solution[target_route_idx] = new_route\n                # Remove customer from source route\n                new_solution[source_route_idx] = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel hybrid local search operator combines adaptive route splitting, demand-aware node swapping, and route merging to balance distance and makespan minimization, intelligently selecting and transforming routes based on their demand profiles and spatial distribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for sol, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Adaptive route splitting: Split a long route into two if possible\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure route has nodes to split\n            split_pos = len(longest_route) // 2\n            route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Demand-aware node swapping: Move a node from one route to another if it improves balance\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3 and len(route2) > 2:\n                    # Select a node from route1 (not depot)\n                    node_pos = random.randint(1, len(route1)-2)\n                    node = route1[node_pos]\n\n                    # Check if moving this node to route2 is feasible\n                    if (sum(demand[route1[1:-1]]) - demand[node] <= capacity and\n                        sum(demand[route2[1:-1]]) + demand[node] <= capacity):\n\n                        # Insert node into route2 (after depot)\n                        new_route2 = np.concatenate([[0], [node], route2[1:]])\n                        new_route1 = np.concatenate([route1[:node_pos], route1[node_pos+1:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Route merging: Merge two routes if they can be combined without exceeding capacity\n    if len(new_solution) > 2 and random.random() < 0.3:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 <= capacity):  # Check if combined route is feasible\n\n            # Combine routes\n            combined_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = combined_route\n            new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.702637000602655,
            1.7872580289840698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for sol, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Adaptive route splitting: Split a long route into two if possible\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure route has nodes to split\n            split_pos = len(longest_route) // 2\n            route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Demand-aware node swapping: Move a node from one route to another if it improves balance\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3 and len(route2) > 2:\n                    # Select a node from route1 (not depot)\n                    node_pos = random.randint(1, len(route1)-2)\n                    node = route1[node_pos]\n\n                    # Check if moving this node to route2 is feasible\n                    if (sum(demand[route1[1:-1]]) - demand[node] <= capacity and\n                        sum(demand[route2[1:-1]]) + demand[node] <= capacity):\n\n                        # Insert node into route2 (after depot)\n                        new_route2 = np.concatenate([[0], [node], route2[1:]])\n                        new_route1 = np.concatenate([route1[:node_pos], route1[node_pos+1:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Route merging: Merge two routes if they can be combined without exceeding capacity\n    if len(new_solution) > 2 and random.random() < 0.3:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 <= capacity):  # Check if combined route is feasible\n\n            # Combine routes\n            combined_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = combined_route\n            new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging and customer reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by connecting them directly\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # If merging is not feasible, perform customer reinsertion\n            # Select a random customer from route2 and reinsert it into route1\n            if len(route2) > 2:\n                customer_idx = random.randint(1, len(route2) - 2)\n                customer = route2[customer_idx]\n\n                # Remove the customer from route2\n                route2 = np.delete(route2, customer_idx)\n\n                # Find the best position to insert the customer into route1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route1)):\n                    # Calculate the cost of inserting the customer at position i\n                    cost = distance_matrix[route1[i-1], customer] + distance_matrix[customer, route1[i]] - distance_matrix[route1[i-1], route1[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert the customer into route1\n                route1 = np.insert(route1, best_pos, customer)\n\n                # Update the routes\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.569208174143231,
            0.3946809470653534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by connecting them directly\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # If merging is not feasible, perform customer reinsertion\n            # Select a random customer from route2 and reinsert it into route1\n            if len(route2) > 2:\n                customer_idx = random.randint(1, len(route2) - 2)\n                customer = route2[customer_idx]\n\n                # Remove the customer from route2\n                route2 = np.delete(route2, customer_idx)\n\n                # Find the best position to insert the customer into route1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route1)):\n                    # Calculate the cost of inserting the customer at position i\n                    cost = distance_matrix[route1[i-1], customer] + distance_matrix[customer, route1[i]] - distance_matrix[route1[i-1], route1[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert the customer into route1\n                route1 = np.insert(route1, best_pos, customer)\n\n                # Update the routes\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and 3-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to split or modify\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity for part1\n        if sum(demand[part1[1:-1]]) <= capacity:\n            new_solution.append(part1)\n        else:\n            # If capacity exceeded, try to redistribute nodes\n            new_route = [0]\n            current_load = 0\n            for node in part1[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, node]\n                    current_load = demand[node]\n            if len(new_route) > 1:\n                new_route.append(0)\n                new_solution.append(new_route)\n\n        # Check capacity for part2\n        if sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part2)\n        else:\n            new_route = [0]\n            current_load = 0\n            for node in part2[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, node]\n                    current_load = demand[node]\n            if len(new_route) > 1:\n                new_route.append(0)\n                new_solution.append(new_route)\n\n    # Ensure all nodes are included (in case of redistribution)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - all_nodes\n    if missing_nodes:\n        new_route = [0] + list(missing_nodes) + [0]\n        if sum(demand[list(missing_nodes)]) <= capacity:\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7493795510652569,
            0.6675693988800049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route splitting and 3-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to split or modify\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity for part1\n        if sum(demand[part1[1:-1]]) <= capacity:\n            new_solution.append(part1)\n        else:\n            # If capacity exceeded, try to redistribute nodes\n            new_route = [0]\n            current_load = 0\n            for node in part1[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, node]\n                    current_load = demand[node]\n            if len(new_route) > 1:\n                new_route.append(0)\n                new_solution.append(new_route)\n\n        # Check capacity for part2\n        if sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part2)\n        else:\n            new_route = [0]\n            current_load = 0\n            for node in part2[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, node]\n                    current_load = demand[node]\n            if len(new_route) > 1:\n                new_route.append(0)\n                new_solution.append(new_route)\n\n    # Ensure all nodes are included (in case of redistribution)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - all_nodes\n    if missing_nodes:\n        new_route = [0] + list(missing_nodes) + [0]\n        if sum(demand[list(missing_nodes)]) <= capacity:\n            new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    makespans = [obj[1] for obj in objectives]\n    probs = [1 / (m + 1e-6) for m in makespans]  # Inverse makespan bias\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Find the longest route\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Step 3: Attempt to split the longest route\n    split_success = False\n    for split_pos in range(2, len(longest_route)-2):  # Avoid trivial splits\n        first_part = longest_route[:split_pos+1]\n        second_part = np.array([0] + list(longest_route[split_pos+1:-1]) + [0])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n            split_success = True\n            return new_solution\n\n    # Step 4: If splitting fails, perform cross-route insertion\n    if not split_success:\n        # Select a random customer from the longest route (excluding depot)\n        customer_to_move = np.random.choice(longest_route[1:-1])\n        customer_demand = demand[customer_to_move]\n\n        # Find all possible insertion positions in other routes\n        possible_insertions = []\n        for i, route in enumerate(base_solution):\n            if i == longest_route_idx:\n                continue\n            for j in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + customer_demand <= capacity:\n                    possible_insertions.append((i, j))\n\n        if possible_insertions:\n            # Randomly select an insertion point\n            route_idx, pos = np.random.choice(len(possible_insertions), p=[1/len(possible_insertions)]*len(possible_insertions))\n            route_idx, pos = possible_insertions[route_idx]\n\n            # Perform insertion\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[longest_route_idx] = np.array([node for node in longest_route if node != customer_to_move])\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos, customer_to_move)\n\n            return new_solution\n\n    # If no improvement possible, return original solution\n    return base_solution\n\n",
        "score": [
            -0.7034019702155818,
            0.7209239602088928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    makespans = [obj[1] for obj in objectives]\n    probs = [1 / (m + 1e-6) for m in makespans]  # Inverse makespan bias\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Find the longest route\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Step 3: Attempt to split the longest route\n    split_success = False\n    for split_pos in range(2, len(longest_route)-2):  # Avoid trivial splits\n        first_part = longest_route[:split_pos+1]\n        second_part = np.array([0] + list(longest_route[split_pos+1:-1]) + [0])\n\n        # Check capacity constraints\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n            split_success = True\n            return new_solution\n\n    # Step 4: If splitting fails, perform cross-route insertion\n    if not split_success:\n        # Select a random customer from the longest route (excluding depot)\n        customer_to_move = np.random.choice(longest_route[1:-1])\n        customer_demand = demand[customer_to_move]\n\n        # Find all possible insertion positions in other routes\n        possible_insertions = []\n        for i, route in enumerate(base_solution):\n            if i == longest_route_idx:\n                continue\n            for j in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + customer_demand <= capacity:\n                    possible_insertions.append((i, j))\n\n        if possible_insertions:\n            # Randomly select an insertion point\n            route_idx, pos = np.random.choice(len(possible_insertions), p=[1/len(possible_insertions)]*len(possible_insertions))\n            route_idx, pos = possible_insertions[route_idx]\n\n            # Perform insertion\n            new_solution = [route.copy() for route in base_solution]\n            new_solution[longest_route_idx] = np.array([node for node in longest_route if node != customer_to_move])\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos, customer_to_move)\n\n            return new_solution\n\n    # If no improvement possible, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Split the route at a random point (excluding depot)\n    if len(selected_route) > 3:  # Need at least 3 nodes to split\n        split_pos = np.random.randint(1, len(selected_route)-1)\n        new_route1 = selected_route[:split_pos+1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints for the split\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Replace the original route with the two new routes\n            new_solution = [r.copy() for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n            # Relocate customers between routes to balance demand\n            for route in new_solution:\n                if len(route) > 3:  # Only consider routes with customers\n                    route_demand = np.sum(demand[route[1:-1]])\n                    excess = route_demand - capacity\n                    if excess > 0:\n                        # Find customers to remove to reduce excess\n                        customers = route[1:-1]\n                        np.random.shuffle(customers)\n                        for customer in customers:\n                            if excess <= 0:\n                                break\n                            customer_demand = demand[customer]\n                            if customer_demand <= excess:\n                                # Find another route to place this customer\n                                for other_route in new_solution:\n                                    if not np.array_equal(other_route, route):\n                                        if (np.sum(demand[other_route[1:-1]]) + customer_demand <= capacity):\n                                            # Move customer to other route\n                                            route = route[route != customer]\n                                            other_route = np.insert(other_route, -1, customer)\n                                            excess -= customer_demand\n                                            break\n            return new_solution\n\n    # If split failed, try relocating a customer between routes\n    if len(base_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = np.random.choice(len(base_solution), 2, replace=False)\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        if len(route1) > 3:  # At least one customer to move\n            # Select a random customer from route1\n            customer = np.random.choice(route1[1:-1])\n\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Create new routes\n                new_route1 = route1[route1 != customer]\n                new_route2 = np.insert(route2, -1, customer)\n\n                # Update solution\n                new_solution = [r.copy() for r in base_solution]\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.6273204931547716,
            0.6314153671264648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Split the route at a random point (excluding depot)\n    if len(selected_route) > 3:  # Need at least 3 nodes to split\n        split_pos = np.random.randint(1, len(selected_route)-1)\n        new_route1 = selected_route[:split_pos+1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints for the split\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Replace the original route with the two new routes\n            new_solution = [r.copy() for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n            # Relocate customers between routes to balance demand\n            for route in new_solution:\n                if len(route) > 3:  # Only consider routes with customers\n                    route_demand = np.sum(demand[route[1:-1]])\n                    excess = route_demand - capacity\n                    if excess > 0:\n                        # Find customers to remove to reduce excess\n                        customers = route[1:-1]\n                        np.random.shuffle(customers)\n                        for customer in customers:\n                            if excess <= 0:\n                                break\n                            customer_demand = demand[customer]\n                            if customer_demand <= excess:\n                                # Find another route to place this customer\n                                for other_route in new_solution:\n                                    if not np.array_equal(other_route, route):\n                                        if (np.sum(demand[other_route[1:-1]]) + customer_demand <= capacity):\n                                            # Move customer to other route\n                                            route = route[route != customer]\n                                            other_route = np.insert(other_route, -1, customer)\n                                            excess -= customer_demand\n                                            break\n            return new_solution\n\n    # If split failed, try relocating a customer between routes\n    if len(base_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = np.random.choice(len(base_solution), 2, replace=False)\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        if len(route1) > 3:  # At least one customer to move\n            # Select a random customer from route1\n            customer = np.random.choice(route1[1:-1])\n\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Create new routes\n                new_route1 = route1[route1 != customer]\n                new_route2 = np.insert(route2, -1, customer)\n\n                # Update solution\n                new_solution = [r.copy() for r in base_solution]\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If route has only depot, skip\n    if len(route) <= 2:\n        return selected_solution\n\n    # Hybrid local search: combine 2-opt with route splitting\n    # Step 1: Apply 2-opt on the selected route\n    improved_route = route.copy()\n    n = len(improved_route) - 1  # Exclude depot at end\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if j + 1 < len(improved_route):\n                # Check if swapping (i,j) with (i+1,j+1) improves distance\n                old_dist = distance_matrix[improved_route[i-1], improved_route[i]] + \\\n                           distance_matrix[improved_route[j], improved_route[j+1]]\n                new_dist = distance_matrix[improved_route[i-1], improved_route[j]] + \\\n                           distance_matrix[improved_route[i], improved_route[j+1]]\n\n                if new_dist < old_dist:\n                    # Reverse the segment between i and j\n                    improved_route[i:j+1] = np.flip(improved_route[i:j+1])\n\n    # Step 2: Check if splitting the route into two can improve makespan\n    total_demand = sum(demand[route[1:-1]])\n    if total_demand <= capacity * 2:  # Only split if feasible\n        best_split = None\n        min_max_length = float('inf')\n\n        for k in range(1, len(improved_route) - 1):\n            # Split into two routes\n            route1 = np.concatenate([[0], improved_route[1:k+1], [0]])\n            route2 = np.concatenate([[0], improved_route[k+1:-1], [0]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate makespan\n                length1 = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                length2 = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                max_length = max(length1, length2)\n\n                if max_length < min_max_length:\n                    min_max_length = max_length\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            # Replace original route with two split routes\n            new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n            new_solution.extend(best_split)\n            return new_solution\n\n    # If no improvement, return the 2-opt improved route\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = improved_route\n    return new_solution\n\n",
        "score": [
            -0.6506079377389231,
            1.8243586421012878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If route has only depot, skip\n    if len(route) <= 2:\n        return selected_solution\n\n    # Hybrid local search: combine 2-opt with route splitting\n    # Step 1: Apply 2-opt on the selected route\n    improved_route = route.copy()\n    n = len(improved_route) - 1  # Exclude depot at end\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if j + 1 < len(improved_route):\n                # Check if swapping (i,j) with (i+1,j+1) improves distance\n                old_dist = distance_matrix[improved_route[i-1], improved_route[i]] + \\\n                           distance_matrix[improved_route[j], improved_route[j+1]]\n                new_dist = distance_matrix[improved_route[i-1], improved_route[j]] + \\\n                           distance_matrix[improved_route[i], improved_route[j+1]]\n\n                if new_dist < old_dist:\n                    # Reverse the segment between i and j\n                    improved_route[i:j+1] = np.flip(improved_route[i:j+1])\n\n    # Step 2: Check if splitting the route into two can improve makespan\n    total_demand = sum(demand[route[1:-1]])\n    if total_demand <= capacity * 2:  # Only split if feasible\n        best_split = None\n        min_max_length = float('inf')\n\n        for k in range(1, len(improved_route) - 1):\n            # Split into two routes\n            route1 = np.concatenate([[0], improved_route[1:k+1], [0]])\n            route2 = np.concatenate([[0], improved_route[k+1:-1], [0]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate makespan\n                length1 = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                length2 = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                max_length = max(length1, length2)\n\n                if max_length < min_max_length:\n                    min_max_length = max_length\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            # Replace original route with two split routes\n            new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n            new_solution.extend(best_split)\n            return new_solution\n\n    # If no improvement, return the 2-opt improved route\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = improved_route\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This function selects a promising solution from the archive by prioritizing those with the lowest makespan or total distance, then applies a hybrid local search that combines route splitting, merging, and intra-route 2-opt with demand-aware swaps to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: route splitting, merging, and demand-aware 2-opt\n    new_solution = base_solution.copy()\n\n    # Step 1: Route splitting (if a route is too long)\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity * 0.7:  # If route is over 70% capacity, try splitting\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n    # Step 2: Route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n        total_demand = sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1])\n        if total_demand <= capacity:\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 3: Demand-aware 2-opt (intra-route optimization)\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check if swapping a and b reduces distance and maintains capacity\n            original_dist = distance_matrix[route[a-1], route[a]] + distance_matrix[route[b-1], route[b]] + distance_matrix[route[a], route[b-1]] + distance_matrix[route[b], route[a+1]]\n            new_dist = distance_matrix[route[a-1], route[b]] + distance_matrix[route[b-1], route[a]] + distance_matrix[route[a], route[b-1]] + distance_matrix[route[b], route[a+1]]\n            if new_dist < original_dist:\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in route[a:b])\n                if (sum(demand[node] for node in route[1:a]) + sum(demand[node] for node in route[b:-1]) + segment_demand <= capacity and\n                    sum(demand[node] for node in route[1:a]) + segment_demand + sum(demand[node] for node in route[b+1:-1]) <= capacity):\n                    route[a:b] = route[b-1:a-1:-1]  # Reverse the segment\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If a route becomes infeasible, split it\n            cumulative_demand = 0\n            split_pos = 1\n            for i, node in enumerate(route[1:-1]):\n                cumulative_demand += demand[node]\n                if cumulative_demand > capacity:\n                    split_pos = i + 1\n                    break\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n            idx = new_solution.index(route)\n            new_solution[idx] = new_route1\n            new_solution.insert(idx + 1, new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.44851548617385717,
            2.5978493988513947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: route splitting, merging, and demand-aware 2-opt\n    new_solution = base_solution.copy()\n\n    # Step 1: Route splitting (if a route is too long)\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity * 0.7:  # If route is over 70% capacity, try splitting\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n    # Step 2: Route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n        total_demand = sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1])\n        if total_demand <= capacity:\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 3: Demand-aware 2-opt (intra-route optimization)\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            # Check if swapping a and b reduces distance and maintains capacity\n            original_dist = distance_matrix[route[a-1], route[a]] + distance_matrix[route[b-1], route[b]] + distance_matrix[route[a], route[b-1]] + distance_matrix[route[b], route[a+1]]\n            new_dist = distance_matrix[route[a-1], route[b]] + distance_matrix[route[b-1], route[a]] + distance_matrix[route[a], route[b-1]] + distance_matrix[route[b], route[a+1]]\n            if new_dist < original_dist:\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in route[a:b])\n                if (sum(demand[node] for node in route[1:a]) + sum(demand[node] for node in route[b:-1]) + segment_demand <= capacity and\n                    sum(demand[node] for node in route[1:a]) + segment_demand + sum(demand[node] for node in route[b+1:-1]) <= capacity):\n                    route[a:b] = route[b-1:a-1:-1]  # Reverse the segment\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If a route becomes infeasible, split it\n            cumulative_demand = 0\n            split_pos = 1\n            for i, node in enumerate(route[1:-1]):\n                cumulative_demand += demand[node]\n                if cumulative_demand > capacity:\n                    split_pos = i + 1\n                    break\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n            idx = new_solution.index(route)\n            new_solution[idx] = new_route1\n            new_solution.insert(idx + 1, new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        return None\n\n    # Select a solution with the smallest makespan (promising for balancing routes)\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting heuristic, then apply a cross-route 2-opt\n    new_solution = selected_solution.copy()\n\n    # Route-splitting heuristic: split the longest route into two if possible\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure it's not just depot-depot\n        # Find the split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n\n        for i in range(1, len(longest_route) - 1):\n            # Split into [0, ..., i, 0] and [0, i, ..., 0]\n            route1 = np.concatenate((longest_route[:i+1], [0]))\n            route2 = np.concatenate(([0], longest_route[i:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n\n                # Calculate the increase in total distance\n                increase = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_split = i\n\n        if best_split is not None:\n            # Apply the best split\n            route1 = np.concatenate((longest_route[:best_split+1], [0]))\n            route2 = np.concatenate(([0], longest_route[best_split:]))\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n\n    # Cross-route 2-opt: try to swap segments between routes\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depots)\n        if len(route1) > 3 and len(route2) > 3:\n            i1, j1 = sorted(random.sample(range(1, len(route1)-1), 2))\n            i2, j2 = sorted(random.sample(range(1, len(route2)-1), 2))\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate((route1[:i1], route2[i2:j2+1], route1[j1+1:]))\n            new_route2 = np.concatenate((route2[:i2], route1[i1:j1+1], route2[j2+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.849458238383296,
            1.2943897545337677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        return None\n\n    # Select a solution with the smallest makespan (promising for balancing routes)\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting heuristic, then apply a cross-route 2-opt\n    new_solution = selected_solution.copy()\n\n    # Route-splitting heuristic: split the longest route into two if possible\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure it's not just depot-depot\n        # Find the split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n\n        for i in range(1, len(longest_route) - 1):\n            # Split into [0, ..., i, 0] and [0, i, ..., 0]\n            route1 = np.concatenate((longest_route[:i+1], [0]))\n            route2 = np.concatenate(([0], longest_route[i:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n\n                # Calculate the increase in total distance\n                increase = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_split = i\n\n        if best_split is not None:\n            # Apply the best split\n            route1 = np.concatenate((longest_route[:best_split+1], [0]))\n            route2 = np.concatenate(([0], longest_route[best_split:]))\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n\n    # Cross-route 2-opt: try to swap segments between routes\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depots)\n        if len(route1) > 3 and len(route2) > 3:\n            i1, j1 = sorted(random.sample(range(1, len(route1)-1), 2))\n            i2, j2 = sorted(random.sample(range(1, len(route2)-1), 2))\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate((route1[:i1], route2[i2:j2+1], route1[j1+1:]))\n            new_route2 = np.concatenate((route2[:i2], route1[i1:j1+1], route2[j2+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of objective values and route diversity, then applies a novel route-splitting and merging operator that intelligently redistributes customers between routes while preserving feasibility, balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for obj in archive_objectives])\n    makespans = np.array([obj[1] for obj in archive_objectives])\n\n    if len(distances) > 0:\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        scores = 0.7 * norm_distances + 0.3 * norm_makespans  # Prefer solutions with better makespan\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware redistribution\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find split points that maintain feasibility\n        split1 = random.randint(1, len(route1) - 1)\n        split2 = random.randint(1, len(route2) - 1)\n\n        # Calculate demands for potential new routes\n        demand1 = np.sum(demand[route1[split1:-1]])  # Exclude depot\n        demand2 = np.sum(demand[route2[split2:-1]])  # Exclude depot\n\n        # Try to merge routes if capacity allows\n        if demand1 + demand2 <= capacity:\n            # Create new merged route\n            merged_route = np.concatenate([route1[:split1], route2[split2:-1], route1[-1:]])\n\n            # Replace the two routes with the new merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # If merging fails, try to redistribute customers\n            # Find customers that can be moved from route1 to route2\n            candidates = route1[split1:-1]\n            for customer in candidates:\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route1 and add to route2\n                    route1 = np.concatenate([route1[:split1], route1[split1+1:]])\n                    route2 = np.concatenate([route2[:split2], [customer], route2[split2:]])\n\n                    # Update the solution\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6098975482869423,
            0.7139224112033844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for obj in archive_objectives])\n    makespans = np.array([obj[1] for obj in archive_objectives])\n\n    if len(distances) > 0:\n        norm_distances = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-8)\n        norm_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n        scores = 0.7 * norm_distances + 0.3 * norm_makespans  # Prefer solutions with better makespan\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware redistribution\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find split points that maintain feasibility\n        split1 = random.randint(1, len(route1) - 1)\n        split2 = random.randint(1, len(route2) - 1)\n\n        # Calculate demands for potential new routes\n        demand1 = np.sum(demand[route1[split1:-1]])  # Exclude depot\n        demand2 = np.sum(demand[route2[split2:-1]])  # Exclude depot\n\n        # Try to merge routes if capacity allows\n        if demand1 + demand2 <= capacity:\n            # Create new merged route\n            merged_route = np.concatenate([route1[:split1], route2[split2:-1], route1[-1:]])\n\n            # Replace the two routes with the new merged one\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # If merging fails, try to redistribute customers\n            # Find customers that can be moved from route1 to route2\n            candidates = route1[split1:-1]\n            for customer in candidates:\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route1 and add to route2\n                    route1 = np.concatenate([route1[:split1], route1[split1+1:]])\n                    route2 = np.concatenate([route2[:split2], [customer], route2[split2:]])\n\n                    # Update the solution\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for the split\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break\n\n    # Customer reallocation: move a random customer from one route to another\n    if len(new_solution) >= 2:\n        src_route_idx = np.random.randint(0, len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a customer to move\n            customer_idx = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_idx]\n\n            # Try to insert the customer into another route\n            for dest_route_idx in range(len(new_solution)):\n                if dest_route_idx == src_route_idx:\n                    continue\n                dest_route = new_solution[dest_route_idx]\n\n                # Find the best insertion point in the destination route\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(dest_route)):\n                    # Calculate the increase in distance and makespan\n                    prev_node = dest_route[pos - 1]\n                    next_node = dest_route[pos]\n                    increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if increase < min_increase and np.sum(demand[dest_route[1:-1]]) + demand[customer] <= capacity:\n                        min_increase = increase\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Insert the customer into the best position\n                    new_dest_route = np.insert(dest_route, best_pos, customer)\n                    new_solution[dest_route_idx] = new_dest_route\n\n                    # Remove the customer from the source route\n                    new_src_route = np.delete(src_route, customer_idx)\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7829008384453119,
            0.4667511284351349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for the split\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break\n\n    # Customer reallocation: move a random customer from one route to another\n    if len(new_solution) >= 2:\n        src_route_idx = np.random.randint(0, len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a customer to move\n            customer_idx = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_idx]\n\n            # Try to insert the customer into another route\n            for dest_route_idx in range(len(new_solution)):\n                if dest_route_idx == src_route_idx:\n                    continue\n                dest_route = new_solution[dest_route_idx]\n\n                # Find the best insertion point in the destination route\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(dest_route)):\n                    # Calculate the increase in distance and makespan\n                    prev_node = dest_route[pos - 1]\n                    next_node = dest_route[pos]\n                    increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if increase < min_increase and np.sum(demand[dest_route[1:-1]]) + demand[customer] <= capacity:\n                        min_increase = increase\n                        best_pos = pos\n\n                if best_pos != -1:\n                    # Insert the customer into the best position\n                    new_dest_route = np.insert(dest_route, best_pos, customer)\n                    new_solution[dest_route_idx] = new_dest_route\n\n                    # Remove the customer from the source route\n                    new_src_route = np.delete(src_route, customer_idx)\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement by considering both objective values and spatial distribution of customers, then applies a hybrid local search combining route fragmentation and adaptive insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation and adaptive insertion\n    if len(new_solution) > 1:\n        # Select a random route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Find a split point that balances distance and makespan\n        if len(selected_route) > 3:  # At least 3 nodes (depot + 1 customer + depot)\n            # Calculate cumulative distances and demands\n            cum_dist = np.cumsum([distance_matrix[selected_route[i-1]][selected_route[i]] for i in range(1, len(selected_route))])\n            cum_demand = np.cumsum([demand[node] for node in selected_route[1:-1]])\n\n            # Find a good split point (balance distance and demand)\n            split_pos = 1\n            min_diff = float('inf')\n            for i in range(1, len(selected_route)-1):\n                dist_diff = abs(cum_dist[i-1] - (cum_dist[-1] - cum_dist[i-1]))\n                demand_diff = abs(cum_demand[i-1] - (cum_demand[-1] - cum_demand[i-1]))\n                total_diff = dist_diff + demand_diff\n                if total_diff < min_diff:\n                    min_diff = total_diff\n                    split_pos = i\n\n            # Split the route\n            first_part = selected_route[:split_pos+1]\n            second_part = selected_route[split_pos:]\n\n            # Insert the split point back into the solution\n            if random.random() < 0.5:  # 50% chance to keep original route\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Adaptive insertion: try to insert into other routes\n                for i, route in enumerate(new_solution):\n                    if i != route_idx and sum(demand[node] for node in second_part[1:-1]) <= capacity:\n                        # Check if insertion is feasible\n                        total_demand = sum(demand[node] for node in route[1:-1])\n                        if total_demand + sum(demand[node] for node in second_part[1:-1]) <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            min_cost = float('inf')\n                            for pos in range(1, len(route)):\n                                cost = (distance_matrix[route[pos-1]][second_part[1]] +\n                                       distance_matrix[second_part[-2]][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n                            # Perform insertion\n                            new_route = np.concatenate((route[:best_pos], second_part[1:], route[best_pos:]))\n                            new_solution[i] = new_route\n                            new_solution[route_idx] = first_part\n                            break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original route\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6774662188279765,
            0.9676916301250458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation and adaptive insertion\n    if len(new_solution) > 1:\n        # Select a random route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Find a split point that balances distance and makespan\n        if len(selected_route) > 3:  # At least 3 nodes (depot + 1 customer + depot)\n            # Calculate cumulative distances and demands\n            cum_dist = np.cumsum([distance_matrix[selected_route[i-1]][selected_route[i]] for i in range(1, len(selected_route))])\n            cum_demand = np.cumsum([demand[node] for node in selected_route[1:-1]])\n\n            # Find a good split point (balance distance and demand)\n            split_pos = 1\n            min_diff = float('inf')\n            for i in range(1, len(selected_route)-1):\n                dist_diff = abs(cum_dist[i-1] - (cum_dist[-1] - cum_dist[i-1]))\n                demand_diff = abs(cum_demand[i-1] - (cum_demand[-1] - cum_demand[i-1]))\n                total_diff = dist_diff + demand_diff\n                if total_diff < min_diff:\n                    min_diff = total_diff\n                    split_pos = i\n\n            # Split the route\n            first_part = selected_route[:split_pos+1]\n            second_part = selected_route[split_pos:]\n\n            # Insert the split point back into the solution\n            if random.random() < 0.5:  # 50% chance to keep original route\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Adaptive insertion: try to insert into other routes\n                for i, route in enumerate(new_solution):\n                    if i != route_idx and sum(demand[node] for node in second_part[1:-1]) <= capacity:\n                        # Check if insertion is feasible\n                        total_demand = sum(demand[node] for node in route[1:-1])\n                        if total_demand + sum(demand[node] for node in second_part[1:-1]) <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            min_cost = float('inf')\n                            for pos in range(1, len(route)):\n                                cost = (distance_matrix[route[pos-1]][second_part[1]] +\n                                       distance_matrix[second_part[-2]][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n                            # Perform insertion\n                            new_route = np.concatenate((route[:best_pos], second_part[1:], route[best_pos:]))\n                            new_solution[i] = new_route\n                            new_solution[route_idx] = first_part\n                            break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original route\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])  # Prioritize solutions with poor performance\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split long routes, reallocate customers, and optimize partial routes\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip if route is too short\n            # Step 1: Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Step 2: Reallocate customers from part2 to other routes or create a new route\n            temp_demand = np.sum(demand[part2[1:-1]])\n            for j, other_route in enumerate(base_solution):\n                if i != j and np.sum(demand[other_route[1:-1]]) + temp_demand <= capacity:\n                    # Merge part2 with another route\n                    new_route = np.concatenate((other_route[:-1], part2[1:]))\n                    new_solution[j] = new_route\n                    new_solution[i] = part1\n                    break\n\n            # Step 3: Optimize the split routes using partial 2-opt\n            for _ in range(2):  # Limit iterations for efficiency\n                r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n                route1 = new_solution[r1]\n                route2 = new_solution[r2]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Swap segments between routes\n                    idx1 = np.random.randint(1, len(route1) - 1)\n                    idx2 = np.random.randint(1, len(route2) - 1)\n\n                    # Check capacity constraints\n                    demand1 = np.sum(demand[route1[1:-1]])\n                    demand2 = np.sum(demand[route2[1:-1]])\n                    swapped_demand1 = demand1 - demand[route1[idx1]] + demand[route2[idx2]]\n                    swapped_demand2 = demand2 - demand[route2[idx2]] + demand[route1[idx1]]\n\n                    if swapped_demand1 <= capacity and swapped_demand2 <= capacity:\n                        # Perform the swap\n                        new_route1 = np.concatenate((route1[:idx1], [route2[idx2]], route1[idx1+1:]))\n                        new_route2 = np.concatenate((route2[:idx2], [route1[idx1]], route2[idx2+1:]))\n                        new_solution[r1] = new_route1\n                        new_solution[r2] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7467946074654708,
            5.061039507389069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])  # Prioritize solutions with poor performance\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split long routes, reallocate customers, and optimize partial routes\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip if route is too short\n            # Step 1: Split the route into two parts at a random point\n            split_idx = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:]\n\n            # Step 2: Reallocate customers from part2 to other routes or create a new route\n            temp_demand = np.sum(demand[part2[1:-1]])\n            for j, other_route in enumerate(base_solution):\n                if i != j and np.sum(demand[other_route[1:-1]]) + temp_demand <= capacity:\n                    # Merge part2 with another route\n                    new_route = np.concatenate((other_route[:-1], part2[1:]))\n                    new_solution[j] = new_route\n                    new_solution[i] = part1\n                    break\n\n            # Step 3: Optimize the split routes using partial 2-opt\n            for _ in range(2):  # Limit iterations for efficiency\n                r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n                route1 = new_solution[r1]\n                route2 = new_solution[r2]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Swap segments between routes\n                    idx1 = np.random.randint(1, len(route1) - 1)\n                    idx2 = np.random.randint(1, len(route2) - 1)\n\n                    # Check capacity constraints\n                    demand1 = np.sum(demand[route1[1:-1]])\n                    demand2 = np.sum(demand[route2[1:-1]])\n                    swapped_demand1 = demand1 - demand[route1[idx1]] + demand[route2[idx2]]\n                    swapped_demand2 = demand2 - demand[route2[idx2]] + demand[route1[idx1]]\n\n                    if swapped_demand1 <= capacity and swapped_demand2 <= capacity:\n                        # Perform the swap\n                        new_route1 = np.concatenate((route1[:idx1], [route2[idx2]], route1[idx1+1:]))\n                        new_route2 = np.concatenate((route2[:idx2], [route1[idx1]], route2[idx2+1:]))\n                        new_solution[r1] = new_route1\n                        new_solution[r2] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: try merging two routes, splitting a route, or cross-route relocation\n    if len(new_solution) > 1:\n        # Try merging two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merged route is feasible\n        total_demand = sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j) - 2 * demand[0]\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [new_solution[k] for k in range(len(new_solution)) if k != i and k != j] + [merged_route]\n            return new_solution\n\n    # Try splitting a route into two\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure split is possible\n            split_pos = np.random.randint(1, len(route) - 1)\n            route1 = route[:split_pos + 1]\n            route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in route1) - demand[0]\n            demand2 = sum(demand[node] for node in route2) - demand[0]\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution = [new_solution[k] for k in range(len(new_solution)) if k != route_idx] + [route1, route2]\n                return new_solution\n\n    # Try cross-route relocation\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select a customer from route_i and insert into route_j\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if relocation is feasible\n            new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n            new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n            demand_i = sum(demand[node] for node in new_route_i) - demand[0]\n            demand_j = sum(demand[node] for node in new_route_j) - demand[0]\n\n            if demand_i <= capacity and demand_j <= capacity:\n                new_solution = [new_solution[k] for k in range(len(new_solution)) if k != i and k != j] + [new_route_i, new_route_j]\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7804288755909974,
            0.2186243236064911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: try merging two routes, splitting a route, or cross-route relocation\n    if len(new_solution) > 1:\n        # Try merging two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merged route is feasible\n        total_demand = sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j) - 2 * demand[0]\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [new_solution[k] for k in range(len(new_solution)) if k != i and k != j] + [merged_route]\n            return new_solution\n\n    # Try splitting a route into two\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure split is possible\n            split_pos = np.random.randint(1, len(route) - 1)\n            route1 = route[:split_pos + 1]\n            route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in route1) - demand[0]\n            demand2 = sum(demand[node] for node in route2) - demand[0]\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution = [new_solution[k] for k in range(len(new_solution)) if k != route_idx] + [route1, route2]\n                return new_solution\n\n    # Try cross-route relocation\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Select a customer from route_i and insert into route_j\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if relocation is feasible\n            new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n            new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n            demand_i = sum(demand[node] for node in new_route_i) - demand[0]\n            demand_j = sum(demand[node] for node in new_route_j) - demand[0]\n\n            if demand_i <= capacity and demand_j <= capacity:\n                new_solution = [new_solution[k] for k in range(len(new_solution)) if k != i and k != j] + [new_route_i, new_route_j]\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route concatenation with a capacity-aware insertion heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: concatenate two routes and re-optimize\n    if len(selected_solution) > 1:\n        # Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Concatenate the two routes (excluding depots)\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Try to re-insert nodes into feasible routes\n        new_solution = []\n        current_route = [0]\n        current_load = 0\n\n        for node in combined_route[1:-1]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n        # Remove empty routes (if any)\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # If no improvement, return original\n        if len(new_solution) >= len(selected_solution):\n            return selected_solution\n        return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.755821012199539,
            0.09714493155479431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: concatenate two routes and re-optimize\n    if len(selected_solution) > 1:\n        # Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Concatenate the two routes (excluding depots)\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Try to re-insert nodes into feasible routes\n        new_solution = []\n        current_route = [0]\n        current_load = 0\n\n        for node in combined_route[1:-1]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n        # Remove empty routes (if any)\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # If no improvement, return original\n        if len(new_solution) >= len(selected_solution):\n            return selected_solution\n        return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route concatenation with a capacity-aware insertion heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: concatenate two routes and re-optimize\n    if len(selected_solution) > 1:\n        # Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Concatenate the two routes (excluding depots)\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Try to re-insert nodes into feasible routes\n        new_solution = []\n        current_route = [0]\n        current_load = 0\n\n        for node in combined_route[1:-1]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n        # Remove empty routes (if any)\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # If no improvement, return original\n        if len(new_solution) >= len(selected_solution):\n            return selected_solution\n        return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.755821012199539,
            0.09714493155479431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: concatenate two routes and re-optimize\n    if len(selected_solution) > 1:\n        # Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(selected_solution)), 2)\n        route1 = selected_solution[route1_idx]\n        route2 = selected_solution[route2_idx]\n\n        # Concatenate the two routes (excluding depots)\n        combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Try to re-insert nodes into feasible routes\n        new_solution = []\n        current_route = [0]\n        current_load = 0\n\n        for node in combined_route[1:-1]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n        # Remove empty routes (if any)\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # If no improvement, return original\n        if len(new_solution) >= len(selected_solution):\n            return selected_solution\n        return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the smallest makespan (most promising for route balancing)\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify (avoid depot routes)\n    routes_to_modify = [i for i, route in enumerate(new_solution) if len(route) > 2]\n    if not routes_to_modify:\n        return new_solution\n    route_idx = np.random.choice(routes_to_modify)\n    route = new_solution[route_idx]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    # Step 1: Split the route at a random point if it's long enough\n    if len(route) > 4:\n        split_pos = np.random.randint(2, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos + 1:]\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n        else:\n            # Step 2: If split fails, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                for i, other_route in enumerate(new_solution):\n                    if i != route_idx:\n                        temp_route = other_route.copy()\n                        temp_route.insert(-1, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[i] = temp_route\n                            route = np.delete(route, np.where(route == customer)[0][0])\n                            break\n                if len(route) < 3:\n                    break\n            new_solution[route_idx] = route\n\n    # Step 3: Optimize the selected route with a modified 2-opt (avoiding pure 2-opt)\n    if len(route) > 3:\n        for _ in range(2):  # Limit iterations to avoid excessive computation\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = route.copy()\n            new_route[i:j+1] = route[j:i-1:-1]  # Reverse segment\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route = new_route\n\n    new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.782753600036326,
            0.6822446584701538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the smallest makespan (most promising for route balancing)\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify (avoid depot routes)\n    routes_to_modify = [i for i, route in enumerate(new_solution) if len(route) > 2]\n    if not routes_to_modify:\n        return new_solution\n    route_idx = np.random.choice(routes_to_modify)\n    route = new_solution[route_idx]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    # Step 1: Split the route at a random point if it's long enough\n    if len(route) > 4:\n        split_pos = np.random.randint(2, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos + 1:]\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n        else:\n            # Step 2: If split fails, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                for i, other_route in enumerate(new_solution):\n                    if i != route_idx:\n                        temp_route = other_route.copy()\n                        temp_route.insert(-1, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[i] = temp_route\n                            route = np.delete(route, np.where(route == customer)[0][0])\n                            break\n                if len(route) < 3:\n                    break\n            new_solution[route_idx] = route\n\n    # Step 3: Optimize the selected route with a modified 2-opt (avoiding pure 2-opt)\n    if len(route) > 3:\n        for _ in range(2):  # Limit iterations to avoid excessive computation\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = route.copy()\n            new_route[i:j+1] = route[j:i-1:-1]  # Reverse segment\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route = new_route\n\n    new_solution[route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][1])\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 2)]\n    selected_solution = random.choice(candidate_solutions)[0]\n\n    # Hybrid local search: merge two random routes and reverse a segment in the merged route\n    if len(selected_solution) > 1:\n        # Select two routes to merge\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[i], selected_solution[j]\n\n        # Merge the two routes while maintaining feasibility\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n        # Check capacity constraint for the merged route\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Apply partial route reversal to improve distance\n            if len(merged_route) > 3:\n                start, end = sorted(random.sample(range(1, len(merged_route)-1), 2))\n                merged_route[start:end+1] = merged_route[start:end+1][::-1]\n\n            # Replace the two routes with the merged route\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n        else:\n            # If merging fails, try reversing a segment in one route\n            new_solution = selected_solution.copy()\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx].copy()\n            if len(route) > 3:\n                start, end = sorted(random.sample(range(1, len(route)-1), 2))\n                route[start:end+1] = route[start:end+1][::-1]\n                new_solution[route_idx] = route\n    else:\n        # If only one route exists, apply partial reversal\n        new_solution = selected_solution.copy()\n        route = new_solution[0].copy()\n        if len(route) > 3:\n            start, end = sorted(random.sample(range(1, len(route)-1), 2))\n            route[start:end+1] = route[start:end+1][::-1]\n            new_solution[0] = route\n\n    return new_solution\n\n",
        "score": [
            -0.33071836732609516,
            0.6422398686408997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][1])\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 2)]\n    selected_solution = random.choice(candidate_solutions)[0]\n\n    # Hybrid local search: merge two random routes and reverse a segment in the merged route\n    if len(selected_solution) > 1:\n        # Select two routes to merge\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[i], selected_solution[j]\n\n        # Merge the two routes while maintaining feasibility\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n        # Check capacity constraint for the merged route\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Apply partial route reversal to improve distance\n            if len(merged_route) > 3:\n                start, end = sorted(random.sample(range(1, len(merged_route)-1), 2))\n                merged_route[start:end+1] = merged_route[start:end+1][::-1]\n\n            # Replace the two routes with the merged route\n            new_solution = [r for idx, r in enumerate(selected_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n        else:\n            # If merging fails, try reversing a segment in one route\n            new_solution = selected_solution.copy()\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx].copy()\n            if len(route) > 3:\n                start, end = sorted(random.sample(range(1, len(route)-1), 2))\n                route[start:end+1] = route[start:end+1][::-1]\n                new_solution[route_idx] = route\n    else:\n        # If only one route exists, apply partial reversal\n        new_solution = selected_solution.copy()\n        route = new_solution[0].copy()\n        if len(route) > 3:\n            start, end = sorted(random.sample(range(1, len(route)-1), 2))\n            route[start:end+1] = route[start:end+1][::-1]\n            new_solution[0] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: Route splitting, customer reallocation, and adaptive 2-opt\n    new_solution = selected.copy()\n\n    # Step 1: Route splitting (if a route is too long)\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n\n        customer = random.choice(route1[1:-1])\n        route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n        route2 = new_solution[route2_idx]\n\n        # Check if adding customer to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Remove customer from route1\n            route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n            # Insert customer into route2 (random position)\n            insert_pos = random.randint(1, len(route2)-1)\n            route2 = np.insert(route2, insert_pos, customer)\n\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    # Step 3: Adaptive 2-opt (focus on reducing makespan or total distance)\n    for _ in range(3):  # Try a few times\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to reverse\n        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    assert served_customers == all_customers, \"Not all customers are served!\"\n\n    return new_solution\n\n",
        "score": [
            -0.7978035680310023,
            3.4076752066612244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: Route splitting, customer reallocation, and adaptive 2-opt\n    new_solution = selected.copy()\n\n    # Step 1: Route splitting (if a route is too long)\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Skip trivial routes\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 2:\n            continue\n\n        customer = random.choice(route1[1:-1])\n        route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n        route2 = new_solution[route2_idx]\n\n        # Check if adding customer to route2 is feasible\n        if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Remove customer from route1\n            route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n            # Insert customer into route2 (random position)\n            insert_pos = random.randint(1, len(route2)-1)\n            route2 = np.insert(route2, insert_pos, customer)\n\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    # Step 3: Adaptive 2-opt (focus on reducing makespan or total distance)\n    for _ in range(3):  # Try a few times\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to reverse\n        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    assert served_customers == all_customers, \"Not all customers are served!\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route restructuring, demand-aware node swaps, and capacity-constrained route merges to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute combined score\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    combined_scores = 0.7 * norm_total + 0.3 * norm_makespan  # More weight on total distance\n    probabilities = np.exp(-combined_scores)  # Prefer lower scores\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_operator():\n        nonlocal new_solution\n\n        # Operator 1: Route Restructuring (combine or split routes with demand awareness)\n        if len(new_solution) > 1 and random.random() < 0.5:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Try to merge routes if capacity allows\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = np.sum(demand[merged_route[1:-1]])\n\n            if total_demand <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Operator 2: Demand-Aware Node Swap (consider both distance and demand balance)\n        if len(new_solution) > 0:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Need at least 3 nodes to swap\n                i, j = random.sample(range(1, len(route)-1), 2)\n\n                # Check capacity constraints after swap\n                current_demand = demand[route[i]] + demand[route[j]]\n                if current_demand <= capacity:\n                    # Swap nodes\n                    route[i], route[j] = route[j], route[i]\n\n        # Operator 3: Capacity-Constrained Route Insertion (move nodes between routes)\n        if len(new_solution) > 1 and random.random() < 0.3:\n            from_route_idx, to_route_idx = random.sample(range(len(new_solution)), 2)\n            from_route = new_solution[from_route_idx]\n            to_route = new_solution[to_route_idx]\n\n            if len(from_route) > 3:  # Need at least 3 nodes to move\n                node_pos = random.randint(1, len(from_route)-2)\n                node = from_route[node_pos]\n\n                # Check capacity constraints\n                if demand[node] + np.sum(demand[to_route[1:-1]]) <= capacity:\n                    # Insert node into to_route\n                    insert_pos = random.randint(1, len(to_route)-1)\n                    to_route = np.insert(to_route, insert_pos, node)\n\n                    # Remove node from from_route\n                    from_route = np.delete(from_route, node_pos)\n\n                    # Update routes\n                    new_solution[from_route_idx] = from_route\n                    new_solution[to_route_idx] = to_route\n\n    # Apply the operator multiple times for better exploration\n    for _ in range(3):\n        apply_operator()\n\n    return new_solution\n\n",
        "score": [
            -0.5079784716067286,
            1.0458534061908722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute combined score\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    combined_scores = 0.7 * norm_total + 0.3 * norm_makespan  # More weight on total distance\n    probabilities = np.exp(-combined_scores)  # Prefer lower scores\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_operator():\n        nonlocal new_solution\n\n        # Operator 1: Route Restructuring (combine or split routes with demand awareness)\n        if len(new_solution) > 1 and random.random() < 0.5:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Try to merge routes if capacity allows\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = np.sum(demand[merged_route[1:-1]])\n\n            if total_demand <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Operator 2: Demand-Aware Node Swap (consider both distance and demand balance)\n        if len(new_solution) > 0:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Need at least 3 nodes to swap\n                i, j = random.sample(range(1, len(route)-1), 2)\n\n                # Check capacity constraints after swap\n                current_demand = demand[route[i]] + demand[route[j]]\n                if current_demand <= capacity:\n                    # Swap nodes\n                    route[i], route[j] = route[j], route[i]\n\n        # Operator 3: Capacity-Constrained Route Insertion (move nodes between routes)\n        if len(new_solution) > 1 and random.random() < 0.3:\n            from_route_idx, to_route_idx = random.sample(range(len(new_solution)), 2)\n            from_route = new_solution[from_route_idx]\n            to_route = new_solution[to_route_idx]\n\n            if len(from_route) > 3:  # Need at least 3 nodes to move\n                node_pos = random.randint(1, len(from_route)-2)\n                node = from_route[node_pos]\n\n                # Check capacity constraints\n                if demand[node] + np.sum(demand[to_route[1:-1]]) <= capacity:\n                    # Insert node into to_route\n                    insert_pos = random.randint(1, len(to_route)-1)\n                    to_route = np.insert(to_route, insert_pos, node)\n\n                    # Remove node from from_route\n                    from_route = np.delete(from_route, node_pos)\n\n                    # Update routes\n                    new_solution[from_route_idx] = from_route\n                    new_solution[to_route_idx] = to_route\n\n    # Apply the operator multiple times for better exploration\n    for _ in range(3):\n        apply_operator()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan, then applies a hybrid local search combining a modified 2-opt with a route-splitting heuristic to generate a neighbor solution while ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Modified 2-opt with route-splitting\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in selected_solution]\n\n    # Randomly select two routes to modify\n    if len(routes) > 1:\n        i, j = random.sample(range(len(routes)), 2)\n        route1, route2 = routes[i], routes[j]\n\n        # Try to merge two routes if feasible\n        merged = np.concatenate((route1[:-1], route2[1:]))\n        if sum(demand[merged[1:-1]]) <= capacity:\n            routes[i] = merged\n            del routes[j]\n\n        # Perform a modified 2-opt within a route\n        else:\n            for route in routes:\n                if len(route) > 4:  # Ensure enough nodes to swap\n                    a, b = random.sample(range(1, len(route)-1), 2)\n                    if a > b:\n                        a, b = b, a\n                    # Attempt to swap segments and check feasibility\n                    new_segment = route[a:b+1][::-1]\n                    temp_route = np.concatenate((route[:a], new_segment, route[b+1:]))\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        route[:] = temp_route\n\n    new_solution = [route.copy() for route in routes]\n    return new_solution\n\n",
        "score": [
            -0.6960077766211039,
            1.150439828634262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Modified 2-opt with route-splitting\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in selected_solution]\n\n    # Randomly select two routes to modify\n    if len(routes) > 1:\n        i, j = random.sample(range(len(routes)), 2)\n        route1, route2 = routes[i], routes[j]\n\n        # Try to merge two routes if feasible\n        merged = np.concatenate((route1[:-1], route2[1:]))\n        if sum(demand[merged[1:-1]]) <= capacity:\n            routes[i] = merged\n            del routes[j]\n\n        # Perform a modified 2-opt within a route\n        else:\n            for route in routes:\n                if len(route) > 4:  # Ensure enough nodes to swap\n                    a, b = random.sample(range(1, len(route)-1), 2)\n                    if a > b:\n                        a, b = b, a\n                    # Attempt to swap segments and check feasibility\n                    new_segment = route[a:b+1][::-1]\n                    temp_route = np.concatenate((route[:a], new_segment, route[b+1:]))\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        route[:] = temp_route\n\n    new_solution = [route.copy() for route in routes]\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route merging\n    if len(route) > 4:  # Only perform if route has enough nodes\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n    # Attempt to merge this route with another if it's short\n    if len(route) <= 5 and len(base_solution) > 1:\n        other_idx = np.random.randint(0, len(base_solution))\n        if other_idx != route_idx:\n            other_route = base_solution[other_idx].copy()\n            combined_route = np.concatenate([route[:-1], other_route[1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                base_solution[route_idx] = combined_route\n                base_solution.pop(other_idx)\n\n    # Apply a cross-route relocation to balance makespan\n    if len(base_solution) > 1:\n        # Select a random customer from a random route\n        src_route_idx = np.random.randint(0, len(base_solution))\n        src_route = base_solution[src_route_idx].copy()\n        if len(src_route) > 3:  # Only if route has enough nodes\n            cust_idx = np.random.randint(1, len(src_route)-1)\n            customer = src_route[cust_idx]\n\n            # Try inserting into another route\n            for _ in range(3):  # Try 3 times\n                dest_route_idx = np.random.randint(0, len(base_solution))\n                if dest_route_idx != src_route_idx:\n                    dest_route = base_solution[dest_route_idx].copy()\n\n                    # Find best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(dest_route)):\n                        new_dest_route = np.insert(dest_route, pos, customer)\n                        if np.sum(demand[new_dest_route[1:-1]]) <= capacity:\n                            increase = (distance_matrix[dest_route[pos-1], customer] +\n                                      distance_matrix[customer, dest_route[pos]] -\n                                      distance_matrix[dest_route[pos-1], dest_route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n\n                    if min_increase < float('inf'):\n                        # Perform the relocation\n                        new_dest_route = np.insert(dest_route, best_pos, customer)\n                        new_src_route = np.delete(src_route, cust_idx)\n\n                        # Update solution\n                        base_solution[dest_route_idx] = new_dest_route\n                        base_solution[src_route_idx] = new_src_route\n\n                        # Remove empty routes\n                        if len(new_src_route) == 2:\n                            base_solution.pop(src_route_idx)\n                        break\n\n    return base_solution\n\n",
        "score": [
            -0.35613465404015193,
            2.008090853691101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route merging\n    if len(route) > 4:  # Only perform if route has enough nodes\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n    # Attempt to merge this route with another if it's short\n    if len(route) <= 5 and len(base_solution) > 1:\n        other_idx = np.random.randint(0, len(base_solution))\n        if other_idx != route_idx:\n            other_route = base_solution[other_idx].copy()\n            combined_route = np.concatenate([route[:-1], other_route[1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                base_solution[route_idx] = combined_route\n                base_solution.pop(other_idx)\n\n    # Apply a cross-route relocation to balance makespan\n    if len(base_solution) > 1:\n        # Select a random customer from a random route\n        src_route_idx = np.random.randint(0, len(base_solution))\n        src_route = base_solution[src_route_idx].copy()\n        if len(src_route) > 3:  # Only if route has enough nodes\n            cust_idx = np.random.randint(1, len(src_route)-1)\n            customer = src_route[cust_idx]\n\n            # Try inserting into another route\n            for _ in range(3):  # Try 3 times\n                dest_route_idx = np.random.randint(0, len(base_solution))\n                if dest_route_idx != src_route_idx:\n                    dest_route = base_solution[dest_route_idx].copy()\n\n                    # Find best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(dest_route)):\n                        new_dest_route = np.insert(dest_route, pos, customer)\n                        if np.sum(demand[new_dest_route[1:-1]]) <= capacity:\n                            increase = (distance_matrix[dest_route[pos-1], customer] +\n                                      distance_matrix[customer, dest_route[pos]] -\n                                      distance_matrix[dest_route[pos-1], dest_route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n\n                    if min_increase < float('inf'):\n                        # Perform the relocation\n                        new_dest_route = np.insert(dest_route, best_pos, customer)\n                        new_src_route = np.delete(src_route, cust_idx)\n\n                        # Update solution\n                        base_solution[dest_route_idx] = new_dest_route\n                        base_solution[src_route_idx] = new_src_route\n\n                        # Remove empty routes\n                        if len(new_src_route) == 2:\n                            base_solution.pop(src_route_idx)\n                        break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search operator that combines route fragmentation and intra-route optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Inverse weights to prioritize lower values\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Copy the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route fragmentation and intra-route optimization\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - randomly select a route and split it into two\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(frag_route) - 2)\n            new_route1 = frag_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], frag_route[split_pos + 1:]])\n\n            # Check capacity constraints for both new routes\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                new_solution[frag_route_idx] = new_route1\n                new_solution.insert(frag_route_idx + 1, new_route2)\n\n    # Step 2: Intra-route optimization - apply a modified 2-opt with demand awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Create new route by reversing the segment between i and j\n        new_route = np.concatenate([\n            route[:i],\n            route[i:j+1][::-1],\n            route[j+1:]\n        ])\n\n        # Check capacity constraint\n        if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.8626328334284528,
            0.8976835906505585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Inverse weights to prioritize lower values\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Copy the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route fragmentation and intra-route optimization\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - randomly select a route and split it into two\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(frag_route) - 2)\n            new_route1 = frag_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], frag_route[split_pos + 1:]])\n\n            # Check capacity constraints for both new routes\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                new_solution[frag_route_idx] = new_route1\n                new_solution.insert(frag_route_idx + 1, new_route2)\n\n    # Step 2: Intra-route optimization - apply a modified 2-opt with demand awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Create new route by reversing the segment between i and j\n        new_route = np.concatenate([\n            route[:i],\n            route[i:j+1][::-1],\n            route[j+1:]\n        ])\n\n        # Check capacity constraint\n        if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search operator: Route Swap + Customer Reassignment\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Swap - Swap two entire routes between vehicles\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility after swap\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Step 2: Customer Reassignment - Move a customer from one route to another\n    if len(new_solution) >= 2:\n        # Select a random customer to move\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's a customer to move\n            customer_pos = np.random.choice(len(route) - 2) + 1  # Avoid depot positions\n            customer = route[customer_pos]\n\n            # Try to insert the customer into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Find the best insertion position in the other route\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(other_route)):\n                    # Calculate cost of inserting customer at pos\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    insertion_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if insertion_cost < min_cost:\n                        min_cost = insertion_cost\n                        best_pos = pos\n\n                # Check if insertion is feasible\n                if best_pos != -1:\n                    new_route = np.insert(other_route, best_pos, customer)\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[other_route_idx] = new_route\n                        new_solution[route_idx] = np.delete(route, customer_pos)\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5224161580461865,
            1.6220150887966156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search operator: Route Swap + Customer Reassignment\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Swap - Swap two entire routes between vehicles\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility after swap\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Step 2: Customer Reassignment - Move a customer from one route to another\n    if len(new_solution) >= 2:\n        # Select a random customer to move\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's a customer to move\n            customer_pos = np.random.choice(len(route) - 2) + 1  # Avoid depot positions\n            customer = route[customer_pos]\n\n            # Try to insert the customer into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Find the best insertion position in the other route\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(other_route)):\n                    # Calculate cost of inserting customer at pos\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    insertion_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if insertion_cost < min_cost:\n                        min_cost = insertion_cost\n                        best_pos = pos\n\n                # Check if insertion is feasible\n                if best_pos != -1:\n                    new_route = np.insert(other_route, best_pos, customer)\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[other_route_idx] = new_route\n                        new_solution[route_idx] = np.delete(route, customer_pos)\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This function selects a promising solution from the archive by favoring those with lower makespan and total distance, then applies a hybrid local search combining route splitting, inter-route insertion, and capacity-aware 2-opt to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting - split long routes into two feasible parts\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with customers\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If route is loaded beyond 70% capacity\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:]))\n                if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 2: Inter-route insertion - move a customer from one route to another\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Only consider routes with customers\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Try to insert into another route\n            for _ in range(3):  # Try up to 3 random routes\n                route2_idx = random.randint(0, len(new_solution)-1)\n                if route2_idx != route1_idx:\n                    route2 = new_solution[route2_idx]\n                    # Find best insertion position in route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        new_route = np.insert(route2, pos, customer)\n                        if is_feasible(new_route, demand, capacity):\n                            cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_cost < float('inf'):\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[route2_idx] = new_route2\n                        new_solution[route1_idx] = np.delete(route1, cust_pos)\n                        break\n\n    # Step 3: Capacity-aware 2-opt - optimize within a single route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            best_improvement = 0\n            best_i, best_j = -1, -1\n            # Find the best 2-opt move that preserves capacity\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Check if reversing this segment is feasible\n                    segment = route[a:b+1]\n                    reversed_segment = segment[::-1]\n                    # Check capacity of the new segment\n                    if is_feasible(np.concatenate((route[:a], reversed_segment, route[b+1:])), demand, capacity):\n                        # Calculate improvement\n                        improvement = (distance_matrix[route[a-1], route[a]] + distance_matrix[route[b], route[b+1]]) - \\\n                                     (distance_matrix[route[a-1], route[b]] + distance_matrix[route[a], route[b+1]])\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i, best_j = a, b\n            if best_improvement > 0:\n                new_solution[i] = np.concatenate((route[:best_i], route[best_i:best_j+1][::-1], route[best_j+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.5440123606958509,
            10.850512772798538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    def is_feasible(route, demand, capacity):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting - split long routes into two feasible parts\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with customers\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If route is loaded beyond 70% capacity\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:]))\n                if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 2: Inter-route insertion - move a customer from one route to another\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Only consider routes with customers\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Try to insert into another route\n            for _ in range(3):  # Try up to 3 random routes\n                route2_idx = random.randint(0, len(new_solution)-1)\n                if route2_idx != route1_idx:\n                    route2 = new_solution[route2_idx]\n                    # Find best insertion position in route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        new_route = np.insert(route2, pos, customer)\n                        if is_feasible(new_route, demand, capacity):\n                            cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_cost < float('inf'):\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[route2_idx] = new_route2\n                        new_solution[route1_idx] = np.delete(route1, cust_pos)\n                        break\n\n    # Step 3: Capacity-aware 2-opt - optimize within a single route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            best_improvement = 0\n            best_i, best_j = -1, -1\n            # Find the best 2-opt move that preserves capacity\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Check if reversing this segment is feasible\n                    segment = route[a:b+1]\n                    reversed_segment = segment[::-1]\n                    # Check capacity of the new segment\n                    if is_feasible(np.concatenate((route[:a], reversed_segment, route[b+1:])), demand, capacity):\n                        # Calculate improvement\n                        improvement = (distance_matrix[route[a-1], route[a]] + distance_matrix[route[b], route[b+1]]) - \\\n                                     (distance_matrix[route[a-1], route[b]] + distance_matrix[route[a], route[b+1]])\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i, best_j = a, b\n            if best_improvement > 0:\n                new_solution[i] = np.concatenate((route[:best_i], route[best_i:best_j+1][::-1], route[best_j+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for node in part2[1:-1]:\n                # Find the nearest route that can accommodate the node\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    temp_route = np.append(new_solution[j], node)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[j] = temp_route\n                        break\n                else:\n                    # If no suitable route found, leave the node in the original route\n                    continue\n\n    # Ensure all routes start and end at the depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8343807735606703,
            1.3796607851982117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for node in part2[1:-1]:\n                # Find the nearest route that can accommodate the node\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    temp_route = np.append(new_solution[j], node)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[j] = temp_route\n                        break\n                else:\n                    # If no suitable route found, leave the node in the original route\n                    continue\n\n    # Ensure all routes start and end at the depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Apply a hybrid local search: combine route splitting and node reinsertion\n        if len(selected_route) > 3:  # Ensure route has enough nodes to split\n            # Split the route into two parts\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n            second_part[0] = 0  # Ensure second part starts at depot\n\n            # Check capacity feasibility for both parts\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n            else:\n                # If splitting fails, try reinserting a node into another route\n                node_to_reinsert = selected_route[np.random.randint(1, len(selected_route) - 1)]\n                other_route_idx = np.random.randint(0, len(new_solution))\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Find the best position to insert the node\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, node_to_reinsert)\n                        if check_capacity(temp_route):\n                            cost = distance_matrix[temp_route[pos-1], node_to_reinsert] + distance_matrix[node_to_reinsert, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_cost < float('inf'):\n                        new_solution[other_route_idx] = np.insert(other_route, best_pos, node_to_reinsert)\n                        new_solution[route_idx] = np.delete(selected_route, np.where(selected_route == node_to_reinsert)[0][0])\n        else:\n            # If route is too short, try merging with another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.randint(0, len(new_solution))\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n                    if check_capacity(merged_route):\n                        new_solution[route_idx] = merged_route\n                        new_solution.pop(other_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.8213798953940792,
            0.30951786041259766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Apply a hybrid local search: combine route splitting and node reinsertion\n        if len(selected_route) > 3:  # Ensure route has enough nodes to split\n            # Split the route into two parts\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n            second_part[0] = 0  # Ensure second part starts at depot\n\n            # Check capacity feasibility for both parts\n            def check_capacity(route):\n                total_demand = sum(demand[node] for node in route[1:-1])\n                return total_demand <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n            else:\n                # If splitting fails, try reinserting a node into another route\n                node_to_reinsert = selected_route[np.random.randint(1, len(selected_route) - 1)]\n                other_route_idx = np.random.randint(0, len(new_solution))\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    # Find the best position to insert the node\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, node_to_reinsert)\n                        if check_capacity(temp_route):\n                            cost = distance_matrix[temp_route[pos-1], node_to_reinsert] + distance_matrix[node_to_reinsert, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                    if best_cost < float('inf'):\n                        new_solution[other_route_idx] = np.insert(other_route, best_pos, node_to_reinsert)\n                        new_solution[route_idx] = np.delete(selected_route, np.where(selected_route == node_to_reinsert)[0][0])\n        else:\n            # If route is too short, try merging with another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.randint(0, len(new_solution))\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    merged_route = np.concatenate([selected_route[:-1], other_route[1:]])\n                    if check_capacity(merged_route):\n                        new_solution[route_idx] = merged_route\n                        new_solution.pop(other_route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route-splitting and cross-route relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity feasibility for both parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Cross-route relocation: move a random customer to another route if feasible\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        if len(new_solution[route_idx]) > 3:\n            # Select a random customer to move\n            customer_pos = np.random.randint(1, len(new_solution[route_idx]) - 1)\n            customer = new_solution[route_idx][customer_pos]\n\n            # Try to insert into another route\n            target_route_idx = (route_idx + np.random.randint(1, len(new_solution))) % len(new_solution)\n            if target_route_idx != route_idx:\n                # Find best insertion position in target route\n                best_pos = -1\n                min_increase = float('inf')\n                for i in range(len(new_solution[target_route_idx]) - 1):\n                    # Check capacity constraint\n                    if np.sum(demand[new_solution[target_route_idx][1:i+1]]) + demand[customer] <= capacity:\n                        # Calculate distance increase\n                        dist_increase = (\n                            distance_matrix[new_solution[target_route_idx][i], customer] +\n                            distance_matrix[customer, new_solution[target_route_idx][i+1]] -\n                            distance_matrix[new_solution[target_route_idx][i], new_solution[target_route_idx][i+1]]\n                        )\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = i + 1\n\n                if best_pos != -1:\n                    # Perform the move\n                    new_solution[target_route_idx] = np.insert(new_solution[target_route_idx], best_pos, customer)\n                    new_solution[route_idx] = np.delete(new_solution[route_idx], customer_pos)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8012652736753412,
            1.0177593231201172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route-splitting and cross-route relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity feasibility for both parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Cross-route relocation: move a random customer to another route if feasible\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        if len(new_solution[route_idx]) > 3:\n            # Select a random customer to move\n            customer_pos = np.random.randint(1, len(new_solution[route_idx]) - 1)\n            customer = new_solution[route_idx][customer_pos]\n\n            # Try to insert into another route\n            target_route_idx = (route_idx + np.random.randint(1, len(new_solution))) % len(new_solution)\n            if target_route_idx != route_idx:\n                # Find best insertion position in target route\n                best_pos = -1\n                min_increase = float('inf')\n                for i in range(len(new_solution[target_route_idx]) - 1):\n                    # Check capacity constraint\n                    if np.sum(demand[new_solution[target_route_idx][1:i+1]]) + demand[customer] <= capacity:\n                        # Calculate distance increase\n                        dist_increase = (\n                            distance_matrix[new_solution[target_route_idx][i], customer] +\n                            distance_matrix[customer, new_solution[target_route_idx][i+1]] -\n                            distance_matrix[new_solution[target_route_idx][i], new_solution[target_route_idx][i+1]]\n                        )\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = i + 1\n\n                if best_pos != -1:\n                    # Perform the move\n                    new_solution[target_route_idx] = np.insert(new_solution[target_route_idx], best_pos, customer)\n                    new_solution[route_idx] = np.delete(new_solution[route_idx], customer_pos)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search operator: a combination of route splitting and cross-exchange\n    if len(selected_route) > 4:  # Ensure route is long enough to split\n        # Split the route into two parts\n        split_point = np.random.randint(2, len(selected_route) - 2)\n        part1 = selected_route[:split_point]\n        part2 = selected_route[split_point:]\n\n        # Try to reinsert parts into other routes or create new routes\n        new_routes = []\n        for route in selected_solution:\n            if np.array_equal(route, selected_route):\n                continue\n            # Cross-exchange between part1 and part2\n            if len(part1) > 2 and len(part2) > 2:\n                # Swap parts between routes\n                new_route = np.concatenate([part1, route[len(part1):]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(new_route)\n                new_route = np.concatenate([part2, route[len(part2):]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(new_route)\n\n        # If successful, update the solution\n        if new_routes:\n            selected_solution = [route for route in selected_solution if not np.array_equal(route, selected_route)]\n            selected_solution.extend(new_routes)\n\n    # Ensure the solution is feasible\n    for route in selected_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is exceeded, split the route\n            split_point = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity) + 1\n            part1 = route[:split_point + 1]\n            part2 = np.concatenate([[0], route[split_point + 1:]])\n            selected_solution = [r for r in selected_solution if not np.array_equal(r, route)]\n            selected_solution.extend([part1, part2])\n\n    return selected_solution\n\n",
        "score": [
            -0.5243241604674953,
            1.926830679178238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search operator: a combination of route splitting and cross-exchange\n    if len(selected_route) > 4:  # Ensure route is long enough to split\n        # Split the route into two parts\n        split_point = np.random.randint(2, len(selected_route) - 2)\n        part1 = selected_route[:split_point]\n        part2 = selected_route[split_point:]\n\n        # Try to reinsert parts into other routes or create new routes\n        new_routes = []\n        for route in selected_solution:\n            if np.array_equal(route, selected_route):\n                continue\n            # Cross-exchange between part1 and part2\n            if len(part1) > 2 and len(part2) > 2:\n                # Swap parts between routes\n                new_route = np.concatenate([part1, route[len(part1):]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(new_route)\n                new_route = np.concatenate([part2, route[len(part2):]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(new_route)\n\n        # If successful, update the solution\n        if new_routes:\n            selected_solution = [route for route in selected_solution if not np.array_equal(route, selected_route)]\n            selected_solution.extend(new_routes)\n\n    # Ensure the solution is feasible\n    for route in selected_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is exceeded, split the route\n            split_point = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity) + 1\n            part1 = route[:split_point + 1]\n            part2 = np.concatenate([[0], route[split_point + 1:]])\n            selected_solution = [r for r in selected_solution if not np.array_equal(r, route)]\n            selected_solution.extend([part1, part2])\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Split the route into two parts at a random point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    part1 = selected_route[:split_point + 1]\n    part2 = selected_route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[part1[1:-1]]) > capacity or np.sum(demand[part2[1:-1]]) > capacity:\n        return selected_solution  # No improvement possible\n\n    # Try to reallocate customers between the split parts\n    for i in range(1, len(part1) - 1):\n        for j in range(1, len(part2) - 1):\n            # Swap customer i from part1 with customer j from part2\n            new_part1 = part1.copy()\n            new_part1[i] = part2[j]\n            new_part2 = part2.copy()\n            new_part2[j] = part1[i]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_part1[1:-1]]) <= capacity and\n                np.sum(demand[new_part2[1:-1]]) <= capacity):\n                # Calculate new distances\n                dist_part1 = np.sum(distance_matrix[np.roll(new_part1, 1)[:-1], new_part1[1:]])\n                dist_part2 = np.sum(distance_matrix[np.roll(new_part2, 1)[:-1], new_part2[1:]])\n\n                # If improvement, update the solution\n                if dist_part1 + dist_part2 < np.sum(distance_matrix[np.roll(part1, 1)[:-1], part1[1:]]) + np.sum(distance_matrix[np.roll(part2, 1)[:-1], part2[1:]]):\n                    part1, part2 = new_part1, new_part2\n                    break\n\n    # Update the solution with the modified routes\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = part1\n    if len(part2) > 2:  # Ensure the second part is valid\n        new_solution.append(part2)\n\n    return new_solution\n\n",
        "score": [
            -0.8714566218334056,
            2.8769307136535645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Split the route into two parts at a random point\n    split_point = np.random.randint(1, len(selected_route) - 1)\n    part1 = selected_route[:split_point + 1]\n    part2 = selected_route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints)\n    if np.sum(demand[part1[1:-1]]) > capacity or np.sum(demand[part2[1:-1]]) > capacity:\n        return selected_solution  # No improvement possible\n\n    # Try to reallocate customers between the split parts\n    for i in range(1, len(part1) - 1):\n        for j in range(1, len(part2) - 1):\n            # Swap customer i from part1 with customer j from part2\n            new_part1 = part1.copy()\n            new_part1[i] = part2[j]\n            new_part2 = part2.copy()\n            new_part2[j] = part1[i]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_part1[1:-1]]) <= capacity and\n                np.sum(demand[new_part2[1:-1]]) <= capacity):\n                # Calculate new distances\n                dist_part1 = np.sum(distance_matrix[np.roll(new_part1, 1)[:-1], new_part1[1:]])\n                dist_part2 = np.sum(distance_matrix[np.roll(new_part2, 1)[:-1], new_part2[1:]])\n\n                # If improvement, update the solution\n                if dist_part1 + dist_part2 < np.sum(distance_matrix[np.roll(part1, 1)[:-1], part1[1:]]) + np.sum(distance_matrix[np.roll(part2, 1)[:-1], part2[1:]]):\n                    part1, part2 = new_part1, new_part2\n                    break\n\n    # Update the solution with the modified routes\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = part1\n    if len(part2) > 2:  # Ensure the second part is valid\n        new_solution.append(part2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing solutions with low makespan and total distance, then applies a hybrid local search combining route fragmentation and demand-aware 2-opt to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation + demand-aware 2-opt\n    for _ in range(3):  # Limit iterations for efficiency\n        # Step 1: Route fragmentation - split long routes into shorter ones\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 5:  # Arbitrary threshold for fragmentation\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = [0] + route[split_pos+1:]\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n        # Step 2: Demand-aware 2-opt - swap nodes considering demand balance\n        for route in new_solution:\n            if len(route) < 4:\n                continue\n            i, j = np.random.randint(1, len(route)-1, size=2)\n            if i > j:\n                i, j = j, i\n            if i == j or (i == 0 and j == len(route)-1):\n                continue\n\n            # Check demand feasibility before swap\n            segment1 = route[i:j+1]\n            segment2 = route[j:i-1:-1]\n            if (sum(demand[segment1]) <= capacity and\n                sum(demand[segment2]) <= capacity):\n                route[i:j+1] = segment2\n\n    # Ensure feasibility after all modifications\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Revert to original if capacity exceeded\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8220065992037516,
            4.978356659412384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation + demand-aware 2-opt\n    for _ in range(3):  # Limit iterations for efficiency\n        # Step 1: Route fragmentation - split long routes into shorter ones\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 5:  # Arbitrary threshold for fragmentation\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = [0] + route[split_pos+1:]\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n        # Step 2: Demand-aware 2-opt - swap nodes considering demand balance\n        for route in new_solution:\n            if len(route) < 4:\n                continue\n            i, j = np.random.randint(1, len(route)-1, size=2)\n            if i > j:\n                i, j = j, i\n            if i == j or (i == 0 and j == len(route)-1):\n                continue\n\n            # Check demand feasibility before swap\n            segment1 = route[i:j+1]\n            segment2 = route[j:i-1:-1]\n            if (sum(demand[segment1]) <= capacity and\n                sum(demand[segment2]) <= capacity):\n                route[i:j+1] = segment2\n\n    # Ensure feasibility after all modifications\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Revert to original if capacity exceeded\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their combined load is within capacity\n        merged_load = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if merged_load <= capacity:\n            # Find the best insertion point for route2 into route1\n            best_distance = float('inf')\n            best_insert_pos = -1\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Insert route2[j] into route1[i]\n                    new_route = np.concatenate([route1[:i], route2[j:j+1], route1[i:]])\n                    new_distance = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    if new_distance < best_distance:\n                        best_distance = new_distance\n                        best_insert_pos = i\n            if best_insert_pos != -1:\n                new_route1 = np.concatenate([route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]])\n                new_solution = [r for idx, r in enumerate(selected_solution) if idx not in route_indices]\n                new_solution.append(new_route1)\n                # Check feasibility\n                if all(np.sum(demand[r[1:-1]]) <= capacity for r in new_solution):\n                    return new_solution\n\n    # If merging failed, try splitting a long route into two\n    longest_route = max(selected_solution, key=lambda r: len(r))\n    if len(longest_route) > 3:  # Ensure there are nodes to split\n        # Find the best split point to minimize the sum of distances\n        best_split = -1\n        min_total_distance = float('inf')\n        for k in range(2, len(longest_route) - 1):\n            route1 = longest_route[:k+1]\n            route2 = np.concatenate([[0], longest_route[k:-1], [0]])\n            total_distance = np.sum(distance_matrix[route1[:-1], route1[1:]]) + np.sum(distance_matrix[route2[:-1], route2[1:]])\n            if total_distance < min_total_distance and np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                min_total_distance = total_distance\n                best_split = k\n        if best_split != -1:\n            route1 = longest_route[:best_split+1]\n            route2 = np.concatenate([[0], longest_route[best_split:-1], [0]])\n            new_solution = [r for r in selected_solution if not np.array_equal(r, longest_route)]\n            new_solution.extend([route1, route2])\n            return new_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.7087871820291369,
            1.4762656390666962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their combined load is within capacity\n        merged_load = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if merged_load <= capacity:\n            # Find the best insertion point for route2 into route1\n            best_distance = float('inf')\n            best_insert_pos = -1\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Insert route2[j] into route1[i]\n                    new_route = np.concatenate([route1[:i], route2[j:j+1], route1[i:]])\n                    new_distance = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    if new_distance < best_distance:\n                        best_distance = new_distance\n                        best_insert_pos = i\n            if best_insert_pos != -1:\n                new_route1 = np.concatenate([route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]])\n                new_solution = [r for idx, r in enumerate(selected_solution) if idx not in route_indices]\n                new_solution.append(new_route1)\n                # Check feasibility\n                if all(np.sum(demand[r[1:-1]]) <= capacity for r in new_solution):\n                    return new_solution\n\n    # If merging failed, try splitting a long route into two\n    longest_route = max(selected_solution, key=lambda r: len(r))\n    if len(longest_route) > 3:  # Ensure there are nodes to split\n        # Find the best split point to minimize the sum of distances\n        best_split = -1\n        min_total_distance = float('inf')\n        for k in range(2, len(longest_route) - 1):\n            route1 = longest_route[:k+1]\n            route2 = np.concatenate([[0], longest_route[k:-1], [0]])\n            total_distance = np.sum(distance_matrix[route1[:-1], route1[1:]]) + np.sum(distance_matrix[route2[:-1], route2[1:]])\n            if total_distance < min_total_distance and np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                min_total_distance = total_distance\n                best_split = k\n        if best_split != -1:\n            route1 = longest_route[:best_split+1]\n            route2 = np.concatenate([[0], longest_route[best_split:-1], [0]])\n            new_solution = [r for r in selected_solution if not np.array_equal(r, longest_route)]\n            new_solution.extend([route1, route2])\n            return new_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower makespan, then applies a hybrid local search combining route swapping and intra-route insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping + intra-route insertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try swapping segments between routes\n        if len(new_solution[i]) > 3 and len(new_solution[j]) > 3:\n            # Select a segment from route i\n            start_i = random.randint(1, len(new_solution[i]) - 3)\n            end_i = random.randint(start_i + 1, len(new_solution[i]) - 2)\n            segment_i = new_solution[i][start_i:end_i]\n\n            # Check capacity constraint for route j after insertion\n            if sum(demand[segment_i]) <= capacity - sum(demand[new_solution[j][1:-1]]):\n                # Insert segment into route j\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_solution[j] = np.concatenate([new_solution[j][:insert_pos], segment_i, new_solution[j][insert_pos:]])\n\n                # Remove segment from route i\n                new_solution[i] = np.concatenate([new_solution[i][:start_i], new_solution[i][end_i:]])\n\n                # Check if routes are empty after removal\n                if len(new_solution[i]) == 2:  # Only depot left\n                    new_solution.pop(i)\n                if len(new_solution[j]) == 2:\n                    new_solution.pop(j)\n\n        # Intra-route insertion for one route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select two nodes to swap\n            pos1, pos2 = sorted(random.sample(range(1, len(route) - 1), 2))\n\n            # Check capacity constraint\n            if (sum(demand[route[pos1+1:pos2]]) <= capacity - sum(demand[route[1:pos1]]) + sum(demand[route[pos1:pos2]])) and \\\n               (sum(demand[route[pos1+1:pos2]]) <= capacity - sum(demand[route[pos2+1:-1]]) + sum(demand[route[pos1:pos2]])):\n                # Perform insertion\n                node = route[pos1]\n                new_route = np.concatenate([route[:pos1], route[pos1+1:pos2], [node], route[pos2:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5144055606430161,
            0.8307536244392395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping + intra-route insertion\n    if len(new_solution) >= 2:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try swapping segments between routes\n        if len(new_solution[i]) > 3 and len(new_solution[j]) > 3:\n            # Select a segment from route i\n            start_i = random.randint(1, len(new_solution[i]) - 3)\n            end_i = random.randint(start_i + 1, len(new_solution[i]) - 2)\n            segment_i = new_solution[i][start_i:end_i]\n\n            # Check capacity constraint for route j after insertion\n            if sum(demand[segment_i]) <= capacity - sum(demand[new_solution[j][1:-1]]):\n                # Insert segment into route j\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_solution[j] = np.concatenate([new_solution[j][:insert_pos], segment_i, new_solution[j][insert_pos:]])\n\n                # Remove segment from route i\n                new_solution[i] = np.concatenate([new_solution[i][:start_i], new_solution[i][end_i:]])\n\n                # Check if routes are empty after removal\n                if len(new_solution[i]) == 2:  # Only depot left\n                    new_solution.pop(i)\n                if len(new_solution[j]) == 2:\n                    new_solution.pop(j)\n\n        # Intra-route insertion for one route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select two nodes to swap\n            pos1, pos2 = sorted(random.sample(range(1, len(route) - 1), 2))\n\n            # Check capacity constraint\n            if (sum(demand[route[pos1+1:pos2]]) <= capacity - sum(demand[route[1:pos1]]) + sum(demand[route[pos1:pos2]])) and \\\n               (sum(demand[route[pos1+1:pos2]]) <= capacity - sum(demand[route[pos2+1:-1]]) + sum(demand[route[pos1:pos2]])):\n                # Perform insertion\n                node = route[pos1]\n                new_route = np.concatenate([route[:pos1], route[pos1+1:pos2], [node], route[pos2:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A hybrid local search strategy that combines route exchange, segment relocation, and capacity-aware merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: exchange segments between routes, relocate segments, or merge feasible routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Extract a random segment from route1\n        if len(route1) > 3:  # Ensure segment is non-trivial\n            start = random.randint(1, len(route1)-3)\n            end = random.randint(start+1, len(route1)-2)\n            segment = route1[start:end]\n\n            # Check if segment can be placed in route2 without exceeding capacity\n            current_load = sum(demand[segment])\n            if sum(demand[route2]) + current_load <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_solution[route1_idx] = np.concatenate([route1[:start], route1[end:]])\n                new_solution[route2_idx] = new_route2\n\n                # Check for empty routes and remove them\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 3: Attempt to merge two routes if their total demand is within capacity\n    if len(new_solution) > 1:\n        for _ in range(3):  # Try up to 3 merges\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.44131117252816765,
            0.8529227077960968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: exchange segments between routes, relocate segments, or merge feasible routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Extract a random segment from route1\n        if len(route1) > 3:  # Ensure segment is non-trivial\n            start = random.randint(1, len(route1)-3)\n            end = random.randint(start+1, len(route1)-2)\n            segment = route1[start:end]\n\n            # Check if segment can be placed in route2 without exceeding capacity\n            current_load = sum(demand[segment])\n            if sum(demand[route2]) + current_load <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_solution[route1_idx] = np.concatenate([route1[:start], route1[end:]])\n                new_solution[route2_idx] = new_route2\n\n                # Check for empty routes and remove them\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 3: Attempt to merge two routes if their total demand is within capacity\n    if len(new_solution) > 1:\n        for _ in range(3):  # Try up to 3 merges\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the smallest makespan, then applies a hybrid local search combining route splitting, customer reallocation, and 3-opt improvements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes, reallocate customers, and apply 3-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Step 1: Split long routes if possible\n            if len(route) > 6:  # Arbitrary threshold for splitting\n                split_point = random.randint(2, len(route) - 3)\n                new_route1 = route[:split_point + 1]\n                new_route2 = [0] + route[split_point + 1:]\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n            # Step 2: Reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                for k in range(1, len(route) - 1):\n                    customer = route[k]\n                    # Check if moving customer to other_route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Temporarily remove customer from current route\n                        temp_route = np.delete(route, k)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Add customer to other route\n                            insert_pos = random.randint(1, len(other_route) - 1)\n                            new_other_route = np.insert(other_route, insert_pos, customer)\n                            if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[j] = new_other_route\n                                break\n\n            # Step 3: Apply 3-opt improvement\n            route = new_solution[i]\n            if len(route) > 4:  # Need at least 4 nodes to perform 3-opt\n                a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all 8 possible 3-opt moves\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    new_route = route.copy()\n                    new_route[perm[0]], new_route[perm[1]], new_route[perm[2]] = route[a], route[b], route[c]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7932012498617116,
            0.06241592764854431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes, reallocate customers, and apply 3-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Step 1: Split long routes if possible\n            if len(route) > 6:  # Arbitrary threshold for splitting\n                split_point = random.randint(2, len(route) - 3)\n                new_route1 = route[:split_point + 1]\n                new_route2 = [0] + route[split_point + 1:]\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n            # Step 2: Reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                for k in range(1, len(route) - 1):\n                    customer = route[k]\n                    # Check if moving customer to other_route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Temporarily remove customer from current route\n                        temp_route = np.delete(route, k)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Add customer to other route\n                            insert_pos = random.randint(1, len(other_route) - 1)\n                            new_other_route = np.insert(other_route, insert_pos, customer)\n                            if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[j] = new_other_route\n                                break\n\n            # Step 3: Apply 3-opt improvement\n            route = new_solution[i]\n            if len(route) > 4:  # Need at least 4 nodes to perform 3-opt\n                a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all 8 possible 3-opt moves\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    new_route = route.copy()\n                    new_route[perm[0]], new_route[perm[1]], new_route[perm[2]] = route[a], route[b], route[c]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the smallest makespan, then applies a hybrid local search combining route splitting, customer reallocation, and 3-opt improvements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes, reallocate customers, and apply 3-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Step 1: Split long routes if possible\n            if len(route) > 6:  # Arbitrary threshold for splitting\n                split_point = random.randint(2, len(route) - 3)\n                new_route1 = route[:split_point + 1]\n                new_route2 = [0] + route[split_point + 1:]\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n            # Step 2: Reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                for k in range(1, len(route) - 1):\n                    customer = route[k]\n                    # Check if moving customer to other_route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Temporarily remove customer from current route\n                        temp_route = np.delete(route, k)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Add customer to other route\n                            insert_pos = random.randint(1, len(other_route) - 1)\n                            new_other_route = np.insert(other_route, insert_pos, customer)\n                            if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[j] = new_other_route\n                                break\n\n            # Step 3: Apply 3-opt improvement\n            route = new_solution[i]\n            if len(route) > 4:  # Need at least 4 nodes to perform 3-opt\n                a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all 8 possible 3-opt moves\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    new_route = route.copy()\n                    new_route[perm[0]], new_route[perm[1]], new_route[perm[2]] = route[a], route[b], route[c]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7932012498617116,
            0.06241592764854431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes, reallocate customers, and apply 3-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            # Step 1: Split long routes if possible\n            if len(route) > 6:  # Arbitrary threshold for splitting\n                split_point = random.randint(2, len(route) - 3)\n                new_route1 = route[:split_point + 1]\n                new_route2 = [0] + route[split_point + 1:]\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n            # Step 2: Reallocate customers between routes\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                for k in range(1, len(route) - 1):\n                    customer = route[k]\n                    # Check if moving customer to other_route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Temporarily remove customer from current route\n                        temp_route = np.delete(route, k)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Add customer to other route\n                            insert_pos = random.randint(1, len(other_route) - 1)\n                            new_other_route = np.insert(other_route, insert_pos, customer)\n                            if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[j] = new_other_route\n                                break\n\n            # Step 3: Apply 3-opt improvement\n            route = new_solution[i]\n            if len(route) > 4:  # Need at least 4 nodes to perform 3-opt\n                a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all 8 possible 3-opt moves\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    new_route = route.copy()\n                    new_route[perm[0]], new_route[perm[1]], new_route[perm[2]] = route[a], route[b], route[c]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high total distance and low makespan, then applies a hybrid local search combining route merging and reinsertion with demand-aware swaps to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - 0.5 * x[1][1]))[0].copy()\n\n    # Hybrid local search: route merging and demand-aware reinsertion\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution = np.delete(new_solution, j, axis=0)\n\n            # Perform demand-aware reinsertion\n            for route in new_solution:\n                if len(route) > 3:  # Only reinsert if route has customers\n                    # Select a random customer to reinsert\n                    idx = random.randint(1, len(route) - 2)\n                    customer = route[idx]\n\n                    # Try inserting at different positions in other routes\n                    for other_route in new_solution:\n                        if len(other_route) > 2 and np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(other_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Perform insertion if beneficial\n                            if best_cost < 0:\n                                other_route = np.insert(other_route, best_pos, customer)\n                                route = np.delete(route, idx)\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.671477613965577,
            0.6171980202198029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - 0.5 * x[1][1]))[0].copy()\n\n    # Hybrid local search: route merging and demand-aware reinsertion\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution = np.delete(new_solution, j, axis=0)\n\n            # Perform demand-aware reinsertion\n            for route in new_solution:\n                if len(route) > 3:  # Only reinsert if route has customers\n                    # Select a random customer to reinsert\n                    idx = random.randint(1, len(route) - 2)\n                    customer = route[idx]\n\n                    # Try inserting at different positions in other routes\n                    for other_route in new_solution:\n                        if len(other_route) > 2 and np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(other_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Perform insertion if beneficial\n                            if best_cost < 0:\n                                other_route = np.insert(other_route, best_pos, customer)\n                                route = np.delete(route, idx)\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Randomly select a segment to split\n            split_pos = np.random.randint(2, len(route) - 2)\n            segment = route[split_pos:-1]\n\n            # Check if splitting this segment is feasible\n            segment_demand = np.sum(demand[segment])\n            if segment_demand <= capacity:\n                # Create a new route from the segment\n                new_route = np.concatenate(([0], segment, [0]))\n                new_solution.append(new_route)\n                # Remove the segment from the original route\n                new_solution[i] = np.concatenate((route[:split_pos], [0]))\n\n    # Randomly reallocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(len(new_solution))\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            # Select a random customer to move\n            customer_idx = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx == from_route_idx:\n                    continue\n                to_route = new_solution[to_route_idx]\n\n                # Check capacity constraint\n                if np.sum(demand[to_route]) + demand[customer] <= capacity:\n                    # Insert customer into the new route\n                    insert_pos = np.random.randint(1, len(to_route))\n                    new_solution[to_route_idx] = np.concatenate((\n                        to_route[:insert_pos], [customer], to_route[insert_pos:]\n                    ))\n                    # Remove customer from original route\n                    new_solution[from_route_idx] = np.concatenate((\n                        from_route[:customer_idx], from_route[customer_idx+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8198140155917268,
            3.0391796827316284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Randomly select a segment to split\n            split_pos = np.random.randint(2, len(route) - 2)\n            segment = route[split_pos:-1]\n\n            # Check if splitting this segment is feasible\n            segment_demand = np.sum(demand[segment])\n            if segment_demand <= capacity:\n                # Create a new route from the segment\n                new_route = np.concatenate(([0], segment, [0]))\n                new_solution.append(new_route)\n                # Remove the segment from the original route\n                new_solution[i] = np.concatenate((route[:split_pos], [0]))\n\n    # Randomly reallocate a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(len(new_solution))\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            # Select a random customer to move\n            customer_idx = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            for to_route_idx in range(len(new_solution)):\n                if to_route_idx == from_route_idx:\n                    continue\n                to_route = new_solution[to_route_idx]\n\n                # Check capacity constraint\n                if np.sum(demand[to_route]) + demand[customer] <= capacity:\n                    # Insert customer into the new route\n                    insert_pos = np.random.randint(1, len(to_route))\n                    new_solution[to_route_idx] = np.concatenate((\n                        to_route[:insert_pos], [customer], to_route[insert_pos:]\n                    ))\n                    # Remove customer from original route\n                    new_solution[from_route_idx] = np.concatenate((\n                        from_route[:customer_idx], from_route[customer_idx+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a promising solution from the archive by considering both objective values, then applies a hybrid local search strategy combining route segment reinsertion with a capacity-aware swap operator to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment reinsertion with capacity-aware swap\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to reinsert\n        seg_start = np.random.randint(1, len(route)-2)\n        seg_end = np.random.randint(seg_start+1, len(route)-1)\n        segment = route[seg_start:seg_end+1]\n\n        # Check capacity constraint for the segment\n        if np.sum(demand[segment]) > capacity:\n            continue\n\n        # Remove the segment from the route\n        new_route = np.concatenate([route[:seg_start], route[seg_end+1:]])\n\n        # Try to insert the segment in a different position in the same route\n        for pos in range(1, len(new_route)):\n            if pos == seg_start or pos == seg_end:\n                continue\n            temp_route = np.insert(new_route, pos, segment)\n            if np.all(np.cumsum(demand[temp_route]) <= capacity):\n                new_solution[route_idx] = temp_route\n                break\n\n        # If no improvement in same route, try inserting into another route\n        if new_solution[route_idx].tolist() == new_route.tolist():\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, segment)\n                    if np.all(np.cumsum(demand[temp_route]) <= capacity):\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = temp_route\n                        break\n                else:\n                    continue\n                break\n\n    # Capacity-aware swap operator\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select two customers to swap\n        i, j = np.random.choice(range(1, len(route)-1), 2, replace=False)\n\n        # Check if swap is feasible\n        if demand[route[i]] + demand[route[j]] <= capacity:\n            # Perform swap\n            route[i], route[j] = route[j], route[i]\n            new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.6718619221918392,
            3.8810432851314545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment reinsertion with capacity-aware swap\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to reinsert\n        seg_start = np.random.randint(1, len(route)-2)\n        seg_end = np.random.randint(seg_start+1, len(route)-1)\n        segment = route[seg_start:seg_end+1]\n\n        # Check capacity constraint for the segment\n        if np.sum(demand[segment]) > capacity:\n            continue\n\n        # Remove the segment from the route\n        new_route = np.concatenate([route[:seg_start], route[seg_end+1:]])\n\n        # Try to insert the segment in a different position in the same route\n        for pos in range(1, len(new_route)):\n            if pos == seg_start or pos == seg_end:\n                continue\n            temp_route = np.insert(new_route, pos, segment)\n            if np.all(np.cumsum(demand[temp_route]) <= capacity):\n                new_solution[route_idx] = temp_route\n                break\n\n        # If no improvement in same route, try inserting into another route\n        if new_solution[route_idx].tolist() == new_route.tolist():\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, segment)\n                    if np.all(np.cumsum(demand[temp_route]) <= capacity):\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = temp_route\n                        break\n                else:\n                    continue\n                break\n\n    # Capacity-aware swap operator\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select two customers to swap\n        i, j = np.random.choice(range(1, len(route)-1), 2, replace=False)\n\n        # Check if swap is feasible\n        if demand[route[i]] + demand[route[j]] <= capacity:\n            # Perform swap\n            route[i], route[j] = route[j], route[i]\n            new_solution[route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for selection\n    total_distances = np.array([obj[0] for obj in archive_objectives])\n    makespans = np.array([obj[1] for obj in archive_objectives])\n\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (total_distances - min_dist) / (max_dist - min_dist + 1e-6)\n    normalized_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Select solutions with good balance (close to Pareto front)\n    scores = normalized_dist + normalized_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: Combine route merging, customer reallocation, and 2-opt with capacity checks\n    new_solution = []\n\n    # Step 1: Try merging two routes if it reduces total distance and improves makespan\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route_i, route_j = base_solution[i], base_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            # Create merged route (simplified for illustration)\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if k == i or k == j else base_solution[k] for k in range(len(base_solution)) if k != j]\n\n            # Validate and return if feasible\n            if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                return new_solution\n\n    # Step 2: Try reallocating a customer from one route to another if it improves objectives\n    if len(base_solution) > 1:\n        for route_idx, route in enumerate(base_solution):\n            if len(route) <= 3:  # Skip if route has only depot and one customer\n                continue\n\n            # Select a random customer to move\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            # Try moving to another route\n            for other_route_idx, other_route in enumerate(base_solution):\n                if route_idx == other_route_idx:\n                    continue\n\n                # Check capacity constraint\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_route = np.insert(route, customer_pos, 0)\n                    new_route = np.delete(new_route, customer_pos + 1)\n                    new_other_route = np.insert(other_route, -1, customer)\n\n                    # Update solution\n                    new_solution = [new_route if k == route_idx else new_other_route if k == other_route_idx else base_solution[k] for k in range(len(base_solution))]\n\n                    # Validate and return if feasible\n                    if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                        return new_solution\n\n    # Step 3: Apply 2-opt with capacity checks if no better move found\n    for route in base_solution:\n        if len(route) <= 4:  # Skip if too short for 2-opt\n            continue\n\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[j:j+1], route[i+1:j+1], route[i:i+1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = [new_route if r.tolist() == route.tolist() else r for r in base_solution]\n\n            # Validate and return if feasible\n            if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                return new_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n",
        "score": [
            -0.8307562104853604,
            0.989058256149292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives for selection\n    total_distances = np.array([obj[0] for obj in archive_objectives])\n    makespans = np.array([obj[1] for obj in archive_objectives])\n\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (total_distances - min_dist) / (max_dist - min_dist + 1e-6)\n    normalized_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Select solutions with good balance (close to Pareto front)\n    scores = normalized_dist + normalized_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: Combine route merging, customer reallocation, and 2-opt with capacity checks\n    new_solution = []\n\n    # Step 1: Try merging two routes if it reduces total distance and improves makespan\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route_i, route_j = base_solution[i], base_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            # Create merged route (simplified for illustration)\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if k == i or k == j else base_solution[k] for k in range(len(base_solution)) if k != j]\n\n            # Validate and return if feasible\n            if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                return new_solution\n\n    # Step 2: Try reallocating a customer from one route to another if it improves objectives\n    if len(base_solution) > 1:\n        for route_idx, route in enumerate(base_solution):\n            if len(route) <= 3:  # Skip if route has only depot and one customer\n                continue\n\n            # Select a random customer to move\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            # Try moving to another route\n            for other_route_idx, other_route in enumerate(base_solution):\n                if route_idx == other_route_idx:\n                    continue\n\n                # Check capacity constraint\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_route = np.insert(route, customer_pos, 0)\n                    new_route = np.delete(new_route, customer_pos + 1)\n                    new_other_route = np.insert(other_route, -1, customer)\n\n                    # Update solution\n                    new_solution = [new_route if k == route_idx else new_other_route if k == other_route_idx else base_solution[k] for k in range(len(base_solution))]\n\n                    # Validate and return if feasible\n                    if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                        return new_solution\n\n    # Step 3: Apply 2-opt with capacity checks if no better move found\n    for route in base_solution:\n        if len(route) <= 4:  # Skip if too short for 2-opt\n            continue\n\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[j:j+1], route[i+1:j+1], route[i:i+1], route[j+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution = [new_route if r.tolist() == route.tolist() else r for r in base_solution]\n\n            # Validate and return if feasible\n            if all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n                return new_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance makespan\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with at least one customer\n            # Calculate route demand\n            route_demand = sum(demand[node] for node in route[1:-1])\n\n            # If route is overloaded, split it\n            if route_demand > capacity:\n                # Find a split point that balances demand\n                split_point = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand <= capacity:\n                        split_point = i\n                    else:\n                        break\n\n                # Split the route\n                new_route1 = np.array([0] + route[1:split_point+1].tolist() + [0])\n                new_route2 = np.array([0] + route[split_point+1:-1].tolist() + [0])\n\n                # Add the split routes to the solution\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if reallocating a customer between routes improves makespan\n            for node in route1[1:-1]:\n                # Calculate the cost of removing node from route1\n                cost_remove = distance_matrix[route1[np.where(route1 == node)[0][0]-1]][node] + \\\n                              distance_matrix[node][route1[np.where(route1 == node)[0][0]+1]]\n\n                # Calculate the cost of adding node to route2\n                best_pos = 1\n                min_cost_add = float('inf')\n                for pos in range(1, len(route2)):\n                    cost_add = distance_matrix[route2[pos-1]][node] + \\\n                              distance_matrix[node][route2[pos]] - \\\n                              distance_matrix[route2[pos-1]][route2[pos]]\n                    if cost_add < min_cost_add:\n                        min_cost_add = cost_add\n                        best_pos = pos\n\n                # If reallocation improves makespan, perform it\n                if min_cost_add < cost_remove:\n                    # Remove node from route1\n                    mask = route1 != node\n                    new_route1 = route1[mask]\n\n                    # Insert node into route2\n                    new_route2 = np.insert(route2, best_pos, node)\n\n                    # Update the solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n                    # Recheck the updated routes\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7458255080806395,
            10.6790412068367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance makespan\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with at least one customer\n            # Calculate route demand\n            route_demand = sum(demand[node] for node in route[1:-1])\n\n            # If route is overloaded, split it\n            if route_demand > capacity:\n                # Find a split point that balances demand\n                split_point = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand <= capacity:\n                        split_point = i\n                    else:\n                        break\n\n                # Split the route\n                new_route1 = np.array([0] + route[1:split_point+1].tolist() + [0])\n                new_route2 = np.array([0] + route[split_point+1:-1].tolist() + [0])\n\n                # Add the split routes to the solution\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n            else:\n                new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if reallocating a customer between routes improves makespan\n            for node in route1[1:-1]:\n                # Calculate the cost of removing node from route1\n                cost_remove = distance_matrix[route1[np.where(route1 == node)[0][0]-1]][node] + \\\n                              distance_matrix[node][route1[np.where(route1 == node)[0][0]+1]]\n\n                # Calculate the cost of adding node to route2\n                best_pos = 1\n                min_cost_add = float('inf')\n                for pos in range(1, len(route2)):\n                    cost_add = distance_matrix[route2[pos-1]][node] + \\\n                              distance_matrix[node][route2[pos]] - \\\n                              distance_matrix[route2[pos-1]][route2[pos]]\n                    if cost_add < min_cost_add:\n                        min_cost_add = cost_add\n                        best_pos = pos\n\n                # If reallocation improves makespan, perform it\n                if min_cost_add < cost_remove:\n                    # Remove node from route1\n                    mask = route1 != node\n                    new_route1 = route1[mask]\n\n                    # Insert node into route2\n                    new_route2 = np.insert(route2, best_pos, node)\n\n                    # Update the solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n                    # Recheck the updated routes\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break\n\n    # Customer reallocation: Move a customer from a long route to a short route if feasible\n    long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    short_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n    if long_route_idx != short_route_idx:\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            # Check if adding the customer to the short route is feasible\n            if np.sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into the shortest route\n                insert_pos = np.argmin(distance_matrix[short_route[:-1], customer] + distance_matrix[customer, short_route[1:]])\n                short_route = np.insert(short_route, insert_pos + 1, customer)\n                long_route = np.delete(long_route, i)\n\n                # Update the solution\n                new_solution[short_route_idx] = short_route\n                new_solution[long_route_idx] = long_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6783568209625321,
            0.8873895704746246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break\n\n    # Customer reallocation: Move a customer from a long route to a short route if feasible\n    long_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    short_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n    if long_route_idx != short_route_idx:\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            # Check if adding the customer to the short route is feasible\n            if np.sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into the shortest route\n                insert_pos = np.argmin(distance_matrix[short_route[:-1], customer] + distance_matrix[customer, short_route[1:]])\n                short_route = np.insert(short_route, insert_pos + 1, customer)\n                long_route = np.delete(long_route, i)\n\n                # Update the solution\n                new_solution[short_route_idx] = short_route\n                new_solution[long_route_idx] = long_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan (longest route) to balance improvement across objectives, then applies a hybrid local search combining route splitting and customer reallocation to reduce makespan while maintaining feasibility and exploring trade-offs between distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and reallocate customers\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in base_solution])\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Reallocate customers from the second part to other routes if feasible\n    for customer in part2[1:-1]:\n        best_route_idx = -1\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            new_demand = sum(demand[route[1:-1]]) + demand[customer]\n            if new_demand <= capacity:\n                # Calculate the increase in distance if we insert the customer\n                # (simplified: insert at the end for this example)\n                last_node = route[-2]\n                increase = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_route_idx = i\n\n        if best_route_idx != -1:\n            # Insert the customer into the best feasible route\n            new_solution[best_route_idx] = np.append(new_solution[best_route_idx][:-1], [customer, 0])\n\n    # Update the longest route (now split)\n    new_solution[longest_route_idx] = part1\n    if len(part2) > 2:  # Only add if there are customers left\n        new_solution.append(part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6796100055153671,
            0.9357651472091675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split the longest route and reallocate customers\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in base_solution])\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Reallocate customers from the second part to other routes if feasible\n    for customer in part2[1:-1]:\n        best_route_idx = -1\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            new_demand = sum(demand[route[1:-1]]) + demand[customer]\n            if new_demand <= capacity:\n                # Calculate the increase in distance if we insert the customer\n                # (simplified: insert at the end for this example)\n                last_node = route[-2]\n                increase = distance_matrix[last_node][customer] + distance_matrix[customer][0] - distance_matrix[last_node][0]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_route_idx = i\n\n        if best_route_idx != -1:\n            # Insert the customer into the best feasible route\n            new_solution[best_route_idx] = np.append(new_solution[best_route_idx][:-1], [customer, 0])\n\n    # Update the longest route (now split)\n    new_solution[longest_route_idx] = part1\n    if len(part2) > 2:  # Only add if there are customers left\n        new_solution.append(part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine route merging, cross-route relocation, and within-route 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging - merge two routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Cross-route relocation - move a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(len(new_solution))\n        to_route_idx = np.random.randint(len(new_solution))\n        if from_route_idx != to_route_idx:\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:  # Ensure we don't leave an empty route\n                customer_pos = np.random.randint(1, len(from_route) - 1)\n                customer = from_route[customer_pos]\n                to_route = new_solution[to_route_idx]\n\n                # Check capacity constraint\n                if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion point in the target route\n                    best_cost = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(to_route)):\n                        cost = (distance_matrix[to_route[pos-1], customer] +\n                                distance_matrix[customer, to_route[pos]] -\n                                distance_matrix[to_route[pos-1], to_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        new_to_route = np.insert(to_route, best_pos, customer)\n                        new_from_route = np.delete(from_route, customer_pos)\n                        new_solution[to_route_idx] = new_to_route\n                        new_solution[from_route_idx] = new_from_route\n\n    # Step 3: Within-route 2-opt with demand-aware constraints\n    for route in new_solution:\n        if len(route) > 4:  # Only perform if route has enough customers\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            if i + 1 < j:  # Ensure valid 2-opt\n                # Check if the reversed segment's demand is within capacity\n                segment = route[i:j+1]\n                if np.sum(demand[segment[1:-1]]) <= capacity:\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.564071689912953,
            1.7203456163406372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine route merging, cross-route relocation, and within-route 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging - merge two routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Cross-route relocation - move a customer from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(len(new_solution))\n        to_route_idx = np.random.randint(len(new_solution))\n        if from_route_idx != to_route_idx:\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:  # Ensure we don't leave an empty route\n                customer_pos = np.random.randint(1, len(from_route) - 1)\n                customer = from_route[customer_pos]\n                to_route = new_solution[to_route_idx]\n\n                # Check capacity constraint\n                if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion point in the target route\n                    best_cost = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(to_route)):\n                        cost = (distance_matrix[to_route[pos-1], customer] +\n                                distance_matrix[customer, to_route[pos]] -\n                                distance_matrix[to_route[pos-1], to_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        new_to_route = np.insert(to_route, best_pos, customer)\n                        new_from_route = np.delete(from_route, customer_pos)\n                        new_solution[to_route_idx] = new_to_route\n                        new_solution[from_route_idx] = new_from_route\n\n    # Step 3: Within-route 2-opt with demand-aware constraints\n    for route in new_solution:\n        if len(route) > 4:  # Only perform if route has enough customers\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            if i + 1 < j:  # Ensure valid 2-opt\n                # Check if the reversed segment's demand is within capacity\n                segment = route[i:j+1]\n                if np.sum(demand[segment[1:-1]]) <= capacity:\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel hybrid local search operator combines route segment relocation with capacity-aware route merging and splitting, intelligently selected from the archive based on a multi-objective improvement potential heuristic to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (ascending) and distance (descending) to prioritize diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n        selected_idx = min(1, int(0.3 * len(archive_sorted)))  # Select from top 30% candidates\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment relocation + capacity-aware merging/splitting\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Select a random route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        current_route = new_solution[route_idx]\n\n        # Step 2: Extract a random segment from the route\n        if len(current_route) <= 3:  # Skip if route is too short\n            continue\n        start_idx = random.randint(1, len(current_route) - 3)\n        end_idx = random.randint(start_idx + 1, len(current_route) - 2)\n        segment = current_route[start_idx:end_idx]\n\n        # Step 3: Try to relocate the segment to another route or create a new route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n        segment_demand = np.sum(demand[segment])\n\n        # Check capacity constraint for relocation\n        if np.sum(demand[target_route]) + segment_demand <= capacity:\n            # Relocate the segment\n            new_route = np.concatenate([\n                target_route[:1],  # Depot\n                segment,\n                target_route[1:]  # Rest of the route\n            ])\n            new_solution[route_idx] = np.concatenate([\n                current_route[:start_idx],\n                current_route[end_idx:]\n            ])\n            new_solution[target_route_idx] = new_route\n        else:\n            # Try to split the target route to accommodate the segment\n            for split_pos in range(1, len(target_route) - 1):\n                first_part = target_route[:split_pos + 1]\n                second_part = target_route[split_pos:]\n                if (np.sum(demand[first_part]) + segment_demand <= capacity and\n                    np.sum(demand[second_part]) + segment_demand <= capacity):\n                    # Create two new routes\n                    new_route1 = np.concatenate([first_part, segment, second_part])\n                    new_route2 = np.concatenate([target_route[:split_pos + 1], segment, target_route[split_pos:]])\n                    new_solution[route_idx] = np.concatenate([\n                        current_route[:start_idx],\n                        current_route[end_idx:]\n                    ])\n                    new_solution[target_route_idx] = new_route1\n                    if len(new_solution) < len(base_solution) + 1:  # Limit new routes\n                        new_solution.append(new_route2)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Revert to original if infeasible\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8237910496706109,
            0.8911306858062744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (ascending) and distance (descending) to prioritize diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n        selected_idx = min(1, int(0.3 * len(archive_sorted)))  # Select from top 30% candidates\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment relocation + capacity-aware merging/splitting\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Select a random route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        current_route = new_solution[route_idx]\n\n        # Step 2: Extract a random segment from the route\n        if len(current_route) <= 3:  # Skip if route is too short\n            continue\n        start_idx = random.randint(1, len(current_route) - 3)\n        end_idx = random.randint(start_idx + 1, len(current_route) - 2)\n        segment = current_route[start_idx:end_idx]\n\n        # Step 3: Try to relocate the segment to another route or create a new route\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n        segment_demand = np.sum(demand[segment])\n\n        # Check capacity constraint for relocation\n        if np.sum(demand[target_route]) + segment_demand <= capacity:\n            # Relocate the segment\n            new_route = np.concatenate([\n                target_route[:1],  # Depot\n                segment,\n                target_route[1:]  # Rest of the route\n            ])\n            new_solution[route_idx] = np.concatenate([\n                current_route[:start_idx],\n                current_route[end_idx:]\n            ])\n            new_solution[target_route_idx] = new_route\n        else:\n            # Try to split the target route to accommodate the segment\n            for split_pos in range(1, len(target_route) - 1):\n                first_part = target_route[:split_pos + 1]\n                second_part = target_route[split_pos:]\n                if (np.sum(demand[first_part]) + segment_demand <= capacity and\n                    np.sum(demand[second_part]) + segment_demand <= capacity):\n                    # Create two new routes\n                    new_route1 = np.concatenate([first_part, segment, second_part])\n                    new_route2 = np.concatenate([target_route[:split_pos + 1], segment, target_route[split_pos:]])\n                    new_solution[route_idx] = np.concatenate([\n                        current_route[:start_idx],\n                        current_route[end_idx:]\n                    ])\n                    new_solution[target_route_idx] = new_route1\n                    if len(new_solution) < len(base_solution) + 1:  # Limit new routes\n                        new_solution.append(new_route2)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Revert to original if infeasible\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search combining route concatenation, partial reversal, and demand-balanced split to generate a neighbor solution while ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route concatenation, partial reversal, and demand-balanced split\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if concatenation is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Concatenate the two routes\n            concatenated_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.append(concatenated_route)\n\n        # Step 3: Apply partial reversal to a random route\n        if len(new_solution) > 0:\n            route_to_reverse = random.choice(new_solution)\n            if len(route_to_reverse) > 4:  # Ensure enough nodes to reverse\n                start, end = sorted(random.sample(range(1, len(route_to_reverse)-1), 2))\n                reversed_segment = route_to_reverse[start:end+1][::-1]\n                route_to_reverse[start:end+1] = reversed_segment\n\n        # Step 4: Demand-balanced split for overloaded routes\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two balanced parts\n                total_demand = np.sum(demand[route[1:-1]])\n                split_pos = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand > total_demand / 2:\n                        split_pos = i\n                        break\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n                new_solution.remove(route)\n                new_solution.extend([route1, route2])\n\n    return new_solution\n\n",
        "score": [
            -0.6512440870103523,
            0.8189198970794678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route concatenation, partial reversal, and demand-balanced split\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to concatenate\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Check if concatenation is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Concatenate the two routes\n            concatenated_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.append(concatenated_route)\n\n        # Step 3: Apply partial reversal to a random route\n        if len(new_solution) > 0:\n            route_to_reverse = random.choice(new_solution)\n            if len(route_to_reverse) > 4:  # Ensure enough nodes to reverse\n                start, end = sorted(random.sample(range(1, len(route_to_reverse)-1), 2))\n                reversed_segment = route_to_reverse[start:end+1][::-1]\n                route_to_reverse[start:end+1] = reversed_segment\n\n        # Step 4: Demand-balanced split for overloaded routes\n        for route in new_solution:\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two balanced parts\n                total_demand = np.sum(demand[route[1:-1]])\n                split_pos = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand > total_demand / 2:\n                        split_pos = i\n                        break\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n                new_solution.remove(route)\n                new_solution.extend([route1, route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with demand-balanced route merging, dynamically adjusting route lengths to improve both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = random.choices(\n        archive_sorted[:max(1, len(archive) // 2)],\n        weights=[1 / (i + 1) for i in range(min(len(archive) // 2, len(archive)))],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route segment swap + demand-balanced merging\n    if len(new_solution) > 1:\n        # Step 1: Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Find feasible segment swaps\n        feasible_swaps = []\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraints for both routes after swap\n                if (sum(demand[route1[j:]]) + sum(demand[route2[:-1]]) <= capacity and\n                    sum(demand[route1[:i+1]]) + sum(demand[route2[j:]]) <= capacity):\n                    feasible_swaps.append((i, j))\n\n        if feasible_swaps:\n            i, j = random.choice(feasible_swaps)\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:i+1], route2[j:]])\n            new_route2 = np.concatenate([route2[:j+1], route1[i:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 3: Attempt demand-balanced merging if makespan is high\n        if len(new_solution) > 1 and random.random() < 0.3:\n            # Sort routes by demand to find balanced pairs\n            routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n            routes_with_demand.sort(key=lambda x: x[1])\n\n            for i in range(len(routes_with_demand) - 1):\n                idx1, demand1 = routes_with_demand[i]\n                idx2, demand2 = routes_with_demand[i+1]\n\n                if demand1 + demand2 <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([new_solution[idx1][:-1], new_solution[idx2][1:]])\n                    new_solution[idx1] = merged_route\n                    new_solution.pop(idx2)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6266054166853613,
            5.051017701625824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = random.choices(\n        archive_sorted[:max(1, len(archive) // 2)],\n        weights=[1 / (i + 1) for i in range(min(len(archive) // 2, len(archive)))],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route segment swap + demand-balanced merging\n    if len(new_solution) > 1:\n        # Step 1: Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Find feasible segment swaps\n        feasible_swaps = []\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                # Check capacity constraints for both routes after swap\n                if (sum(demand[route1[j:]]) + sum(demand[route2[:-1]]) <= capacity and\n                    sum(demand[route1[:i+1]]) + sum(demand[route2[j:]]) <= capacity):\n                    feasible_swaps.append((i, j))\n\n        if feasible_swaps:\n            i, j = random.choice(feasible_swaps)\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:i+1], route2[j:]])\n            new_route2 = np.concatenate([route2[:j+1], route1[i:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 3: Attempt demand-balanced merging if makespan is high\n        if len(new_solution) > 1 and random.random() < 0.3:\n            # Sort routes by demand to find balanced pairs\n            routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n            routes_with_demand.sort(key=lambda x: x[1])\n\n            for i in range(len(routes_with_demand) - 1):\n                idx1, demand1 = routes_with_demand[i]\n                idx2, demand2 = routes_with_demand[i+1]\n\n                if demand1 + demand2 <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([new_solution[idx1][:-1], new_solution[idx2][1:]])\n                    new_solution[idx1] = merged_route\n                    new_solution.pop(idx2)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Intelligent selection: choose a solution with low makespan or low total distance\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion with capacity checks\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by removing depots and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Customer reinsertion: randomly select a customer and reinsert it into a different route\n    if len(new_solution) > 1 and len(new_solution[0]) > 3:  # Ensure at least one customer in the route\n        # Select a random route and a random customer (excluding depots)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove the customer from the current route\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n            # Find a feasible insertion point in another route\n            for other_route in new_solution:\n                if other_route is not route:\n                    for i in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:i]]) + demand[customer] <= capacity and sum(demand[other_route[i:-1]]) + demand[customer] <= capacity:\n                            # Insert the customer\n                            other_route = np.insert(other_route, i, customer)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.8414813825763162,
            1.401970088481903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Intelligent selection: choose a solution with low makespan or low total distance\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion with capacity checks\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by removing depots and concatenating\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Customer reinsertion: randomly select a customer and reinsert it into a different route\n    if len(new_solution) > 1 and len(new_solution[0]) > 3:  # Ensure at least one customer in the route\n        # Select a random route and a random customer (excluding depots)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove the customer from the current route\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n            # Find a feasible insertion point in another route\n            for other_route in new_solution:\n                if other_route is not route:\n                    for i in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if sum(demand[other_route[1:i]]) + demand[customer] <= capacity and sum(demand[other_route[i:-1]]) + demand[customer] <= capacity:\n                            # Insert the customer\n                            other_route = np.insert(other_route, i, customer)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{A novel hybrid local search strategy combines route splitting, insertion-based relocation, and adaptive capacity-aware swaps to balance distance minimization and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting, insertion-based relocation, and adaptive swaps\n    for _ in range(5):  # Repeat for multiple attempts\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n                split_point = random.randint(2, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_point], [0]])\n                new_route2 = np.concatenate([[0], route[split_point:-1]])\n\n                # Check capacity feasibility\n                if (demand[new_route1[1:-1]].sum() <= capacity and\n                    demand[new_route2[1:-1]].sum() <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Insertion-based relocation (move a customer to another route)\n        for _ in range(3):\n            route_idx = random.randint(0, len(new_solution) - 1)\n            if len(new_solution[route_idx]) <= 3:  # Skip trivial routes\n                continue\n            customer_pos = random.randint(1, len(new_solution[route_idx]) - 2)\n            customer = new_solution[route_idx][customer_pos]\n\n            # Try inserting into another route\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            # Find best insertion position in target route\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(new_solution[target_route_idx])):\n                # Calculate insertion cost\n                prev_node = new_solution[target_route_idx][pos - 1]\n                next_node = new_solution[target_route_idx][pos]\n                cost = (distance_matrix[prev_node][customer] +\n                        distance_matrix[customer][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n                if cost < min_cost and (demand[new_solution[target_route_idx][1:-1]].sum() + demand[customer] <= capacity):\n                    min_cost = cost\n                    best_pos = pos\n\n            # Perform insertion if beneficial\n            if min_cost < float('inf'):\n                # Remove from original route\n                new_solution[route_idx] = np.concatenate([\n                    new_solution[route_idx][:customer_pos],\n                    new_solution[route_idx][customer_pos+1:]\n                ])\n                # Insert into target route\n                new_solution[target_route_idx] = np.concatenate([\n                    new_solution[target_route_idx][:best_pos],\n                    [customer],\n                    new_solution[target_route_idx][best_pos:]\n                ])\n\n        # Step 3: Adaptive capacity-aware swap (between routes)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Select two customers from each route\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                # Check capacity feasibility after swap\n                new_demand1 = demand[route1[1:-1]].sum() - demand[cust1] + demand[cust2]\n                new_demand2 = demand[route2[1:-1]].sum() - demand[cust2] + demand[cust1]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform swap\n                    route1[cust1_pos], route2[cust2_pos] = route2[cust2_pos], route1[cust1_pos]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6907078150097945,
            2.7690301835536957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route splitting, insertion-based relocation, and adaptive swaps\n    for _ in range(5):  # Repeat for multiple attempts\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n                split_point = random.randint(2, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_point], [0]])\n                new_route2 = np.concatenate([[0], route[split_point:-1]])\n\n                # Check capacity feasibility\n                if (demand[new_route1[1:-1]].sum() <= capacity and\n                    demand[new_route2[1:-1]].sum() <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Insertion-based relocation (move a customer to another route)\n        for _ in range(3):\n            route_idx = random.randint(0, len(new_solution) - 1)\n            if len(new_solution[route_idx]) <= 3:  # Skip trivial routes\n                continue\n            customer_pos = random.randint(1, len(new_solution[route_idx]) - 2)\n            customer = new_solution[route_idx][customer_pos]\n\n            # Try inserting into another route\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            # Find best insertion position in target route\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(new_solution[target_route_idx])):\n                # Calculate insertion cost\n                prev_node = new_solution[target_route_idx][pos - 1]\n                next_node = new_solution[target_route_idx][pos]\n                cost = (distance_matrix[prev_node][customer] +\n                        distance_matrix[customer][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n                if cost < min_cost and (demand[new_solution[target_route_idx][1:-1]].sum() + demand[customer] <= capacity):\n                    min_cost = cost\n                    best_pos = pos\n\n            # Perform insertion if beneficial\n            if min_cost < float('inf'):\n                # Remove from original route\n                new_solution[route_idx] = np.concatenate([\n                    new_solution[route_idx][:customer_pos],\n                    new_solution[route_idx][customer_pos+1:]\n                ])\n                # Insert into target route\n                new_solution[target_route_idx] = np.concatenate([\n                    new_solution[target_route_idx][:best_pos],\n                    [customer],\n                    new_solution[target_route_idx][best_pos:]\n                ])\n\n        # Step 3: Adaptive capacity-aware swap (between routes)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Select two customers from each route\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                # Check capacity feasibility after swap\n                new_demand1 = demand[route1[1:-1]].sum() - demand[cust1] + demand[cust2]\n                new_demand2 = demand[route2[1:-1]].sum() - demand[cust2] + demand[cust1]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform swap\n                    route1[cust1_pos], route2[cust2_pos] = route2[cust2_pos], route1[cust1_pos]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The algorithm selects a promising solution from the archive by ranking candidates based on a combined objective score (weighted sum of normalized distance and makespan) and applies a hybrid local search operator that combines route segment swaps with capacity-aware insertions to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Rank solutions by a combined objective score (weighted sum of normalized distance and makespan)\n    objective_values = np.array([obj for _, obj in archive])\n    normalized_distance = (objective_values[:, 0] - np.min(objective_values[:, 0])) / (np.max(objective_values[:, 0]) - np.min(objective_values[:, 0]) + 1e-6)\n    normalized_makespan = (objective_values[:, 1] - np.min(objective_values[:, 1])) / (np.max(objective_values[:, 1]) - np.min(objective_values[:, 1]) + 1e-6)\n    combined_score = normalized_distance + normalized_makespan\n    best_idx = np.argmin(combined_score)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: combine route segment swaps with capacity-aware insertions\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx = random.randint(0, len(new_solution) - 1)\n    route2_idx = random.randint(0, len(new_solution) - 1)\n    while route2_idx == route1_idx:\n        route2_idx = random.randint(0, len(new_solution) - 1)\n\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Step 2: Randomly select segments from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select segment from route1\n    start1 = random.randint(1, len(route1) - 2)\n    end1 = random.randint(start1, len(route1) - 2)\n    segment1 = route1[start1:end1 + 1]\n\n    # Select segment from route2\n    start2 = random.randint(1, len(route2) - 2)\n    end2 = random.randint(start2, len(route2) - 2)\n    segment2 = route2[start2:end2 + 1]\n\n    # Step 3: Check capacity constraints for swapping\n    total_demand1 = np.sum(demand[segment1])\n    total_demand2 = np.sum(demand[segment2])\n\n    # Check if swapping is feasible\n    if (np.sum(demand[route1]) - total_demand1 + total_demand2 <= capacity and\n        np.sum(demand[route2]) - total_demand2 + total_demand1 <= capacity):\n\n        # Perform the swap\n        new_route1 = np.concatenate([route1[:start1], segment2, route1[end1 + 1:]])\n        new_route2 = np.concatenate([route2[:start2], segment1, route2[end2 + 1:]])\n\n        # Update the solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Step 4: Additional capacity-aware insertion (optional)\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Find a random position in another route to insert\n            other_route_idx = random.randint(0, len(new_solution) - 1)\n            while other_route_idx == route1_idx or other_route_idx == route2_idx:\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check capacity constraint\n            if np.sum(demand[other_route]) + demand[customer] <= capacity:\n                # Insert the customer\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove from original route\n                new_route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n                new_solution[route1_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.4433920898598804,
            0.8446364402770996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Rank solutions by a combined objective score (weighted sum of normalized distance and makespan)\n    objective_values = np.array([obj for _, obj in archive])\n    normalized_distance = (objective_values[:, 0] - np.min(objective_values[:, 0])) / (np.max(objective_values[:, 0]) - np.min(objective_values[:, 0]) + 1e-6)\n    normalized_makespan = (objective_values[:, 1] - np.min(objective_values[:, 1])) / (np.max(objective_values[:, 1]) - np.min(objective_values[:, 1]) + 1e-6)\n    combined_score = normalized_distance + normalized_makespan\n    best_idx = np.argmin(combined_score)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: combine route segment swaps with capacity-aware insertions\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx = random.randint(0, len(new_solution) - 1)\n    route2_idx = random.randint(0, len(new_solution) - 1)\n    while route2_idx == route1_idx:\n        route2_idx = random.randint(0, len(new_solution) - 1)\n\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Step 2: Randomly select segments from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select segment from route1\n    start1 = random.randint(1, len(route1) - 2)\n    end1 = random.randint(start1, len(route1) - 2)\n    segment1 = route1[start1:end1 + 1]\n\n    # Select segment from route2\n    start2 = random.randint(1, len(route2) - 2)\n    end2 = random.randint(start2, len(route2) - 2)\n    segment2 = route2[start2:end2 + 1]\n\n    # Step 3: Check capacity constraints for swapping\n    total_demand1 = np.sum(demand[segment1])\n    total_demand2 = np.sum(demand[segment2])\n\n    # Check if swapping is feasible\n    if (np.sum(demand[route1]) - total_demand1 + total_demand2 <= capacity and\n        np.sum(demand[route2]) - total_demand2 + total_demand1 <= capacity):\n\n        # Perform the swap\n        new_route1 = np.concatenate([route1[:start1], segment2, route1[end1 + 1:]])\n        new_route2 = np.concatenate([route2[:start2], segment1, route2[end2 + 1:]])\n\n        # Update the solution\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Step 4: Additional capacity-aware insertion (optional)\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Find a random position in another route to insert\n            other_route_idx = random.randint(0, len(new_solution) - 1)\n            while other_route_idx == route1_idx or other_route_idx == route2_idx:\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check capacity constraint\n            if np.sum(demand[other_route]) + demand[customer] <= capacity:\n                # Insert the customer\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove from original route\n                new_route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n                new_solution[route1_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting and customer reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer solutions with better total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Try splitting the route into two\n        split_pos = random.randint(1, len(route) - 2)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity feasibility for both new routes\n        load1 = sum(demand[node] for node in route1[1:-1])\n        load2 = sum(demand[node] for node in route2[1:-1])\n\n        if load1 <= capacity and load2 <= capacity:\n            new_solution.append(route1.copy())\n            new_solution.append(route2.copy())\n        else:\n            new_solution.append(route.copy())\n\n        # Try reallocating a random customer to another route\n        if len(new_solution) > 1 and len(route) > 3:\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != len(new_solution) - 1])\n            target_route = new_solution[target_route_idx]\n            customer = random.choice(route[1:-1])\n\n            # Check if adding customer to target route is feasible\n            new_load = sum(demand[node] for node in target_route[1:-1]) + demand[customer]\n            if new_load <= capacity:\n                # Find best insertion position in target route\n                min_cost = float('inf')\n                best_pos = 1\n                for i in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                # Insert customer and update routes\n                new_target_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_target_route\n\n                # Remove customer from original route\n                original_route = [r for r in new_solution if customer in r][0]\n                original_route = np.delete(original_route, np.where(original_route == customer)[0][0])\n                new_solution = [r for r in new_solution if len(r) > 2 or (len(r) == 2 and r[0] == 0 and r[1] == 0)]\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Handle missing customers by adding them to the route with most capacity left\n        for customer in missing:\n            best_route_idx = -1\n            best_capacity = -1\n            for i, route in enumerate(new_solution):\n                current_load = sum(demand[node] for node in route[1:-1])\n                if capacity - current_load >= demand[customer] and capacity - current_load > best_capacity:\n                    best_route_idx = i\n                    best_capacity = capacity - current_load\n\n            if best_route_idx != -1:\n                # Find best insertion position\n                best_pos = 1\n                min_cost = float('inf')\n                for i in range(1, len(new_solution[best_route_idx])):\n                    cost = distance_matrix[new_solution[best_route_idx][i-1], customer] + \\\n                           distance_matrix[customer, new_solution[best_route_idx][i]] - \\\n                           distance_matrix[new_solution[best_route_idx][i-1], new_solution[best_route_idx][i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.724666737530469,
            9.051065564155579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer solutions with better total distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Try splitting the route into two\n        split_pos = random.randint(1, len(route) - 2)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity feasibility for both new routes\n        load1 = sum(demand[node] for node in route1[1:-1])\n        load2 = sum(demand[node] for node in route2[1:-1])\n\n        if load1 <= capacity and load2 <= capacity:\n            new_solution.append(route1.copy())\n            new_solution.append(route2.copy())\n        else:\n            new_solution.append(route.copy())\n\n        # Try reallocating a random customer to another route\n        if len(new_solution) > 1 and len(route) > 3:\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != len(new_solution) - 1])\n            target_route = new_solution[target_route_idx]\n            customer = random.choice(route[1:-1])\n\n            # Check if adding customer to target route is feasible\n            new_load = sum(demand[node] for node in target_route[1:-1]) + demand[customer]\n            if new_load <= capacity:\n                # Find best insertion position in target route\n                min_cost = float('inf')\n                best_pos = 1\n                for i in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                # Insert customer and update routes\n                new_target_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_target_route\n\n                # Remove customer from original route\n                original_route = [r for r in new_solution if customer in r][0]\n                original_route = np.delete(original_route, np.where(original_route == customer)[0][0])\n                new_solution = [r for r in new_solution if len(r) > 2 or (len(r) == 2 and r[0] == 0 and r[1] == 0)]\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Handle missing customers by adding them to the route with most capacity left\n        for customer in missing:\n            best_route_idx = -1\n            best_capacity = -1\n            for i, route in enumerate(new_solution):\n                current_load = sum(demand[node] for node in route[1:-1])\n                if capacity - current_load >= demand[customer] and capacity - current_load > best_capacity:\n                    best_route_idx = i\n                    best_capacity = capacity - current_load\n\n            if best_route_idx != -1:\n                # Find best insertion position\n                best_pos = 1\n                min_cost = float('inf')\n                for i in range(1, len(new_solution[best_route_idx])):\n                    cost = distance_matrix[new_solution[best_route_idx][i-1], customer] + \\\n                           distance_matrix[customer, new_solution[best_route_idx][i]] - \\\n                           distance_matrix[new_solution[best_route_idx][i-1], new_solution[best_route_idx][i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a solution from the archive with the highest ratio of total distance to makespan (indicating potential for improvement in both objectives), then applies a hybrid local search combining route merging and split insertion to balance distance and makespan, ensuring feasibility through capacity checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / x[1][1] if x[1][1] != 0 else float('inf'), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route merging and split insertion\n    new_solution = selected_solution.copy()\n\n    # Try merging two routes if they fit capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by concatenating (excluding the depot at the end of first route)\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if idx == i else route for idx, route in enumerate(new_solution) if idx != j]\n\n    # Try splitting a route into two if it reduces makespan\n    if len(new_solution) > 0:\n        route_to_split = random.choice(new_solution)\n        if len(route_to_split) > 3:  # At least 3 nodes (depot + 2 customers + depot)\n            # Find the best split point to minimize the maximum of the two new routes\n            min_max_distance = float('inf')\n            best_split = None\n\n            for k in range(1, len(route_to_split) - 1):\n                first_part = route_to_split[:k+1]\n                second_part = np.concatenate([[0], route_to_split[k+1:]])\n\n                # Check capacity constraints\n                if (sum(demand[first_part[1:-1]]) <= capacity and\n                    sum(demand[second_part[1:-1]]) <= capacity):\n\n                    # Calculate distances for both parts\n                    dist1 = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                    dist2 = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n\n                    if max(dist1, dist2) < min_max_distance:\n                        min_max_distance = max(dist1, dist2)\n                        best_split = (first_part, second_part)\n\n            # Apply the best split if found\n            if best_split is not None:\n                new_solution = [route for route in new_solution if not np.array_equal(route, route_to_split)]\n                new_solution.extend(best_split)\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.776611764562793,
            1.2001149654388428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / x[1][1] if x[1][1] != 0 else float('inf'), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route merging and split insertion\n    new_solution = selected_solution.copy()\n\n    # Try merging two routes if they fit capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by concatenating (excluding the depot at the end of first route)\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [merged_route if idx == i else route for idx, route in enumerate(new_solution) if idx != j]\n\n    # Try splitting a route into two if it reduces makespan\n    if len(new_solution) > 0:\n        route_to_split = random.choice(new_solution)\n        if len(route_to_split) > 3:  # At least 3 nodes (depot + 2 customers + depot)\n            # Find the best split point to minimize the maximum of the two new routes\n            min_max_distance = float('inf')\n            best_split = None\n\n            for k in range(1, len(route_to_split) - 1):\n                first_part = route_to_split[:k+1]\n                second_part = np.concatenate([[0], route_to_split[k+1:]])\n\n                # Check capacity constraints\n                if (sum(demand[first_part[1:-1]]) <= capacity and\n                    sum(demand[second_part[1:-1]]) <= capacity):\n\n                    # Calculate distances for both parts\n                    dist1 = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                    dist2 = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n\n                    if max(dist1, dist2) < min_max_distance:\n                        min_max_distance = max(dist1, dist2)\n                        best_split = (first_part, second_part)\n\n            # Apply the best split if found\n            if best_split is not None:\n                new_solution = [route for route in new_solution if not np.array_equal(route, route_to_split)]\n                new_solution.extend(best_split)\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route-swap + demand-balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to swap segments\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i][1:-1]  # Exclude depot\n        route_j = new_solution[j][1:-1]  # Exclude depot\n\n        # Find feasible split points in both routes\n        def get_feasible_splits(route, max_load):\n            splits = []\n            current_load = 0\n            for k in range(len(route)):\n                current_load += demand[route[k]]\n                if current_load <= max_load:\n                    splits.append(k)\n            return splits\n\n        splits_i = get_feasible_splits(route_i, capacity)\n        splits_j = get_feasible_splits(route_j, capacity)\n\n        if splits_i and splits_j:\n            # Randomly select split points\n            split_i = random.choice(splits_i)\n            split_j = random.choice(splits_j)\n\n            # Swap segments between the two routes\n            new_route_i = np.concatenate([[0], route_i[:split_i], route_j[split_j:], [0]])\n            new_route_j = np.concatenate([[0], route_j[:split_j], route_i[split_i:], [0]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route_i[1:-1]]) <= capacity and\n                np.sum(demand[new_route_j[1:-1]]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Demand-balancing: redistribute customers to balance loads\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 1:\n            # Find the most overloaded customer\n            loads = np.cumsum(demand[customers])\n            overloaded = np.where(loads > capacity)[0]\n            if len(overloaded) > 0:\n                # Move the overloaded customer to a new route\n                overloaded_customer = customers[overloaded[0]]\n                new_route = np.array([0, overloaded_customer, 0])\n                if demand[overloaded_customer] <= capacity:\n                    new_solution.append(new_route)\n                    # Remove from original route\n                    mask = customers != overloaded_customer\n                    new_solution[new_solution.index(route)] = np.concatenate([[0], customers[mask], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.5641133964919524,
            1.4198606312274933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route-swap + demand-balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to swap segments\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i][1:-1]  # Exclude depot\n        route_j = new_solution[j][1:-1]  # Exclude depot\n\n        # Find feasible split points in both routes\n        def get_feasible_splits(route, max_load):\n            splits = []\n            current_load = 0\n            for k in range(len(route)):\n                current_load += demand[route[k]]\n                if current_load <= max_load:\n                    splits.append(k)\n            return splits\n\n        splits_i = get_feasible_splits(route_i, capacity)\n        splits_j = get_feasible_splits(route_j, capacity)\n\n        if splits_i and splits_j:\n            # Randomly select split points\n            split_i = random.choice(splits_i)\n            split_j = random.choice(splits_j)\n\n            # Swap segments between the two routes\n            new_route_i = np.concatenate([[0], route_i[:split_i], route_j[split_j:], [0]])\n            new_route_j = np.concatenate([[0], route_j[:split_j], route_i[split_i:], [0]])\n\n            # Check feasibility\n            if (np.sum(demand[new_route_i[1:-1]]) <= capacity and\n                np.sum(demand[new_route_j[1:-1]]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Demand-balancing: redistribute customers to balance loads\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 1:\n            # Find the most overloaded customer\n            loads = np.cumsum(demand[customers])\n            overloaded = np.where(loads > capacity)[0]\n            if len(overloaded) > 0:\n                # Move the overloaded customer to a new route\n                overloaded_customer = customers[overloaded[0]]\n                new_route = np.array([0, overloaded_customer, 0])\n                if demand[overloaded_customer] <= capacity:\n                    new_solution.append(new_route)\n                    # Remove from original route\n                    mask = customers != overloaded_customer\n                    new_solution[new_solution.index(route)] = np.concatenate([[0], customers[mask], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route shortening and demand-based rebalancing\n    if len(selected_route) > 3:  # Ensure the route has customers to modify\n        # Step 1: Shorten the route by removing a customer with low demand\n        min_demand_idx = np.argmin(demand[selected_route[1:-1]]) + 1  # Skip depot\n        if min_demand_idx < len(selected_route) - 1:\n            removed_customer = selected_route[min_demand_idx]\n            selected_route = np.delete(selected_route, min_demand_idx)\n\n            # Step 2: Rebalance demand by inserting a high-demand customer from another route\n            for i in range(len(base_solution)):\n                if i != route_idx and len(base_solution[i]) > 3:\n                    other_route = base_solution[i].copy()\n                    max_demand_idx = np.argmax(demand[other_route[1:-1]]) + 1\n                    if max_demand_idx < len(other_route) - 1:\n                        inserted_customer = other_route[max_demand_idx]\n                        # Check capacity constraint\n                        if (np.sum(demand[selected_route[1:-1]]) + demand[inserted_customer]) <= capacity:\n                            selected_route = np.insert(selected_route, -1, inserted_customer)\n                            other_route = np.delete(other_route, max_demand_idx)\n                            base_solution[i] = other_route\n                            break\n\n    # Update the base solution with the modified route\n    base_solution[route_idx] = selected_route\n\n    return base_solution\n\n",
        "score": [
            -0.7542986710942208,
            0.6551407277584076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route shortening and demand-based rebalancing\n    if len(selected_route) > 3:  # Ensure the route has customers to modify\n        # Step 1: Shorten the route by removing a customer with low demand\n        min_demand_idx = np.argmin(demand[selected_route[1:-1]]) + 1  # Skip depot\n        if min_demand_idx < len(selected_route) - 1:\n            removed_customer = selected_route[min_demand_idx]\n            selected_route = np.delete(selected_route, min_demand_idx)\n\n            # Step 2: Rebalance demand by inserting a high-demand customer from another route\n            for i in range(len(base_solution)):\n                if i != route_idx and len(base_solution[i]) > 3:\n                    other_route = base_solution[i].copy()\n                    max_demand_idx = np.argmax(demand[other_route[1:-1]]) + 1\n                    if max_demand_idx < len(other_route) - 1:\n                        inserted_customer = other_route[max_demand_idx]\n                        # Check capacity constraint\n                        if (np.sum(demand[selected_route[1:-1]]) + demand[inserted_customer]) <= capacity:\n                            selected_route = np.insert(selected_route, -1, inserted_customer)\n                            other_route = np.delete(other_route, max_demand_idx)\n                            base_solution[i] = other_route\n                            break\n\n    # Update the base solution with the modified route\n    base_solution[route_idx] = selected_route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Attempt route merging with capacity-aware splitting\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n\n        # Check capacity feasibility\n        total_demand = sum(demand[merged_route])\n        if total_demand <= capacity:\n            # Split the merged route into two if it exceeds capacity\n            split_pos = len(merged_route) // 2\n            route1 = np.concatenate(([0], merged_route[:split_pos], [0]))\n            route2 = np.concatenate(([0], merged_route[split_pos:], [0]))\n\n            # Replace the original routes\n            new_solution[i] = route1\n            new_solution[j] = route2\n\n    # Step 3: Perform inter-route insertion with demand balancing\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes and a customer to move\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 2:\n            # Select a customer from route1 (excluding depot)\n            customer_pos = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_pos]\n\n            # Check if moving the customer to route2 is feasible\n            if sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert the customer into route2\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.insert(route2, insert_pos, customer)\n                new_route1 = np.delete(route1, customer_pos)\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.724870679339668,
            0.6767160296440125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Attempt route merging with capacity-aware splitting\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n\n        # Check capacity feasibility\n        total_demand = sum(demand[merged_route])\n        if total_demand <= capacity:\n            # Split the merged route into two if it exceeds capacity\n            split_pos = len(merged_route) // 2\n            route1 = np.concatenate(([0], merged_route[:split_pos], [0]))\n            route2 = np.concatenate(([0], merged_route[split_pos:], [0]))\n\n            # Replace the original routes\n            new_solution[i] = route1\n            new_solution[j] = route2\n\n    # Step 3: Perform inter-route insertion with demand balancing\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes and a customer to move\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 2:\n            # Select a customer from route1 (excluding depot)\n            customer_pos = np.random.randint(1, len(route1)-1)\n            customer = route1[customer_pos]\n\n            # Check if moving the customer to route2 is feasible\n            if sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert the customer into route2\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.insert(route2, insert_pos, customer)\n                new_route1 = np.delete(route1, customer_pos)\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Choose a random route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    if len(selected_route) > 4:  # Ensure the route is long enough to split\n        # Split the route into two parts\n        split_pos = np.random.randint(2, len(selected_route) - 2)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r.copy() for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.extend([part1, part2])\n            return new_solution\n\n    # If splitting fails, try reinserting a random customer into a different route\n    if len(base_solution) > 1:\n        # Select a random customer from a random route (excluding depot)\n        from_route_idx = np.random.randint(0, len(base_solution))\n        from_route = base_solution[from_route_idx].copy()\n        if len(from_route) > 3:  # Ensure the route has customers to remove\n            customer_pos = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_pos]\n            customer_demand = demand[customer]\n\n            # Remove the customer from its current route\n            modified_route = np.delete(from_route, customer_pos)\n\n            # Try to insert into another route\n            to_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != from_route_idx])\n            to_route = base_solution[to_route_idx].copy()\n\n            # Find the best insertion position in the target route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(to_route)):\n                new_route = np.insert(to_route, pos, customer)\n                new_demand = np.sum(demand[new_route[1:-1]])\n\n                if new_demand <= capacity:\n                    # Calculate the increase in total distance\n                    if pos == 1:\n                        increase = distance_matrix[0, customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[0, to_route[pos]]\n                    elif pos == len(to_route) - 1:\n                        increase = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, 0] - distance_matrix[to_route[pos-1], 0]\n                    else:\n                        increase = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[to_route[pos-1], to_route[pos]]\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if min_increase != float('inf'):\n                # Perform the insertion\n                new_to_route = np.insert(to_route, best_pos, customer)\n                new_solution = [r.copy() for r in base_solution]\n                new_solution[from_route_idx] = modified_route\n                new_solution[to_route_idx] = new_to_route\n                return new_solution\n\n    # If no improvement, return the original solution\n    return base_solution\n\n",
        "score": [
            -0.8469436884484955,
            0.4374014735221863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Choose a random route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    if len(selected_route) > 4:  # Ensure the route is long enough to split\n        # Split the route into two parts\n        split_pos = np.random.randint(2, len(selected_route) - 2)\n        part1 = selected_route[:split_pos + 1]\n        part2 = selected_route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r.copy() for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.extend([part1, part2])\n            return new_solution\n\n    # If splitting fails, try reinserting a random customer into a different route\n    if len(base_solution) > 1:\n        # Select a random customer from a random route (excluding depot)\n        from_route_idx = np.random.randint(0, len(base_solution))\n        from_route = base_solution[from_route_idx].copy()\n        if len(from_route) > 3:  # Ensure the route has customers to remove\n            customer_pos = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_pos]\n            customer_demand = demand[customer]\n\n            # Remove the customer from its current route\n            modified_route = np.delete(from_route, customer_pos)\n\n            # Try to insert into another route\n            to_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != from_route_idx])\n            to_route = base_solution[to_route_idx].copy()\n\n            # Find the best insertion position in the target route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(to_route)):\n                new_route = np.insert(to_route, pos, customer)\n                new_demand = np.sum(demand[new_route[1:-1]])\n\n                if new_demand <= capacity:\n                    # Calculate the increase in total distance\n                    if pos == 1:\n                        increase = distance_matrix[0, customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[0, to_route[pos]]\n                    elif pos == len(to_route) - 1:\n                        increase = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, 0] - distance_matrix[to_route[pos-1], 0]\n                    else:\n                        increase = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[to_route[pos-1], to_route[pos]]\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if min_increase != float('inf'):\n                # Perform the insertion\n                new_to_route = np.insert(to_route, best_pos, customer)\n                new_solution = [r.copy() for r in base_solution]\n                new_solution[from_route_idx] = modified_route\n                new_solution[to_route_idx] = new_to_route\n                return new_solution\n\n    # If no improvement, return the original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a solution from the archive with the highest normalized objective improvement potential, then applies a hybrid local search combining route-splitting and demand-aware node swapping to generate a neighbor solution while balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and demand-aware node swapping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try to split the route into two if demand allows\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand <= capacity * 0.8:  # Only split if route is not too full\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity constraints\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Demand-aware node swapping\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if swapping nodes i and j improves distance or makespan\n                original_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]] + \\\n                               distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n                swapped_dist = distance_matrix[route[i-1], route[j]] + distance_matrix[route[j], route[i+1]] + \\\n                              distance_matrix[route[j-1], route[i]] + distance_matrix[route[i], route[j+1]]\n\n                if swapped_dist < original_dist:\n                    # Check capacity constraints after swap\n                    route_demand = sum(demand[node] for node in route[1:-1])\n                    if route_demand <= capacity:\n                        route[i], route[j] = route[j], route[i]\n                        new_solution[route_idx] = route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6005535548032699,
            5.159442692995071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-splitting and demand-aware node swapping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try to split the route into two if demand allows\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand <= capacity * 0.8:  # Only split if route is not too full\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity constraints\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Demand-aware node swapping\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if swapping nodes i and j improves distance or makespan\n                original_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]] + \\\n                               distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n                swapped_dist = distance_matrix[route[i-1], route[j]] + distance_matrix[route[j], route[i+1]] + \\\n                              distance_matrix[route[j-1], route[i]] + distance_matrix[route[i], route[j+1]]\n\n                if swapped_dist < original_dist:\n                    # Check capacity constraints after swap\n                    route_demand = sum(demand[node] for node in route[1:-1])\n                    if route_demand <= capacity:\n                        route[i], route[j] = route[j], route[i]\n                        new_solution[route_idx] = route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{Our novel local search strategy combines route splitting, cross-route insertion, and adaptive route merging to balance distance and makespan objectives, while ensuring feasibility through capacity checks and intelligent customer reallocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Pick from top 30%\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        new_route = route.copy()\n        # Randomly select a segment to modify\n        if len(new_route) > 3:  # Ensure route has enough nodes to modify\n            start = random.randint(1, len(new_route) - 3)\n            end = random.randint(start + 1, len(new_route) - 2)\n            segment = new_route[start:end]\n\n            # Try to insert this segment into another route\n            for other_route in selected_solution:\n                if np.array_equal(other_route, new_route):\n                    continue\n                # Check if other route can accommodate the segment\n                segment_demand = sum(demand[segment])\n                if sum(demand[other_route]) + segment_demand <= capacity:\n                    # Insert segment into other route\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    modified_other_route = np.concatenate([\n                        other_route[:insert_pos],\n                        segment,\n                        other_route[insert_pos:]\n                    ])\n                    # Update the routes\n                    new_route = np.concatenate([new_route[:start], new_route[end:]])\n                    new_solution.append(modified_other_route)\n                    break\n\n        # Add the modified (or unmodified) route to the new solution\n        new_solution.append(new_route)\n\n    # Remove empty routes and check feasibility\n    final_solution = [route for route in new_solution if len(route) > 2]\n    for route in final_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, try to split the route\n            split_pos = len(route) // 2\n            final_solution.remove(route)\n            final_solution.append(route[:split_pos + 1])\n            final_solution.append(np.concatenate([[0], route[split_pos:], [0]]))\n\n    return final_solution\n\n",
        "score": [
            -0.8070900632632896,
            3.347507119178772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Pick from top 30%\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        new_route = route.copy()\n        # Randomly select a segment to modify\n        if len(new_route) > 3:  # Ensure route has enough nodes to modify\n            start = random.randint(1, len(new_route) - 3)\n            end = random.randint(start + 1, len(new_route) - 2)\n            segment = new_route[start:end]\n\n            # Try to insert this segment into another route\n            for other_route in selected_solution:\n                if np.array_equal(other_route, new_route):\n                    continue\n                # Check if other route can accommodate the segment\n                segment_demand = sum(demand[segment])\n                if sum(demand[other_route]) + segment_demand <= capacity:\n                    # Insert segment into other route\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    modified_other_route = np.concatenate([\n                        other_route[:insert_pos],\n                        segment,\n                        other_route[insert_pos:]\n                    ])\n                    # Update the routes\n                    new_route = np.concatenate([new_route[:start], new_route[end:]])\n                    new_solution.append(modified_other_route)\n                    break\n\n        # Add the modified (or unmodified) route to the new solution\n        new_solution.append(new_route)\n\n    # Remove empty routes and check feasibility\n    final_solution = [route for route in new_solution if len(route) > 2]\n    for route in final_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, try to split the route\n            split_pos = len(route) // 2\n            final_solution.remove(route)\n            final_solution.append(route[:split_pos + 1])\n            final_solution.append(np.concatenate([[0], route[split_pos:], [0]]))\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, merging, and reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with potential for splitting\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Reinsertion: Move a random customer from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure route has customers to remove\n            customer_pos = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_pos]\n\n            # Try to insert into another route\n            for dst_route_idx in range(len(new_solution)):\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n                for insert_pos in range(1, len(dst_route)):\n                    new_dst_route = np.insert(dst_route, insert_pos, customer)\n                    if np.sum(demand[new_dst_route[1:-1]]) <= capacity:\n                        new_solution[dst_route_idx] = new_dst_route\n                        new_solution[src_route_idx] = np.delete(src_route, customer_pos)\n                        break\n\n    # Merge routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8237114521931803,
            8.612370491027832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting, merging, and reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with potential for splitting\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Reinsertion: Move a random customer from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure route has customers to remove\n            customer_pos = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_pos]\n\n            # Try to insert into another route\n            for dst_route_idx in range(len(new_solution)):\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n                for insert_pos in range(1, len(dst_route)):\n                    new_dst_route = np.insert(dst_route, insert_pos, customer)\n                    if np.sum(demand[new_dst_route[1:-1]]) <= capacity:\n                        new_solution[dst_route_idx] = new_dst_route\n                        new_solution[src_route_idx] = np.delete(src_route, customer_pos)\n                        break\n\n    # Merge routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(selected_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Merge the two routes into a single route\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Reinsert customers from the merged route back into separate routes\n            # using a greedy approach to minimize total distance\n            remaining_customers = merged_route[1:-1]\n            new_routes = []\n\n            while remaining_customers.size > 0:\n                current_route = [0]\n                current_load = 0\n\n                for customer in remaining_customers:\n                    if current_load + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_load += demand[customer]\n                        remaining_customers = np.delete(remaining_customers, np.where(remaining_customers == customer)[0])\n                    else:\n                        break\n\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n\n            # Replace the original routes with the new ones\n            selected_solution.pop(route_indices[0])\n            selected_solution.pop(route_indices[1] - 1 if route_indices[0] < route_indices[1] else route_indices[1])\n            selected_solution.extend(new_routes)\n\n    # If merging didn't work, perform a customer reinsertion\n    if len(selected_solution) == 1 or random.random() < 0.3:\n        # Select a random route and a random customer to reinsert\n        route_idx = random.randint(0, len(selected_solution) - 1)\n        route = selected_solution[route_idx].copy()\n\n        if len(route) > 3:  # Ensure there are customers to remove\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Remove the customer from the route\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n            # Find the best position to reinsert the customer in another route or new route\n            best_cost = float('inf')\n            best_new_solution = None\n\n            # Try inserting into existing routes\n            for i, candidate_route in enumerate(selected_solution):\n                if i == route_idx:\n                    continue\n\n                for pos in range(1, len(candidate_route)):\n                    # Insert customer at position pos\n                    temp_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n\n                    # Check capacity\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the new solution\n                        new_routes = selected_solution.copy()\n                        new_routes[route_idx] = new_route\n                        new_routes[i] = temp_route\n\n                        # Calculate total distance\n                        total_distance = sum(\n                            sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n                            for temp_route in new_routes\n                        )\n\n                        if total_distance < best_cost:\n                            best_cost = total_distance\n                            best_new_solution = new_routes\n\n            # If no better insertion found, create a new route\n            if best_new_solution is None:\n                new_route = np.array([0, customer, 0])\n                if demand[customer] <= capacity:\n                    best_new_solution = selected_solution.copy()\n                    best_new_solution[route_idx] = new_route\n                    best_new_solution.append(new_route)\n\n            if best_new_solution is not None:\n                selected_solution = best_new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.7286452388617599,
            5.28037616610527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(selected_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Merge the two routes into a single route\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Reinsert customers from the merged route back into separate routes\n            # using a greedy approach to minimize total distance\n            remaining_customers = merged_route[1:-1]\n            new_routes = []\n\n            while remaining_customers.size > 0:\n                current_route = [0]\n                current_load = 0\n\n                for customer in remaining_customers:\n                    if current_load + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_load += demand[customer]\n                        remaining_customers = np.delete(remaining_customers, np.where(remaining_customers == customer)[0])\n                    else:\n                        break\n\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n\n            # Replace the original routes with the new ones\n            selected_solution.pop(route_indices[0])\n            selected_solution.pop(route_indices[1] - 1 if route_indices[0] < route_indices[1] else route_indices[1])\n            selected_solution.extend(new_routes)\n\n    # If merging didn't work, perform a customer reinsertion\n    if len(selected_solution) == 1 or random.random() < 0.3:\n        # Select a random route and a random customer to reinsert\n        route_idx = random.randint(0, len(selected_solution) - 1)\n        route = selected_solution[route_idx].copy()\n\n        if len(route) > 3:  # Ensure there are customers to remove\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n\n            # Remove the customer from the route\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n            # Find the best position to reinsert the customer in another route or new route\n            best_cost = float('inf')\n            best_new_solution = None\n\n            # Try inserting into existing routes\n            for i, candidate_route in enumerate(selected_solution):\n                if i == route_idx:\n                    continue\n\n                for pos in range(1, len(candidate_route)):\n                    # Insert customer at position pos\n                    temp_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n\n                    # Check capacity\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the new solution\n                        new_routes = selected_solution.copy()\n                        new_routes[route_idx] = new_route\n                        new_routes[i] = temp_route\n\n                        # Calculate total distance\n                        total_distance = sum(\n                            sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n                            for temp_route in new_routes\n                        )\n\n                        if total_distance < best_cost:\n                            best_cost = total_distance\n                            best_new_solution = new_routes\n\n            # If no better insertion found, create a new route\n            if best_new_solution is None:\n                new_route = np.array([0, customer, 0])\n                if demand[customer] <= capacity:\n                    best_new_solution = selected_solution.copy()\n                    best_new_solution[route_idx] = new_route\n                    best_new_solution.append(new_route)\n\n            if best_new_solution is not None:\n                selected_solution = best_new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting operation, then a cross-route insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route-splitting (split the longest route into two parts)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n    split_pos = len(longest_route) // 2\n    new_route1 = longest_route[:split_pos + 1]\n    new_route2 = longest_route[split_pos:]\n\n    # Ensure both new routes are valid (start and end at depot)\n    new_route1[-1] = 0\n    new_route2[0] = 0\n\n    # Check capacity constraints for the new routes\n    def is_valid(route):\n        total_demand = sum(demand[node] for node in route[1:-1])\n        return total_demand <= capacity\n\n    if is_valid(new_route1) and is_valid(new_route2):\n        new_solution[longest_route_idx] = new_route1\n        new_solution.append(new_route2)\n    else:\n        # If splitting violates capacity, revert to original route\n        new_solution = selected_solution.copy()\n\n    # Step 2: Cross-route insertion (move a node from the longest route to another route)\n    if len(new_solution) > 1:\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a random node from the longest route (excluding depot)\n        if len(longest_route) > 2:\n            node_to_move = np.random.choice(longest_route[1:-1])\n\n            # Find the best insertion position in another route\n            best_route_idx, best_pos, best_cost = None, None, float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Insert node_to_move at position pos in route\n                    new_route = np.insert(route, pos, node_to_move)\n\n                    # Check capacity constraint\n                    if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                        continue\n\n                    # Calculate the cost of the new route\n                    cost = sum(distance_matrix[new_route[k-1], new_route[k]] for k in range(1, len(new_route)))\n\n                    # Update best insertion if cost is lower\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx is not None:\n                # Remove node_to_move from the original route\n                new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == node_to_move)[0])\n\n                # Insert node_to_move into the best route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6322154786144596,
            7.247788369655609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search: first perform a route-splitting operation, then a cross-route insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route-splitting (split the longest route into two parts)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n    split_pos = len(longest_route) // 2\n    new_route1 = longest_route[:split_pos + 1]\n    new_route2 = longest_route[split_pos:]\n\n    # Ensure both new routes are valid (start and end at depot)\n    new_route1[-1] = 0\n    new_route2[0] = 0\n\n    # Check capacity constraints for the new routes\n    def is_valid(route):\n        total_demand = sum(demand[node] for node in route[1:-1])\n        return total_demand <= capacity\n\n    if is_valid(new_route1) and is_valid(new_route2):\n        new_solution[longest_route_idx] = new_route1\n        new_solution.append(new_route2)\n    else:\n        # If splitting violates capacity, revert to original route\n        new_solution = selected_solution.copy()\n\n    # Step 2: Cross-route insertion (move a node from the longest route to another route)\n    if len(new_solution) > 1:\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a random node from the longest route (excluding depot)\n        if len(longest_route) > 2:\n            node_to_move = np.random.choice(longest_route[1:-1])\n\n            # Find the best insertion position in another route\n            best_route_idx, best_pos, best_cost = None, None, float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Insert node_to_move at position pos in route\n                    new_route = np.insert(route, pos, node_to_move)\n\n                    # Check capacity constraint\n                    if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                        continue\n\n                    # Calculate the cost of the new route\n                    cost = sum(distance_matrix[new_route[k-1], new_route[k]] for k in range(1, len(new_route)))\n\n                    # Update best insertion if cost is lower\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx is not None:\n                # Remove node_to_move from the original route\n                new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == node_to_move)[0])\n\n                # Insert node_to_move into the best route\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    if len(route) > 4:  # Skip if route is too short\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(2, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Calculate total demand for each part\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        # Ensure both parts are feasible\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Update the solution with the split routes\n            new_solution = [r.copy() for r in selected_solution if not np.array_equal(r, route)]\n            new_solution.extend([part1, part2])\n\n            # Apply customer reinsertion to improve the split routes\n            for r in new_solution:\n                if len(r) > 4:  # Only reinsert if route is long enough\n                    # Randomly select a customer to reinsert\n                    customer_idx = np.random.randint(1, len(r) - 1)\n                    customer = r[customer_idx]\n\n                    # Remove the customer\n                    r = np.delete(r, customer_idx)\n\n                    # Find the best position to reinsert the customer (minimizing distance increase)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(r)):\n                        # Calculate distance increase if inserted at position i\n                        dist_increase = (distance_matrix[r[i-1]][customer] + distance_matrix[customer][r[i]]) - distance_matrix[r[i-1]][r[i]]\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = i\n\n                    # Insert the customer at the best position\n                    r = np.insert(r, best_pos, customer)\n\n            return new_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.7664254033502877,
            1.7297991216182709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    if len(route) > 4:  # Skip if route is too short\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(2, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Calculate total demand for each part\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        # Ensure both parts are feasible\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Update the solution with the split routes\n            new_solution = [r.copy() for r in selected_solution if not np.array_equal(r, route)]\n            new_solution.extend([part1, part2])\n\n            # Apply customer reinsertion to improve the split routes\n            for r in new_solution:\n                if len(r) > 4:  # Only reinsert if route is long enough\n                    # Randomly select a customer to reinsert\n                    customer_idx = np.random.randint(1, len(r) - 1)\n                    customer = r[customer_idx]\n\n                    # Remove the customer\n                    r = np.delete(r, customer_idx)\n\n                    # Find the best position to reinsert the customer (minimizing distance increase)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(r)):\n                        # Calculate distance increase if inserted at position i\n                        dist_increase = (distance_matrix[r[i-1]][customer] + distance_matrix[customer][r[i]]) - distance_matrix[r[i-1]][r[i]]\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = i\n\n                    # Insert the customer at the best position\n                    r = np.insert(r, best_pos, customer)\n\n            return new_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, insertion, and swap operations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias\n    total_distances = [sol[1][0] for sol in archive]\n    makespans = [sol[1][1] for sol in archive]\n\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_make, max_make = min(makespans), max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        norm_distances = [0.5 for _ in total_distances]\n    else:\n        norm_distances = [(d - min_dist) / (max_dist - min_dist) for d in total_distances]\n\n    if max_make == min_make:\n        norm_makespans = [0.5 for _ in makespans]\n    else:\n        norm_makespans = [(m - min_make) / (max_make - min_make) for m in makespans]\n\n    # Combine normalized objectives and select the best\n    scores = [norm_distances[i] + norm_makespans[i] for i in range(len(archive))]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine route splitting, insertion, and swap\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for the split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try a different approach\n            # Try inserting a random customer into another route or swapping segments\n            temp_route = route.copy()\n            # Randomly select two positions to swap\n            pos1, pos2 = np.random.choice(range(1, len(temp_route) - 1), 2, replace=False)\n            # Ensure the swap maintains capacity\n            if np.sum(demand[temp_route[1:pos1]]) + demand[temp_route[pos2]] <= capacity and \\\n               np.sum(demand[temp_route[1:pos2]]) + demand[temp_route[pos1]] <= capacity:\n                temp_route[pos1], temp_route[pos2] = temp_route[pos2], temp_route[pos1]\n            new_solution.append(temp_route)\n\n    # Post-process to ensure all routes are valid\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Ensure route has at least one customer\n            final_solution.append(route)\n\n    # If no routes remain, revert to original solution\n    if not final_solution:\n        final_solution = base_solution.copy()\n\n    return final_solution\n\n",
        "score": [
            -0.7623334200195355,
            0.822720468044281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias\n    total_distances = [sol[1][0] for sol in archive]\n    makespans = [sol[1][1] for sol in archive]\n\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_make, max_make = min(makespans), max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        norm_distances = [0.5 for _ in total_distances]\n    else:\n        norm_distances = [(d - min_dist) / (max_dist - min_dist) for d in total_distances]\n\n    if max_make == min_make:\n        norm_makespans = [0.5 for _ in makespans]\n    else:\n        norm_makespans = [(m - min_make) / (max_make - min_make) for m in makespans]\n\n    # Combine normalized objectives and select the best\n    scores = [norm_distances[i] + norm_makespans[i] for i in range(len(archive))]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine route splitting, insertion, and swap\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for the split parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try a different approach\n            # Try inserting a random customer into another route or swapping segments\n            temp_route = route.copy()\n            # Randomly select two positions to swap\n            pos1, pos2 = np.random.choice(range(1, len(temp_route) - 1), 2, replace=False)\n            # Ensure the swap maintains capacity\n            if np.sum(demand[temp_route[1:pos1]]) + demand[temp_route[pos2]] <= capacity and \\\n               np.sum(demand[temp_route[1:pos2]]) + demand[temp_route[pos1]] <= capacity:\n                temp_route[pos1], temp_route[pos2] = temp_route[pos2], temp_route[pos1]\n            new_solution.append(temp_route)\n\n    # Post-process to ensure all routes are valid\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Ensure route has at least one customer\n            final_solution.append(route)\n\n    # If no routes remain, revert to original solution\n    if not final_solution:\n        final_solution = base_solution.copy()\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + customer reallocation + capacity-aware insertion\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i = np.random.randint(0, len(new_solution))\n        j = np.random.randint(0, len(new_solution))\n        if i != j:\n            route1 = new_solution[i][1:-1]  # exclude depots\n            route2 = new_solution[j][1:-1]\n            merged_route = np.concatenate([[0], route1, route2, [0]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # If merge is feasible, perform it\n                new_solution.pop(max(i, j))\n                new_solution.pop(min(i, j))\n                new_solution.append(merged_route)\n            else:\n                # If not, try reallocating customers between routes\n                for _ in range(2):  # try a few times\n                    k = np.random.randint(0, len(route1))\n                    customer = route1[k]\n                    # Find feasible insertion in route2\n                    for pos in range(1, len(route2)):\n                        temp_route = np.concatenate([[0], route2[:pos], [customer], route2[pos:], [0]])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[i] = np.concatenate([[0], route1[:k], route1[k+1:], [0]])\n                            new_solution[j] = temp_route\n                            break\n\n    # Capacity-aware insertion for unassigned customers\n    unassigned = set(range(1, len(demand)))\n    for route in new_solution:\n        unassigned.difference_update(route[1:-1])\n    if unassigned:\n        for customer in list(unassigned):\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r_idx, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    temp_route = np.concatenate([[0], route[1:pos], [customer], route[pos:-1], [0]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_route = r_idx\n                            best_pos = pos\n                            best_cost = cost\n            if best_route != -1:\n                new_solution[best_route] = np.concatenate([[0], new_solution[best_route][1:best_pos], [customer], new_solution[best_route][best_pos:-1], [0]])\n                unassigned.remove(customer)\n    # If any customers remain unassigned, create new routes\n    while unassigned:\n        customer = unassigned.pop()\n        new_solution.append(np.array([0, customer, 0]))\n\n    return [route.copy() for route in new_solution]\n\n",
        "score": [
            -0.6606259769950538,
            1.5634324252605438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route merging + customer reallocation + capacity-aware insertion\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        i = np.random.randint(0, len(new_solution))\n        j = np.random.randint(0, len(new_solution))\n        if i != j:\n            route1 = new_solution[i][1:-1]  # exclude depots\n            route2 = new_solution[j][1:-1]\n            merged_route = np.concatenate([[0], route1, route2, [0]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # If merge is feasible, perform it\n                new_solution.pop(max(i, j))\n                new_solution.pop(min(i, j))\n                new_solution.append(merged_route)\n            else:\n                # If not, try reallocating customers between routes\n                for _ in range(2):  # try a few times\n                    k = np.random.randint(0, len(route1))\n                    customer = route1[k]\n                    # Find feasible insertion in route2\n                    for pos in range(1, len(route2)):\n                        temp_route = np.concatenate([[0], route2[:pos], [customer], route2[pos:], [0]])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[i] = np.concatenate([[0], route1[:k], route1[k+1:], [0]])\n                            new_solution[j] = temp_route\n                            break\n\n    # Capacity-aware insertion for unassigned customers\n    unassigned = set(range(1, len(demand)))\n    for route in new_solution:\n        unassigned.difference_update(route[1:-1])\n    if unassigned:\n        for customer in list(unassigned):\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r_idx, route in enumerate(new_solution):\n                for pos in range(1, len(route)):\n                    temp_route = np.concatenate([[0], route[1:pos], [customer], route[pos:-1], [0]])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_route = r_idx\n                            best_pos = pos\n                            best_cost = cost\n            if best_route != -1:\n                new_solution[best_route] = np.concatenate([[0], new_solution[best_route][1:best_pos], [customer], new_solution[best_route][best_pos:-1], [0]])\n                unassigned.remove(customer)\n    # If any customers remain unassigned, create new routes\n    while unassigned:\n        customer = unassigned.pop()\n        new_solution.append(np.array([0, customer, 0]))\n\n    return [route.copy() for route in new_solution]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n\n    # Step 2: Identify the longest route (highest makespan) in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Segment the longest route into two parts at a demand-balanced split point\n    cumulative_demand = np.cumsum(demand[longest_route[1:-1]])\n    split_idx = np.argmin(np.abs(cumulative_demand - cumulative_demand[-1] / 2)) + 1\n    part1 = longest_route[:split_idx + 1]\n    part2 = np.concatenate([[0], longest_route[split_idx:]])\n\n    # Step 4: Find a compatible route to merge part2 into (demand + part2 demand <= capacity)\n    compatible_routes = []\n    part2_demand = demand[part2[1:-1]].sum()\n    for i, route in enumerate(selected_solution):\n        if i != longest_route_idx and demand[route[1:-1]].sum() + part2_demand <= capacity:\n            compatible_routes.append(i)\n\n    if compatible_routes:\n        merge_route_idx = np.random.choice(compatible_routes)\n        merge_route = selected_solution[merge_route_idx].copy()\n\n        # Step 5: Merge part2 into the compatible route at the best insertion point\n        best_insertion_cost = float('inf')\n        best_insertion_pos = 1\n        for i in range(1, len(merge_route)):\n            insertion_cost = distance_matrix[merge_route[i-1], part2[1]] + distance_matrix[part2[-2], merge_route[i]] - distance_matrix[merge_route[i-1], merge_route[i]]\n            if insertion_cost < best_insertion_cost:\n                best_insertion_cost = insertion_cost\n                best_insertion_pos = i\n\n        # Insert part2 into merge_route at the best position\n        new_merge_route = np.concatenate([merge_route[:best_insertion_pos], part2[1:-1], merge_route[best_insertion_pos:]])\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in [longest_route_idx, merge_route_idx]]\n        new_solution.extend([part1, new_merge_route])\n    else:\n        # If no compatible route, just split the longest route into two\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.extend([part1, part2])\n\n    # Step 6: Apply inter-route customer swaps to improve both objectives\n    for _ in range(2):  # Limited iterations for efficiency\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find best customer to swap between routes\n        best_swap_cost = float('inf')\n        best_swap = None\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Check demand constraints\n                if demand[route1[1:-1]].sum() - demand[route1[i]] + demand[route2[j]] <= capacity and \\\n                   demand[route2[1:-1]].sum() - demand[route2[j]] + demand[route1[i]] <= capacity:\n                    # Calculate swap cost difference\n                    cost_diff = (distance_matrix[route1[i-1], route2[j]] + distance_matrix[route2[j], route1[i+1]] +\n                                 distance_matrix[route2[j-1], route1[i]] + distance_matrix[route1[i], route2[j+1]]) - \\\n                                (distance_matrix[route1[i-1], route1[i]] + distance_matrix[route1[i], route1[i+1]] +\n                                 distance_matrix[route2[j-1], route2[j]] + distance_matrix[route2[j], route2[j+1]])\n                    if cost_diff < best_swap_cost:\n                        best_swap_cost = cost_diff\n                        best_swap = (i, j)\n\n        if best_swap and best_swap_cost < 0:\n            i, j = best_swap\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.59690945939493,
            8.27712282538414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n\n    # Step 2: Identify the longest route (highest makespan) in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Segment the longest route into two parts at a demand-balanced split point\n    cumulative_demand = np.cumsum(demand[longest_route[1:-1]])\n    split_idx = np.argmin(np.abs(cumulative_demand - cumulative_demand[-1] / 2)) + 1\n    part1 = longest_route[:split_idx + 1]\n    part2 = np.concatenate([[0], longest_route[split_idx:]])\n\n    # Step 4: Find a compatible route to merge part2 into (demand + part2 demand <= capacity)\n    compatible_routes = []\n    part2_demand = demand[part2[1:-1]].sum()\n    for i, route in enumerate(selected_solution):\n        if i != longest_route_idx and demand[route[1:-1]].sum() + part2_demand <= capacity:\n            compatible_routes.append(i)\n\n    if compatible_routes:\n        merge_route_idx = np.random.choice(compatible_routes)\n        merge_route = selected_solution[merge_route_idx].copy()\n\n        # Step 5: Merge part2 into the compatible route at the best insertion point\n        best_insertion_cost = float('inf')\n        best_insertion_pos = 1\n        for i in range(1, len(merge_route)):\n            insertion_cost = distance_matrix[merge_route[i-1], part2[1]] + distance_matrix[part2[-2], merge_route[i]] - distance_matrix[merge_route[i-1], merge_route[i]]\n            if insertion_cost < best_insertion_cost:\n                best_insertion_cost = insertion_cost\n                best_insertion_pos = i\n\n        # Insert part2 into merge_route at the best position\n        new_merge_route = np.concatenate([merge_route[:best_insertion_pos], part2[1:-1], merge_route[best_insertion_pos:]])\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in [longest_route_idx, merge_route_idx]]\n        new_solution.extend([part1, new_merge_route])\n    else:\n        # If no compatible route, just split the longest route into two\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.extend([part1, part2])\n\n    # Step 6: Apply inter-route customer swaps to improve both objectives\n    for _ in range(2):  # Limited iterations for efficiency\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find best customer to swap between routes\n        best_swap_cost = float('inf')\n        best_swap = None\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Check demand constraints\n                if demand[route1[1:-1]].sum() - demand[route1[i]] + demand[route2[j]] <= capacity and \\\n                   demand[route2[1:-1]].sum() - demand[route2[j]] + demand[route1[i]] <= capacity:\n                    # Calculate swap cost difference\n                    cost_diff = (distance_matrix[route1[i-1], route2[j]] + distance_matrix[route2[j], route1[i+1]] +\n                                 distance_matrix[route2[j-1], route1[i]] + distance_matrix[route1[i], route2[j+1]]) - \\\n                                (distance_matrix[route1[i-1], route1[i]] + distance_matrix[route1[i], route1[i+1]] +\n                                 distance_matrix[route2[j-1], route2[j]] + distance_matrix[route2[j], route2[j+1]])\n                    if cost_diff < best_swap_cost:\n                        best_swap_cost = cost_diff\n                        best_swap = (i, j)\n\n        if best_swap and best_swap_cost < 0:\n            i, j = best_swap\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting with demand-aware 2-opt\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Try merging two routes if possible\n    if len(new_solution) > 1:\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged, demand, capacity):\n                new_solution[route1_idx] = merged\n                del new_solution[route2_idx]\n                return new_solution\n\n    # Step 2: Try splitting a route if it's too long\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Arbitrary threshold for route length\n            split_pos = np.random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                return new_solution\n\n    # Step 3: Demand-aware 2-opt within a single route\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            if a != b:\n                new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n                if is_feasible(new_route, demand, capacity):\n                    new_solution[i] = new_route\n                    return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7698849845651872,
            0.6430124640464783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and route splitting with demand-aware 2-opt\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Try merging two routes if possible\n    if len(new_solution) > 1:\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged, demand, capacity):\n                new_solution[route1_idx] = merged\n                del new_solution[route2_idx]\n                return new_solution\n\n    # Step 2: Try splitting a route if it's too long\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Arbitrary threshold for route length\n            split_pos = np.random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                return new_solution\n\n    # Step 3: Demand-aware 2-opt within a single route\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            if a != b:\n                new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n                if is_feasible(new_route, demand, capacity):\n                    new_solution[i] = new_route\n                    return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The novel local search operator combines route fragmentation with demand-aware segment reinsertion, iteratively splitting and merging routes while ensuring capacity feasibility and balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected = random.choice(candidates[:max(1, len(candidates)//3)])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator: Route fragmentation with demand-aware reinsertion\n    for _ in range(3):  # Perform multiple iterations\n        # Select a random route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Find split points based on demand balance\n        total_demand = sum(demand[route[1:-1]])\n        split_demand = total_demand * random.uniform(0.3, 0.7)\n        current_demand = 0\n        split_pos = 1\n\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand >= split_demand:\n                split_pos = i\n                break\n\n        # Split the route into two segments\n        segment1 = route[:split_pos+1]\n        segment2 = route[split_pos:]\n\n        # Ensure segments are valid (end with depot)\n        if len(segment1) < 2 or len(segment2) < 3:\n            continue\n\n        # Try to reinsert segments into other routes or create new routes\n        for segment in [segment1, segment2]:\n            segment_demand = sum(demand[segment[1:-1]])\n\n            # Find compatible routes to insert into\n            compatible_routes = []\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                route_demand = sum(demand[new_solution[i][1:-1]])\n                if route_demand + segment_demand <= capacity:\n                    compatible_routes.append(i)\n\n            if compatible_routes:\n                # Insert into a random compatible route\n                target_route_idx = random.choice(compatible_routes)\n                target_route = new_solution[target_route_idx]\n\n                # Find insertion position that minimizes additional distance\n                min_increase = float('inf')\n                best_pos = len(target_route) - 1\n\n                for i in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[i-1], segment[1]] +\n                               distance_matrix[segment[-2], target_route[i]] -\n                               distance_matrix[target_route[i-1], target_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Insert the segment\n                new_route = np.concatenate([target_route[:best_pos], segment[1:-1], target_route[best_pos:]])\n                new_solution[target_route_idx] = new_route\n            else:\n                # Create a new route if no compatible route found\n                if segment_demand <= capacity:\n                    new_solution.append(segment.copy())\n\n        # Remove the original fragmented route if it's now empty\n        if len(new_solution[route_idx]) == 2:  # Only depot\n            new_solution.pop(route_idx)\n\n    # Ensure all routes are valid and non-empty\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # If no changes were made, perform a simple 2-opt on a random route\n    if len(new_solution) == len(selected) and all(np.array_equal(a, b) for a, b in zip(new_solution, selected)):\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx].copy()\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.774406947345977,
            1.2482036352157593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected = random.choice(candidates[:max(1, len(candidates)//3)])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator: Route fragmentation with demand-aware reinsertion\n    for _ in range(3):  # Perform multiple iterations\n        # Select a random route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Find split points based on demand balance\n        total_demand = sum(demand[route[1:-1]])\n        split_demand = total_demand * random.uniform(0.3, 0.7)\n        current_demand = 0\n        split_pos = 1\n\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand >= split_demand:\n                split_pos = i\n                break\n\n        # Split the route into two segments\n        segment1 = route[:split_pos+1]\n        segment2 = route[split_pos:]\n\n        # Ensure segments are valid (end with depot)\n        if len(segment1) < 2 or len(segment2) < 3:\n            continue\n\n        # Try to reinsert segments into other routes or create new routes\n        for segment in [segment1, segment2]:\n            segment_demand = sum(demand[segment[1:-1]])\n\n            # Find compatible routes to insert into\n            compatible_routes = []\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                route_demand = sum(demand[new_solution[i][1:-1]])\n                if route_demand + segment_demand <= capacity:\n                    compatible_routes.append(i)\n\n            if compatible_routes:\n                # Insert into a random compatible route\n                target_route_idx = random.choice(compatible_routes)\n                target_route = new_solution[target_route_idx]\n\n                # Find insertion position that minimizes additional distance\n                min_increase = float('inf')\n                best_pos = len(target_route) - 1\n\n                for i in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[i-1], segment[1]] +\n                               distance_matrix[segment[-2], target_route[i]] -\n                               distance_matrix[target_route[i-1], target_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Insert the segment\n                new_route = np.concatenate([target_route[:best_pos], segment[1:-1], target_route[best_pos:]])\n                new_solution[target_route_idx] = new_route\n            else:\n                # Create a new route if no compatible route found\n                if segment_demand <= capacity:\n                    new_solution.append(segment.copy())\n\n        # Remove the original fragmented route if it's now empty\n        if len(new_solution[route_idx]) == 2:  # Only depot\n            new_solution.pop(route_idx)\n\n    # Ensure all routes are valid and non-empty\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # If no changes were made, perform a simple 2-opt on a random route\n    if len(new_solution) == len(selected) and all(np.array_equal(a, b) for a, b in zip(new_solution, selected)):\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx].copy()\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by combining route length diversity with makespan reduction, then applies a hybrid local search that combines route merging, segment relocation, and demand-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + segment relocation + demand-aware swaps\n    if len(new_solution) > 1:\n        # Try to merge two routes if demand allows\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i][1:-1]  # Exclude depot\n                route2 = new_solution[j][1:-1]\n                merged_demand = sum(demand[route1]) + sum(demand[route2])\n                if merged_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([[0], route1, route2, [0]])\n                    new_solution = [merged_route] + [r for k, r in enumerate(new_solution) if k != i and k != j]\n                    break\n\n    # Relocate a segment between routes\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution) - 1)\n        route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 3:  # Ensure there's a segment to move\n            # Select a random segment from route1\n            start = random.randint(1, len(route1) - 3)\n            end = random.randint(start + 1, len(route1) - 2)\n            segment = route1[start:end]\n\n            # Check if moving the segment to route2 is feasible\n            if sum(demand[segment]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_route1 = np.concatenate([route1[:start], route1[end:]])\n                new_solution[route_idx1] = new_route1\n                new_solution[route_idx2] = new_route2\n\n    # Demand-aware swap between routes\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution) - 1)\n        route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Find a customer in each route with similar demand\n            for c1 in route1[1:-1]:\n                for c2 in route2[1:-1]:\n                    if abs(demand[c1] - demand[c2]) <= capacity * 0.2:  # Threshold for \"similar\" demand\n                        # Check feasibility after swap\n                        new_demand1 = sum(demand[route1[1:-1]]) - demand[c1] + demand[c2]\n                        new_demand2 = sum(demand[route2[1:-1]]) - demand[c2] + demand[c1]\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            # Perform swap\n                            idx1 = np.where(route1 == c1)[0][0]\n                            idx2 = np.where(route2 == c2)[0][0]\n                            route1[idx1], route2[idx2] = c2, c1\n                            new_solution[route_idx1] = route1\n                            new_solution[route_idx2] = route2\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.8585825335484392,
            2.0427261888980865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + segment relocation + demand-aware swaps\n    if len(new_solution) > 1:\n        # Try to merge two routes if demand allows\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i][1:-1]  # Exclude depot\n                route2 = new_solution[j][1:-1]\n                merged_demand = sum(demand[route1]) + sum(demand[route2])\n                if merged_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([[0], route1, route2, [0]])\n                    new_solution = [merged_route] + [r for k, r in enumerate(new_solution) if k != i and k != j]\n                    break\n\n    # Relocate a segment between routes\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution) - 1)\n        route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 3:  # Ensure there's a segment to move\n            # Select a random segment from route1\n            start = random.randint(1, len(route1) - 3)\n            end = random.randint(start + 1, len(route1) - 2)\n            segment = route1[start:end]\n\n            # Check if moving the segment to route2 is feasible\n            if sum(demand[segment]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_route1 = np.concatenate([route1[:start], route1[end:]])\n                new_solution[route_idx1] = new_route1\n                new_solution[route_idx2] = new_route2\n\n    # Demand-aware swap between routes\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution) - 1)\n        route_idx2 = random.choice([i for i in range(len(new_solution)) if i != route_idx1])\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Find a customer in each route with similar demand\n            for c1 in route1[1:-1]:\n                for c2 in route2[1:-1]:\n                    if abs(demand[c1] - demand[c2]) <= capacity * 0.2:  # Threshold for \"similar\" demand\n                        # Check feasibility after swap\n                        new_demand1 = sum(demand[route1[1:-1]]) - demand[c1] + demand[c2]\n                        new_demand2 = sum(demand[route2[1:-1]]) - demand[c2] + demand[c1]\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            # Perform swap\n                            idx1 = np.where(route1 == c1)[0][0]\n                            idx2 = np.where(route2 == c2)[0][0]\n                            route1[idx1], route2[idx2] = c2, c1\n                            new_solution[route_idx1] = route1\n                            new_solution[route_idx2] = route2\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive, then applies a hybrid local search strategy combining route merging, partial route reversal, and demand-aware insertion to balance travel distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objective_values = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    # Identify non-dominated solutions in the archive\n    for i in range(len(objective_values)):\n        dominated = False\n        for j in range(len(objective_values)):\n            if i != j and (objective_values[j][0] <= objective_values[i][0] and objective_values[j][1] <= objective_values[i][1]) and (objective_values[j][0] < objective_values[i][0] or objective_values[j][1] < objective_values[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # 1. Route merging: combine two shortest routes if possible\n        route_lengths = [sum(distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        shortest_route = np.argmin(route_lengths)\n        second_shortest = np.argsort(route_lengths)[1] if len(new_solution) > 1 else -1\n\n        if second_shortest != -1 and sum(demand[new_solution[shortest_route][1:-1]]) + sum(demand[new_solution[second_shortest][1:-1]]) <= capacity:\n            merged_route = np.concatenate([new_solution[shortest_route][:-1], new_solution[second_shortest][1:]])\n            new_solution = [merged_route] + [r for i, r in enumerate(new_solution) if i not in [shortest_route, second_shortest]]\n\n    # 2. Partial route reversal: reverse a segment of the longest route to reduce distance\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)) for i in range(len(new_solution))])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        if len(longest_route) > 4:  # Need at least 3 nodes to reverse (excluding depot)\n            start = random.randint(1, len(longest_route)-3)\n            end = random.randint(start+1, len(longest_route)-2)\n            reversed_segment = longest_route[start:end+1][::-1]\n            new_route = np.concatenate([longest_route[:start], reversed_segment, longest_route[end+1:]])\n\n            # Check feasibility\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    # 3. Demand-aware insertion: move customers between routes to balance loads\n    if len(new_solution) > 1:\n        # Find route with highest load\n        route_loads = [sum(demand[r[1:-1]]) for r in new_solution]\n        overloaded_route_idx = np.argmax(route_loads)\n\n        if route_loads[overloaded_route_idx] > capacity * 0.7:  # If over 70% capacity\n            overloaded_route = new_solution[overloaded_route_idx].copy()\n            other_routes = [i for i in range(len(new_solution)) if i != overloaded_route_idx]\n\n            for customer in overloaded_route[1:-1]:\n                # Find best insertion position in another route\n                best_insertion = None\n                best_distance = float('inf')\n\n                for route_idx in other_routes:\n                    route = new_solution[route_idx].copy()\n                    if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for i in range(len(route)-1):\n                        # Insert after route[i]\n                        new_route = np.concatenate([route[:i+1], [customer], route[i+1:]])\n                        new_distance = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n\n                        if new_distance < best_distance:\n                            best_distance = new_distance\n                            best_insertion = (route_idx, i, new_route)\n\n                if best_insertion is not None:\n                    # Perform the best insertion\n                    route_idx, insert_pos, new_route = best_insertion\n                    new_solution[route_idx] = new_route\n                    overloaded_route = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    new_solution[overloaded_route_idx] = overloaded_route\n\n                    # Remove empty routes\n                    new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.416658680587166,
            10.255494683980942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objective_values = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    # Identify non-dominated solutions in the archive\n    for i in range(len(objective_values)):\n        dominated = False\n        for j in range(len(objective_values)):\n            if i != j and (objective_values[j][0] <= objective_values[i][0] and objective_values[j][1] <= objective_values[i][1]) and (objective_values[j][0] < objective_values[i][0] or objective_values[j][1] < objective_values[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # 1. Route merging: combine two shortest routes if possible\n        route_lengths = [sum(distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        shortest_route = np.argmin(route_lengths)\n        second_shortest = np.argsort(route_lengths)[1] if len(new_solution) > 1 else -1\n\n        if second_shortest != -1 and sum(demand[new_solution[shortest_route][1:-1]]) + sum(demand[new_solution[second_shortest][1:-1]]) <= capacity:\n            merged_route = np.concatenate([new_solution[shortest_route][:-1], new_solution[second_shortest][1:]])\n            new_solution = [merged_route] + [r for i, r in enumerate(new_solution) if i not in [shortest_route, second_shortest]]\n\n    # 2. Partial route reversal: reverse a segment of the longest route to reduce distance\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)) for i in range(len(new_solution))])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        if len(longest_route) > 4:  # Need at least 3 nodes to reverse (excluding depot)\n            start = random.randint(1, len(longest_route)-3)\n            end = random.randint(start+1, len(longest_route)-2)\n            reversed_segment = longest_route[start:end+1][::-1]\n            new_route = np.concatenate([longest_route[:start], reversed_segment, longest_route[end+1:]])\n\n            # Check feasibility\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    # 3. Demand-aware insertion: move customers between routes to balance loads\n    if len(new_solution) > 1:\n        # Find route with highest load\n        route_loads = [sum(demand[r[1:-1]]) for r in new_solution]\n        overloaded_route_idx = np.argmax(route_loads)\n\n        if route_loads[overloaded_route_idx] > capacity * 0.7:  # If over 70% capacity\n            overloaded_route = new_solution[overloaded_route_idx].copy()\n            other_routes = [i for i in range(len(new_solution)) if i != overloaded_route_idx]\n\n            for customer in overloaded_route[1:-1]:\n                # Find best insertion position in another route\n                best_insertion = None\n                best_distance = float('inf')\n\n                for route_idx in other_routes:\n                    route = new_solution[route_idx].copy()\n                    if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for i in range(len(route)-1):\n                        # Insert after route[i]\n                        new_route = np.concatenate([route[:i+1], [customer], route[i+1:]])\n                        new_distance = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n\n                        if new_distance < best_distance:\n                            best_distance = new_distance\n                            best_insertion = (route_idx, i, new_route)\n\n                if best_insertion is not None:\n                    # Perform the best insertion\n                    route_idx, insert_pos, new_route = best_insertion\n                    new_solution[route_idx] = new_route\n                    overloaded_route = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    new_solution[overloaded_route_idx] = overloaded_route\n\n                    # Remove empty routes\n                    new_solution = [r for r in new_solution if len(r) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of the two objectives (total distance and makespan), then applies a hybrid local search operator that combines route merging, customer reallocation, and adaptive 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for balancing objectives\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Apply multiple iterations\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes (remove depot from the middle)\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            source_route_idx = random.randint(0, len(new_solution) - 1)\n            source_route = new_solution[source_route_idx]\n            if len(source_route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(source_route) - 2)\n                customer = source_route[customer_pos]\n\n                # Try to insert into another route\n                for target_route_idx in range(len(new_solution)):\n                    if target_route_idx == source_route_idx:\n                        continue\n                    target_route = new_solution[target_route_idx]\n\n                    # Find insertion points and check capacity\n                    for insert_pos in range(1, len(target_route)):\n                        # Insert customer before insert_pos\n                        new_route = np.concatenate([\n                            target_route[:insert_pos],\n                            [customer],\n                            target_route[insert_pos:]\n                        ])\n                        total_demand = sum(demand[new_route[1:-1]])\n                        if total_demand <= capacity:\n                            new_solution[target_route_idx] = new_route\n                            # Remove from source route\n                            new_solution[source_route_idx] = np.concatenate([\n                                source_route[:customer_pos],\n                                source_route[customer_pos+1:]\n                            ])\n                            break\n\n        # Step 3: Adaptive 2-opt (focus on long edges)\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) < 4:\n                continue\n\n            # Find the longest edge in the route\n            max_dist = -1\n            split_pos = 0\n            for i in range(len(route) - 1):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            # Perform 2-opt on the longest edge\n            if split_pos > 0 and split_pos < len(route) - 2:\n                new_route = np.concatenate([\n                    route[:split_pos+1],\n                    route[split_pos+1:][::-1]\n                ])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8019719643116636,
            6.511171132326126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for balancing objectives\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Apply multiple iterations\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes (remove depot from the middle)\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            source_route_idx = random.randint(0, len(new_solution) - 1)\n            source_route = new_solution[source_route_idx]\n            if len(source_route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(source_route) - 2)\n                customer = source_route[customer_pos]\n\n                # Try to insert into another route\n                for target_route_idx in range(len(new_solution)):\n                    if target_route_idx == source_route_idx:\n                        continue\n                    target_route = new_solution[target_route_idx]\n\n                    # Find insertion points and check capacity\n                    for insert_pos in range(1, len(target_route)):\n                        # Insert customer before insert_pos\n                        new_route = np.concatenate([\n                            target_route[:insert_pos],\n                            [customer],\n                            target_route[insert_pos:]\n                        ])\n                        total_demand = sum(demand[new_route[1:-1]])\n                        if total_demand <= capacity:\n                            new_solution[target_route_idx] = new_route\n                            # Remove from source route\n                            new_solution[source_route_idx] = np.concatenate([\n                                source_route[:customer_pos],\n                                source_route[customer_pos+1:]\n                            ])\n                            break\n\n        # Step 3: Adaptive 2-opt (focus on long edges)\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) < 4:\n                continue\n\n            # Find the longest edge in the route\n            max_dist = -1\n            split_pos = 0\n            for i in range(len(route) - 1):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            # Perform 2-opt on the longest edge\n            if split_pos > 0 and split_pos < len(route) - 2:\n                new_route = np.concatenate([\n                    route[:split_pos+1],\n                    route[split_pos+1:][::-1]\n                ])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection biased toward solutions with lower makespan, then applies a hybrid local search combining route splitting, cross-exchange, and demand-aware node reinsertion to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, cross-exchange, and demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure split is meaningful\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos:]])\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Cross-exchange between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find valid exchange points (avoid depot)\n        valid_pos1 = [i for i in range(1, len(route1)-1) if sum(demand[route1[:i+1]]) <= capacity and sum(demand[route1[i+1:]]) <= capacity]\n        valid_pos2 = [i for i in range(1, len(route2)-1) if sum(demand[route2[:i+1]]) <= capacity and sum(demand[route2[i+1:]]) <= capacity]\n\n        if valid_pos1 and valid_pos2:\n            pos1, pos2 = random.choice(valid_pos1), random.choice(valid_pos2)\n            # Perform cross-exchange\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Demand-aware node reinsertion\n    if len(new_solution) > 1:\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure reinsertion is meaningful\n            # Select a node to remove (not depot)\n            node_pos = random.randint(1, len(route)-2)\n            node = route[node_pos]\n            # Remove node\n            new_route = np.concatenate([route[:node_pos], route[node_pos+1:]])\n            # Find best position to reinsert\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                # Try inserting after position i\n                candidate_route = np.concatenate([new_route[:i], [node], new_route[i:]])\n                if sum(demand[candidate_route[1:-1]]) <= capacity:\n                    cost = sum(distance_matrix[candidate_route[j]][candidate_route[j+1]] for j in range(len(candidate_route)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            # Perform reinsertion\n            new_route = np.concatenate([new_route[:best_pos], [node], new_route[best_pos:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7757908210870887,
            2.647918224334717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, cross-exchange, and demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # Ensure split is meaningful\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos:]])\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Cross-exchange between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find valid exchange points (avoid depot)\n        valid_pos1 = [i for i in range(1, len(route1)-1) if sum(demand[route1[:i+1]]) <= capacity and sum(demand[route1[i+1:]]) <= capacity]\n        valid_pos2 = [i for i in range(1, len(route2)-1) if sum(demand[route2[:i+1]]) <= capacity and sum(demand[route2[i+1:]]) <= capacity]\n\n        if valid_pos1 and valid_pos2:\n            pos1, pos2 = random.choice(valid_pos1), random.choice(valid_pos2)\n            # Perform cross-exchange\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Demand-aware node reinsertion\n    if len(new_solution) > 1:\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure reinsertion is meaningful\n            # Select a node to remove (not depot)\n            node_pos = random.randint(1, len(route)-2)\n            node = route[node_pos]\n            # Remove node\n            new_route = np.concatenate([route[:node_pos], route[node_pos+1:]])\n            # Find best position to reinsert\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                # Try inserting after position i\n                candidate_route = np.concatenate([new_route[:i], [node], new_route[i:]])\n                if sum(demand[candidate_route[1:-1]]) <= capacity:\n                    cost = sum(distance_matrix[candidate_route[j]][candidate_route[j+1]] for j in range(len(candidate_route)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            # Perform reinsertion\n            new_route = np.concatenate([new_route[:best_pos], [node], new_route[best_pos:]])\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive, identifies bottleneck routes (those contributing most to makespan), and applies a hybrid local search combining route splitting, customer reinsertion, and edge swapping to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    # Identify the longest route (bottleneck)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Split the longest route into two parts\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Ensure valid routes\n    if len(part1) > 2 and len(part2) > 2:\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If split is invalid, try random reinsertion instead\n        random_route_idx = random.randint(0, len(new_solution) - 1)\n        random_route = new_solution[random_route_idx]\n        if len(random_route) > 3:\n            customer_to_move = random.choice(random_route[1:-1])\n            new_solution[random_route_idx] = np.array([node for node in random_route if node != customer_to_move])\n            new_solution.append(np.array([0, customer_to_move, 0]))\n\n    # Step 2: Check capacity constraints and fix if violated\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If capacity is exceeded, try to reinsert violating customers\n            violating_customers = [node for node in route[1:-1] if demand[node] > capacity]\n            for customer in violating_customers:\n                new_solution[i] = np.array([node for node in route if node != customer])\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Step 3: Perform edge swapping between routes to improve distance\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                # Select edges to swap\n                pos1 = random.randint(1, len(route1) - 2)\n                pos2 = random.randint(1, len(route2) - 2)\n                # Swap customers\n                new_route1 = np.concatenate([route1[:pos1], [route2[pos2]], route1[pos1+1:]])\n                new_route2 = np.concatenate([route2[:pos2], [route1[pos1]], route2[pos2+1:]])\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7113472815883513,
            0.685562014579773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    # Identify the longest route (bottleneck)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Split the longest route into two parts\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos + 1]\n    part2 = longest_route[split_pos:]\n\n    # Ensure valid routes\n    if len(part1) > 2 and len(part2) > 2:\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If split is invalid, try random reinsertion instead\n        random_route_idx = random.randint(0, len(new_solution) - 1)\n        random_route = new_solution[random_route_idx]\n        if len(random_route) > 3:\n            customer_to_move = random.choice(random_route[1:-1])\n            new_solution[random_route_idx] = np.array([node for node in random_route if node != customer_to_move])\n            new_solution.append(np.array([0, customer_to_move, 0]))\n\n    # Step 2: Check capacity constraints and fix if violated\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If capacity is exceeded, try to reinsert violating customers\n            violating_customers = [node for node in route[1:-1] if demand[node] > capacity]\n            for customer in violating_customers:\n                new_solution[i] = np.array([node for node in route if node != customer])\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Step 3: Perform edge swapping between routes to improve distance\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                # Select edges to swap\n                pos1 = random.randint(1, len(route1) - 2)\n                pos2 = random.randint(1, len(route2) - 2)\n                # Swap customers\n                new_route1 = np.concatenate([route1[:pos1], [route2[pos2]], route1[pos1+1:]])\n                new_route2 = np.concatenate([route2[:pos2], [route1[pos1]], route2[pos2+1:]])\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected = candidates[min(3, len(candidates) - 1)][0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try to merge part1 with another route (if feasible)\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[part1[1:-1]]) <= capacity:\n                merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                new_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n\n        # Reallocate customers from part2 to other routes or create new route\n        temp_route = [0]\n        current_load = 0\n        for node in part2[1:-1]:\n            if current_load + demand[node] <= capacity:\n                temp_route.append(node)\n                current_load += demand[node]\n            else:\n                if len(temp_route) > 1:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0]\n                    current_load = 0\n                # Try to add to existing routes\n                added = False\n                for i, route in enumerate(new_solution):\n                    if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                        new_route = np.insert(route, -1, node)\n                        new_solution[i] = new_route\n                        added = True\n                        break\n                if not added:\n                    temp_route.append(node)\n                    current_load = demand[node]\n\n        if len(temp_route) > 1:\n            temp_route.append(0)\n            new_solution.append(np.array(temp_route))\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    for node in missing:\n        # Add missing customers to the shortest feasible route\n        best_route = None\n        best_idx = -1\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                if best_route is None or len(route) < len(best_route):\n                    best_route = route\n                    best_idx = i\n        if best_route is not None:\n            new_route = np.insert(best_route, -1, node)\n            new_solution[best_idx] = new_route\n        else:\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6473268669994979,
            5.648226320743561
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected = candidates[min(3, len(candidates) - 1)][0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Try to merge part1 with another route (if feasible)\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[part1[1:-1]]) <= capacity:\n                merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                new_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n\n        # Reallocate customers from part2 to other routes or create new route\n        temp_route = [0]\n        current_load = 0\n        for node in part2[1:-1]:\n            if current_load + demand[node] <= capacity:\n                temp_route.append(node)\n                current_load += demand[node]\n            else:\n                if len(temp_route) > 1:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0]\n                    current_load = 0\n                # Try to add to existing routes\n                added = False\n                for i, route in enumerate(new_solution):\n                    if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                        new_route = np.insert(route, -1, node)\n                        new_solution[i] = new_route\n                        added = True\n                        break\n                if not added:\n                    temp_route.append(node)\n                    current_load = demand[node]\n\n        if len(temp_route) > 1:\n            temp_route.append(0)\n            new_solution.append(np.array(temp_route))\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    for node in missing:\n        # Add missing customers to the shortest feasible route\n        best_route = None\n        best_idx = -1\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                if best_route is None or len(route) < len(best_route):\n                    best_route = route\n                    best_idx = i\n        if best_route is not None:\n            new_route = np.insert(best_route, -1, node)\n            new_solution[best_idx] = new_route\n        else:\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel hybrid local search operator combines route segment swapping with capacity-aware demand rebalancing, where segments are selected based on their contribution to the makespan and total distance, while ensuring feasibility through demand checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select two routes for segment swapping\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments from both routes (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Extract segments (excluding depots)\n            segment1_start = random.randint(1, len(route1) - 2)\n            segment1_end = random.randint(segment1_start, len(route1) - 2)\n            segment1 = route1[segment1_start:segment1_end + 1]\n\n            segment2_start = random.randint(1, len(route2) - 2)\n            segment2_end = random.randint(segment2_start, len(route2) - 2)\n            segment2 = route2[segment2_start:segment2_end + 1]\n\n            # Calculate demand for segments\n            demand1 = np.sum(demand[segment1])\n            demand2 = np.sum(demand[segment2])\n\n            # Check if swapping is feasible (capacity constraints)\n            if (np.sum(demand[route1]) - demand1 + demand2 <= capacity and\n                np.sum(demand[route2]) - demand2 + demand1 <= capacity):\n\n                # Swap segments\n                new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n                new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n                # Update routes\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.4270008810291591,
            0.9552349746227264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select two routes for segment swapping\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments from both routes (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Extract segments (excluding depots)\n            segment1_start = random.randint(1, len(route1) - 2)\n            segment1_end = random.randint(segment1_start, len(route1) - 2)\n            segment1 = route1[segment1_start:segment1_end + 1]\n\n            segment2_start = random.randint(1, len(route2) - 2)\n            segment2_end = random.randint(segment2_start, len(route2) - 2)\n            segment2 = route2[segment2_start:segment2_end + 1]\n\n            # Calculate demand for segments\n            demand1 = np.sum(demand[segment1])\n            demand2 = np.sum(demand[segment2])\n\n            # Check if swapping is feasible (capacity constraints)\n            if (np.sum(demand[route1]) - demand1 + demand2 <= capacity and\n                np.sum(demand[route2]) - demand2 + demand1 <= capacity):\n\n                # Swap segments\n                new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n                new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n                # Update routes\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search operator combines route fragmentation and reinsertion with adaptive capacity-aware 2-opt moves to balance distance and makespan reduction, intelligently selecting promising solutions from the archive for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol in archive:\n        total_dist, makespan = sol[1]\n        # Prefer solutions with low total distance or low makespan\n        if total_dist < np.percentile([s[1][0] for s in archive], 30) or makespan < np.percentile([s[1][1] for s in archive], 30):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route fragmentation and reinsertion\n    if len(new_solution) > 1:\n        # Select a random route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(route) - 3)\n            fragment = route[split_pos:-1]  # Exclude the last depot\n            new_solution[route_idx] = route[:split_pos] + [0]  # Truncate and add depot\n\n            # Reinsert fragment into another route or create a new one\n            if random.random() < 0.7:  # 70% chance to reinsert into existing route\n                target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx]\n                if sum(demand[fragment]) + sum(demand[target_route[1:-1]]) <= capacity:\n                    new_solution[target_route_idx] = np.concatenate([target_route[:-1], fragment, [0]])\n            else:  # Create a new route\n                if sum(demand[fragment]) <= capacity:\n                    new_solution.append(np.concatenate([[0], fragment, [0]]))\n\n    # Step 2: Adaptive capacity-aware 2-opt\n    for route in new_solution:\n        if len(route) > 4:\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            if j - i > 1:  # Ensure we have a segment to swap\n                # Check capacity constraint\n                segment = route[i:j]\n                if sum(demand[segment]) <= capacity:\n                    # Perform the swap\n                    new_route = np.concatenate([route[:i], route[j-1:i-1:-1], route[j:]])\n                    # Verify no duplicate nodes and depot at ends\n                    if len(np.unique(new_route)) == len(new_route) and new_route[0] == 0 and new_route[-1] == 0:\n                        route[:] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - served_nodes\n\n    # Reinsert missing nodes\n    for node in missing_nodes:\n        # Find a route with enough capacity\n        for route in new_solution:\n            if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                # Find the best insertion position (minimizing added distance)\n                best_pos = 1\n                min_distance = float('inf')\n                for i in range(1, len(route)):\n                    dist = distance_matrix[route[i-1]][node] + distance_matrix[node][route[i]] - distance_matrix[route[i-1]][route[i]]\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_pos = i\n                # Insert the node\n                route = np.insert(route, best_pos, node)\n                break\n        else:\n            # Create a new route if no existing route can accommodate\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6902427253668795,
            7.2841426730155945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol in archive:\n        total_dist, makespan = sol[1]\n        # Prefer solutions with low total distance or low makespan\n        if total_dist < np.percentile([s[1][0] for s in archive], 30) or makespan < np.percentile([s[1][1] for s in archive], 30):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route fragmentation and reinsertion\n    if len(new_solution) > 1:\n        # Select a random route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(route) - 3)\n            fragment = route[split_pos:-1]  # Exclude the last depot\n            new_solution[route_idx] = route[:split_pos] + [0]  # Truncate and add depot\n\n            # Reinsert fragment into another route or create a new one\n            if random.random() < 0.7:  # 70% chance to reinsert into existing route\n                target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx]\n                if sum(demand[fragment]) + sum(demand[target_route[1:-1]]) <= capacity:\n                    new_solution[target_route_idx] = np.concatenate([target_route[:-1], fragment, [0]])\n            else:  # Create a new route\n                if sum(demand[fragment]) <= capacity:\n                    new_solution.append(np.concatenate([[0], fragment, [0]]))\n\n    # Step 2: Adaptive capacity-aware 2-opt\n    for route in new_solution:\n        if len(route) > 4:\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            if j - i > 1:  # Ensure we have a segment to swap\n                # Check capacity constraint\n                segment = route[i:j]\n                if sum(demand[segment]) <= capacity:\n                    # Perform the swap\n                    new_route = np.concatenate([route[:i], route[j-1:i-1:-1], route[j:]])\n                    # Verify no duplicate nodes and depot at ends\n                    if len(np.unique(new_route)) == len(new_route) and new_route[0] == 0 and new_route[-1] == 0:\n                        route[:] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_nodes = set(range(1, len(coords)))\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - served_nodes\n\n    # Reinsert missing nodes\n    for node in missing_nodes:\n        # Find a route with enough capacity\n        for route in new_solution:\n            if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                # Find the best insertion position (minimizing added distance)\n                best_pos = 1\n                min_distance = float('inf')\n                for i in range(1, len(route)):\n                    dist = distance_matrix[route[i-1]][node] + distance_matrix[node][route[i]] - distance_matrix[route[i-1]][route[i]]\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_pos = i\n                # Insert the node\n                route = np.insert(route, best_pos, node)\n                break\n        else:\n            # Create a new route if no existing route can accommodate\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(route) > 4:  # Ensure route is long enough to modify\n        # Randomly select two non-depot nodes\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n\n        # Attempt 2-opt move\n        new_route = route.copy()\n        new_route[i:j+1] = route[j:i-1:-1]\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n        else:\n            # If 2-opt violates capacity, try splitting the route\n            split_pos = np.random.randint(1, len(route)-1)\n            if np.sum(demand[route[1:split_pos+1]]) <= capacity and np.sum(demand[route[split_pos+1:-1]]) <= capacity:\n                new_solution.append(np.concatenate([[0], route[split_pos+1:], [0]]))\n                route = np.concatenate([[0], route[1:split_pos+1], [0]])\n\n    # Update the modified route in the solution\n    new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.4088955204038061,
            0.7439703643321991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting\n    if len(route) > 4:  # Ensure route is long enough to modify\n        # Randomly select two non-depot nodes\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n\n        # Attempt 2-opt move\n        new_route = route.copy()\n        new_route[i:j+1] = route[j:i-1:-1]\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n        else:\n            # If 2-opt violates capacity, try splitting the route\n            split_pos = np.random.randint(1, len(route)-1)\n            if np.sum(demand[route[1:split_pos+1]]) <= capacity and np.sum(demand[route[split_pos+1:-1]]) <= capacity:\n                new_solution.append(np.concatenate([[0], route[split_pos+1:], [0]]))\n                route = np.concatenate([[0], route[1:split_pos+1], [0]])\n\n    # Update the modified route in the solution\n    new_solution[route_idx] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route splitting and intra-route 2-opt with demand-aware adjustments to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware 2-opt\n    if len(new_solution) > 1:\n        # Try splitting a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(longest_route) - 2)\n            new_route1 = longest_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], longest_route[split_pos:-1], [0]])\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If split violates capacity, try demand-aware 2-opt\n                for i in range(1, len(longest_route) - 2):\n                    for j in range(i + 1, len(longest_route) - 1):\n                        if (demand[longest_route[i]] + demand[longest_route[j]] <= capacity):\n                            # Swap nodes i and j\n                            temp = longest_route[i]\n                            longest_route[i] = longest_route[j]\n                            longest_route[j] = temp\n                            new_solution[longest_route_idx] = longest_route\n                            break\n    else:\n        # For single-route solutions, apply demand-aware 2-opt\n        route = new_solution[0]\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if (demand[route[i]] + demand[route[j]] <= capacity):\n                    # Swap nodes i and j\n                    temp = route[i]\n                    route[i] = route[j]\n                    route[j] = temp\n                    new_solution[0] = route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7209018973815732,
            0.3857409954071045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware 2-opt\n    if len(new_solution) > 1:\n        # Try splitting a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(longest_route) - 2)\n            new_route1 = longest_route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], longest_route[split_pos:-1], [0]])\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If split violates capacity, try demand-aware 2-opt\n                for i in range(1, len(longest_route) - 2):\n                    for j in range(i + 1, len(longest_route) - 1):\n                        if (demand[longest_route[i]] + demand[longest_route[j]] <= capacity):\n                            # Swap nodes i and j\n                            temp = longest_route[i]\n                            longest_route[i] = longest_route[j]\n                            longest_route[j] = temp\n                            new_solution[longest_route_idx] = longest_route\n                            break\n    else:\n        # For single-route solutions, apply demand-aware 2-opt\n        route = new_solution[0]\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if (demand[route[i]] + demand[route[j]] <= capacity):\n                    # Swap nodes i and j\n                    temp = route[i]\n                    route[i] = route[j]\n                    route[j] = temp\n                    new_solution[0] = route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Avoid trivial routes\n            # Split route into two parts at a random point\n            split_idx = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx+1:]])\n\n            # Check feasibility of new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Inter-route insertion: try moving a random customer from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a customer to move\n            customer_to_move = np.random.choice(src_route[1:-1])\n            new_solution[src_route_idx] = np.delete(src_route, np.where(src_route == customer_to_move)[0])\n\n            # Try inserting into another route\n            for j in range(len(new_solution)):\n                if j != src_route_idx:\n                    tgt_route = new_solution[j]\n                    for pos in range(1, len(tgt_route)):\n                        new_route = np.insert(tgt_route, pos, customer_to_move)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            new_solution[j] = new_route\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.778646472790897,
            5.45721298456192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Avoid trivial routes\n            # Split route into two parts at a random point\n            split_idx = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx+1:]])\n\n            # Check feasibility of new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Inter-route insertion: try moving a random customer from one route to another\n    if len(new_solution) > 1:\n        src_route_idx = np.random.randint(len(new_solution))\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure there's a customer to move\n            customer_to_move = np.random.choice(src_route[1:-1])\n            new_solution[src_route_idx] = np.delete(src_route, np.where(src_route == customer_to_move)[0])\n\n            # Try inserting into another route\n            for j in range(len(new_solution)):\n                if j != src_route_idx:\n                    tgt_route = new_solution[j]\n                    for pos in range(1, len(tgt_route)):\n                        new_route = np.insert(tgt_route, pos, customer_to_move)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            new_solution[j] = new_route\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by combining a random selection weighted by makespan and total distance, then applies a hybrid local search operator that combines route merging, customer reinsertion, and depot-based route splitting to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, (dist, span) in archive:\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(obj[0] for obj in [x[1] for x in archive])\n        max_span = max(obj[1] for obj in [x[1] for x in archive])\n        norm_dist = dist / max_dist if max_dist > 0 else 0\n        norm_span = span / max_span if max_span > 0 else 0\n        # Higher weight for solutions with better balance between objectives\n        weight = 1 / (0.5 * norm_dist + 0.5 * norm_span + 1e-6)\n        weights.append(weight)\n\n    # Normalize weights\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 2.1: Route merging (if feasible)\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n            other_route = base_solution[other_route_idx].copy()\n            merged_route = np.concatenate([route[1:-1], other_route[1:-1]])\n            # Check capacity constraint\n            if np.sum(demand[merged_route]) <= capacity:\n                new_solution.append(np.concatenate([[0], merged_route, [0]]))\n                # Remove the merged route from the solution\n                base_solution = [r for i, r in enumerate(base_solution) if i != selected_idx and i != other_route_idx]\n                break\n\n        # Step 2.2: Customer reinsertion\n        if len(route) > 3:\n            # Select a random customer to reinsert\n            candidate_idx = random.randint(1, len(route) - 2)\n            customer = route[candidate_idx]\n            # Remove customer from the route\n            modified_route = np.concatenate([route[:candidate_idx], route[candidate_idx+1:]])\n            # Try to insert at a different position in the same route\n            best_pos = None\n            best_cost = float('inf')\n            for i in range(1, len(modified_route)):\n                new_route = np.concatenate([modified_route[:i], [customer], modified_route[i:]])\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Calculate insertion cost (delta distance)\n                    cost = (distance_matrix[new_route[i-1], customer] +\n                            distance_matrix[customer, new_route[i]] -\n                            distance_matrix[new_route[i-1], new_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos is not None:\n                modified_route = np.concatenate([modified_route[:best_pos], [customer], modified_route[best_pos:]])\n            # Add modified route to new solution\n            new_solution.append(modified_route)\n\n        # Step 2.3: Depot-based route splitting (if makespan is large)\n        if len(route) > 3 and random.random() < 0.5:\n            # Find the position with the largest gap\n            max_gap = -1\n            split_pos = -1\n            for i in range(1, len(route) - 1):\n                gap = distance_matrix[route[i-1], route[i+1]] - distance_matrix[route[i-1], route[i]] - distance_matrix[route[i], route[i+1]]\n                if gap > max_gap:\n                    max_gap = gap\n                    split_pos = i\n            if split_pos != -1:\n                # Split the route at the best position\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:]])\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # If no changes were made, return the original solution\n    if not new_solution:\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7301324522616345,
            4.927073180675507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, (dist, span) in archive:\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(obj[0] for obj in [x[1] for x in archive])\n        max_span = max(obj[1] for obj in [x[1] for x in archive])\n        norm_dist = dist / max_dist if max_dist > 0 else 0\n        norm_span = span / max_span if max_span > 0 else 0\n        # Higher weight for solutions with better balance between objectives\n        weight = 1 / (0.5 * norm_dist + 0.5 * norm_span + 1e-6)\n        weights.append(weight)\n\n    # Normalize weights\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 2.1: Route merging (if feasible)\n        if len(base_solution) > 1 and random.random() < 0.3:\n            other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n            other_route = base_solution[other_route_idx].copy()\n            merged_route = np.concatenate([route[1:-1], other_route[1:-1]])\n            # Check capacity constraint\n            if np.sum(demand[merged_route]) <= capacity:\n                new_solution.append(np.concatenate([[0], merged_route, [0]]))\n                # Remove the merged route from the solution\n                base_solution = [r for i, r in enumerate(base_solution) if i != selected_idx and i != other_route_idx]\n                break\n\n        # Step 2.2: Customer reinsertion\n        if len(route) > 3:\n            # Select a random customer to reinsert\n            candidate_idx = random.randint(1, len(route) - 2)\n            customer = route[candidate_idx]\n            # Remove customer from the route\n            modified_route = np.concatenate([route[:candidate_idx], route[candidate_idx+1:]])\n            # Try to insert at a different position in the same route\n            best_pos = None\n            best_cost = float('inf')\n            for i in range(1, len(modified_route)):\n                new_route = np.concatenate([modified_route[:i], [customer], modified_route[i:]])\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Calculate insertion cost (delta distance)\n                    cost = (distance_matrix[new_route[i-1], customer] +\n                            distance_matrix[customer, new_route[i]] -\n                            distance_matrix[new_route[i-1], new_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos is not None:\n                modified_route = np.concatenate([modified_route[:best_pos], [customer], modified_route[best_pos:]])\n            # Add modified route to new solution\n            new_solution.append(modified_route)\n\n        # Step 2.3: Depot-based route splitting (if makespan is large)\n        if len(route) > 3 and random.random() < 0.5:\n            # Find the position with the largest gap\n            max_gap = -1\n            split_pos = -1\n            for i in range(1, len(route) - 1):\n                gap = distance_matrix[route[i-1], route[i+1]] - distance_matrix[route[i-1], route[i]] - distance_matrix[route[i], route[i+1]]\n                if gap > max_gap:\n                    max_gap = gap\n                    split_pos = i\n            if split_pos != -1:\n                # Split the route at the best position\n                route1 = np.concatenate([route[:split_pos+1], [0]])\n                route2 = np.concatenate([[0], route[split_pos+1:]])\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # If no changes were made, return the original solution\n    if not new_solution:\n        return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route Segmentation + Inter-Route Relocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Segment the longer route into two parts\n        if len(route1) > 4 and len(route2) > 2:\n            split_pos = np.random.randint(2, len(route1) - 1)\n            segment = route1[split_pos:-1]  # Exclude depot\n\n            # Check capacity constraint for the segment\n            if np.sum(demand[segment]) <= capacity:\n                # Step 3: Insert the segment into the second route\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update the solution\n                new_solution[route1_idx] = np.concatenate([route1[:split_pos], [0]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n",
        "score": [
            -0.5453417324423293,
            0.3754447102546692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route Segmentation + Inter-Route Relocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Step 2: Segment the longer route into two parts\n        if len(route1) > 4 and len(route2) > 2:\n            split_pos = np.random.randint(2, len(route1) - 1)\n            segment = route1[split_pos:-1]  # Exclude depot\n\n            # Check capacity constraint for the segment\n            if np.sum(demand[segment]) <= capacity:\n                # Step 3: Insert the segment into the second route\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update the solution\n                new_solution[route1_idx] = np.concatenate([route1[:split_pos], [0]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Split the route into two parts\n            split_idx = np.random.randint(2, len(route) - 2)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:-1]\n\n            # Check capacity for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[i] = part1\n                new_solution.append(np.concatenate([part2, [0]]))\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Number of reallocation attempts\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Try to move a customer from the longest to the shortest route\n            for j in range(1, len(longest_route) - 2):\n                customer = longest_route[j]\n                new_shortest_route = np.concatenate([shortest_route[:-1], [customer], [0]])\n                new_demand = np.sum(demand[new_shortest_route[1:-1]])\n\n                if new_demand <= capacity:\n                    # Update routes\n                    new_solution[longest_route_idx] = np.concatenate([longest_route[:j], longest_route[j+1:-1], [0]])\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6725538006225867,
            0.7548350691795349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough customers\n            # Split the route into two parts\n            split_idx = np.random.randint(2, len(route) - 2)\n            part1 = route[:split_idx + 1]\n            part2 = route[split_idx:-1]\n\n            # Check capacity for both parts\n            demand_part1 = np.sum(demand[part1[1:-1]])\n            demand_part2 = np.sum(demand[part2[1:-1]])\n\n            if demand_part1 <= capacity and demand_part2 <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[i] = part1\n                new_solution.append(np.concatenate([part2, [0]]))\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Number of reallocation attempts\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Try to move a customer from the longest to the shortest route\n            for j in range(1, len(longest_route) - 2):\n                customer = longest_route[j]\n                new_shortest_route = np.concatenate([shortest_route[:-1], [customer], [0]])\n                new_demand = np.sum(demand[new_shortest_route[1:-1]])\n\n                if new_demand <= capacity:\n                    # Update routes\n                    new_solution[longest_route_idx] = np.concatenate([longest_route[:j], longest_route[j+1:-1], [0]])\n                    new_solution[shortest_route_idx] = new_shortest_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, insertion, and reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts if it's too long\n        if distance_matrix[route[0], route[-1]] > 1.5 * np.mean([distance_matrix[r, route[j+1]] for r in route[:-1] for j in range(len(route)-1)]):\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate((route[:split_idx], [0]))\n            new_route2 = np.concatenate(([0], route[split_idx:]))\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n        # Try inserting a random customer from another route into this route\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 2:\n                continue\n            candidate_route = new_solution[j]\n            candidate_node = candidate_route[1]  # Insert the second node in the candidate route\n            if np.sum(demand[route[1:-1]]) + demand[candidate_node] <= capacity:\n                # Find the best insertion point in the current route\n                best_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(route)-1):\n                    new_cost = distance_matrix[route[pos-1], candidate_node] + distance_matrix[candidate_node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n                if best_pos != -1:\n                    new_route = np.insert(route, best_pos, candidate_node)\n                    new_solution[i] = new_route\n                    new_solution[j] = np.delete(candidate_route, 1)  # Remove the inserted node from the original route\n                    break\n\n        # Reverse a segment of the route to potentially reduce distance\n        if len(route) > 4:\n            start = np.random.randint(1, len(route)-3)\n            end = np.random.randint(start+1, len(route)-1)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate((route[:start], reversed_segment, route[end:]))\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Ensure feasibility by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "score": [
            -0.7728517589725813,
            6.56527242064476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, insertion, and reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts if it's too long\n        if distance_matrix[route[0], route[-1]] > 1.5 * np.mean([distance_matrix[r, route[j+1]] for r in route[:-1] for j in range(len(route)-1)]):\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate((route[:split_idx], [0]))\n            new_route2 = np.concatenate(([0], route[split_idx:]))\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n        # Try inserting a random customer from another route into this route\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 2:\n                continue\n            candidate_route = new_solution[j]\n            candidate_node = candidate_route[1]  # Insert the second node in the candidate route\n            if np.sum(demand[route[1:-1]]) + demand[candidate_node] <= capacity:\n                # Find the best insertion point in the current route\n                best_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(route)-1):\n                    new_cost = distance_matrix[route[pos-1], candidate_node] + distance_matrix[candidate_node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n                if best_pos != -1:\n                    new_route = np.insert(route, best_pos, candidate_node)\n                    new_solution[i] = new_route\n                    new_solution[j] = np.delete(candidate_route, 1)  # Remove the inserted node from the original route\n                    break\n\n        # Reverse a segment of the route to potentially reduce distance\n        if len(route) > 4:\n            start = np.random.randint(1, len(route)-3)\n            end = np.random.randint(start+1, len(route)-1)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate((route[:start], reversed_segment, route[end:]))\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Ensure feasibility by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high makespan or total distance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and cross-exchange\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if parts are feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n\n            # Cross-exchange between two random routes\n            if len(new_solution) > 1:\n                j = np.random.randint(0, len(new_solution))\n                if j != i and len(new_solution[j]) > 3:\n                    route_j = new_solution[j]\n                    split_pos_j = np.random.randint(1, len(route_j) - 1)\n                    part_j = route_j[split_pos_j:]\n\n                    # Check feasibility of merged route\n                    merged = np.concatenate([part1, part_j])\n                    if np.sum(demand[merged[1:-1]]) <= capacity:\n                        new_solution[i] = merged\n                        new_solution[j] = np.concatenate([route_j[:split_pos_j], part2])\n\n    return new_solution\n\n",
        "score": [
            -0.815577681987701,
            1.080247014760971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high makespan or total distance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and cross-exchange\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if parts are feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n\n            # Cross-exchange between two random routes\n            if len(new_solution) > 1:\n                j = np.random.randint(0, len(new_solution))\n                if j != i and len(new_solution[j]) > 3:\n                    route_j = new_solution[j]\n                    split_pos_j = np.random.randint(1, len(route_j) - 1)\n                    part_j = route_j[split_pos_j:]\n\n                    # Check feasibility of merged route\n                    merged = np.concatenate([part1, part_j])\n                    if np.sum(demand[merged[1:-1]]) <= capacity:\n                        new_solution[i] = merged\n                        new_solution[j] = np.concatenate([route_j[:split_pos_j], part2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point, ensuring feasibility\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for both parts\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If splitting is infeasible, try reinserting a random customer from the longest route into another route\n        customer_to_move = np.random.choice(longest_route[1:-1])\n        longest_route = np.delete(longest_route, np.where(longest_route == customer_to_move)[0][0])\n        new_solution[longest_route_idx] = longest_route\n\n        # Find the best route to insert the customer into (minimizing total distance)\n        best_route_idx = -1\n        min_increase = float('inf')\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity:\n                for pos in range(1, len(route)):\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[route[pos-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7042509690161765,
            0.5555848479270935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    longest_route = base_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point, ensuring feasibility\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check capacity constraints for both parts\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If splitting is infeasible, try reinserting a random customer from the longest route into another route\n        customer_to_move = np.random.choice(longest_route[1:-1])\n        longest_route = np.delete(longest_route, np.where(longest_route == customer_to_move)[0][0])\n        new_solution[longest_route_idx] = longest_route\n\n        # Find the best route to insert the customer into (minimizing total distance)\n        best_route_idx = -1\n        min_increase = float('inf')\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity:\n                for pos in range(1, len(route)):\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[route[pos-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize low makespan, then low distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Step 3: Apply novel hybrid operator: Split, Reassign, Invert\n    if len(route) > 4:  # Ensure route is long enough to split\n        split_pos = np.random.randint(2, len(route) - 1)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        # Reassign segment2 to another route or create a new route\n        if len(selected_solution) > 1 and np.random.rand() < 0.5:\n            # Reassign to another route\n            target_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Check capacity constraint\n            segment2_demand = np.sum(demand[segment2[1:-1]])\n            if np.sum(demand[target_route[1:-1]]) + segment2_demand <= capacity:\n                # Invert segment2 before reassigning\n                segment2 = np.concatenate([[0], segment2[-2:0:-1], [0]])\n                new_route = np.concatenate([target_route, segment2[1:-1]])\n                selected_solution[target_route_idx] = new_route\n                selected_solution[route_idx] = np.concatenate([segment1, [0]])\n        else:\n            # Create a new route\n            segment2 = np.concatenate([[0], segment2[-2:0:-1], [0]])  # Invert segment2\n            if np.sum(demand[segment2[1:-1]]) <= capacity:\n                selected_solution.append(segment2)\n                selected_solution[route_idx] = np.concatenate([segment1, [0]])\n\n    # Step 4: Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n",
        "score": [
            -0.5148129355044875,
            2.843628853559494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize low makespan, then low distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Step 3: Apply novel hybrid operator: Split, Reassign, Invert\n    if len(route) > 4:  # Ensure route is long enough to split\n        split_pos = np.random.randint(2, len(route) - 1)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        # Reassign segment2 to another route or create a new route\n        if len(selected_solution) > 1 and np.random.rand() < 0.5:\n            # Reassign to another route\n            target_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            target_route = selected_solution[target_route_idx].copy()\n\n            # Check capacity constraint\n            segment2_demand = np.sum(demand[segment2[1:-1]])\n            if np.sum(demand[target_route[1:-1]]) + segment2_demand <= capacity:\n                # Invert segment2 before reassigning\n                segment2 = np.concatenate([[0], segment2[-2:0:-1], [0]])\n                new_route = np.concatenate([target_route, segment2[1:-1]])\n                selected_solution[target_route_idx] = new_route\n                selected_solution[route_idx] = np.concatenate([segment1, [0]])\n        else:\n            # Create a new route\n            segment2 = np.concatenate([[0], segment2[-2:0:-1], [0]])  # Invert segment2\n            if np.sum(demand[segment2[1:-1]]) <= capacity:\n                selected_solution.append(segment2)\n                selected_solution[route_idx] = np.concatenate([segment1, [0]])\n\n    # Step 4: Remove empty routes\n    selected_solution = [route for route in selected_solution if len(route) > 2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting and cross-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with potential for splitting\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Cross-route insertion: move a customer from one route to another\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) > 3 and len(route2) > 3:\n                    # Try moving a customer from route1 to route2\n                    customer = route1[1]\n                    new_route1 = np.concatenate([[0], route1[2:]])\n                    new_route2 = np.concatenate([route2[:-1], [customer], [0]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7645648534491025,
            0.34190911054611206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] - obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route splitting and cross-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with potential for splitting\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Cross-route insertion: move a customer from one route to another\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) > 3 and len(route2) > 3:\n                    # Try moving a customer from route1 to route2\n                    customer = route1[1]\n                    new_route1 = np.concatenate([[0], route1[2:]])\n                    new_route2 = np.concatenate([route2[:-1], [customer], [0]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{My novel algorithm combines route-mixing with adaptive route-splitting, where promising segments from high-quality solutions are selectively inserted into target routes, followed by capacity-aware route adjustments to maintain feasibility while exploring the trade-off between distance and makespan minimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Find the solution with the best makespan or total distance\n    best_makespan_idx = np.argmin([obj[1] for obj in archive_objectives])\n    best_distance_idx = np.argmin([obj[0] for obj in archive_objectives])\n\n    # Randomly choose between the two best solutions\n    if np.random.rand() < 0.5:\n        base_solution = archive_solutions[best_makespan_idx].copy()\n    else:\n        base_solution = archive_solutions[best_distance_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-mixing with adaptive splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from another route\n        other_route_idx = np.random.choice([j for j in range(len(new_solution)) if j != i])\n        other_route = new_solution[other_route_idx]\n\n        if len(other_route) <= 3:\n            continue\n\n        # Extract a random segment from the other route\n        start = np.random.randint(1, len(other_route) - 1)\n        end = np.random.randint(start + 1, len(other_route))\n        segment = other_route[start:end]\n\n        # Check if the segment can be inserted into the current route without exceeding capacity\n        current_demand = sum(demand[route[1:-1]])\n        segment_demand = sum(demand[segment])\n\n        if current_demand + segment_demand <= capacity:\n            # Insert the segment into the current route\n            insert_pos = np.random.randint(1, len(route))\n            new_route = np.concatenate([route[:insert_pos], segment, route[insert_pos:]])\n\n            # Check if the new route is feasible\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Adaptive route splitting to balance makespan and distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            # Replace the original route with the two split routes\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n\n    return new_solution\n\n",
        "score": [
            -0.7400470341940265,
            1.966020941734314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Find the solution with the best makespan or total distance\n    best_makespan_idx = np.argmin([obj[1] for obj in archive_objectives])\n    best_distance_idx = np.argmin([obj[0] for obj in archive_objectives])\n\n    # Randomly choose between the two best solutions\n    if np.random.rand() < 0.5:\n        base_solution = archive_solutions[best_makespan_idx].copy()\n    else:\n        base_solution = archive_solutions[best_distance_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route-mixing with adaptive splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment from another route\n        other_route_idx = np.random.choice([j for j in range(len(new_solution)) if j != i])\n        other_route = new_solution[other_route_idx]\n\n        if len(other_route) <= 3:\n            continue\n\n        # Extract a random segment from the other route\n        start = np.random.randint(1, len(other_route) - 1)\n        end = np.random.randint(start + 1, len(other_route))\n        segment = other_route[start:end]\n\n        # Check if the segment can be inserted into the current route without exceeding capacity\n        current_demand = sum(demand[route[1:-1]])\n        segment_demand = sum(demand[segment])\n\n        if current_demand + segment_demand <= capacity:\n            # Insert the segment into the current route\n            insert_pos = np.random.randint(1, len(route))\n            new_route = np.concatenate([route[:insert_pos], segment, route[insert_pos:]])\n\n            # Check if the new route is feasible\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Adaptive route splitting to balance makespan and distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Randomly split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            # Replace the original route with the two split routes\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If merging is not feasible, perform a route-splitting operation\n            split_point = np.random.randint(1, len(route1) - 1)\n            new_route1 = np.concatenate([route1[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route1[split_point + 1:]])\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_indices[0]]\n            new_solution.extend([new_route1, new_route2])\n    else:\n        # If only one route exists, perform a random 2-opt within the route\n        route = selected_solution[0]\n        i, j = np.random.choice(len(route) - 2, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_route = np.concatenate([route[:i + 1], route[j:i:-1], route[j + 1:]])\n        new_solution = [new_route]\n\n    # Ensure the solution is feasible (demand constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert to the original solution if infeasible\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9753162663962383,
            1.851816177368164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If merging is not feasible, perform a route-splitting operation\n            split_point = np.random.randint(1, len(route1) - 1)\n            new_route1 = np.concatenate([route1[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route1[split_point + 1:]])\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_indices[0]]\n            new_solution.extend([new_route1, new_route2])\n    else:\n        # If only one route exists, perform a random 2-opt within the route\n        route = selected_solution[0]\n        i, j = np.random.choice(len(route) - 2, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_route = np.concatenate([route[:i + 1], route[j:i:-1], route[j + 1:]])\n        new_solution = [new_route]\n\n    # Ensure the solution is feasible (demand constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert to the original solution if infeasible\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If merging is not feasible, perform a route-splitting operation\n            split_point = np.random.randint(1, len(route1) - 1)\n            new_route1 = np.concatenate([route1[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route1[split_point + 1:]])\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_indices[0]]\n            new_solution.extend([new_route1, new_route2])\n    else:\n        # If only one route exists, perform a random 2-opt within the route\n        route = selected_solution[0]\n        i, j = np.random.choice(len(route) - 2, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_route = np.concatenate([route[:i + 1], route[j:i:-1], route[j + 1:]])\n        new_solution = [new_route]\n\n    # Ensure the solution is feasible (demand constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert to the original solution if infeasible\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9753162663962383,
            1.851816177368164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select two routes to merge or split\n    if len(selected_solution) > 1:\n        route_indices = np.random.choice(len(selected_solution), 2, replace=False)\n        route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n        # Attempt to merge the two routes if their total demand is within capacity\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in route_indices]\n            new_solution.append(merged_route)\n        else:\n            # If merging is not feasible, perform a route-splitting operation\n            split_point = np.random.randint(1, len(route1) - 1)\n            new_route1 = np.concatenate([route1[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route1[split_point + 1:]])\n            new_solution = [route for i, route in enumerate(selected_solution) if i != route_indices[0]]\n            new_solution.extend([new_route1, new_route2])\n    else:\n        # If only one route exists, perform a random 2-opt within the route\n        route = selected_solution[0]\n        i, j = np.random.choice(len(route) - 2, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_route = np.concatenate([route[:i + 1], route[j:i:-1], route[j + 1:]])\n        new_solution = [new_route]\n\n    # Ensure the solution is feasible (demand constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Revert to the original solution if infeasible\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of objective diversity and route structure, then applies a novel \"route fusion and fragmentation\" operator that combines and splits routes to balance distance and makespan, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Route Fusion and Fragmentation\n    if len(selected_solution) > 1:\n        # Randomly select two routes to fuse\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[i], selected_solution[j]\n\n        # Find feasible fusion point by checking capacity constraints\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check if fusion is feasible\n                if sum(demand[route1[k:]] + demand[route2[:l]]) <= capacity:\n                    # Fuse routes at the found points\n                    fused_route = np.concatenate((route1[:k], route2[l-1::-1], route1[k:]))\n                    # Split the fused route into two new routes\n                    split_pos = len(route1[:k]) + len(route2[l-1::-1])\n                    new_route1 = fused_route[:split_pos+1]\n                    new_route2 = np.concatenate(([0], fused_route[split_pos+1:-1], [0]))\n\n                    # Replace the original routes with the new ones\n                    selected_solution[i] = new_route1\n                    selected_solution[j] = new_route2\n                    break\n            else:\n                continue\n            break\n\n    # Ensure all routes are feasible\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return archive[selected_idx][0]\n\n    return selected_solution\n\n",
        "score": [
            -0.7709969779226526,
            0.39305686950683594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Route Fusion and Fragmentation\n    if len(selected_solution) > 1:\n        # Randomly select two routes to fuse\n        i, j = random.sample(range(len(selected_solution)), 2)\n        route1, route2 = selected_solution[i], selected_solution[j]\n\n        # Find feasible fusion point by checking capacity constraints\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check if fusion is feasible\n                if sum(demand[route1[k:]] + demand[route2[:l]]) <= capacity:\n                    # Fuse routes at the found points\n                    fused_route = np.concatenate((route1[:k], route2[l-1::-1], route1[k:]))\n                    # Split the fused route into two new routes\n                    split_pos = len(route1[:k]) + len(route2[l-1::-1])\n                    new_route1 = fused_route[:split_pos+1]\n                    new_route2 = np.concatenate(([0], fused_route[split_pos+1:-1], [0]))\n\n                    # Replace the original routes with the new ones\n                    selected_solution[i] = new_route1\n                    selected_solution[j] = new_route2\n                    break\n            else:\n                continue\n            break\n\n    # Ensure all routes are feasible\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return archive[selected_idx][0]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement (e.g., high makespan or total distance), then applies a hybrid local search combining route splitting, customer reallocation, and route merging to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting, customer reallocation, and route merging\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer Reallocation - Move customers between routes\n    for _ in range(2):  # Try a few reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route and customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no customers\n            continue\n\n        customer_pos = random.randint(1, len(route)-2)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            for insert_pos in range(1, len(other_route)):\n                # Create new routes with the customer moved\n                new_route = np.concatenate((other_route[:insert_pos], [customer], other_route[insert_pos:]))\n                new_other_route = np.delete(route, customer_pos)\n\n                # Check capacity constraints\n                if np.sum(demand[new_route[1:-1]]) <= capacity and np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    # Update solution\n                    new_solution[other_idx] = new_route\n                    new_solution[route_idx] = new_other_route\n                    if len(new_other_route) == 2:  # If route becomes empty, remove it\n                        new_solution.pop(route_idx)\n                    break\n\n    # Step 3: Route Merging - Merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_idx = np.argmin([len(route) for route in new_solution])\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to merge with another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == shortest_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            # Create merged route\n            merged_route = np.concatenate((shortest_route[:-1], other_route[1:]))\n\n            # Check capacity constraint\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Update solution\n                new_solution[shortest_idx] = merged_route\n                new_solution.pop(other_idx)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7514398767870438,
            7.281956225633621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting, customer reallocation, and route merging\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has enough customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer Reallocation - Move customers between routes\n    for _ in range(2):  # Try a few reallocations\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route and customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no customers\n            continue\n\n        customer_pos = random.randint(1, len(route)-2)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            for insert_pos in range(1, len(other_route)):\n                # Create new routes with the customer moved\n                new_route = np.concatenate((other_route[:insert_pos], [customer], other_route[insert_pos:]))\n                new_other_route = np.delete(route, customer_pos)\n\n                # Check capacity constraints\n                if np.sum(demand[new_route[1:-1]]) <= capacity and np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    # Update solution\n                    new_solution[other_idx] = new_route\n                    new_solution[route_idx] = new_other_route\n                    if len(new_other_route) == 2:  # If route becomes empty, remove it\n                        new_solution.pop(route_idx)\n                    break\n\n    # Step 3: Route Merging - Merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_idx = np.argmin([len(route) for route in new_solution])\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to merge with another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == shortest_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            # Create merged route\n            merged_route = np.concatenate((shortest_route[:-1], other_route[1:]))\n\n            # Check capacity constraint\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Update solution\n                new_solution[shortest_idx] = merged_route\n                new_solution.pop(other_idx)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware edge swaps to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n\n    # Combine objectives with weights\n    combined = 0.4 * norm_total + 0.6 * norm_makespan\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a working copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operators\n    # 1. Route merging if possible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged[1:-1]]) <= capacity:\n            new_solution[i] = merged\n            del new_solution[j]\n\n    # 2. Customer reallocation between routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Try moving a customer from route1 to route2\n        customer = random.choice(route1[1:-1])\n        new_route1 = np.delete(route1, np.where(route1 == customer))\n        new_route2 = np.insert(route2, -1, customer)\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    # 3. Capacity-aware edge swaps\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Randomly select two edges to swap\n        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n        # Check if swap is feasible\n        if (np.sum(demand[route[a]]) + np.sum(demand[route[b]]) <= capacity):\n            route[a], route[b] = route[b], route[a]\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route detected\")\n\n    return new_solution\n\n",
        "score": [
            -0.505752314247455,
            1.8025532364845276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n\n    # Combine objectives with weights\n    combined = 0.4 * norm_total + 0.6 * norm_makespan\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a working copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operators\n    # 1. Route merging if possible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged[1:-1]]) <= capacity:\n            new_solution[i] = merged\n            del new_solution[j]\n\n    # 2. Customer reallocation between routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Try moving a customer from route1 to route2\n        customer = random.choice(route1[1:-1])\n        new_route1 = np.delete(route1, np.where(route1 == customer))\n        new_route2 = np.insert(route2, -1, customer)\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    # 3. Capacity-aware edge swaps\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Randomly select two edges to swap\n        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n        # Check if swap is feasible\n        if (np.sum(demand[route[a]]) + np.sum(demand[route[b]]) <= capacity):\n            route[a], route[b] = route[b], route[a]\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route detected\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and intra-route reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by reversing one and connecting them\n            merged_route = np.concatenate([route1[:-1], route2[::-1][1:]])\n            new_solution[i] = merged_route\n            new_solution = np.delete(new_solution, j)\n        else:\n            # If merging fails, perform intra-route reversal on the first route\n            k, l = np.random.choice(len(route1) - 2, 2, replace=False) + 1\n            if k > l:\n                k, l = l, k\n            reversed_segment = route1[k:l+1][::-1]\n            route1[k:l+1] = reversed_segment\n            new_solution[i] = route1\n\n    return new_solution\n\n",
        "score": [
            -0.6786033745181432,
            0.7650807499885559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and intra-route reversal\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by reversing one and connecting them\n            merged_route = np.concatenate([route1[:-1], route2[::-1][1:]])\n            new_solution[i] = merged_route\n            new_solution = np.delete(new_solution, j)\n        else:\n            # If merging fails, perform intra-route reversal on the first route\n            k, l = np.random.choice(len(route1) - 2, 2, replace=False) + 1\n            if k > l:\n                k, l = l, k\n            reversed_segment = route1[k:l+1][::-1]\n            route1[k:l+1] = reversed_segment\n            new_solution[i] = route1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split and reinsert with demand-aware clustering\n    if len(longest_route) > 3:\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Reinsert part2 into the best possible position in another route\n        best_route_idx = -1\n        best_insert_pos = -1\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[part2[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    # Calculate the increase in total distance\n                    dist_increase = (distance_matrix[route[pos-1], part2[1]] +\n                                   distance_matrix[part2[-2], route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            new_solution[longest_route_idx] = part1\n            new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:best_insert_pos],\n                                                         part2[1:-1],\n                                                         new_solution[best_route_idx][best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7700534493441589,
            2.112182378768921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split and reinsert with demand-aware clustering\n    if len(longest_route) > 3:\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Reinsert part2 into the best possible position in another route\n        best_route_idx = -1\n        best_insert_pos = -1\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if sum(demand[part2[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    # Calculate the increase in total distance\n                    dist_increase = (distance_matrix[route[pos-1], part2[1]] +\n                                   distance_matrix[part2[-2], route[pos]] -\n                                   distance_matrix[route[pos-1], route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_route_idx = i\n                        best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            new_solution[longest_route_idx] = part1\n            new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:best_insert_pos],\n                                                         part2[1:-1],\n                                                         new_solution[best_route_idx][best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    if len(route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Hybrid local search: combine route splitting and customer relocation\n    split_pos = np.random.randint(1, len(route) - 1)\n    split_route = route[:split_pos + 1]  # New route includes depot\n    remaining_route = [0] + route[split_pos + 1:]  # New route starts and ends with depot\n\n    # Check capacity feasibility\n    split_load = np.sum(demand[split_route[1:-1]])\n    remaining_load = np.sum(demand[remaining_route[1:-1]])\n\n    if split_load <= capacity and remaining_load <= capacity:\n        new_solution[route_idx] = split_route\n        new_solution.append(remaining_route)\n    else:\n        # If splitting violates capacity, try relocating a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Move customer to the other route\n                route = np.delete(route, customer_pos)\n                other_route = np.insert(other_route, -1, customer)\n                new_solution[route_idx] = route\n                new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8814231009369374,
            0.2580184042453766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    if len(route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Hybrid local search: combine route splitting and customer relocation\n    split_pos = np.random.randint(1, len(route) - 1)\n    split_route = route[:split_pos + 1]  # New route includes depot\n    remaining_route = [0] + route[split_pos + 1:]  # New route starts and ends with depot\n\n    # Check capacity feasibility\n    split_load = np.sum(demand[split_route[1:-1]])\n    remaining_load = np.sum(demand[remaining_route[1:-1]])\n\n    if split_load <= capacity and remaining_load <= capacity:\n        new_solution[route_idx] = split_route\n        new_solution.append(remaining_route)\n    else:\n        # If splitting violates capacity, try relocating a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Move customer to the other route\n                route = np.delete(route, customer_pos)\n                other_route = np.insert(other_route, -1, customer)\n                new_solution[route_idx] = route\n                new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware swaps to generate a neighbor solution with improved objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and capacity-aware swaps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into shorter ones if possible\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Customer Reallocation - Move customers between routes if beneficial\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from route1\n        customer_idx = random.randint(1, len(route1) - 2)\n        customer = route1[customer_idx]\n\n        # Check if moving to route2 is feasible\n        new_route1 = np.delete(route1, customer_idx)\n        new_route2 = np.insert(route2, -1, customer)\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Capacity-Aware Swaps - Swap customers between routes if beneficial\n    for _ in range(3):  # Limit iterations\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select customers from both routes\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check if swapping is feasible\n        new_route1 = route1.copy()\n        new_route1[cust1_idx] = cust2\n        new_route2 = route2.copy()\n        new_route2[cust2_idx] = cust1\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.811303178263485,
            4.217877298593521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and capacity-aware swaps\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split long routes into shorter ones if possible\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Arbitrary threshold to avoid trivial splits\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Customer Reallocation - Move customers between routes if beneficial\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select a customer from route1\n        customer_idx = random.randint(1, len(route1) - 2)\n        customer = route1[customer_idx]\n\n        # Check if moving to route2 is feasible\n        new_route1 = np.delete(route1, customer_idx)\n        new_route2 = np.insert(route2, -1, customer)\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Capacity-Aware Swaps - Swap customers between routes if beneficial\n    for _ in range(3):  # Limit iterations\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Randomly select customers from both routes\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check if swapping is feasible\n        new_route1 = route1.copy()\n        new_route1[cust1_idx] = cust2\n        new_route2 = route2.copy()\n        new_route2[cust2_idx] = cust1\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route-splitting and customer reallocation to balance distance and makespan, ensuring feasibility by validating capacity constraints during each transformation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objective_scores = [sol[1][0] + sol[1][1] for sol in archive]\n    selected_idx = np.argmin(objective_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Split route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        new_route1 = route[:split_pos+1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Check capacity constraints\n        def is_valid(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(new_route1) and is_valid(new_route2):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            continue\n\n        # If split fails, try reallocating customers\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            # Try inserting into other routes\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                temp_route = new_solution[k].copy()\n                # Find best insertion position\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(temp_route)):\n                    temp_route.insert(pos, customer)\n                    if is_valid(temp_route):\n                        cost = distance_matrix[temp_route[pos-1]][customer] + distance_matrix[customer][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    temp_route.pop(pos)\n                if best_pos != -1:\n                    temp_route.insert(best_pos, customer)\n                    new_solution[k] = temp_route\n                    route = np.delete(route, j)\n                    new_solution[i] = route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7923409237923853,
            1.0288898944854736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objective_scores = [sol[1][0] + sol[1][1] for sol in archive]\n    selected_idx = np.argmin(objective_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Split route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        new_route1 = route[:split_pos+1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Check capacity constraints\n        def is_valid(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(new_route1) and is_valid(new_route2):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            continue\n\n        # If split fails, try reallocating customers\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            # Try inserting into other routes\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                temp_route = new_solution[k].copy()\n                # Find best insertion position\n                min_cost = float('inf')\n                best_pos = -1\n                for pos in range(1, len(temp_route)):\n                    temp_route.insert(pos, customer)\n                    if is_valid(temp_route):\n                        cost = distance_matrix[temp_route[pos-1]][customer] + distance_matrix[customer][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    temp_route.pop(pos)\n                if best_pos != -1:\n                    temp_route.insert(best_pos, customer)\n                    new_solution[k] = temp_route\n                    route = np.delete(route, j)\n                    new_solution[i] = route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{A novel hybrid local search operator that combines route merging and split operations with capacity-aware edge swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly choose between two novel operators\n    if random.random() < 0.5:\n        # Operator 1: Route merging with capacity check\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n    else:\n        # Operator 2: Capacity-aware edge swap between two routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Select random edges from each route (excluding depot)\n            if len(route_i) > 3 and len(route_j) > 3:\n                pos_i = random.randint(1, len(route_i)-2)\n                pos_j = random.randint(1, len(route_j)-2)\n\n                # Extract edges\n                edge_i = (route_i[pos_i-1], route_i[pos_i])\n                edge_j = (route_j[pos_j-1], route_j[pos_j])\n\n                # Check capacity constraints\n                demand_i = demand[route_i[1:-1]]\n                demand_j = demand[route_j[1:-1]]\n                if (np.sum(demand_i) - demand[edge_i[1]] + demand[edge_j[1]] <= capacity and\n                    np.sum(demand_j) - demand[edge_j[1]] + demand[edge_i[1]] <= capacity):\n\n                    # Perform swap\n                    route_i[pos_i] = edge_j[1]\n                    route_j[pos_j] = edge_i[1]\n\n                    # Check if routes are now empty (shouldn't happen due to constraints)\n                    if len(route_i) <= 2:\n                        del new_solution[i]\n                    if len(route_j) <= 2:\n                        del new_solution[j]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route format\")\n\n    return new_solution\n\n",
        "score": [
            -0.46629209756088785,
            0.9313904345035553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]  # Higher weight for lower makespan\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly choose between two novel operators\n    if random.random() < 0.5:\n        # Operator 1: Route merging with capacity check\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n    else:\n        # Operator 2: Capacity-aware edge swap between two routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Select random edges from each route (excluding depot)\n            if len(route_i) > 3 and len(route_j) > 3:\n                pos_i = random.randint(1, len(route_i)-2)\n                pos_j = random.randint(1, len(route_j)-2)\n\n                # Extract edges\n                edge_i = (route_i[pos_i-1], route_i[pos_i])\n                edge_j = (route_j[pos_j-1], route_j[pos_j])\n\n                # Check capacity constraints\n                demand_i = demand[route_i[1:-1]]\n                demand_j = demand[route_j[1:-1]]\n                if (np.sum(demand_i) - demand[edge_i[1]] + demand[edge_j[1]] <= capacity and\n                    np.sum(demand_j) - demand[edge_j[1]] + demand[edge_i[1]] <= capacity):\n\n                    # Perform swap\n                    route_i[pos_i] = edge_j[1]\n                    route_j[pos_j] = edge_i[1]\n\n                    # Check if routes are now empty (shouldn't happen due to constraints)\n                    if len(route_i) <= 2:\n                        del new_solution[i]\n                    if len(route_j) <= 2:\n                        del new_solution[j]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route format\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The algorithm selects a solution from the archive with the lowest makespan to focus on reducing the longest route, then applies a hybrid local search combining route splitting and customer reinsertion to balance distance and makespan improvements while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Choose a random route to modify\n    if len(base_solution) == 1:\n        return base_solution.copy()\n\n    route_idx = random.randint(0, len(base_solution) - 1)\n    selected_route = base_solution[route_idx].copy()\n\n    # Split the selected route into two parts at a random point\n    if len(selected_route) <= 3:\n        return base_solution.copy()\n\n    split_point = random.randint(1, len(selected_route) - 2)\n    part1 = selected_route[:split_point + 1]\n    part2 = selected_route[split_point:]\n\n    # Check capacity constraints for both parts\n    def check_capacity(route):\n        total_demand = sum(demand[node] for node in route[1:-1])\n        return total_demand <= capacity\n\n    if not check_capacity(part1) or not check_capacity(part2):\n        return base_solution.copy()\n\n    # Create a new solution with the split routes\n    new_solution = [route.copy() for route in base_solution if not np.array_equal(route, selected_route)]\n    new_solution.append(part1)\n    new_solution.append(part2)\n\n    # Attempt to reinsert customers from the longer route into others\n    longer_route = part1 if len(part1) > len(part2) else part2\n    shorter_route = part2 if len(part1) > len(part2) else part1\n\n    for node in longer_route[1:-1]:\n        # Try inserting the node into the shorter route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(1, len(shorter_route)):\n            # Insert node between i-1 and i\n            new_route = np.insert(shorter_route, i, node)\n            new_demand = sum(demand[n] for n in new_route[1:-1])\n\n            if new_demand > capacity:\n                continue\n\n            # Calculate the cost increase\n            cost = (distance_matrix[new_route[i-1], node] +\n                    distance_matrix[node, new_route[i+1]] -\n                    distance_matrix[new_route[i-1], new_route[i+1]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            shorter_route = np.insert(shorter_route, best_pos, node)\n            longer_route = np.delete(longer_route, np.where(longer_route == node)[0][0])\n\n    # Update the new solution\n    new_solution = [route.copy() for route in base_solution if not np.array_equal(route, selected_route)]\n    if len(longer_route) > 2:\n        new_solution.append(longer_route)\n    if len(shorter_route) > 2:\n        new_solution.append(shorter_route)\n\n    return new_solution\n\n",
        "score": [
            -0.8766403822269689,
            4.321232825517654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Choose a random route to modify\n    if len(base_solution) == 1:\n        return base_solution.copy()\n\n    route_idx = random.randint(0, len(base_solution) - 1)\n    selected_route = base_solution[route_idx].copy()\n\n    # Split the selected route into two parts at a random point\n    if len(selected_route) <= 3:\n        return base_solution.copy()\n\n    split_point = random.randint(1, len(selected_route) - 2)\n    part1 = selected_route[:split_point + 1]\n    part2 = selected_route[split_point:]\n\n    # Check capacity constraints for both parts\n    def check_capacity(route):\n        total_demand = sum(demand[node] for node in route[1:-1])\n        return total_demand <= capacity\n\n    if not check_capacity(part1) or not check_capacity(part2):\n        return base_solution.copy()\n\n    # Create a new solution with the split routes\n    new_solution = [route.copy() for route in base_solution if not np.array_equal(route, selected_route)]\n    new_solution.append(part1)\n    new_solution.append(part2)\n\n    # Attempt to reinsert customers from the longer route into others\n    longer_route = part1 if len(part1) > len(part2) else part2\n    shorter_route = part2 if len(part1) > len(part2) else part1\n\n    for node in longer_route[1:-1]:\n        # Try inserting the node into the shorter route\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(1, len(shorter_route)):\n            # Insert node between i-1 and i\n            new_route = np.insert(shorter_route, i, node)\n            new_demand = sum(demand[n] for n in new_route[1:-1])\n\n            if new_demand > capacity:\n                continue\n\n            # Calculate the cost increase\n            cost = (distance_matrix[new_route[i-1], node] +\n                    distance_matrix[node, new_route[i+1]] -\n                    distance_matrix[new_route[i-1], new_route[i+1]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            shorter_route = np.insert(shorter_route, best_pos, node)\n            longer_route = np.delete(longer_route, np.where(longer_route == node)[0][0])\n\n    # Update the new solution\n    new_solution = [route.copy() for route in base_solution if not np.array_equal(route, selected_route)]\n    if len(longer_route) > 2:\n        new_solution.append(longer_route)\n    if len(shorter_route) > 2:\n        new_solution.append(shorter_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The algorithm selects a solution from the archive with the highest combined normalized improvement potential in both objectives, then applies a hybrid local search that combines route swapping and demand-balanced route splitting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high makespan or total distance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route swapping and demand-balanced splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly choose between swapping or splitting\n        if random.random() < 0.5:\n            # Route swapping: swap two non-depot nodes between two routes\n            if len(base_solution) > 1:\n                other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n                other_route = base_solution[other_route_idx].copy()\n\n                # Find swap candidates (non-depot nodes)\n                route_nodes = [n for n in route if n != 0]\n                other_nodes = [n for n in other_route if n != 0]\n\n                if route_nodes and other_nodes:\n                    node1 = random.choice(route_nodes)\n                    node2 = random.choice(other_nodes)\n\n                    # Check feasibility after swap\n                    route_demand = sum(demand[route]) - demand[node1] + demand[node2]\n                    other_demand = sum(demand[other_route]) - demand[node2] + demand[node1]\n\n                    if route_demand <= capacity and other_demand <= capacity:\n                        # Perform swap\n                        route = np.where(route == node1, node2, route)\n                        other_route = np.where(other_route == node2, node1, other_route)\n                        new_solution.append(route.copy())\n                        base_solution[other_route_idx] = other_route.copy()\n                    else:\n                        new_solution.append(route.copy())\n        else:\n            # Demand-balanced splitting: split a route into two balanced parts\n            total_demand = sum(demand[route])\n            if total_demand > capacity:\n                # Find split point that balances demand\n                split_point = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand > total_demand / 2:\n                        split_point = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_point+1], [0]])\n                route2 = np.concatenate([[0], route[split_point+1:], [0]])\n\n                # Check feasibility\n                if sum(demand[route1]) <= capacity and sum(demand[route2]) <= capacity:\n                    new_solution.append(route1.copy())\n                    new_solution.append(route2.copy())\n                else:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # If no changes were made, return the original solution\n    if not new_solution:\n        return base_solution.copy()\n\n    # Ensure all customers are served\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n\n    if len(all_nodes) != len(demand) - 1:\n        # Revert to original if some customers are missing\n        return base_solution.copy()\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.8383295488157471,
            1.0675778985023499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high makespan or total distance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route swapping and demand-balanced splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (just depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly choose between swapping or splitting\n        if random.random() < 0.5:\n            # Route swapping: swap two non-depot nodes between two routes\n            if len(base_solution) > 1:\n                other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx])\n                other_route = base_solution[other_route_idx].copy()\n\n                # Find swap candidates (non-depot nodes)\n                route_nodes = [n for n in route if n != 0]\n                other_nodes = [n for n in other_route if n != 0]\n\n                if route_nodes and other_nodes:\n                    node1 = random.choice(route_nodes)\n                    node2 = random.choice(other_nodes)\n\n                    # Check feasibility after swap\n                    route_demand = sum(demand[route]) - demand[node1] + demand[node2]\n                    other_demand = sum(demand[other_route]) - demand[node2] + demand[node1]\n\n                    if route_demand <= capacity and other_demand <= capacity:\n                        # Perform swap\n                        route = np.where(route == node1, node2, route)\n                        other_route = np.where(other_route == node2, node1, other_route)\n                        new_solution.append(route.copy())\n                        base_solution[other_route_idx] = other_route.copy()\n                    else:\n                        new_solution.append(route.copy())\n        else:\n            # Demand-balanced splitting: split a route into two balanced parts\n            total_demand = sum(demand[route])\n            if total_demand > capacity:\n                # Find split point that balances demand\n                split_point = 1\n                current_demand = 0\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if current_demand > total_demand / 2:\n                        split_point = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_point+1], [0]])\n                route2 = np.concatenate([[0], route[split_point+1:], [0]])\n\n                # Check feasibility\n                if sum(demand[route1]) <= capacity and sum(demand[route2]) <= capacity:\n                    new_solution.append(route1.copy())\n                    new_solution.append(route2.copy())\n                else:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # If no changes were made, return the original solution\n    if not new_solution:\n        return base_solution.copy()\n\n    # Ensure all customers are served\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n\n    if len(all_nodes) != len(demand) - 1:\n        # Revert to original if some customers are missing\n        return base_solution.copy()\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The algorithm selects a promising solution from the archive, identifies critical routes (longest or high-demand), and applies a hybrid local search combining route splitting, customer reallocation, and partial 2-opt with capacity checks to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_index = np.argmax([obj[1] for sol, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = [route.copy() for route in archive[selected_index][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify critical routes (longest or high-demand)\n    route_lengths = [np.sum([distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]) for route in new_solution]\n    route_demands = [np.sum([demand[node] for node in route[1:-1]]) for route in new_solution]\n    critical_route_idx = np.argmax(route_lengths)  # Focus on the longest route\n\n    # Hybrid local search: Split, Reallocate, and Partial 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two feasible parts\n        critical_route = new_solution[critical_route_idx]\n        split_pos = len(critical_route) // 2\n        part1 = critical_route[:split_pos + 1]\n        part2 = critical_route[split_pos:]\n\n        # Ensure splits are feasible\n        part1_demand = np.sum([demand[node] for node in part1[1:-1]])\n        part2_demand = np.sum([demand[node] for node in part2[1:-1]])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            new_solution[critical_route_idx] = part1\n            new_solution.insert(critical_route_idx + 1, part2)\n\n    # Step 2: Reallocate customers between routes to balance loads\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            demand_i = np.sum([demand[node] for node in route_i[1:-1]])\n            demand_j = np.sum([demand[node] for node in route_j[1:-1]])\n\n            for k in range(1, len(route_i) - 1):\n                node = route_i[k]\n                if demand_j + demand[node] <= capacity:\n                    # Check if reallocating improves distance\n                    old_dist = distance_matrix[route_i[k-1]][node] + distance_matrix[node][route_i[k+1]]\n                    new_dist_i = distance_matrix[route_i[k-1]][route_i[k+1]]\n                    new_dist_j = distance_matrix[0][node] + distance_matrix[node][0]\n\n                    if new_dist_i + new_dist_j < old_dist:\n                        # Reallocate node\n                        route_i = np.concatenate([route_i[:k], route_i[k+1:]])\n                        route_j = np.concatenate([route_j[:-1], [node], [0]])\n                        new_solution[i] = route_i\n                        new_solution[j] = route_j\n                        break\n\n    # Step 3: Partial 2-opt on critical route\n    critical_route = new_solution[critical_route_idx]\n    if len(critical_route) > 4:\n        a, b = sorted(random.sample(range(1, len(critical_route) - 1), 2))\n        candidate_route = np.concatenate([critical_route[:a], critical_route[b:a-1:-1], critical_route[b+1:]])\n        candidate_demand = np.sum([demand[node] for node in candidate_route[1:-1]])\n\n        if candidate_demand <= capacity:\n            new_solution[critical_route_idx] = candidate_route\n\n    return new_solution\n\n",
        "score": [
            -0.7155877049985747,
            10.792979419231415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_index = np.argmax([obj[1] for sol, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = [route.copy() for route in archive[selected_index][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify critical routes (longest or high-demand)\n    route_lengths = [np.sum([distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)]) for route in new_solution]\n    route_demands = [np.sum([demand[node] for node in route[1:-1]]) for route in new_solution]\n    critical_route_idx = np.argmax(route_lengths)  # Focus on the longest route\n\n    # Hybrid local search: Split, Reallocate, and Partial 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two feasible parts\n        critical_route = new_solution[critical_route_idx]\n        split_pos = len(critical_route) // 2\n        part1 = critical_route[:split_pos + 1]\n        part2 = critical_route[split_pos:]\n\n        # Ensure splits are feasible\n        part1_demand = np.sum([demand[node] for node in part1[1:-1]])\n        part2_demand = np.sum([demand[node] for node in part2[1:-1]])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            new_solution[critical_route_idx] = part1\n            new_solution.insert(critical_route_idx + 1, part2)\n\n    # Step 2: Reallocate customers between routes to balance loads\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            demand_i = np.sum([demand[node] for node in route_i[1:-1]])\n            demand_j = np.sum([demand[node] for node in route_j[1:-1]])\n\n            for k in range(1, len(route_i) - 1):\n                node = route_i[k]\n                if demand_j + demand[node] <= capacity:\n                    # Check if reallocating improves distance\n                    old_dist = distance_matrix[route_i[k-1]][node] + distance_matrix[node][route_i[k+1]]\n                    new_dist_i = distance_matrix[route_i[k-1]][route_i[k+1]]\n                    new_dist_j = distance_matrix[0][node] + distance_matrix[node][0]\n\n                    if new_dist_i + new_dist_j < old_dist:\n                        # Reallocate node\n                        route_i = np.concatenate([route_i[:k], route_i[k+1:]])\n                        route_j = np.concatenate([route_j[:-1], [node], [0]])\n                        new_solution[i] = route_i\n                        new_solution[j] = route_j\n                        break\n\n    # Step 3: Partial 2-opt on critical route\n    critical_route = new_solution[critical_route_idx]\n    if len(critical_route) > 4:\n        a, b = sorted(random.sample(range(1, len(critical_route) - 1), 2))\n        candidate_route = np.concatenate([critical_route[:a], critical_route[b:a-1:-1], critical_route[b+1:]])\n        candidate_demand = np.sum([demand[node] for node in candidate_route[1:-1]])\n\n        if candidate_demand <= capacity:\n            new_solution[critical_route_idx] = candidate_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route splitting, customer reallocation, and partial route reversal to improve both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and partial route reversal\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Step 1: Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        # Step 3: Check if the split is feasible for the vehicle capacity\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n        if first_demand > capacity or second_demand > capacity:\n            continue\n\n        # Step 4: Reallocate customers between routes or reverse a segment\n        if random.random() < 0.5:  # Reverse a segment\n            reverse_start = random.randint(1, len(route) - 2)\n            reverse_end = random.randint(reverse_start, len(route) - 2)\n            reversed_segment = route[reverse_start:reverse_end + 1][::-1]\n            new_route = np.concatenate([route[:reverse_start], reversed_segment, route[reverse_end + 1:]])\n            new_demand = sum(demand[node] for node in new_route[1:-1])\n            if new_demand <= capacity:\n                new_solution[route_idx] = new_route\n        else:  # Reallocate customers to another route\n            if len(new_solution) > 1:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n                # Move a random customer from the first part to the other route\n                if len(first_part) > 2:\n                    customer_to_move = random.choice(first_part[1:-1])\n                    new_other_route = np.concatenate([other_route[:-1], [customer_to_move], [0]])\n                    new_other_demand = sum(demand[node] for node in new_other_route[1:-1])\n                    if new_other_demand <= capacity:\n                        new_first_part = np.concatenate([first_part[:np.where(first_part == customer_to_move)[0][0]],\n                                                        first_part[np.where(first_part == customer_to_move)[0][0] + 1:]])\n                        new_solution[route_idx] = new_first_part\n                        new_solution[other_route_idx] = new_other_route\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If infeasible, revert to the original route\n            new_solution = base_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4707351917414085,
            1.3188304901123047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and partial route reversal\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Step 1: Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        # Step 3: Check if the split is feasible for the vehicle capacity\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n        if first_demand > capacity or second_demand > capacity:\n            continue\n\n        # Step 4: Reallocate customers between routes or reverse a segment\n        if random.random() < 0.5:  # Reverse a segment\n            reverse_start = random.randint(1, len(route) - 2)\n            reverse_end = random.randint(reverse_start, len(route) - 2)\n            reversed_segment = route[reverse_start:reverse_end + 1][::-1]\n            new_route = np.concatenate([route[:reverse_start], reversed_segment, route[reverse_end + 1:]])\n            new_demand = sum(demand[node] for node in new_route[1:-1])\n            if new_demand <= capacity:\n                new_solution[route_idx] = new_route\n        else:  # Reallocate customers to another route\n            if len(new_solution) > 1:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n                # Move a random customer from the first part to the other route\n                if len(first_part) > 2:\n                    customer_to_move = random.choice(first_part[1:-1])\n                    new_other_route = np.concatenate([other_route[:-1], [customer_to_move], [0]])\n                    new_other_demand = sum(demand[node] for node in new_other_route[1:-1])\n                    if new_other_demand <= capacity:\n                        new_first_part = np.concatenate([first_part[:np.where(first_part == customer_to_move)[0][0]],\n                                                        first_part[np.where(first_part == customer_to_move)[0][0] + 1:]])\n                        new_solution[route_idx] = new_first_part\n                        new_solution[other_route_idx] = new_other_route\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If infeasible, revert to the original route\n            new_solution = base_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search operator that combines route splitting and merging with a novel demand-aware node insertion heuristic to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))  # Weighted sum\n    selected_solution = archive_sorted[min(3, len(archive) - 1)][0]  # Select from top 3 or all available\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route splitting and merging with demand-aware insertion\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a route to split or merge\n        if len(new_solution) > 1 and np.random.rand() < 0.5:\n            # Merge two routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Try to merge by connecting the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n        else:\n            # Split a route\n            if len(new_solution) < len(coords) - 1:  # Prevent too many routes\n                route_idx = np.random.randint(len(new_solution))\n                route = new_solution[route_idx]\n\n                if len(route) > 3:  # Can split\n                    split_pos = np.random.randint(1, len(route) - 1)\n                    new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n                    # Check capacity constraints\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.insert(route_idx + 1, new_route2)\n\n        # Demand-aware node insertion\n        for route in new_solution:\n            if len(route) > 3:  # Can try to improve\n                # Remove a random node and try to reinsert it\n                node_pos = np.random.randint(1, len(route) - 1)\n                node = route[node_pos]\n\n                # Remove the node\n                route_without_node = np.concatenate([route[:node_pos], route[node_pos+1:]])\n\n                # Find best insertion position\n                best_pos = None\n                best_cost = float('inf')\n\n                for i in range(len(route_without_node) - 1):\n                    # Calculate cost of inserting at position i\n                    cost = (distance_matrix[route_without_node[i]][node] +\n                            distance_matrix[node][route_without_node[i+1]] -\n                            distance_matrix[route_without_node[i]][route_without_node[i+1]])\n\n                    if cost < best_cost and sum(demand[np.concatenate([route_without_node[1:i+1], [node], route_without_node[i+1:-1]])]) <= capacity:\n                        best_cost = cost\n                        best_pos = i\n\n                if best_pos is not None:\n                    # Perform the insertion\n                    new_route = np.concatenate([route_without_node[:best_pos+1], [node], route_without_node[best_pos+1:]])\n                    route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6345883357146712,
            9.22606685757637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))  # Weighted sum\n    selected_solution = archive_sorted[min(3, len(archive) - 1)][0]  # Select from top 3 or all available\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route splitting and merging with demand-aware insertion\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a route to split or merge\n        if len(new_solution) > 1 and np.random.rand() < 0.5:\n            # Merge two routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Try to merge by connecting the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n        else:\n            # Split a route\n            if len(new_solution) < len(coords) - 1:  # Prevent too many routes\n                route_idx = np.random.randint(len(new_solution))\n                route = new_solution[route_idx]\n\n                if len(route) > 3:  # Can split\n                    split_pos = np.random.randint(1, len(route) - 1)\n                    new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n                    # Check capacity constraints\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.insert(route_idx + 1, new_route2)\n\n        # Demand-aware node insertion\n        for route in new_solution:\n            if len(route) > 3:  # Can try to improve\n                # Remove a random node and try to reinsert it\n                node_pos = np.random.randint(1, len(route) - 1)\n                node = route[node_pos]\n\n                # Remove the node\n                route_without_node = np.concatenate([route[:node_pos], route[node_pos+1:]])\n\n                # Find best insertion position\n                best_pos = None\n                best_cost = float('inf')\n\n                for i in range(len(route_without_node) - 1):\n                    # Calculate cost of inserting at position i\n                    cost = (distance_matrix[route_without_node[i]][node] +\n                            distance_matrix[node][route_without_node[i+1]] -\n                            distance_matrix[route_without_node[i]][route_without_node[i+1]])\n\n                    if cost < best_cost and sum(demand[np.concatenate([route_without_node[1:i+1], [node], route_without_node[i+1:-1]])]) <= capacity:\n                        best_cost = cost\n                        best_pos = i\n\n                if best_pos is not None:\n                    # Perform the insertion\n                    new_route = np.concatenate([route_without_node[:best_pos+1], [node], route_without_node[best_pos+1:]])\n                    route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{A novel hybrid local search operator combines route-splitting with demand-aware node insertion to balance distance and makespan objectives by intelligently redistributing customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan descending, then distance ascending\n        archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n        selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly pick from top 3\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-splitting with demand-aware insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Calculate current route demand\n        route_demand = sum(demand[node] for node in route[1:-1])\n\n        # Find potential split points (where removing a node would reduce demand below capacity)\n        split_candidates = []\n        for i in range(1, len(route)-1):\n            if route_demand - demand[route[i]] <= capacity:\n                split_candidates.append(i)\n\n        if not split_candidates:\n            continue\n\n        # Randomly select a split point\n        split_pos = np.random.choice(split_candidates)\n\n        # Create two new routes by splitting at split_pos\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Try to insert nodes from new_route2 into existing routes or keep as new route\n        inserted = False\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            # Find feasible insertion positions\n            for i in range(1, len(other_route)):\n                for node in new_route2[1:-1]:\n                    if other_demand + demand[node] <= capacity:\n                        # Insert node and update demand\n                        new_solution[other_route_idx] = np.concatenate([\n                            other_route[:i], [node], other_route[i:]\n                        ])\n                        other_demand += demand[node]\n                        inserted = True\n                        break\n                if inserted:\n                    break\n\n        # If not inserted, add as new route\n        if not inserted and len(new_route2) > 2:\n            new_solution.append(new_route2)\n\n        # Update the original route\n        new_solution[route_idx] = new_route1\n\n    # Remove any empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7666601658462582,
            5.954683601856232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan descending, then distance ascending\n        archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n        selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly pick from top 3\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-splitting with demand-aware insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Calculate current route demand\n        route_demand = sum(demand[node] for node in route[1:-1])\n\n        # Find potential split points (where removing a node would reduce demand below capacity)\n        split_candidates = []\n        for i in range(1, len(route)-1):\n            if route_demand - demand[route[i]] <= capacity:\n                split_candidates.append(i)\n\n        if not split_candidates:\n            continue\n\n        # Randomly select a split point\n        split_pos = np.random.choice(split_candidates)\n\n        # Create two new routes by splitting at split_pos\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Try to insert nodes from new_route2 into existing routes or keep as new route\n        inserted = False\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            # Find feasible insertion positions\n            for i in range(1, len(other_route)):\n                for node in new_route2[1:-1]:\n                    if other_demand + demand[node] <= capacity:\n                        # Insert node and update demand\n                        new_solution[other_route_idx] = np.concatenate([\n                            other_route[:i], [node], other_route[i:]\n                        ])\n                        other_demand += demand[node]\n                        inserted = True\n                        break\n                if inserted:\n                    break\n\n        # If not inserted, add as new route\n        if not inserted and len(new_route2) > 2:\n            new_solution.append(new_route2)\n\n        # Update the original route\n        new_solution[route_idx] = new_route1\n\n    # Remove any empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Identify customers in the selected route (excluding depots)\n    customers_in_route = route[1:-1]\n\n    # If the route has fewer than 2 customers, skip modification\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Randomly select two distinct positions in the route to swap\n    pos1, pos2 = np.random.choice(len(customers_in_route), size=2, replace=False)\n\n    # Swap the customers at the selected positions\n    route[1:-1][pos1], route[1:-1][pos2] = route[1:-1][pos2], route[1:-1][pos1]\n\n    # Check capacity feasibility after swap\n    route_demand = np.sum(demand[route[1:-1]])\n    if route_demand > capacity:\n        # If swap violates capacity, revert the swap\n        route[1:-1][pos1], route[1:-1][pos2] = route[1:-1][pos2], route[1:-1][pos1]\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    return selected_solution\n\n",
        "score": [
            -0.2337017477647704,
            0.5128214657306671
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Identify customers in the selected route (excluding depots)\n    customers_in_route = route[1:-1]\n\n    # If the route has fewer than 2 customers, skip modification\n    if len(customers_in_route) < 2:\n        return selected_solution\n\n    # Randomly select two distinct positions in the route to swap\n    pos1, pos2 = np.random.choice(len(customers_in_route), size=2, replace=False)\n\n    # Swap the customers at the selected positions\n    route[1:-1][pos1], route[1:-1][pos2] = route[1:-1][pos2], route[1:-1][pos1]\n\n    # Check capacity feasibility after swap\n    route_demand = np.sum(demand[route[1:-1]])\n    if route_demand > capacity:\n        # If swap violates capacity, revert the swap\n        route[1:-1][pos1], route[1:-1][pos2] = route[1:-1][pos2], route[1:-1][pos1]\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Apply a hybrid local search: combine 2-opt with route merging/splitting\n        if len(route) > 4:  # Ensure route has enough nodes to perform 2-opt\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If invalid, try splitting the route at the longest edge\n                max_dist = -1\n                split_pos = -1\n                for k in range(1, len(route)-1):\n                    dist = distance_matrix[route[k-1], route[k]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        split_pos = k\n                if split_pos != -1:\n                    split_route1 = np.concatenate([route[:split_pos], [0]])\n                    split_route2 = np.concatenate([[0], route[split_pos:]])\n                    if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n                        np.sum(demand[split_route2[1:-1]]) <= capacity):\n                        new_solution.pop(route_idx)\n                        new_solution.insert(route_idx, split_route2)\n                        new_solution.insert(route_idx, split_route1)\n        else:\n            # For short routes, try merging with another route if possible\n            if len(new_solution) > 1:\n                merge_idx = np.random.randint(0, len(new_solution))\n                if merge_idx != route_idx:\n                    other_route = new_solution[merge_idx]\n                    combined_route = np.concatenate([route[:-1], other_route[1:]])\n                    if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                        new_solution.pop(max(route_idx, merge_idx))\n                        new_solution.pop(min(route_idx, merge_idx))\n                        new_solution.append(combined_route)\n\n    return new_solution\n\n",
        "score": [
            -0.44980502834764186,
            0.6980458796024323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]))[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Apply a hybrid local search: combine 2-opt with route merging/splitting\n        if len(route) > 4:  # Ensure route has enough nodes to perform 2-opt\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If invalid, try splitting the route at the longest edge\n                max_dist = -1\n                split_pos = -1\n                for k in range(1, len(route)-1):\n                    dist = distance_matrix[route[k-1], route[k]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        split_pos = k\n                if split_pos != -1:\n                    split_route1 = np.concatenate([route[:split_pos], [0]])\n                    split_route2 = np.concatenate([[0], route[split_pos:]])\n                    if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n                        np.sum(demand[split_route2[1:-1]]) <= capacity):\n                        new_solution.pop(route_idx)\n                        new_solution.insert(route_idx, split_route2)\n                        new_solution.insert(route_idx, split_route1)\n        else:\n            # For short routes, try merging with another route if possible\n            if len(new_solution) > 1:\n                merge_idx = np.random.randint(0, len(new_solution))\n                if merge_idx != route_idx:\n                    other_route = new_solution[merge_idx]\n                    combined_route = np.concatenate([route[:-1], other_route[1:]])\n                    if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                        new_solution.pop(max(route_idx, merge_idx))\n                        new_solution.pop(min(route_idx, merge_idx))\n                        new_solution.append(combined_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route splitting and merging with demand-aware insertion\n    new_solution = []\n    for route in base_solution:\n        # Split long routes into two if possible\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = len(route) // 2\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            # Check feasibility\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Merge short routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        if i + 1 < len(new_solution):\n            # Try merging two routes\n            route1 = new_solution[i]\n            route2 = new_solution[i+1]\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged[1:-1]]) <= capacity:\n                merged_solution.append(merged)\n                i += 2\n            else:\n                merged_solution.append(route1)\n                i += 1\n        else:\n            merged_solution.append(new_solution[i])\n            i += 1\n\n    # Perform demand-aware insertion for further improvement\n    final_solution = []\n    for route in merged_solution:\n        if len(route) > 3:  # Only process non-trivial routes\n            # Find the most expensive customer in terms of distance\n            max_dist = -1\n            split_pos = -1\n            for j in range(1, len(route)-1):\n                dist = distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = j\n            # Try inserting the customer into a new route\n            if split_pos != -1:\n                customer = route[split_pos]\n                # Create a new route with this customer\n                new_route = np.array([0, customer, 0])\n                # Remove customer from original route\n                modified_route = np.concatenate([route[:split_pos], route[split_pos+1:]])\n                # Check feasibility\n                if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                    final_solution.extend([modified_route, new_route])\n                else:\n                    final_solution.append(route)\n            else:\n                final_solution.append(route)\n        else:\n            final_solution.append(route)\n\n    return final_solution\n\n",
        "score": [
            -0.8754498401204214,
            5.431946277618408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Route splitting and merging with demand-aware insertion\n    new_solution = []\n    for route in base_solution:\n        # Split long routes into two if possible\n        if len(route) > 4:  # Avoid trivial splits\n            split_pos = len(route) // 2\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            # Check feasibility\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Merge short routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        if i + 1 < len(new_solution):\n            # Try merging two routes\n            route1 = new_solution[i]\n            route2 = new_solution[i+1]\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged[1:-1]]) <= capacity:\n                merged_solution.append(merged)\n                i += 2\n            else:\n                merged_solution.append(route1)\n                i += 1\n        else:\n            merged_solution.append(new_solution[i])\n            i += 1\n\n    # Perform demand-aware insertion for further improvement\n    final_solution = []\n    for route in merged_solution:\n        if len(route) > 3:  # Only process non-trivial routes\n            # Find the most expensive customer in terms of distance\n            max_dist = -1\n            split_pos = -1\n            for j in range(1, len(route)-1):\n                dist = distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = j\n            # Try inserting the customer into a new route\n            if split_pos != -1:\n                customer = route[split_pos]\n                # Create a new route with this customer\n                new_route = np.array([0, customer, 0])\n                # Remove customer from original route\n                modified_route = np.concatenate([route[:split_pos], route[split_pos+1:]])\n                # Check feasibility\n                if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                    final_solution.extend([modified_route, new_route])\n                else:\n                    final_solution.append(route)\n            else:\n                final_solution.append(route)\n        else:\n            final_solution.append(route)\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by evaluating both objective values and their trade-offs, then applies a hybrid local search combining route fragmentation and customer reinsertion with capacity-aware swaps to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Select a solution with high makespan or high total distance\n    max_makespan = max(obj[1] for _, obj in archive)\n    high_makespan_solutions = [sol for sol, obj in archive if obj[1] == max_makespan]\n    if high_makespan_solutions:\n        base_solution = random.choice(high_makespan_solutions).copy()\n    else:\n        max_distance = max(obj[0] for _, obj in archive)\n        high_distance_solutions = [sol for sol, obj in archive if obj[0] == max_distance]\n        base_solution = random.choice(high_distance_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route fragmentation + customer reinsertion with capacity-aware swaps\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to fragment\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n        fragment = route[start:end].copy()\n\n        # Remove fragment from route\n        new_route = np.concatenate([route[:start], route[end:]])\n        new_solution[route_idx] = new_route\n\n        # Try to reinsert fragment into another route or create a new one\n        inserted = False\n        for target_route_idx in range(len(new_solution)):\n            if target_route_idx == route_idx:\n                continue\n            target_route = new_solution[target_route_idx]\n            current_load = sum(demand[target_route[1:-1]])  # Exclude depot\n\n            # Check if fragment can fit in target route\n            if current_load + sum(demand[fragment]) <= capacity:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    # Insert fragment at position pos\n                    temp_route = np.concatenate([\n                        target_route[:pos],\n                        fragment,\n                        target_route[pos:]\n                    ])\n                    # Calculate insertion cost\n                    cost = (distance_matrix[temp_route[pos-1], fragment[0]] +\n                            distance_matrix[fragment[-1], temp_route[pos+len(fragment)]] -\n                            distance_matrix[temp_route[pos-1], temp_route[pos+len(fragment)]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Perform the insertion\n                new_solution[target_route_idx] = np.concatenate([\n                    target_route[:best_pos],\n                    fragment,\n                    target_route[best_pos:]\n                ])\n                inserted = True\n                break\n\n        if not inserted:\n            # Create new route if fragment couldn't be inserted\n            new_solution.append(np.concatenate([[0], fragment, [0]]))\n            # Remove empty route if created\n            if len(new_route) == 2:\n                new_solution = [r for r in new_solution if len(r) > 2]\n\n    # Perform capacity-aware swaps between routes\n    for _ in range(2):  # Limit number of swaps\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find customers in each route\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n\n        if len(customers1) == 0 or len(customers2) == 0:\n            continue\n\n        # Randomly select customers to swap\n        c1 = random.choice(customers1)\n        c2 = random.choice(customers2)\n\n        # Calculate loads after swap\n        load1 = sum(demand[route1[1:-1]]) - demand[c1] + demand[c2]\n        load2 = sum(demand[route2[1:-1]]) - demand[c2] + demand[c1]\n\n        if load1 <= capacity and load2 <= capacity:\n            # Perform the swap\n            route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], [c1]), [c2], [0]])\n            route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], [c2]), [c1], [0]])\n\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.6636723954301442,
            4.274656146764755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Select a solution with high makespan or high total distance\n    max_makespan = max(obj[1] for _, obj in archive)\n    high_makespan_solutions = [sol for sol, obj in archive if obj[1] == max_makespan]\n    if high_makespan_solutions:\n        base_solution = random.choice(high_makespan_solutions).copy()\n    else:\n        max_distance = max(obj[0] for _, obj in archive)\n        high_distance_solutions = [sol for sol, obj in archive if obj[0] == max_distance]\n        base_solution = random.choice(high_distance_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route fragmentation + customer reinsertion with capacity-aware swaps\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to fragment\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n        fragment = route[start:end].copy()\n\n        # Remove fragment from route\n        new_route = np.concatenate([route[:start], route[end:]])\n        new_solution[route_idx] = new_route\n\n        # Try to reinsert fragment into another route or create a new one\n        inserted = False\n        for target_route_idx in range(len(new_solution)):\n            if target_route_idx == route_idx:\n                continue\n            target_route = new_solution[target_route_idx]\n            current_load = sum(demand[target_route[1:-1]])  # Exclude depot\n\n            # Check if fragment can fit in target route\n            if current_load + sum(demand[fragment]) <= capacity:\n                # Find best insertion position in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    # Insert fragment at position pos\n                    temp_route = np.concatenate([\n                        target_route[:pos],\n                        fragment,\n                        target_route[pos:]\n                    ])\n                    # Calculate insertion cost\n                    cost = (distance_matrix[temp_route[pos-1], fragment[0]] +\n                            distance_matrix[fragment[-1], temp_route[pos+len(fragment)]] -\n                            distance_matrix[temp_route[pos-1], temp_route[pos+len(fragment)]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Perform the insertion\n                new_solution[target_route_idx] = np.concatenate([\n                    target_route[:best_pos],\n                    fragment,\n                    target_route[best_pos:]\n                ])\n                inserted = True\n                break\n\n        if not inserted:\n            # Create new route if fragment couldn't be inserted\n            new_solution.append(np.concatenate([[0], fragment, [0]]))\n            # Remove empty route if created\n            if len(new_route) == 2:\n                new_solution = [r for r in new_solution if len(r) > 2]\n\n    # Perform capacity-aware swaps between routes\n    for _ in range(2):  # Limit number of swaps\n        # Select two different routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find customers in each route\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n\n        if len(customers1) == 0 or len(customers2) == 0:\n            continue\n\n        # Randomly select customers to swap\n        c1 = random.choice(customers1)\n        c2 = random.choice(customers2)\n\n        # Calculate loads after swap\n        load1 = sum(demand[route1[1:-1]]) - demand[c1] + demand[c2]\n        load2 = sum(demand[route2[1:-1]]) - demand[c2] + demand[c1]\n\n        if load1 <= capacity and load2 <= capacity:\n            # Perform the swap\n            route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], [c1]), [c2], [0]])\n            route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], [c2]), [c1], [0]])\n\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with demand-aware route splitting and merging to balance distance and makespan objectives, while ensuring capacity constraints are preserved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_idx = random.randint(0, min(3, len(archive_sorted)-1))  # Randomly select among top 4 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route segment swap between two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select non-depot segments from both routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Split routes at random points\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints for swapped segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n            total_demand1 = np.sum(demand[segment1])\n            total_demand2 = np.sum(demand[segment2])\n\n            if total_demand1 <= capacity and total_demand2 <= capacity:\n                # Perform swap\n                new_route1 = np.concatenate([route1[:split1], segment2, route1[-1:]])\n                new_route2 = np.concatenate([route2[:split2], segment1, route2[-1:]])\n\n                # Replace routes if valid\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Step 2: Demand-aware route splitting if any route exceeds capacity\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                cumulative_demand = np.cumsum(demand[route[1:-1]])\n                if np.any(cumulative_demand > capacity):\n                    # Find split point\n                    split_point = np.argmax(cumulative_demand > capacity) + 1  # +1 for route index\n                    # Create new route with the split segment\n                    new_route = np.concatenate([route[:split_point+1], [0]])\n                    new_solution[i] = np.concatenate([route[:split_point+1], [0]])\n                    new_solution.append(np.concatenate([[0], route[split_point+1:], [0]]))\n\n    # Step 3: Route merging if possible\n    if len(new_solution) > 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible\n        if (len(route1) > 2 and len(route2) > 2 and\n            np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.577531370832542,
            1.5157038867473602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan, then distance\n    selected_idx = random.randint(0, min(3, len(archive_sorted)-1))  # Randomly select among top 4 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route segment swap between two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select non-depot segments from both routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Split routes at random points\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints for swapped segments\n            segment1 = route1[split1:-1]\n            segment2 = route2[split2:-1]\n            total_demand1 = np.sum(demand[segment1])\n            total_demand2 = np.sum(demand[segment2])\n\n            if total_demand1 <= capacity and total_demand2 <= capacity:\n                # Perform swap\n                new_route1 = np.concatenate([route1[:split1], segment2, route1[-1:]])\n                new_route2 = np.concatenate([route2[:split2], segment1, route2[-1:]])\n\n                # Replace routes if valid\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Step 2: Demand-aware route splitting if any route exceeds capacity\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                cumulative_demand = np.cumsum(demand[route[1:-1]])\n                if np.any(cumulative_demand > capacity):\n                    # Find split point\n                    split_point = np.argmax(cumulative_demand > capacity) + 1  # +1 for route index\n                    # Create new route with the split segment\n                    new_route = np.concatenate([route[:split_point+1], [0]])\n                    new_solution[i] = np.concatenate([route[:split_point+1], [0]])\n                    new_solution.append(np.concatenate([[0], route[split_point+1:], [0]]))\n\n    # Step 3: Route merging if possible\n    if len(new_solution) > 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible\n        if (len(route1) > 2 and len(route2) > 2 and\n            np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion with capacity-aware swaps, and a novel \"demand-balanced\" route splitting to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = random.choice(archive[:max(1, len(archive) // 4)])[0]  # Pick from top 25%\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route merging with demand feasibility check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    # Step 2: Customer reinsertion with capacity-aware swaps\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Remove a random customer and reinsert elsewhere\n        idx = random.randint(1, len(route) - 2)\n        customer = route[idx]\n        route = np.delete(route, idx)\n        # Find feasible insertion points in other routes\n        for other_route in new_solution:\n            if other_route is route:\n                continue\n            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                for pos in range(1, len(other_route)):\n                    if sum(demand[other_route[1:pos]]) + demand[customer] <= capacity:\n                        other_route = np.insert(other_route, pos, customer)\n                        break\n\n    # Step 3: Demand-balanced route splitting\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Split route into two balanced parts\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Only split if demand is high\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > total_demand / 2:\n                    split_pos = i\n                    break\n            new_route = np.concatenate([[0], route[split_pos:-1], [0]])\n            route = np.concatenate([[0], route[1:split_pos], [0]])\n            new_solution.append(new_route)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.813771140054838,
            4.899741172790527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = random.choice(archive[:max(1, len(archive) // 4)])[0]  # Pick from top 25%\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route merging with demand feasibility check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    # Step 2: Customer reinsertion with capacity-aware swaps\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Remove a random customer and reinsert elsewhere\n        idx = random.randint(1, len(route) - 2)\n        customer = route[idx]\n        route = np.delete(route, idx)\n        # Find feasible insertion points in other routes\n        for other_route in new_solution:\n            if other_route is route:\n                continue\n            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                for pos in range(1, len(other_route)):\n                    if sum(demand[other_route[1:pos]]) + demand[customer] <= capacity:\n                        other_route = np.insert(other_route, pos, customer)\n                        break\n\n    # Step 3: Demand-balanced route splitting\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Split route into two balanced parts\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Only split if demand is high\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > total_demand / 2:\n                    split_pos = i\n                    break\n            new_route = np.concatenate([[0], route[split_pos:-1], [0]])\n            route = np.concatenate([[0], route[1:split_pos], [0]])\n            new_solution.append(new_route)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of its normalized objective values, then applies a hybrid local search operator that combines route merging, customer reinsertion with capacity checks, and a novel \"route reshaping\" step to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging with demand feasibility check\n    if len(new_solution) > 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if i < j:\n            new_solution.pop(j)\n            new_solution.pop(i)\n        else:\n            new_solution.pop(i)\n            new_solution.pop(j)\n\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[node] for node in merged_route)\n        if total_demand <= capacity:\n            new_solution.append(merged_route)\n        else:\n            new_solution.insert(i, route1)\n            new_solution.insert(j, route2)\n\n    # Step 2: Customer reinsertion with capacity checks\n    for route in new_solution:\n        if len(route) > 3:  # Skip if route is too short\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Remove the customer\n            route = np.delete(route, customer_idx)\n\n            # Try to reinsert at a different position in the same route\n            best_pos = -1\n            min_increase = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                total_demand = sum(demand[node] for node in new_route)\n                if total_demand <= capacity:\n                    increase = distance_matrix[new_route[pos-1]][customer] + distance_matrix[customer][new_route[pos+1]] - distance_matrix[new_route[pos-1]][new_route[pos+1]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                route = np.insert(route, best_pos, customer)\n\n    # Step 3: Route reshaping (novel operator)\n    for route in new_solution:\n        if len(route) > 4:\n            # Select a random segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check feasibility\n            total_demand = sum(demand[node] for node in new_route)\n            if total_demand <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5515242393944934,
            10.92252516746521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging with demand feasibility check\n    if len(new_solution) > 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if i < j:\n            new_solution.pop(j)\n            new_solution.pop(i)\n        else:\n            new_solution.pop(i)\n            new_solution.pop(j)\n\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[node] for node in merged_route)\n        if total_demand <= capacity:\n            new_solution.append(merged_route)\n        else:\n            new_solution.insert(i, route1)\n            new_solution.insert(j, route2)\n\n    # Step 2: Customer reinsertion with capacity checks\n    for route in new_solution:\n        if len(route) > 3:  # Skip if route is too short\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Remove the customer\n            route = np.delete(route, customer_idx)\n\n            # Try to reinsert at a different position in the same route\n            best_pos = -1\n            min_increase = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                total_demand = sum(demand[node] for node in new_route)\n                if total_demand <= capacity:\n                    increase = distance_matrix[new_route[pos-1]][customer] + distance_matrix[customer][new_route[pos+1]] - distance_matrix[new_route[pos-1]][new_route[pos+1]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                route = np.insert(route, best_pos, customer)\n\n    # Step 3: Route reshaping (novel operator)\n    for route in new_solution:\n        if len(route) > 4:\n            # Select a random segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check feasibility\n            total_demand = sum(demand[node] for node in new_route)\n            if total_demand <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_solutions = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan (descending)\n    selected_solution = candidate_solutions[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Split the route at the point where the cumulative demand exceeds capacity\n        split_points = []\n        current_load = 0\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load > capacity:\n                split_points.append(i)\n                current_load = demand[route[i]]\n\n        # Split the route into smaller segments\n        if not split_points:\n            new_solution.append(route.copy())\n        else:\n            start = 0\n            for point in split_points:\n                new_route = np.concatenate(([0], route[start:point], [0]))\n                new_solution.append(new_route)\n                start = point\n            new_route = np.concatenate(([0], route[start:], [0]))\n            new_solution.append(new_route)\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Find a customer in route_i that can be moved to route_j without violating capacity\n            for k in range(1, len(route_i) - 1):\n                customer = route_i[k]\n                if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Temporarily remove the customer from route_i\n                    temp_route_i = np.concatenate((route_i[:k], route_i[k+1:]))\n                    # Add the customer to route_j\n                    temp_route_j = np.concatenate((route_j[:-1], [customer], [0]))\n                    # Check if the new routes are feasible\n                    if np.sum(demand[temp_route_i[1:-1]]) <= capacity and np.sum(demand[temp_route_j[1:-1]]) <= capacity:\n                        new_solution[i] = temp_route_i\n                        new_solution[j] = temp_route_j\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8143572056446621,
            8.321054637432098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_solutions = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan (descending)\n    selected_solution = candidate_solutions[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Split the route at the point where the cumulative demand exceeds capacity\n        split_points = []\n        current_load = 0\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load > capacity:\n                split_points.append(i)\n                current_load = demand[route[i]]\n\n        # Split the route into smaller segments\n        if not split_points:\n            new_solution.append(route.copy())\n        else:\n            start = 0\n            for point in split_points:\n                new_route = np.concatenate(([0], route[start:point], [0]))\n                new_solution.append(new_route)\n                start = point\n            new_route = np.concatenate(([0], route[start:], [0]))\n            new_solution.append(new_route)\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Find a customer in route_i that can be moved to route_j without violating capacity\n            for k in range(1, len(route_i) - 1):\n                customer = route_i[k]\n                if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Temporarily remove the customer from route_i\n                    temp_route_i = np.concatenate((route_i[:k], route_i[k+1:]))\n                    # Add the customer to route_j\n                    temp_route_j = np.concatenate((route_j[:-1], [customer], [0]))\n                    # Check if the new routes are feasible\n                    if np.sum(demand[temp_route_i[1:-1]]) <= capacity and np.sum(demand[temp_route_j[1:-1]]) <= capacity:\n                        new_solution[i] = temp_route_i\n                        new_solution[j] = temp_route_j\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel hybrid local search operator combines route fragmentation and merging with demand-aware customer reinsertion, prioritizing high-demand customers to balance travel distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_indices = [i for i, (_, (_, makespan)) in enumerate(archive) if makespan > np.median([m for _, (_, m) in archive])]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation and merging with demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 3:  # Ensure fragmentation is possible\n            # Split the route at a random position\n            split_pos = random.randint(1, len(frag_route) - 2)\n            new_route1 = frag_route[:split_pos + 1]\n            new_route2 = frag_route[split_pos:]\n\n            # Replace the original route with the two new routes\n            new_solution[frag_route_idx] = new_route1\n            new_solution.insert(frag_route_idx + 1, new_route2)\n\n            # Try to merge routes if possible\n            for i in range(len(new_solution) - 1):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    # Demand-aware reinsertion of high-demand customers\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unserved = list(all_customers - served_customers)\n\n    if unserved:\n        # Sort unserved customers by demand (descending)\n        unserved.sort(key=lambda x: -demand[x])\n\n        for customer in unserved:\n            best_route_idx = -1\n            best_pos = -1\n            best_cost_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Calculate cost increase for inserting customer at position pos\n                    prev_node = route[pos - 1]\n                    next_node = route[pos]\n                    cost_increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost_increase < best_cost_increase:\n                        best_cost_increase = cost_increase\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                # Insert customer into the best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.6828431165194964,
            8.085648387670517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_indices = [i for i, (_, (_, makespan)) in enumerate(archive) if makespan > np.median([m for _, (_, m) in archive])]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route fragmentation and merging with demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select a route to fragment\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 3:  # Ensure fragmentation is possible\n            # Split the route at a random position\n            split_pos = random.randint(1, len(frag_route) - 2)\n            new_route1 = frag_route[:split_pos + 1]\n            new_route2 = frag_route[split_pos:]\n\n            # Replace the original route with the two new routes\n            new_solution[frag_route_idx] = new_route1\n            new_solution.insert(frag_route_idx + 1, new_route2)\n\n            # Try to merge routes if possible\n            for i in range(len(new_solution) - 1):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        del new_solution[j]\n                        break\n\n    # Demand-aware reinsertion of high-demand customers\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unserved = list(all_customers - served_customers)\n\n    if unserved:\n        # Sort unserved customers by demand (descending)\n        unserved.sort(key=lambda x: -demand[x])\n\n        for customer in unserved:\n            best_route_idx = -1\n            best_pos = -1\n            best_cost_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Calculate cost increase for inserting customer at position pos\n                    prev_node = route[pos - 1]\n                    next_node = route[pos]\n                    cost_increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost_increase < best_cost_increase:\n                        best_cost_increase = cost_increase\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                # Insert customer into the best position\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + capacity-aware edge swaps\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route splitting - Split long routes into two\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route has enough customers\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Customer reallocation - Move customers between routes\n        for _ in range(3):\n            if len(new_solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select a random customer from route1 and try to insert into route2\n            customer_pos = random.randint(1, len(route1) - 2)\n            customer = route1[customer_pos]\n\n            # Find insertion point in route2 that minimizes additional distance\n            min_increase = float('inf')\n            best_pos = -1\n            for pos in range(1, len(route2)):\n                prev_node = route2[pos - 1]\n                next_node = route2[pos]\n                increase = (distance_matrix[prev_node][customer] +\n                          distance_matrix[customer][next_node] -\n                          distance_matrix[prev_node][next_node])\n                if increase < min_increase and (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity):\n                    min_increase = increase\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos + 1:]])\n                new_solution[route1_idx] = new_route1\n                break\n\n        # Step 3: Capacity-aware edge swaps - Swap edges between routes if beneficial\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select random edges from each route\n            edge1_pos = random.randint(1, len(route1) - 2)\n            edge2_pos = random.randint(1, len(route2) - 2)\n\n            # Swap edges and check feasibility\n            new_route1 = np.concatenate([route1[:edge1_pos], route2[edge2_pos:edge2_pos + 1], route1[edge1_pos + 1:]])\n            new_route2 = np.concatenate([route2[:edge2_pos], route1[edge1_pos:edge1_pos + 1], route2[edge2_pos + 1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9531982315634654,
            3.0045081675052643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + capacity-aware edge swaps\n    for _ in range(5):  # Number of iterations\n        # Step 1: Route splitting - Split long routes into two\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route has enough customers\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Customer reallocation - Move customers between routes\n        for _ in range(3):\n            if len(new_solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select a random customer from route1 and try to insert into route2\n            customer_pos = random.randint(1, len(route1) - 2)\n            customer = route1[customer_pos]\n\n            # Find insertion point in route2 that minimizes additional distance\n            min_increase = float('inf')\n            best_pos = -1\n            for pos in range(1, len(route2)):\n                prev_node = route2[pos - 1]\n                next_node = route2[pos]\n                increase = (distance_matrix[prev_node][customer] +\n                          distance_matrix[customer][next_node] -\n                          distance_matrix[prev_node][next_node])\n                if increase < min_increase and (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity):\n                    min_increase = increase\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos + 1:]])\n                new_solution[route1_idx] = new_route1\n                break\n\n        # Step 3: Capacity-aware edge swaps - Swap edges between routes if beneficial\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select random edges from each route\n            edge1_pos = random.randint(1, len(route1) - 2)\n            edge2_pos = random.randint(1, len(route2) - 2)\n\n            # Swap edges and check feasibility\n            new_route1 = np.concatenate([route1[:edge1_pos], route2[edge2_pos:edge2_pos + 1], route1[edge1_pos + 1:]])\n            new_route2 = np.concatenate([route2[:edge2_pos], route1[edge1_pos:edge1_pos + 1], route2[edge2_pos + 1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route segmentation and demand-aware customer reallocation to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route segmentation + demand-aware reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Segment the route into parts with balanced demand\n        total_demand = sum(demand[route[1:-1]])\n        segment_size = max(2, int(np.ceil(total_demand / capacity)))\n        segment_length = max(2, len(route) // segment_size)\n        segments = [route[i:i+segment_length] for i in range(1, len(route)-1, segment_length-1)]\n        segments = [np.concatenate([[0], seg, [0]]) for seg in segments]\n\n        # Reallocate customers between segments to balance demand and distance\n        for i in range(len(segments)-1):\n            seg1, seg2 = segments[i], segments[i+1]\n            seg1_demand = sum(demand[seg1[1:-1]])\n            seg2_demand = sum(demand[seg2[1:-1]])\n\n            # Find customers to swap between segments\n            for j in range(1, len(seg1)-1):\n                for k in range(1, len(seg2)-1):\n                    customer1, customer2 = seg1[j], seg2[k]\n                    if seg1_demand - demand[customer1] + demand[customer2] <= capacity and \\\n                       seg2_demand - demand[customer2] + demand[customer1] <= capacity:\n                        # Swap customers if it reduces total distance\n                        new_dist1 = distance_matrix[seg1[j-1], customer2] + distance_matrix[customer2, seg1[j+1]] + \\\n                                    distance_matrix[seg2[k-1], customer1] + distance_matrix[customer1, seg2[k+1]]\n                        old_dist1 = distance_matrix[seg1[j-1], customer1] + distance_matrix[customer1, seg1[j+1]] + \\\n                                    distance_matrix[seg2[k-1], customer2] + distance_matrix[customer2, seg2[k+1]]\n                        if new_dist1 < old_dist1:\n                            seg1[j], seg2[k] = seg2[k], seg1[j]\n                            break\n\n        # Rebuild segments into new routes\n        for seg in segments:\n            if len(seg) > 2:  # Only add non-empty routes\n                new_solution.append(seg)\n\n    # Ensure all customers are covered\n    covered = set()\n    for route in new_solution:\n        covered.update(route[1:-1])\n    missing = set(range(1, len(coords))) - covered\n    if missing:\n        # Add missing customers to the shortest route if feasible\n        for customer in missing:\n            best_route = None\n            best_increase = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find insertion position that minimizes distance increase\n                    for j in range(1, len(route)):\n                        increase = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route = (i, j)\n            if best_route:\n                route_idx, pos = best_route\n                new_solution[route_idx] = np.insert(new_solution[route_idx], pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.7879761994806156,
            6.88545224070549
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route segmentation + demand-aware reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Segment the route into parts with balanced demand\n        total_demand = sum(demand[route[1:-1]])\n        segment_size = max(2, int(np.ceil(total_demand / capacity)))\n        segment_length = max(2, len(route) // segment_size)\n        segments = [route[i:i+segment_length] for i in range(1, len(route)-1, segment_length-1)]\n        segments = [np.concatenate([[0], seg, [0]]) for seg in segments]\n\n        # Reallocate customers between segments to balance demand and distance\n        for i in range(len(segments)-1):\n            seg1, seg2 = segments[i], segments[i+1]\n            seg1_demand = sum(demand[seg1[1:-1]])\n            seg2_demand = sum(demand[seg2[1:-1]])\n\n            # Find customers to swap between segments\n            for j in range(1, len(seg1)-1):\n                for k in range(1, len(seg2)-1):\n                    customer1, customer2 = seg1[j], seg2[k]\n                    if seg1_demand - demand[customer1] + demand[customer2] <= capacity and \\\n                       seg2_demand - demand[customer2] + demand[customer1] <= capacity:\n                        # Swap customers if it reduces total distance\n                        new_dist1 = distance_matrix[seg1[j-1], customer2] + distance_matrix[customer2, seg1[j+1]] + \\\n                                    distance_matrix[seg2[k-1], customer1] + distance_matrix[customer1, seg2[k+1]]\n                        old_dist1 = distance_matrix[seg1[j-1], customer1] + distance_matrix[customer1, seg1[j+1]] + \\\n                                    distance_matrix[seg2[k-1], customer2] + distance_matrix[customer2, seg2[k+1]]\n                        if new_dist1 < old_dist1:\n                            seg1[j], seg2[k] = seg2[k], seg1[j]\n                            break\n\n        # Rebuild segments into new routes\n        for seg in segments:\n            if len(seg) > 2:  # Only add non-empty routes\n                new_solution.append(seg)\n\n    # Ensure all customers are covered\n    covered = set()\n    for route in new_solution:\n        covered.update(route[1:-1])\n    missing = set(range(1, len(coords))) - covered\n    if missing:\n        # Add missing customers to the shortest route if feasible\n        for customer in missing:\n            best_route = None\n            best_increase = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Find insertion position that minimizes distance increase\n                    for j in range(1, len(route)):\n                        increase = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route = (i, j)\n            if best_route:\n                route_idx, pos = best_route\n                new_solution[route_idx] = np.insert(new_solution[route_idx], pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with the highest objective diversity (to avoid local optima) and applies a hybrid local search operator combining route segment swapping and insertion heuristics, while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]) if x[1][0] * x[1][1] != 0 else float('inf'))\n    selected_solution = archive_sorted[min(1, len(archive_sorted) // 2)][0].copy()\n\n    # Hybrid local search: route segment swap + insertion heuristic\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes\n    route_indices = random.sample(range(n_routes), 2)\n    route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n    # Extract segments from both routes\n    segment1_start = random.randint(1, len(route1) - 2)\n    segment1_end = random.randint(segment1_start, len(route1) - 2)\n    segment1 = route1[segment1_start:segment1_end + 1]\n\n    segment2_start = random.randint(1, len(route2) - 2)\n    segment2_end = random.randint(segment2_start, len(route2) - 2)\n    segment2 = route2[segment2_start:segment2_end + 1]\n\n    # Check capacity constraints for swapping\n    def check_capacity(route, segment):\n        total_demand = sum(demand[node] for node in route) - sum(demand[node] for node in segment)\n        return total_demand <= capacity\n\n    if check_capacity(route1, segment1) and check_capacity(route2, segment2):\n        # Perform segment swap\n        new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n        new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n        # Update solution\n        new_solution[route_indices[0]] = new_route1\n        new_solution[route_indices[1]] = new_route2\n\n        # Optional: Apply insertion heuristic to improve the new routes\n        for i in range(2):\n            route = new_solution[route_indices[i]]\n            for node in route[1:-1]:\n                # Remove node from its current position\n                mask = route != node\n                route_without_node = route[mask]\n\n                # Find best insertion position\n                min_cost_increase = float('inf')\n                best_pos = 1\n                for pos in range(1, len(route_without_node)):\n                    new_route = np.concatenate([route_without_node[:pos], [node], route_without_node[pos:]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        cost_increase = distance_matrix[new_route[pos-1], node] + distance_matrix[node, new_route[pos]] - distance_matrix[new_route[pos-1], new_route[pos]]\n                        if cost_increase < min_cost_increase:\n                            min_cost_increase = cost_increase\n                            best_pos = pos\n\n                # Insert node at best position if feasible\n                if min_cost_increase < float('inf'):\n                    new_route = np.concatenate([route_without_node[:best_pos], [node], route_without_node[best_pos:]])\n                    new_solution[route_indices[i]] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6177451075971362,
            6.927955985069275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]) if x[1][0] * x[1][1] != 0 else float('inf'))\n    selected_solution = archive_sorted[min(1, len(archive_sorted) // 2)][0].copy()\n\n    # Hybrid local search: route segment swap + insertion heuristic\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Randomly select two routes\n    route_indices = random.sample(range(n_routes), 2)\n    route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n    # Extract segments from both routes\n    segment1_start = random.randint(1, len(route1) - 2)\n    segment1_end = random.randint(segment1_start, len(route1) - 2)\n    segment1 = route1[segment1_start:segment1_end + 1]\n\n    segment2_start = random.randint(1, len(route2) - 2)\n    segment2_end = random.randint(segment2_start, len(route2) - 2)\n    segment2 = route2[segment2_start:segment2_end + 1]\n\n    # Check capacity constraints for swapping\n    def check_capacity(route, segment):\n        total_demand = sum(demand[node] for node in route) - sum(demand[node] for node in segment)\n        return total_demand <= capacity\n\n    if check_capacity(route1, segment1) and check_capacity(route2, segment2):\n        # Perform segment swap\n        new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n        new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n        # Update solution\n        new_solution[route_indices[0]] = new_route1\n        new_solution[route_indices[1]] = new_route2\n\n        # Optional: Apply insertion heuristic to improve the new routes\n        for i in range(2):\n            route = new_solution[route_indices[i]]\n            for node in route[1:-1]:\n                # Remove node from its current position\n                mask = route != node\n                route_without_node = route[mask]\n\n                # Find best insertion position\n                min_cost_increase = float('inf')\n                best_pos = 1\n                for pos in range(1, len(route_without_node)):\n                    new_route = np.concatenate([route_without_node[:pos], [node], route_without_node[pos:]])\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        cost_increase = distance_matrix[new_route[pos-1], node] + distance_matrix[node, new_route[pos]] - distance_matrix[new_route[pos-1], new_route[pos]]\n                        if cost_increase < min_cost_increase:\n                            min_cost_increase = cost_increase\n                            best_pos = pos\n\n                # Insert node at best position if feasible\n                if min_cost_increase < float('inf'):\n                    new_route = np.concatenate([route_without_node[:best_pos], [node], route_without_node[best_pos:]])\n                    new_solution[route_indices[i]] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The algorithm selects a high-performing solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route perturbation with capacity-aware customer reinsertion to generate a high-quality neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for total distance and makespan\n    selected_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route perturbation + capacity-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select a route to perturb\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Remove a random segment of the route (excluding depot)\n        if len(route) > 3:  # Ensure we don't remove everything\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            removed_segment = route[start:end]\n            route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = route\n\n            # Reinsert removed segment into a different route or create a new route\n            for customer in removed_segment:\n                # Find the best insertion point in any route (including creating a new route)\n                best_route_idx = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for i, candidate_route in enumerate(new_solution):\n                    for pos in range(1, len(candidate_route)):\n                        # Check capacity constraint\n                        if np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[candidate_route[pos-1]][customer] +\n                                   distance_matrix[customer][candidate_route[pos]] -\n                                   distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = i\n                                best_pos = pos\n\n                # If no valid insertion found, create a new route\n                if best_route_idx == -1:\n                    new_route = np.array([0, customer, 0])\n                    new_solution.append(new_route)\n                else:\n                    # Insert into the best route\n                    new_route = np.concatenate([\n                        new_solution[best_route_idx][:best_pos],\n                        [customer],\n                        new_solution[best_route_idx][best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.3968955667428785,
            9.777655810117722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for total distance and makespan\n    selected_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route perturbation + capacity-aware reinsertion\n    if len(new_solution) > 1:\n        # Randomly select a route to perturb\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Remove a random segment of the route (excluding depot)\n        if len(route) > 3:  # Ensure we don't remove everything\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            removed_segment = route[start:end]\n            route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = route\n\n            # Reinsert removed segment into a different route or create a new route\n            for customer in removed_segment:\n                # Find the best insertion point in any route (including creating a new route)\n                best_route_idx = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for i, candidate_route in enumerate(new_solution):\n                    for pos in range(1, len(candidate_route)):\n                        # Check capacity constraint\n                        if np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[candidate_route[pos-1]][customer] +\n                                   distance_matrix[customer][candidate_route[pos]] -\n                                   distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = i\n                                best_pos = pos\n\n                # If no valid insertion found, create a new route\n                if best_route_idx == -1:\n                    new_route = np.array([0, customer, 0])\n                    new_solution.append(new_route)\n                else:\n                    # Insert into the best route\n                    new_route = np.concatenate([\n                        new_solution[best_route_idx][:best_pos],\n                        [customer],\n                        new_solution[best_route_idx][best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: split and merge with capacity-aware swaps\n    if len(route) > 4:  # Ensure the route is long enough to split\n        # Split the route into two parts\n        split_pos = np.random.randint(2, len(route) - 2)\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for each part\n        def is_valid(segment):\n            return np.sum(demand[segment[1:-1]]) <= capacity\n\n        if is_valid(part1) and is_valid(part2):\n            # Merge parts into two new routes\n            new_route1 = part1\n            new_route2 = part2\n\n            # Insert the new routes into the solution\n            selected_solution[route_idx] = new_route1\n            if len(new_route2) > 2:  # Only add if it has customers\n                selected_solution.append(new_route2)\n\n    # Apply capacity-aware swaps between routes\n    if len(selected_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(selected_solution), 2, replace=False)\n        route_i = selected_solution[i].copy()\n        route_j = selected_solution[j].copy()\n\n        # Find a swap between customers in the two routes\n        for _ in range(10):  # Try up to 10 times\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Randomly select customers from each route (excluding depots)\n                cust_i = np.random.randint(1, len(route_i) - 1)\n                cust_j = np.random.randint(1, len(route_j) - 1)\n\n                # Swap the customers\n                new_route_i = route_i.copy()\n                new_route_j = route_j.copy()\n                new_route_i[cust_i], new_route_j[cust_j] = new_route_j[cust_j], new_route_i[cust_i]\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route_i[1:-1]]) <= capacity and\n                    np.sum(demand[new_route_j[1:-1]]) <= capacity):\n                    selected_solution[i] = new_route_i\n                    selected_solution[j] = new_route_j\n                    break\n\n    return selected_solution\n\n",
        "score": [
            -0.7706476624157159,
            0.47251763939857483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: split and merge with capacity-aware swaps\n    if len(route) > 4:  # Ensure the route is long enough to split\n        # Split the route into two parts\n        split_pos = np.random.randint(2, len(route) - 2)\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for each part\n        def is_valid(segment):\n            return np.sum(demand[segment[1:-1]]) <= capacity\n\n        if is_valid(part1) and is_valid(part2):\n            # Merge parts into two new routes\n            new_route1 = part1\n            new_route2 = part2\n\n            # Insert the new routes into the solution\n            selected_solution[route_idx] = new_route1\n            if len(new_route2) > 2:  # Only add if it has customers\n                selected_solution.append(new_route2)\n\n    # Apply capacity-aware swaps between routes\n    if len(selected_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(selected_solution), 2, replace=False)\n        route_i = selected_solution[i].copy()\n        route_j = selected_solution[j].copy()\n\n        # Find a swap between customers in the two routes\n        for _ in range(10):  # Try up to 10 times\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Randomly select customers from each route (excluding depots)\n                cust_i = np.random.randint(1, len(route_i) - 1)\n                cust_j = np.random.randint(1, len(route_j) - 1)\n\n                # Swap the customers\n                new_route_i = route_i.copy()\n                new_route_j = route_j.copy()\n                new_route_i[cust_i], new_route_j[cust_j] = new_route_j[cust_j], new_route_i[cust_i]\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route_i[1:-1]]) <= capacity and\n                    np.sum(demand[new_route_j[1:-1]]) <= capacity):\n                    selected_solution[i] = new_route_i\n                    selected_solution[j] = new_route_j\n                    break\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The algorithm selects a promising solution from the archive using a probabilistic approach based on objective values, then applies a hybrid local search combining route segmentation, inter-route insertion, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segmentation, inter-route insertion, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route segmentation - split a long route into two\n        long_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Ensure it can be split\n            split_pos = random.randint(1, len(long_route) - 2)\n            route1 = np.concatenate([long_route[:split_pos + 1], [0]])\n            route2 = np.concatenate([[0], long_route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = route1\n                new_solution.append(route2)\n\n    # Step 2: Inter-route insertion - move a segment between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3:  # Ensure we can move a segment\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end + 1]\n            segment_demand = sum(demand[segment])\n\n            # Check if insertion is feasible in route2\n            if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                new_route1 = np.concatenate([route1[:start], route1[end + 1:]])\n                new_route2 = np.concatenate([route2[:-1], segment, [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Capacity-aware swap - swap nodes between routes if it improves capacity utilization\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            node1 = random.choice(route1[1:-1])\n            node2 = random.choice(route2[1:-1])\n\n            # Calculate new demands\n            new_route1_demand = sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n            new_route2_demand = sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n\n            # Check capacity constraints\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform swap\n                route1[route1 == node1] = node2\n                route2[route2 == node2] = node1\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7478652740698545,
            1.8336467444896698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route segmentation, inter-route insertion, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route segmentation - split a long route into two\n        long_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Ensure it can be split\n            split_pos = random.randint(1, len(long_route) - 2)\n            route1 = np.concatenate([long_route[:split_pos + 1], [0]])\n            route2 = np.concatenate([[0], long_route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = route1\n                new_solution.append(route2)\n\n    # Step 2: Inter-route insertion - move a segment between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3:  # Ensure we can move a segment\n            start = random.randint(1, len(route1) - 2)\n            end = random.randint(start, len(route1) - 2)\n            segment = route1[start:end + 1]\n            segment_demand = sum(demand[segment])\n\n            # Check if insertion is feasible in route2\n            if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                new_route1 = np.concatenate([route1[:start], route1[end + 1:]])\n                new_route2 = np.concatenate([route2[:-1], segment, [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Capacity-aware swap - swap nodes between routes if it improves capacity utilization\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            node1 = random.choice(route1[1:-1])\n            node2 = random.choice(route2[1:-1])\n\n            # Calculate new demands\n            new_route1_demand = sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n            new_route2_demand = sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n\n            # Check capacity constraints\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform swap\n                route1[route1 == node1] = node2\n                route2[route2 == node2] = node1\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = [(sol[1][0] + 0.5 * sol[1][1], idx) for idx, sol in enumerate(archive)]\n    selected_idx = min(weighted_scores, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search steps\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Merging - Try to merge two shortest routes if feasible\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argsort(route_lengths)[1]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[new_solution[shortest_route_idx][1:-1]]) + sum(demand[new_solution[second_shortest_route_idx][1:-1]])\n        if total_demand <= capacity:\n            merged_route = np.concatenate([new_solution[shortest_route_idx][:-1], new_solution[second_shortest_route_idx][1:]])\n            new_solution = [merged_route] + [r for i, r in enumerate(new_solution) if i not in {shortest_route_idx, second_shortest_route_idx}]\n\n    # Step 2: Customer Reallocation - Move a customer from the longest route to another route\n    if len(new_solution) > 1:\n        route_lengths = [sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        longest_route_idx = np.argmax(route_lengths)\n\n        # Find a customer to move\n        for i in range(1, len(new_solution[longest_route_idx])-1):\n            customer = new_solution[longest_route_idx][i]\n            # Try to insert into other routes\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == longest_route_idx:\n                    continue\n                # Find insertion position with minimal increase in distance\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(new_solution[target_route_idx])):\n                    prev_node = new_solution[target_route_idx][pos-1]\n                    next_node = new_solution[target_route_idx][pos]\n                    increase = (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Check capacity constraint\n                if sum(demand[new_solution[target_route_idx][1:-1]]) + demand[customer] <= capacity:\n                    # Perform insertion\n                    new_route = np.insert(new_solution[target_route_idx], best_pos, customer)\n                    new_solution[target_route_idx] = new_route\n                    new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                    break\n            else:\n                continue\n            break\n\n    # Step 3: Route Reshaping - Novel operator that reorders customers in a route using a greedy heuristic\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        customers = route[1:-1]\n        if len(customers) <= 1:\n            continue\n\n        # Shuffle customers and try to find a better order\n        shuffled = customers.copy()\n        np.random.shuffle(shuffled)\n        current_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n\n        # Try to insert each customer in the best position\n        improved = True\n        while improved:\n            improved = False\n            for i in range(len(shuffled)):\n                customer = shuffled[i]\n                # Remove customer from current position\n                temp_route = np.delete(shuffled, i)\n                # Find best insertion position\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(len(temp_route)+1):\n                    if pos == 0:\n                        prev_node = 0\n                        next_node = temp_route[pos] if pos < len(temp_route) else 0\n                    elif pos == len(temp_route):\n                        prev_node = temp_route[pos-1]\n                        next_node = 0\n                    else:\n                        prev_node = temp_route[pos-1]\n                        next_node = temp_route[pos]\n                    increase = (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Check if insertion improves the route\n                if min_increase < 0:\n                    improved = True\n                    shuffled = np.insert(temp_route, best_pos, customer)\n                    break\n\n        # Update route if improvement was found\n        if len(shuffled) > 0:\n            new_solution[route_idx] = np.concatenate([[0], shuffled, [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.4382518321693903,
            11.063221246004105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = [(sol[1][0] + 0.5 * sol[1][1], idx) for idx, sol in enumerate(archive)]\n    selected_idx = min(weighted_scores, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search steps\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Merging - Try to merge two shortest routes if feasible\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argsort(route_lengths)[1]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[new_solution[shortest_route_idx][1:-1]]) + sum(demand[new_solution[second_shortest_route_idx][1:-1]])\n        if total_demand <= capacity:\n            merged_route = np.concatenate([new_solution[shortest_route_idx][:-1], new_solution[second_shortest_route_idx][1:]])\n            new_solution = [merged_route] + [r for i, r in enumerate(new_solution) if i not in {shortest_route_idx, second_shortest_route_idx}]\n\n    # Step 2: Customer Reallocation - Move a customer from the longest route to another route\n    if len(new_solution) > 1:\n        route_lengths = [sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))]\n        longest_route_idx = np.argmax(route_lengths)\n\n        # Find a customer to move\n        for i in range(1, len(new_solution[longest_route_idx])-1):\n            customer = new_solution[longest_route_idx][i]\n            # Try to insert into other routes\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == longest_route_idx:\n                    continue\n                # Find insertion position with minimal increase in distance\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(new_solution[target_route_idx])):\n                    prev_node = new_solution[target_route_idx][pos-1]\n                    next_node = new_solution[target_route_idx][pos]\n                    increase = (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Check capacity constraint\n                if sum(demand[new_solution[target_route_idx][1:-1]]) + demand[customer] <= capacity:\n                    # Perform insertion\n                    new_route = np.insert(new_solution[target_route_idx], best_pos, customer)\n                    new_solution[target_route_idx] = new_route\n                    new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                    break\n            else:\n                continue\n            break\n\n    # Step 3: Route Reshaping - Novel operator that reorders customers in a route using a greedy heuristic\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        customers = route[1:-1]\n        if len(customers) <= 1:\n            continue\n\n        # Shuffle customers and try to find a better order\n        shuffled = customers.copy()\n        np.random.shuffle(shuffled)\n        current_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n\n        # Try to insert each customer in the best position\n        improved = True\n        while improved:\n            improved = False\n            for i in range(len(shuffled)):\n                customer = shuffled[i]\n                # Remove customer from current position\n                temp_route = np.delete(shuffled, i)\n                # Find best insertion position\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(len(temp_route)+1):\n                    if pos == 0:\n                        prev_node = 0\n                        next_node = temp_route[pos] if pos < len(temp_route) else 0\n                    elif pos == len(temp_route):\n                        prev_node = temp_route[pos-1]\n                        next_node = 0\n                    else:\n                        prev_node = temp_route[pos-1]\n                        next_node = temp_route[pos]\n                    increase = (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] -\n                                distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Check if insertion improves the route\n                if min_increase < 0:\n                    improved = True\n                    shuffled = np.insert(temp_route, best_pos, customer)\n                    break\n\n        # Update route if improvement was found\n        if len(shuffled) > 0:\n            new_solution[route_idx] = np.concatenate([[0], shuffled, [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The novel local search strategy combines route fragmentation and reinsertion with adaptive capacity-aware swaps to balance distance and makespan minimization while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        makespans = [obj[1] for _, obj in archive]\n        max_makespan = max(makespans)\n        weights = [max_makespan / m for m in makespans]\n        total_weight = sum(weights)\n        probs = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation (select a random route and split at a random point)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes to split (depot + 2+ customers)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 2: Adaptive capacity-aware swaps (between different routes)\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from each route (excluding depots)\n        if len(route1) > 2 and len(route2) > 2:\n            pos1 = random.randint(1, len(route1) - 2)\n            pos2 = random.randint(1, len(route2) - 2)\n\n            cust1 = route1[pos1]\n            cust2 = route2[pos2]\n\n            # Try swapping the customers\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            new_route1[pos1] = cust2\n            new_route2[pos2] = cust1\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Local 2-opt improvement (only if route length is reasonable)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two non-adjacent edges\n            n = len(route) - 1\n            a = random.randint(1, n - 3)\n            b = random.randint(a + 1, n - 2)\n\n            # Reverse the segment between a and b\n            new_route = route.copy()\n            new_route[a:b+1] = route[b:a-1:-1]\n\n            # Check capacity constraint (no change in demands)\n            new_solution[i] = new_route\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8517569339689607,
            0.5938320159912109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        makespans = [obj[1] for _, obj in archive]\n        max_makespan = max(makespans)\n        weights = [max_makespan / m for m in makespans]\n        total_weight = sum(weights)\n        probs = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation (select a random route and split at a random point)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes to split (depot + 2+ customers)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 2: Adaptive capacity-aware swaps (between different routes)\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random customer from each route (excluding depots)\n        if len(route1) > 2 and len(route2) > 2:\n            pos1 = random.randint(1, len(route1) - 2)\n            pos2 = random.randint(1, len(route2) - 2)\n\n            cust1 = route1[pos1]\n            cust2 = route2[pos2]\n\n            # Try swapping the customers\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            new_route1[pos1] = cust2\n            new_route2[pos2] = cust1\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Local 2-opt improvement (only if route length is reasonable)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two non-adjacent edges\n            n = len(route) - 1\n            a = random.randint(1, n - 3)\n            b = random.randint(a + 1, n - 2)\n\n            # Reverse the segment between a and b\n            new_route = route.copy()\n            new_route[a:b+1] = route[b:a-1:-1]\n\n            # Check capacity constraint (no change in demands)\n            new_solution[i] = new_route\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with shorter total distance and lower makespan, then applies a hybrid local search combining route splitting, demand-based reinsertion, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for total distance\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 1. Route splitting, 2. Demand-based reinsertion, 3. Capacity-aware swap\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Step 1: Route splitting\n        split_pos = np.random.randint(1, len(route) - 1)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    # Step 2: Demand-based reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find the customer with the smallest demand\n        customers = route[1:-1]\n        if len(customers) == 0:\n            continue\n        min_demand_idx = np.argmin(demand[customers])\n        node_to_move = customers[min_demand_idx]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            target_route = new_solution[j]\n            if np.sum(demand[target_route[1:-1]]) + demand[node_to_move] > capacity:\n                continue\n\n            # Find best insertion position\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(target_route)):\n                increase = (distance_matrix[target_route[pos-1], node_to_move] +\n                           distance_matrix[node_to_move, target_route[pos]] -\n                           distance_matrix[target_route[pos-1], target_route[pos]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Perform insertion\n            new_route = np.insert(target_route, best_pos, node_to_move)\n            new_solution[j] = new_route\n            new_solution[i] = np.delete(route, np.where(route == node_to_move)[0][0])\n            break\n\n    # Step 3: Capacity-aware swap\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find two customers to swap\n        customers = route[1:-1]\n        if len(customers) < 2:\n            continue\n\n        # Select two customers with demands that can be swapped\n        for a in range(len(customers)):\n            for b in range(a + 1, len(customers)):\n                if (demand[customers[a]] <= demand[customers[b]] and\n                    np.sum(demand[customers]) - demand[customers[a]] + demand[customers[b]] <= capacity):\n                    # Perform swap\n                    new_route = route.copy()\n                    pos_a = np.where(new_route == customers[a])[0][0]\n                    pos_b = np.where(new_route == customers[b])[0][0]\n                    new_route[pos_a], new_route[pos_b] = new_route[pos_b], new_route[pos_a]\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6887665161030552,
            7.40550634264946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Higher weight for total distance\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 1. Route splitting, 2. Demand-based reinsertion, 3. Capacity-aware swap\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Step 1: Route splitting\n        split_pos = np.random.randint(1, len(route) - 1)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = route[split_pos:]\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n            break\n\n    # Step 2: Demand-based reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find the customer with the smallest demand\n        customers = route[1:-1]\n        if len(customers) == 0:\n            continue\n        min_demand_idx = np.argmin(demand[customers])\n        node_to_move = customers[min_demand_idx]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            target_route = new_solution[j]\n            if np.sum(demand[target_route[1:-1]]) + demand[node_to_move] > capacity:\n                continue\n\n            # Find best insertion position\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(target_route)):\n                increase = (distance_matrix[target_route[pos-1], node_to_move] +\n                           distance_matrix[node_to_move, target_route[pos]] -\n                           distance_matrix[target_route[pos-1], target_route[pos]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n\n            # Perform insertion\n            new_route = np.insert(target_route, best_pos, node_to_move)\n            new_solution[j] = new_route\n            new_solution[i] = np.delete(route, np.where(route == node_to_move)[0][0])\n            break\n\n    # Step 3: Capacity-aware swap\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find two customers to swap\n        customers = route[1:-1]\n        if len(customers) < 2:\n            continue\n\n        # Select two customers with demands that can be swapped\n        for a in range(len(customers)):\n            for b in range(a + 1, len(customers)):\n                if (demand[customers[a]] <= demand[customers[b]] and\n                    np.sum(demand[customers]) - demand[customers[a]] + demand[customers[b]] <= capacity):\n                    # Perform swap\n                    new_route = route.copy()\n                    pos_a = np.where(new_route == customers[a])[0][0]\n                    pos_b = np.where(new_route == customers[b])[0][0]\n                    new_route[pos_a], new_route[pos_b] = new_route[pos_b], new_route[pos_a]\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted selection\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Relocate a random segment from this route to another route\n        if len(selected_route) > 3:  # Ensure there's a segment to move\n            # Select a random segment (excluding depot)\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            segment = selected_route[start:end]\n\n            # Remove segment from current route\n            new_route = np.concatenate([selected_route[:start], selected_route[end:]])\n            new_solution[route_idx] = new_route\n\n            # Find another route to insert the segment\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            target_route = new_solution[target_route_idx]\n\n            # Check capacity constraint\n            segment_demand = sum(demand[node] for node in segment)\n            current_demand = sum(demand[node] for node in target_route[:-1])  # Exclude depot\n\n            if current_demand + segment_demand <= capacity:\n                # Insert segment into target route (after depot)\n                new_target_route = np.concatenate([[target_route[0]], segment, target_route[1:]])\n                new_solution[target_route_idx] = new_target_route\n\n    # Apply capacity-aware swap heuristic\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two non-depot nodes\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            # Check if swapping them maintains capacity\n            if (sum(demand[node] for node in route[1:-1]) - demand[route[i]] + demand[route[j]]) <= capacity:\n                route[i], route[j] = route[j], route[i]\n\n    # Ensure all routes remain feasible\n    for route in new_solution:\n        if len(route) > 2 and route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route format\")\n\n    return new_solution\n\n",
        "score": [
            -0.7556996976650457,
            1.728491723537445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted selection\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Relocate a random segment from this route to another route\n        if len(selected_route) > 3:  # Ensure there's a segment to move\n            # Select a random segment (excluding depot)\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            segment = selected_route[start:end]\n\n            # Remove segment from current route\n            new_route = np.concatenate([selected_route[:start], selected_route[end:]])\n            new_solution[route_idx] = new_route\n\n            # Find another route to insert the segment\n            target_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            target_route = new_solution[target_route_idx]\n\n            # Check capacity constraint\n            segment_demand = sum(demand[node] for node in segment)\n            current_demand = sum(demand[node] for node in target_route[:-1])  # Exclude depot\n\n            if current_demand + segment_demand <= capacity:\n                # Insert segment into target route (after depot)\n                new_target_route = np.concatenate([[target_route[0]], segment, target_route[1:]])\n                new_solution[target_route_idx] = new_target_route\n\n    # Apply capacity-aware swap heuristic\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two non-depot nodes\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            # Check if swapping them maintains capacity\n            if (sum(demand[node] for node in route[1:-1]) - demand[route[i]] + demand[route[j]]) <= capacity:\n                route[i], route[j] = route[j], route[i]\n\n    # Ensure all routes remain feasible\n    for route in new_solution:\n        if len(route) > 2 and route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route format\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search operator that combines route swapping and partial reordering to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping and partial reordering\n    if len(new_solution) > 1:\n        # Randomly select two routes to swap segments\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try up to 10 times\n            # Choose random segments from each route (excluding depot)\n            seg1_start = random.randint(1, len(route1)-2)\n            seg1_end = random.randint(seg1_start, len(route1)-2)\n            seg2_start = random.randint(1, len(route2)-2)\n            seg2_end = random.randint(seg2_start, len(route2)-2)\n\n            # Check capacity constraints for swapped segments\n            seg1_demand = np.sum(demand[route1[seg1_start:seg1_end+1]])\n            seg2_demand = np.sum(demand[route2[seg2_start:seg2_end+1]])\n\n            if seg1_demand + np.sum(demand[route2]) - seg2_demand <= capacity and \\\n               seg2_demand + np.sum(demand[route1]) - seg1_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    route2[seg2_start:seg2_end+1],\n                    route1[seg1_end+1:]\n                ])\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    route1[seg1_start:seg1_end+1],\n                    route2[seg2_end+1:]\n                ])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n        # Partial reordering to reduce makespan\n        for route in new_solution:\n            if len(route) > 4:  # Only reorder if route has enough customers\n                # Select a random segment to reorder\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                segment_demand = np.sum(demand[route[start:end+1]])\n                if segment_demand <= capacity:\n                    # Reorder the segment\n                    segment = route[start:end+1]\n                    np.random.shuffle(segment)\n                    route[start:end+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6367371704983353,
            1.180541217327118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping and partial reordering\n    if len(new_solution) > 1:\n        # Randomly select two routes to swap segments\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try up to 10 times\n            # Choose random segments from each route (excluding depot)\n            seg1_start = random.randint(1, len(route1)-2)\n            seg1_end = random.randint(seg1_start, len(route1)-2)\n            seg2_start = random.randint(1, len(route2)-2)\n            seg2_end = random.randint(seg2_start, len(route2)-2)\n\n            # Check capacity constraints for swapped segments\n            seg1_demand = np.sum(demand[route1[seg1_start:seg1_end+1]])\n            seg2_demand = np.sum(demand[route2[seg2_start:seg2_end+1]])\n\n            if seg1_demand + np.sum(demand[route2]) - seg2_demand <= capacity and \\\n               seg2_demand + np.sum(demand[route1]) - seg1_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    route2[seg2_start:seg2_end+1],\n                    route1[seg1_end+1:]\n                ])\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    route1[seg1_start:seg1_end+1],\n                    route2[seg2_end+1:]\n                ])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n        # Partial reordering to reduce makespan\n        for route in new_solution:\n            if len(route) > 4:  # Only reorder if route has enough customers\n                # Select a random segment to reorder\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                segment_demand = np.sum(demand[route[start:end+1]])\n                if segment_demand <= capacity:\n                    # Reorder the segment\n                    segment = route[start:end+1]\n                    np.random.shuffle(segment)\n                    route[start:end+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then applies a hybrid local search that combines route merging and segment relocation while ensuring feasibility through capacity checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select two distinct routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging routes is feasible\n    total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n    if total_demand > capacity:\n        # Try segment relocation instead\n        # Select a random segment from route1 (excluding depot)\n        if len(route1) <= 3:\n            return new_solution\n        start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n        segment = route1[start:end+1]\n        segment_demand = sum(demand[segment])\n\n        # Check if segment can be inserted into route2\n        if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n            # Remove segment from route1\n            new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n            # Insert segment into route2 (random position)\n            insert_pos = random.randint(1, len(route2)-1)\n            new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n    else:\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[route1_idx] = merged_route\n        new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.5212012723073235,
            1.473869949579239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select two distinct routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging routes is feasible\n    total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n    if total_demand > capacity:\n        # Try segment relocation instead\n        # Select a random segment from route1 (excluding depot)\n        if len(route1) <= 3:\n            return new_solution\n        start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n        segment = route1[start:end+1]\n        segment_demand = sum(demand[segment])\n\n        # Check if segment can be inserted into route2\n        if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n            # Remove segment from route1\n            new_route1 = np.concatenate([route1[:start], route1[end+1:]])\n            # Insert segment into route2 (random position)\n            insert_pos = random.randint(1, len(route2)-1)\n            new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n    else:\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[route1_idx] = merged_route\n        new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The algorithm selects a promising solution from the archive using a tournament selection based on normalized objective values, then applies a hybrid local search combining route segmentation and customer reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.sample(archive, min(5, len(archive)))\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple multi-objective sorting\n    base_solution = selected[0][0].copy()\n\n    # Hybrid local search: combine route segmentation and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment the route into two parts\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Try to reallocate customers between parts\n        current_load1 = sum(demand[node] for node in part1[1:-1])\n        current_load2 = sum(demand[node] for node in part2[1:-1])\n\n        # Shuffle customers to try different allocations\n        customers = list(part1[1:-1]) + list(part2[1:-1])\n        random.shuffle(customers)\n\n        new_part1 = [part1[0]]\n        new_part2 = [part2[0]]\n        load1 = current_load1\n        load2 = current_load2\n\n        for customer in customers:\n            if load1 + demand[customer] <= capacity:\n                new_part1.append(customer)\n                load1 += demand[customer]\n            elif load2 + demand[customer] <= capacity:\n                new_part2.append(customer)\n                load2 += demand[customer]\n            else:\n                # If can't fit, place in the part with less current load\n                if load1 <= load2:\n                    new_part1.append(customer)\n                    load1 += demand[customer]\n                else:\n                    new_part2.append(customer)\n                    load2 += demand[customer]\n\n        new_part1.append(part1[-1])\n        new_part2.append(part2[-1])\n\n        # Ensure both new parts are valid\n        if len(new_part1) > 2:\n            new_solution.append(np.array(new_part1))\n        if len(new_part2) > 2:\n            new_solution.append(np.array(new_part2))\n\n    # Check for empty routes and merge if needed\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n        else:\n            # Merge with nearest route if possible\n            if final_solution:\n                nearest_route = min(final_solution, key=lambda r: distance_matrix[route[1]][r[1]])\n                merged_route = np.concatenate([nearest_route[:-1], route[1:-1], [nearest_route[-1]]])\n                total_demand = sum(demand[node] for node in merged_route[1:-1])\n                if total_demand <= capacity:\n                    final_solution.remove(nearest_route)\n                    final_solution.append(merged_route)\n\n    if not final_solution:\n        return base_solution\n\n    return final_solution\n\n",
        "score": [
            -0.8514764824426932,
            0.7495598793029785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.sample(archive, min(5, len(archive)))\n    selected.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple multi-objective sorting\n    base_solution = selected[0][0].copy()\n\n    # Hybrid local search: combine route segmentation and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment the route into two parts\n        split_pos = random.randint(1, len(route)-2)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Try to reallocate customers between parts\n        current_load1 = sum(demand[node] for node in part1[1:-1])\n        current_load2 = sum(demand[node] for node in part2[1:-1])\n\n        # Shuffle customers to try different allocations\n        customers = list(part1[1:-1]) + list(part2[1:-1])\n        random.shuffle(customers)\n\n        new_part1 = [part1[0]]\n        new_part2 = [part2[0]]\n        load1 = current_load1\n        load2 = current_load2\n\n        for customer in customers:\n            if load1 + demand[customer] <= capacity:\n                new_part1.append(customer)\n                load1 += demand[customer]\n            elif load2 + demand[customer] <= capacity:\n                new_part2.append(customer)\n                load2 += demand[customer]\n            else:\n                # If can't fit, place in the part with less current load\n                if load1 <= load2:\n                    new_part1.append(customer)\n                    load1 += demand[customer]\n                else:\n                    new_part2.append(customer)\n                    load2 += demand[customer]\n\n        new_part1.append(part1[-1])\n        new_part2.append(part2[-1])\n\n        # Ensure both new parts are valid\n        if len(new_part1) > 2:\n            new_solution.append(np.array(new_part1))\n        if len(new_part2) > 2:\n            new_solution.append(np.array(new_part2))\n\n    # Check for empty routes and merge if needed\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n        else:\n            # Merge with nearest route if possible\n            if final_solution:\n                nearest_route = min(final_solution, key=lambda r: distance_matrix[route[1]][r[1]])\n                merged_route = np.concatenate([nearest_route[:-1], route[1:-1], [nearest_route[-1]]])\n                total_demand = sum(demand[node] for node in merged_route[1:-1])\n                if total_demand <= capacity:\n                    final_solution.remove(nearest_route)\n                    final_solution.append(merged_route)\n\n    if not final_solution:\n        return base_solution\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted fitness score combining total distance and makespan, then applies a hybrid local search combining route splitting, demand-based node reinsertion, and a novel \"demand-aware 2-opt\" to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def fitness(solution, objectives):\n        total_dist, makespan = objectives\n        return total_dist * 0.7 + makespan * 0.3  # Weighted fitness\n\n    fitness_scores = [fitness(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmin(fitness_scores)  # Select the solution with best fitness\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting (if a route is too long, split it into two)\n    for i, route in enumerate(new_solution):\n        if len(route) > 5:  # Arbitrary threshold for route length\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.concatenate([[0], new_route2[1:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            break\n\n    # Step 2: Demand-aware Node Reinsertion (move nodes between routes if capacity allows)\n    for _ in range(3):  # Number of reinsertion attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip if route is too short\n\n        # Select a random node to move (excluding depot)\n        node_pos = random.randint(1, len(route) - 2)\n        node = route[node_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n\n            # Check if adding this node exceeds capacity\n            if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    cost = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform insertion\n                new_other_route = np.concatenate([other_route[:best_pos], [node], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n                new_solution[route_idx] = np.concatenate([route[:node_pos], route[node_pos + 1:]])\n                break\n\n    # Step 3: Demand-aware 2-opt (modified for makespan balancing)\n    for _ in range(5):  # Number of 2-opt attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 4:\n            continue  # Skip if route is too short\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Get the four nodes involved\n        a, b = route[i - 1], route[i]\n        c, d = route[j], route[j + 1]\n\n        # Calculate original and new distances\n        original_dist = distance_matrix[a][b] + distance_matrix[c][d]\n        new_dist = distance_matrix[a][c] + distance_matrix[b][d]\n\n        # Check if swap improves distance\n        if new_dist < original_dist:\n            # Perform the swap\n            new_route = np.concatenate([route[:i], route[j:i:-1], route[j + 1:]])\n            new_solution[route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.781570102638146,
            0.4128728210926056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def fitness(solution, objectives):\n        total_dist, makespan = objectives\n        return total_dist * 0.7 + makespan * 0.3  # Weighted fitness\n\n    fitness_scores = [fitness(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmin(fitness_scores)  # Select the solution with best fitness\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Route Splitting (if a route is too long, split it into two)\n    for i, route in enumerate(new_solution):\n        if len(route) > 5:  # Arbitrary threshold for route length\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.concatenate([[0], new_route2[1:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n            break\n\n    # Step 2: Demand-aware Node Reinsertion (move nodes between routes if capacity allows)\n    for _ in range(3):  # Number of reinsertion attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip if route is too short\n\n        # Select a random node to move (excluding depot)\n        node_pos = random.randint(1, len(route) - 2)\n        node = route[node_pos]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n\n            # Check if adding this node exceeds capacity\n            if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    cost = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Perform insertion\n                new_other_route = np.concatenate([other_route[:best_pos], [node], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n                new_solution[route_idx] = np.concatenate([route[:node_pos], route[node_pos + 1:]])\n                break\n\n    # Step 3: Demand-aware 2-opt (modified for makespan balancing)\n    for _ in range(5):  # Number of 2-opt attempts\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 4:\n            continue  # Skip if route is too short\n\n        # Select two random edges to swap\n        i = random.randint(1, len(route) - 3)\n        j = random.randint(i + 1, len(route) - 2)\n\n        # Get the four nodes involved\n        a, b = route[i - 1], route[i]\n        c, d = route[j], route[j + 1]\n\n        # Calculate original and new distances\n        original_dist = distance_matrix[a][b] + distance_matrix[c][d]\n        new_dist = distance_matrix[a][c] + distance_matrix[b][d]\n\n        # Check if swap improves distance\n        if new_dist < original_dist:\n            # Perform the swap\n            new_route = np.concatenate([route[:i], route[j:i:-1], route[j + 1:]])\n            new_solution[route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)[0].copy()\n\n    # Step 2: Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Step 3: Segment the route into two parts at a random customer node\n    if len(selected_route) > 3:\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        first_part = selected_route[:split_pos + 1]\n        second_part = selected_route[split_pos:]\n\n        # Step 4: Reallocate customers from the second part to other routes if feasible\n        for node in second_part[1:-1]:\n            best_route = None\n            min_increase = float('inf')\n\n            for i, route in enumerate(selected_solution):\n                if i == route_idx:\n                    continue\n                # Check if adding the node increases the route's makespan within capacity\n                new_route = np.append(route[:-1], [node, 0])\n                total_demand = sum(demand[new_route[1:-1]])\n                if total_demand <= capacity:\n                    route_makespan = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    if route_makespan < min_increase:\n                        min_increase = route_makespan\n                        best_route = i\n\n            if best_route is not None:\n                # Move the node to the best feasible route\n                selected_solution[best_route] = np.append(selected_solution[best_route][:-1], [node, 0])\n                second_part = np.delete(second_part, np.where(second_part == node)[0][0])\n\n        # Step 5: Merge the modified second part back if it's feasible\n        if len(second_part) > 2:\n            total_demand = sum(demand[second_part[1:-1]])\n            if total_demand <= capacity:\n                selected_solution[route_idx] = np.append(first_part[:-1], second_part)\n\n    # Step 6: Ensure the solution is feasible and return\n    for route in selected_solution:\n        if len(route) > 2:\n            total_demand = sum(demand[route[1:-1]])\n            assert total_demand <= capacity, \"Invalid solution generated\"\n\n    return selected_solution\n\n",
        "score": [
            -0.6481991435062202,
            2.20599502325058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)[0].copy()\n\n    # Step 2: Randomly select a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Step 3: Segment the route into two parts at a random customer node\n    if len(selected_route) > 3:\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        first_part = selected_route[:split_pos + 1]\n        second_part = selected_route[split_pos:]\n\n        # Step 4: Reallocate customers from the second part to other routes if feasible\n        for node in second_part[1:-1]:\n            best_route = None\n            min_increase = float('inf')\n\n            for i, route in enumerate(selected_solution):\n                if i == route_idx:\n                    continue\n                # Check if adding the node increases the route's makespan within capacity\n                new_route = np.append(route[:-1], [node, 0])\n                total_demand = sum(demand[new_route[1:-1]])\n                if total_demand <= capacity:\n                    route_makespan = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    if route_makespan < min_increase:\n                        min_increase = route_makespan\n                        best_route = i\n\n            if best_route is not None:\n                # Move the node to the best feasible route\n                selected_solution[best_route] = np.append(selected_solution[best_route][:-1], [node, 0])\n                second_part = np.delete(second_part, np.where(second_part == node)[0][0])\n\n        # Step 5: Merge the modified second part back if it's feasible\n        if len(second_part) > 2:\n            total_demand = sum(demand[second_part[1:-1]])\n            if total_demand <= capacity:\n                selected_solution[route_idx] = np.append(first_part[:-1], second_part)\n\n    # Step 6: Ensure the solution is feasible and return\n    for route in selected_solution:\n        if len(route) > 2:\n            total_demand = sum(demand[route[1:-1]])\n            assert total_demand <= capacity, \"Invalid solution generated\"\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, then applies a hybrid local search combining route segment relocation with capacity-aware route merging to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select a solution with weighted random selection\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    normalized_distances = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    normalized_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n\n    # Weighted score: prioritize solutions with good balance between objectives\n    scores = 0.4 * normalized_distances + 0.6 * normalized_makespans\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation with route merging\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a random route and extract a segment\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx].copy()\n\n    if len(route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Randomly select a segment to relocate\n    start = random.randint(1, len(route) - 3)\n    end = random.randint(start + 1, len(route) - 2)\n    segment = route[start:end]\n\n    # Step 2: Check if segment can be merged into another route\n    for i, other_route in enumerate(new_solution):\n        if i == route_idx:\n            continue\n\n        # Check capacity constraint\n        if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) > capacity:\n            continue\n\n        # Find best insertion position in other route\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(1, len(other_route)):\n            # Insert segment at position pos\n            new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n            # Calculate cost increase\n            cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                    distance_matrix[segment[-1], other_route[pos]] -\n                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the merge\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n\n            # Remove the segment from original route\n            new_route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = new_route\n\n            # Check if original route is now empty (only depot)\n            if len(new_route) == 1:\n                new_solution.pop(route_idx)\n\n            return new_solution\n\n    # If no merge was possible, try a simple relocation\n    for i, other_route in enumerate(new_solution):\n        if i == route_idx:\n            continue\n\n        if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) > capacity:\n            continue\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(1, len(other_route)):\n            cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                    distance_matrix[segment[-1], other_route[pos]] -\n                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n\n            new_route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = new_route\n\n            if len(new_route) == 1:\n                new_solution.pop(route_idx)\n\n            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6179161241304928,
            1.2536321580410004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select a solution with weighted random selection\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    normalized_distances = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    normalized_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n\n    # Weighted score: prioritize solutions with good balance between objectives\n    scores = 0.4 * normalized_distances + 0.6 * normalized_makespans\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation with route merging\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a random route and extract a segment\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_idx = random.randint(0, len(new_solution) - 1)\n    route = new_solution[route_idx].copy()\n\n    if len(route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Randomly select a segment to relocate\n    start = random.randint(1, len(route) - 3)\n    end = random.randint(start + 1, len(route) - 2)\n    segment = route[start:end]\n\n    # Step 2: Check if segment can be merged into another route\n    for i, other_route in enumerate(new_solution):\n        if i == route_idx:\n            continue\n\n        # Check capacity constraint\n        if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) > capacity:\n            continue\n\n        # Find best insertion position in other route\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(1, len(other_route)):\n            # Insert segment at position pos\n            new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n            # Calculate cost increase\n            cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                    distance_matrix[segment[-1], other_route[pos]] -\n                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the merge\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n\n            # Remove the segment from original route\n            new_route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = new_route\n\n            # Check if original route is now empty (only depot)\n            if len(new_route) == 1:\n                new_solution.pop(route_idx)\n\n            return new_solution\n\n    # If no merge was possible, try a simple relocation\n    for i, other_route in enumerate(new_solution):\n        if i == route_idx:\n            continue\n\n        if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) > capacity:\n            continue\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(1, len(other_route)):\n            cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                    distance_matrix[segment[-1], other_route[pos]] -\n                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n            new_solution[i] = new_route\n\n            new_route = np.concatenate([route[:start], route[end:]])\n            new_solution[route_idx] = new_route\n\n            if len(new_route) == 1:\n                new_solution.pop(route_idx)\n\n            return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement (e.g., based on objective values) and applies a hybrid local search combining route splitting, demand-based node reinsertion, and distance-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    threshold = int(0.3 * len(archive_sorted))\n    candidates = archive_sorted[:threshold] if threshold > 0 else archive_sorted\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, demand-based reinsertion, and distance-aware edge swapping\n    for route in new_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting (if demand allows)\n        split_pos = random.randint(1, len(route) - 2)\n        if np.sum(demand[route[split_pos:]]) <= capacity:\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n            break\n\n    # Step 2: Demand-based reinsertion\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        node_to_move = random.choice(route[1:-1])\n        current_demand = np.sum(demand[route[1:-1]])\n        if current_demand - demand[node_to_move] <= capacity:\n            route = np.delete(route, np.where(route == node_to_move))\n            # Find the best insertion position in another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                if np.sum(demand[other_route[1:-1]]) + demand[node_to_move] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(other_route)):\n                        increase = distance_matrix[other_route[i-1], node_to_move] + distance_matrix[node_to_move, other_route[i]] - distance_matrix[other_route[i-1], other_route[i]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    other_route = np.insert(other_route, best_pos, node_to_move)\n                    break\n\n    # Step 3: Distance-aware edge swapping\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        i, j = random.sample(range(1, len(route) - 1), 2)\n        if i > j:\n            i, j = j, i\n        # Check capacity constraint\n        segment_demand = np.sum(demand[route[i:j+1]])\n        if np.sum(demand[route[1:i]]) + segment_demand <= capacity and np.sum(demand[route[j+1:-1]]) + segment_demand <= capacity:\n            # Reverse the segment\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if np.all(distance_matrix[new_route[:-1], new_route[1:]] <= distance_matrix[route[:-1], route[1:]]):\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7836658580606465,
            4.669236809015274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    threshold = int(0.3 * len(archive_sorted))\n    candidates = archive_sorted[:threshold] if threshold > 0 else archive_sorted\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting, demand-based reinsertion, and distance-aware edge swapping\n    for route in new_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting (if demand allows)\n        split_pos = random.randint(1, len(route) - 2)\n        if np.sum(demand[route[split_pos:]]) <= capacity:\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n            break\n\n    # Step 2: Demand-based reinsertion\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        node_to_move = random.choice(route[1:-1])\n        current_demand = np.sum(demand[route[1:-1]])\n        if current_demand - demand[node_to_move] <= capacity:\n            route = np.delete(route, np.where(route == node_to_move))\n            # Find the best insertion position in another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                if np.sum(demand[other_route[1:-1]]) + demand[node_to_move] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(other_route)):\n                        increase = distance_matrix[other_route[i-1], node_to_move] + distance_matrix[node_to_move, other_route[i]] - distance_matrix[other_route[i-1], other_route[i]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    other_route = np.insert(other_route, best_pos, node_to_move)\n                    break\n\n    # Step 3: Distance-aware edge swapping\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        i, j = random.sample(range(1, len(route) - 1), 2)\n        if i > j:\n            i, j = j, i\n        # Check capacity constraint\n        segment_demand = np.sum(demand[route[i:j+1]])\n        if np.sum(demand[route[1:i]]) + segment_demand <= capacity and np.sum(demand[route[j+1:-1]]) + segment_demand <= capacity:\n            # Reverse the segment\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if np.all(distance_matrix[new_route[:-1], new_route[1:]] <= distance_matrix[route[:-1], route[1:]]):\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with route merging/splitting\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Apply 2-opt within the selected route\n        if len(selected_route) > 4:  # Ensure enough nodes for 2-opt\n            i = random.randint(1, len(selected_route) - 3)\n            j = random.randint(i + 1, len(selected_route) - 2)\n            # Reverse the segment between i and j\n            selected_route[i:j+1] = selected_route[j:i-1:-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = selected_route\n        else:\n            # If capacity violated, attempt to split the route\n            split_pos = np.argmax(np.cumsum(demand[selected_route[1:-1]]) > capacity)\n            if split_pos > 0:\n                new_route1 = np.concatenate([[0], selected_route[1:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], selected_route[split_pos+1:-1], [0]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution = new_solution[:route_idx] + [new_route1, new_route2] + new_solution[route_idx+1:]\n\n    return new_solution\n\n",
        "score": [
            -0.4067158906572348,
            0.5935334861278534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with route merging/splitting\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx].copy()\n\n        # Apply 2-opt within the selected route\n        if len(selected_route) > 4:  # Ensure enough nodes for 2-opt\n            i = random.randint(1, len(selected_route) - 3)\n            j = random.randint(i + 1, len(selected_route) - 2)\n            # Reverse the segment between i and j\n            selected_route[i:j+1] = selected_route[j:i-1:-1]\n\n        # Check capacity feasibility\n        if np.sum(demand[selected_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = selected_route\n        else:\n            # If capacity violated, attempt to split the route\n            split_pos = np.argmax(np.cumsum(demand[selected_route[1:-1]]) > capacity)\n            if split_pos > 0:\n                new_route1 = np.concatenate([[0], selected_route[1:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], selected_route[split_pos+1:-1], [0]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution = new_solution[:route_idx] + [new_route1, new_route2] + new_solution[route_idx+1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random choice favoring solutions with better makespan, then applies a hybrid local search combining route splitting, customer reallocation, and a novel \"demand-balanced\" 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + demand-balanced 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - identify high-demand segments\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Split if demand exceeds 70% of capacity\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity * 0.5)\n            if split_pos > 0 and split_pos < len(route)-2:\n                new_route1 = np.concatenate([[0], route[1:split_pos+2], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+2:-1], [0]])\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                # Check if adding customer to other route is feasible\n                other_route = new_solution[k].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at best position\n                    best_pos = 1\n                    min_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = pos\n                    # Update routes\n                    new_route = np.insert(other_route, best_pos, customer)\n                    new_solution[k] = new_route\n                    new_solution[i] = np.delete(route, j)\n                    break\n\n        # Step 3: Demand-balanced 2-opt\n        improved = True\n        while improved:\n            improved = False\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Calculate demand before and after swap\n                    segment_a = route[a:b+1]\n                    segment_b = route[b+1:a-1:-1]  # Reversed segment\n                    before_demand = sum(demand[segment_a])\n                    after_demand = sum(demand[segment_b])\n\n                    if before_demand <= capacity and after_demand <= capacity:\n                        # Calculate distance change\n                        old_dist = (distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n                        new_dist = (distance_matrix[route[a-1], route[b]] +\n                                    distance_matrix[route[a], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n\n                        if new_dist < old_dist:\n                            # Perform the swap\n                            route[a:b+1] = route[b:a-1:-1]\n                            new_solution[i] = route\n                            improved = True\n                            break\n                if improved:\n                    break\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(coords) - 1:  # Exclude depot\n        # Recover missing customers by adding to shortest route\n        missing = set(range(1, len(coords))) - all_nodes\n        for customer in missing:\n            best_route = min(range(len(new_solution)),\n                           key=lambda r: (sum(demand[new_solution[r][1:-1]]) + demand[customer] <= capacity,\n                                         len(new_solution[r])))\n            if sum(demand[new_solution[best_route][1:-1]]) + demand[customer] <= capacity:\n                # Insert at best position\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.6678742629469308,
            1.2159636616706848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (1 + obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + customer reallocation + demand-balanced 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route splitting - identify high-demand segments\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Split if demand exceeds 70% of capacity\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity * 0.5)\n            if split_pos > 0 and split_pos < len(route)-2:\n                new_route1 = np.concatenate([[0], route[1:split_pos+2], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+2:-1], [0]])\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([new_route1, new_route2])\n                break\n\n        # Step 2: Customer reallocation - move customers between routes\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                # Check if adding customer to other route is feasible\n                other_route = new_solution[k].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer at best position\n                    best_pos = 1\n                    min_dist = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = pos\n                    # Update routes\n                    new_route = np.insert(other_route, best_pos, customer)\n                    new_solution[k] = new_route\n                    new_solution[i] = np.delete(route, j)\n                    break\n\n        # Step 3: Demand-balanced 2-opt\n        improved = True\n        while improved:\n            improved = False\n            for a in range(1, len(route)-2):\n                for b in range(a+1, len(route)-1):\n                    # Calculate demand before and after swap\n                    segment_a = route[a:b+1]\n                    segment_b = route[b+1:a-1:-1]  # Reversed segment\n                    before_demand = sum(demand[segment_a])\n                    after_demand = sum(demand[segment_b])\n\n                    if before_demand <= capacity and after_demand <= capacity:\n                        # Calculate distance change\n                        old_dist = (distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n                        new_dist = (distance_matrix[route[a-1], route[b]] +\n                                    distance_matrix[route[a], route[b+1]] +\n                                    distance_matrix[route[a-1], route[a]] +\n                                    distance_matrix[route[b], route[b+1]])\n\n                        if new_dist < old_dist:\n                            # Perform the swap\n                            route[a:b+1] = route[b:a-1:-1]\n                            new_solution[i] = route\n                            improved = True\n                            break\n                if improved:\n                    break\n\n    # Ensure all customers are served (sanity check)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(coords) - 1:  # Exclude depot\n        # Recover missing customers by adding to shortest route\n        missing = set(range(1, len(coords))) - all_nodes\n        for customer in missing:\n            best_route = min(range(len(new_solution)),\n                           key=lambda r: (sum(demand[new_solution[r][1:-1]]) + demand[customer] <= capacity,\n                                         len(new_solution[r])))\n            if sum(demand[new_solution[best_route][1:-1]]) + demand[customer] <= capacity:\n                # Insert at best position\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a split point\n            split_point = np.random.randint(1, len(route) - 1)\n            new_route1 = route[:split_point + 1]\n            new_route2 = route[split_point:]\n\n            # Check feasibility of the split\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        if np.sum(demand[np.concatenate([route1[1:-1], route2[1:-1]])]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n\n    return new_solution\n\n",
        "score": [
            -0.6280363316158044,
            0.21988248825073242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route splitting and route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Randomly select a split point\n            split_point = np.random.randint(1, len(route) - 1)\n            new_route1 = route[:split_point + 1]\n            new_route2 = route[split_point:]\n\n            # Check feasibility of the split\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        if np.sum(demand[np.concatenate([route1[1:-1], route2[1:-1]])]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The algorithm combines route merging (to reduce total distance) and route splitting (to balance makespan) with a randomized selection of routes for transformation, ensuring feasibility and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to transform\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    selected_route_idx = route_indices[0]\n\n    # Hybrid transformation: merge or split the selected route\n    new_solution = []\n    for i, route in enumerate(selected_solution):\n        if i == selected_route_idx:\n            # Try merging with a random neighbor route\n            if len(selected_solution) > 1:\n                neighbor_idx = random.choice([j for j in route_indices if j != i])\n                neighbor_route = selected_solution[neighbor_idx]\n\n                # Check if merging is feasible\n                merged_route = np.concatenate((route[:-1], neighbor_route[1:]))\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution.append(merged_route)\n                    continue\n\n            # If merging fails, try splitting the route\n            if len(route) > 3:  # Ensure the route can be split\n                split_pos = random.randint(1, len(route) - 2)\n                route1 = np.concatenate((route[:split_pos], [0]))\n                route2 = np.concatenate(([0], route[split_pos:]))\n\n                if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution.extend([route1, route2])\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are covered\n    covered_customers = set()\n    for route in new_solution:\n        covered_customers.update(route[1:-1])\n    missing_customers = set(range(1, len(demand))) - covered_customers\n\n    if missing_customers:\n        # Assign missing customers to a random route (if feasible)\n        for customer in missing_customers:\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n            if feasible_routes:\n                selected_route = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[selected_route]) - 1)\n                new_route = np.insert(new_solution[selected_route], insert_pos, customer)\n                new_solution[selected_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.3972373095215495,
            1.3487249314785004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Randomly choose a route to transform\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = list(range(len(selected_solution)))\n    random.shuffle(route_indices)\n    selected_route_idx = route_indices[0]\n\n    # Hybrid transformation: merge or split the selected route\n    new_solution = []\n    for i, route in enumerate(selected_solution):\n        if i == selected_route_idx:\n            # Try merging with a random neighbor route\n            if len(selected_solution) > 1:\n                neighbor_idx = random.choice([j for j in route_indices if j != i])\n                neighbor_route = selected_solution[neighbor_idx]\n\n                # Check if merging is feasible\n                merged_route = np.concatenate((route[:-1], neighbor_route[1:]))\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution.append(merged_route)\n                    continue\n\n            # If merging fails, try splitting the route\n            if len(route) > 3:  # Ensure the route can be split\n                split_pos = random.randint(1, len(route) - 2)\n                route1 = np.concatenate((route[:split_pos], [0]))\n                route2 = np.concatenate(([0], route[split_pos:]))\n\n                if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution.extend([route1, route2])\n                    continue\n\n        new_solution.append(route.copy())\n\n    # Ensure all customers are covered\n    covered_customers = set()\n    for route in new_solution:\n        covered_customers.update(route[1:-1])\n    missing_customers = set(range(1, len(demand))) - covered_customers\n\n    if missing_customers:\n        # Assign missing customers to a random route (if feasible)\n        for customer in missing_customers:\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n            if feasible_routes:\n                selected_route = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[selected_route]) - 1)\n                new_route = np.insert(new_solution[selected_route], insert_pos, customer)\n                new_solution[selected_route] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(2):  # Perform two iterations of the hybrid operator\n        # Step 1: Route Splitting - Split the longest route into two\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] + sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure the route can be split\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos]\n            new_route2 = longest_route[split_pos:]\n\n            # Ensure capacity constraints are met\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If splitting violates capacity, try to reassign customers\n                for i in range(1, len(longest_route)-1):\n                    customer = longest_route[i]\n                    for route in new_solution:\n                        if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                            route.insert(-1, customer)\n                            longest_route = np.delete(longest_route, i)\n                            break\n\n        # Step 2: Route Merging - Merge two routes if their combined demand fits in capacity\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                    merged_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Ensure all routes start and end with the depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7219216542689235,
            2.821205288171768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(2):  # Perform two iterations of the hybrid operator\n        # Step 1: Route Splitting - Split the longest route into two\n        longest_route_idx = np.argmax([distance_matrix[route[-2], 0] + sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure the route can be split\n            split_pos = len(longest_route) // 2\n            new_route1 = longest_route[:split_pos]\n            new_route2 = longest_route[split_pos:]\n\n            # Ensure capacity constraints are met\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n            else:\n                # If splitting violates capacity, try to reassign customers\n                for i in range(1, len(longest_route)-1):\n                    customer = longest_route[i]\n                    for route in new_solution:\n                        if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                            route.insert(-1, customer)\n                            longest_route = np.delete(longest_route, i)\n                            break\n\n        # Step 2: Route Merging - Merge two routes if their combined demand fits in capacity\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                    merged_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Ensure all routes start and end with the depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine route splitting and customer reallocation to reduce makespan and total distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Step 2.1: Split the longest route into two\n        # Find the customer with the highest demand in this route\n        customers_in_route = route[1:-1]  # Exclude depots\n        if len(customers_in_route) == 0:\n            continue\n\n        max_demand_idx = np.argmax(demand[customers_in_route])\n        split_customer = customers_in_route[max_demand_idx]\n\n        # Split the route at this customer\n        split_pos = np.where(route == split_customer)[0][0]\n        new_route1 = route[:split_pos+1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1]) <= capacity) and (np.sum(demand[new_route2]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2.2: Reallocate customers between routes to balance makespan\n    # Find the two routes with the most extreme makespans (longest and shortest)\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    shortest_route_idx = np.argmin(route_lengths)\n\n    if longest_route_idx != shortest_route_idx:\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from the longest to the shortest route\n        for customer in longest_route[1:-1]:\n            # Check if moving this customer to the shortest route is feasible\n            if (np.sum(demand[shortest_route]) + demand[customer] <= capacity):\n                # Find the best insertion position in the shortest route\n                best_insert_pos = 1  # Default to after depot\n                min_insert_cost = float('inf')\n\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost: distance increase\n                    prev_node = shortest_route[i-1]\n                    next_node = shortest_route[i]\n                    insert_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if insert_cost < min_insert_cost:\n                        min_insert_cost = insert_cost\n                        best_insert_pos = i\n\n                # Perform the move\n                new_shortest_route = np.concatenate([shortest_route[:best_insert_pos], [customer], shortest_route[best_insert_pos:]])\n                new_longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n                break  # Only one move per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.6922140696866241,
            1.5576107203960419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine route splitting and customer reallocation to reduce makespan and total distance\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Step 2.1: Split the longest route into two\n        # Find the customer with the highest demand in this route\n        customers_in_route = route[1:-1]  # Exclude depots\n        if len(customers_in_route) == 0:\n            continue\n\n        max_demand_idx = np.argmax(demand[customers_in_route])\n        split_customer = customers_in_route[max_demand_idx]\n\n        # Split the route at this customer\n        split_pos = np.where(route == split_customer)[0][0]\n        new_route1 = route[:split_pos+1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1]) <= capacity) and (np.sum(demand[new_route2]) <= capacity):\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2.2: Reallocate customers between routes to balance makespan\n    # Find the two routes with the most extreme makespans (longest and shortest)\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    shortest_route_idx = np.argmin(route_lengths)\n\n    if longest_route_idx != shortest_route_idx:\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to move a customer from the longest to the shortest route\n        for customer in longest_route[1:-1]:\n            # Check if moving this customer to the shortest route is feasible\n            if (np.sum(demand[shortest_route]) + demand[customer] <= capacity):\n                # Find the best insertion position in the shortest route\n                best_insert_pos = 1  # Default to after depot\n                min_insert_cost = float('inf')\n\n                for i in range(1, len(shortest_route)):\n                    # Calculate insertion cost: distance increase\n                    prev_node = shortest_route[i-1]\n                    next_node = shortest_route[i]\n                    insert_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if insert_cost < min_insert_cost:\n                        min_insert_cost = insert_cost\n                        best_insert_pos = i\n\n                # Perform the move\n                new_shortest_route = np.concatenate([shortest_route[:best_insert_pos], [customer], shortest_route[best_insert_pos:]])\n                new_longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n                break  # Only one move per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and attempt to merge with another route\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if merging part1 with another route is feasible\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part1) - 2 > 20:  # Avoid overly long routes\n                continue\n\n            # Check capacity constraint\n            if sum(demand[part1[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                new_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n\n        # Attempt to insert part2 into another route\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part2) - 2 > 20:  # Avoid overly long routes\n                continue\n\n            # Check capacity constraint\n            if sum(demand[part2[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    cost = distance_matrix[other_route[pos-1], part2[1]] + distance_matrix[part2[-2], other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Insert part2\n                new_route = np.concatenate([other_route[:best_pos], part2[1:-1], other_route[best_pos:]])\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        if not inserted:\n            new_solution.append(part2.copy())\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(demand))) - served_customers\n    if missing_customers:\n        # Greedily assign missing customers to the least loaded route\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n        for customer in missing_customers:\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            current_load = [sum(demand[route[1:-1]]) for route in new_solution]\n\n            for i, route in enumerate(new_solution):\n                if current_load[i] + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = i\n                        best_pos = pos\n\n            if best_route != -1:\n                new_route = np.concatenate([new_solution[best_route][:best_pos], [customer], new_solution[best_route][best_pos:]])\n                new_solution[best_route] = new_route\n            else:\n                # If no feasible insertion found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7210873026370843,
            6.395725786685944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route merging and customer insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and attempt to merge with another route\n        split_point = len(route) // 2\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if merging part1 with another route is feasible\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part1) - 2 > 20:  # Avoid overly long routes\n                continue\n\n            # Check capacity constraint\n            if sum(demand[part1[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([other_route[:-1], part1[1:]])\n                new_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n\n        # Attempt to insert part2 into another route\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part2) - 2 > 20:  # Avoid overly long routes\n                continue\n\n            # Check capacity constraint\n            if sum(demand[part2[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    cost = distance_matrix[other_route[pos-1], part2[1]] + distance_matrix[part2[-2], other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Insert part2\n                new_route = np.concatenate([other_route[:best_pos], part2[1:-1], other_route[best_pos:]])\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        if not inserted:\n            new_solution.append(part2.copy())\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(demand))) - served_customers\n    if missing_customers:\n        # Greedily assign missing customers to the least loaded route\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n        for customer in missing_customers:\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            current_load = [sum(demand[route[1:-1]]) for route in new_solution]\n\n            for i, route in enumerate(new_solution):\n                if current_load[i] + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = i\n                        best_pos = pos\n\n            if best_route != -1:\n                new_route = np.concatenate([new_solution[best_route][:best_pos], [customer], new_solution[best_route][best_pos:]])\n                new_solution[best_route] = new_route\n            else:\n                # If no feasible insertion found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1] if x[1][1] > np.median([sol[1][1] for sol in archive]) else x[1][0])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    target_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply hybrid local search: Split, Reverse, and Insert\n    new_solution = selected_solution.copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(target_route)-1)\n    part1 = target_route[:split_point+1]\n    part2 = target_route[split_point:]\n\n    # Reverse part2 to explore alternative paths\n    part2_reversed = part2[::-1]\n\n    # Insert part2_reversed into a new route or merge with another route\n    if len(new_solution) < len(selected_solution) * 1.5:  # Avoid excessive route creation\n        new_solution.append(part2_reversed)\n    else:\n        # Find another route to merge with (demand-aware)\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[route[1:-1]]) + sum(demand[part2_reversed[1:-1]]) <= capacity:\n                # Merge by inserting part2_reversed into route\n                best_pos = 0\n                min_cost = float('inf')\n                for j in range(len(route)-1):\n                    cost = distance_matrix[route[j], part2_reversed[1]] + distance_matrix[part2_reversed[-2], route[j+1]] - distance_matrix[route[j], route[j+1]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n                merged_route = np.concatenate([route[:best_pos+1], part2_reversed[1:-1], route[best_pos+1:]])\n                new_solution[i] = merged_route\n                break\n\n    # Ensure feasibility: Check all routes in new_solution for capacity constraints\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7876803873503511,
            1.6963614225387573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1] if x[1][1] > np.median([sol[1][1] for sol in archive]) else x[1][0])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n    target_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply hybrid local search: Split, Reverse, and Insert\n    new_solution = selected_solution.copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(target_route)-1)\n    part1 = target_route[:split_point+1]\n    part2 = target_route[split_point:]\n\n    # Reverse part2 to explore alternative paths\n    part2_reversed = part2[::-1]\n\n    # Insert part2_reversed into a new route or merge with another route\n    if len(new_solution) < len(selected_solution) * 1.5:  # Avoid excessive route creation\n        new_solution.append(part2_reversed)\n    else:\n        # Find another route to merge with (demand-aware)\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[route[1:-1]]) + sum(demand[part2_reversed[1:-1]]) <= capacity:\n                # Merge by inserting part2_reversed into route\n                best_pos = 0\n                min_cost = float('inf')\n                for j in range(len(route)-1):\n                    cost = distance_matrix[route[j], part2_reversed[1]] + distance_matrix[part2_reversed[-2], route[j+1]] - distance_matrix[route[j], route[j+1]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n                merged_route = np.concatenate([route[:best_pos+1], part2_reversed[1:-1], route[best_pos+1:]])\n                new_solution[i] = merged_route\n                break\n\n    # Ensure feasibility: Check all routes in new_solution for capacity constraints\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This function selects a solution from the archive using a hybrid approach that combines route segment swapping and local reinsertion, prioritizing solutions with lower makespan and total distance, while ensuring feasibility through capacity checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Choose a random route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        route = selected_solution[route_idx].copy()\n\n        # Extract customers from the route (excluding depot)\n        customers = route[1:-1]\n\n        if len(customers) > 1:\n            # Randomly select a segment of the route to reinsert elsewhere\n            segment_start = np.random.randint(0, len(customers))\n            segment_length = np.random.randint(1, min(4, len(customers) - segment_start + 1))\n            segment = customers[segment_start:segment_start + segment_length]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([\n                route[:segment_start + 1],\n                route[segment_start + segment_length + 1:]\n            ])\n\n            # Check capacity constraint for the modified route\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Find the best position to reinsert the segment in another route or the same route\n                best_pos = -1\n                best_insert_cost = float('inf')\n\n                # Try inserting into the same route\n                for insert_pos in range(1, len(new_route)):\n                    temp_route = np.concatenate([\n                        new_route[:insert_pos],\n                        segment,\n                        new_route[insert_pos:]\n                    ])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        insert_cost = distance_matrix[temp_route[insert_pos - 1], segment[0]] + \\\n                                      distance_matrix[segment[-1], temp_route[insert_pos + len(segment)]] - \\\n                                      distance_matrix[temp_route[insert_pos - 1], temp_route[insert_pos]]\n                        if insert_cost < best_insert_cost:\n                            best_insert_cost = insert_cost\n                            best_pos = insert_pos\n\n                # If no valid position found in the same route, try inserting into another route\n                if best_pos == -1 and len(selected_solution) > 1:\n                    for other_route_idx in range(len(selected_solution)):\n                        if other_route_idx == route_idx:\n                            continue\n                        other_route = selected_solution[other_route_idx].copy()\n                        for insert_pos in range(1, len(other_route)):\n                            temp_route = np.concatenate([\n                                other_route[:insert_pos],\n                                segment,\n                                other_route[insert_pos:]\n                            ])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                insert_cost = distance_matrix[temp_route[insert_pos - 1], segment[0]] + \\\n                                              distance_matrix[segment[-1], temp_route[insert_pos + len(segment)]] - \\\n                                              distance_matrix[temp_route[insert_pos - 1], temp_route[insert_pos]]\n                                if insert_cost < best_insert_cost:\n                                    best_insert_cost = insert_cost\n                                    best_pos = insert_pos\n                                    selected_solution[other_route_idx] = temp_route\n                                    selected_solution[route_idx] = new_route\n                                    return selected_solution\n\n                if best_pos != -1:\n                    new_route = np.concatenate([\n                        new_route[:best_pos],\n                        segment,\n                        new_route[best_pos:]\n                    ])\n                    selected_solution[route_idx] = new_route\n\n    return selected_solution\n\n",
        "score": [
            -0.3938164056909355,
            1.6136414706707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Choose a random route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        route = selected_solution[route_idx].copy()\n\n        # Extract customers from the route (excluding depot)\n        customers = route[1:-1]\n\n        if len(customers) > 1:\n            # Randomly select a segment of the route to reinsert elsewhere\n            segment_start = np.random.randint(0, len(customers))\n            segment_length = np.random.randint(1, min(4, len(customers) - segment_start + 1))\n            segment = customers[segment_start:segment_start + segment_length]\n\n            # Remove the segment from the route\n            new_route = np.concatenate([\n                route[:segment_start + 1],\n                route[segment_start + segment_length + 1:]\n            ])\n\n            # Check capacity constraint for the modified route\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                # Find the best position to reinsert the segment in another route or the same route\n                best_pos = -1\n                best_insert_cost = float('inf')\n\n                # Try inserting into the same route\n                for insert_pos in range(1, len(new_route)):\n                    temp_route = np.concatenate([\n                        new_route[:insert_pos],\n                        segment,\n                        new_route[insert_pos:]\n                    ])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        insert_cost = distance_matrix[temp_route[insert_pos - 1], segment[0]] + \\\n                                      distance_matrix[segment[-1], temp_route[insert_pos + len(segment)]] - \\\n                                      distance_matrix[temp_route[insert_pos - 1], temp_route[insert_pos]]\n                        if insert_cost < best_insert_cost:\n                            best_insert_cost = insert_cost\n                            best_pos = insert_pos\n\n                # If no valid position found in the same route, try inserting into another route\n                if best_pos == -1 and len(selected_solution) > 1:\n                    for other_route_idx in range(len(selected_solution)):\n                        if other_route_idx == route_idx:\n                            continue\n                        other_route = selected_solution[other_route_idx].copy()\n                        for insert_pos in range(1, len(other_route)):\n                            temp_route = np.concatenate([\n                                other_route[:insert_pos],\n                                segment,\n                                other_route[insert_pos:]\n                            ])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                insert_cost = distance_matrix[temp_route[insert_pos - 1], segment[0]] + \\\n                                              distance_matrix[segment[-1], temp_route[insert_pos + len(segment)]] - \\\n                                              distance_matrix[temp_route[insert_pos - 1], temp_route[insert_pos]]\n                                if insert_cost < best_insert_cost:\n                                    best_insert_cost = insert_cost\n                                    best_pos = insert_pos\n                                    selected_solution[other_route_idx] = temp_route\n                                    selected_solution[route_idx] = new_route\n                                    return selected_solution\n\n                if best_pos != -1:\n                    new_route = np.concatenate([\n                        new_route[:best_pos],\n                        segment,\n                        new_route[best_pos:]\n                    ])\n                    selected_solution[route_idx] = new_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{The algorithm selects a solution from the archive with the highest makespan, then applies a hybrid local search combining route merging and split insertion to balance distance and makespan, ensuring feasibility by checking capacity constraints at each step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and split into new routes\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Merge routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check feasibility of merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            # Split merged route into two new routes\n            split_pos = np.random.randint(1, len(merged_route) - 1)\n            new_route1 = np.concatenate([[0], merged_route[1:split_pos], [0]])\n            new_route2 = np.concatenate([[0], merged_route[split_pos:], [0]])\n\n            # Replace old routes with new ones\n            new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n",
        "score": [
            -0.7036447631935296,
            0.6760682165622711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and split into new routes\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Merge routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check feasibility of merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            # Split merged route into two new routes\n            split_pos = np.random.randint(1, len(merged_route) - 1)\n            new_route1 = np.concatenate([[0], merged_route[1:split_pos], [0]])\n            new_route2 = np.concatenate([[0], merged_route[split_pos:], [0]])\n\n            # Replace old routes with new ones\n            new_solution = [r for i, r in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route swapping with partial route reversal\n    for _ in range(5):  # Perform 5 iterations of the hybrid operator\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Swap entire routes if feasible\n        if (np.sum(demand[new_solution[i][1:-1]]) + np.sum(demand[new_solution[j][1:-1]]) <= 2 * capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            continue\n\n        # If not feasible, try partial route reversal\n        for route in [new_solution[i], new_solution[j]]:\n            if len(route) <= 4:  # Skip if route is too short\n                continue\n            # Select a random segment to reverse\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            # Check capacity constraint\n            if np.sum(demand[route[start:end]]) <= capacity:\n                route[start:end] = route[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6388361633472857,
            1.0540084838867188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route swapping with partial route reversal\n    for _ in range(5):  # Perform 5 iterations of the hybrid operator\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Swap entire routes if feasible\n        if (np.sum(demand[new_solution[i][1:-1]]) + np.sum(demand[new_solution[j][1:-1]]) <= 2 * capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            continue\n\n        # If not feasible, try partial route reversal\n        for route in [new_solution[i], new_solution[j]]:\n            if len(route) <= 4:  # Skip if route is too short\n                continue\n            # Select a random segment to reverse\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            # Check capacity constraint\n            if np.sum(demand[route[start:end]]) <= capacity:\n                route[start:end] = route[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting and intra-route 3-opt with demand-aware perturbations to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware 3-opt\n    for _ in range(3):  # Number of perturbations\n        # Randomly select a route to perturb\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split route into two parts if demand allows\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = part1\n            new_solution.append(part2)\n            continue\n\n        # If splitting fails, perform demand-aware 3-opt\n        i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n        candidate_routes = [\n            np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n            np.concatenate([route[:i], route[k:j-1:-1], route[i:j], route[k:]]),\n            np.concatenate([route[:i], route[j:k], route[j-1:i-1:-1], route[k:]]),\n            np.concatenate([route[:i], route[k:j-1:-1], route[j-1:i-1:-1], route[k:]])\n        ]\n\n        # Find the best feasible candidate\n        best_route = None\n        min_distance = float('inf')\n        for candidate in candidate_routes:\n            if sum(demand[node] for node in candidate[1:-1]) <= capacity:\n                distance = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n                if distance < min_distance:\n                    min_distance = distance\n                    best_route = candidate\n\n        if best_route is not None:\n            new_solution[route_idx] = best_route\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6822891097834061,
            0.1888173520565033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware 3-opt\n    for _ in range(3):  # Number of perturbations\n        # Randomly select a route to perturb\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split route into two parts if demand allows\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = part1\n            new_solution.append(part2)\n            continue\n\n        # If splitting fails, perform demand-aware 3-opt\n        i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n        candidate_routes = [\n            np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n            np.concatenate([route[:i], route[k:j-1:-1], route[i:j], route[k:]]),\n            np.concatenate([route[:i], route[j:k], route[j-1:i-1:-1], route[k:]]),\n            np.concatenate([route[:i], route[k:j-1:-1], route[j-1:i-1:-1], route[k:]])\n        ]\n\n        # Find the best feasible candidate\n        best_route = None\n        min_distance = float('inf')\n        for candidate in candidate_routes:\n            if sum(demand[node] for node in candidate[1:-1]) <= capacity:\n                distance = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n                if distance < min_distance:\n                    min_distance = distance\n                    best_route = candidate\n\n        if best_route is not None:\n            new_solution[route_idx] = best_route\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine route splitting and customer reinsertion with a focus on reducing makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip routes with only depot and one customer\n            # Split the route at a random point and attempt to reinsert customers into new routes\n            split_idx = np.random.randint(1, len(route) - 1)\n            first_part = route[:split_idx + 1]\n            second_part = route[split_idx:]\n\n            # Check if the split parts are feasible\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                # Replace the original route with the split parts\n                new_solution[i] = first_part\n                new_solution.insert(i + 1, second_part)\n                break\n\n    # Perform customer reinsertion to further improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Remove a random customer from the route\n            customer_idx = np.random.randint(1, len(route) - 1)\n            customer = route[customer_idx]\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n\n            # Try to reinsert the customer into the same route or another route\n            for j in range(len(new_solution)):\n                target_route = new_solution[j]\n                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the target route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = distance_matrix[target_route[pos - 1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos - 1], target_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Insert the customer into the target route\n                    new_route_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                    new_solution[j] = new_route_target\n                    break\n\n            # Update the current route\n            new_solution[i] = new_route\n\n    # Remove empty routes that may have been created\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8956024735085047,
            0.8570665121078491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine route splitting and customer reinsertion with a focus on reducing makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip routes with only depot and one customer\n            # Split the route at a random point and attempt to reinsert customers into new routes\n            split_idx = np.random.randint(1, len(route) - 1)\n            first_part = route[:split_idx + 1]\n            second_part = route[split_idx:]\n\n            # Check if the split parts are feasible\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                # Replace the original route with the split parts\n                new_solution[i] = first_part\n                new_solution.insert(i + 1, second_part)\n                break\n\n    # Perform customer reinsertion to further improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Remove a random customer from the route\n            customer_idx = np.random.randint(1, len(route) - 1)\n            customer = route[customer_idx]\n            new_route = np.concatenate([route[:customer_idx], route[customer_idx + 1:]])\n\n            # Try to reinsert the customer into the same route or another route\n            for j in range(len(new_solution)):\n                target_route = new_solution[j]\n                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the target route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = distance_matrix[target_route[pos - 1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos - 1], target_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Insert the customer into the target route\n                    new_route_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                    new_solution[j] = new_route_target\n                    break\n\n            # Update the current route\n            new_solution[i] = new_route\n\n    # Remove empty routes that may have been created\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Step 2: Choose a route to modify (select the longest route to prioritize makespan reduction)\n    longest_route_idx = np.argmax([np.sum([distance_matrix[int(selected_solution[r][i]), int(selected_solution[r][i+1])] for i in range(len(selected_solution[r])-1)]) for r in range(len(selected_solution))])\n    target_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Split the route into two parts at a random point (to create new routes)\n    split_point = np.random.randint(1, len(target_route)-2)\n    first_part = target_route[:split_point+1]\n    second_part = target_route[split_point:]\n\n    # Step 4: Check feasibility of the split parts\n    first_demand = np.sum(demand[first_part[1:-1]])\n    second_demand = np.sum(demand[second_part[1:-1]])\n\n    if first_demand <= capacity and second_demand <= capacity:\n        # Replace the original route with the two new routes\n        new_solution = [r.copy() for r in selected_solution if not np.array_equal(r, target_route)]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, perform a demand-aware 2-opt swap within the route\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(range(1, len(target_route)-1), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j to reduce distance and potentially makespan\n        new_route = np.concatenate([target_route[:i], target_route[i:j+1][::-1], target_route[j+1:]])\n        # Check feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7473801156716444,
            1.0520524084568024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Step 2: Choose a route to modify (select the longest route to prioritize makespan reduction)\n    longest_route_idx = np.argmax([np.sum([distance_matrix[int(selected_solution[r][i]), int(selected_solution[r][i+1])] for i in range(len(selected_solution[r])-1)]) for r in range(len(selected_solution))])\n    target_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Split the route into two parts at a random point (to create new routes)\n    split_point = np.random.randint(1, len(target_route)-2)\n    first_part = target_route[:split_point+1]\n    second_part = target_route[split_point:]\n\n    # Step 4: Check feasibility of the split parts\n    first_demand = np.sum(demand[first_part[1:-1]])\n    second_demand = np.sum(demand[second_part[1:-1]])\n\n    if first_demand <= capacity and second_demand <= capacity:\n        # Replace the original route with the two new routes\n        new_solution = [r.copy() for r in selected_solution if not np.array_equal(r, target_route)]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, perform a demand-aware 2-opt swap within the route\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(range(1, len(target_route)-1), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j to reduce distance and potentially makespan\n        new_route = np.concatenate([target_route[:i], target_route[i:j+1][::-1], target_route[j+1:]])\n        # Check feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining route splitting, customer reallocation, and multi-segment swapping to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1 / (obj[1] + 1e-6)) * obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Split long routes if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Not just depot-depot\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Reallocate customers between routes\n    all_customers = set(np.arange(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unassigned = list(all_customers - served_customers)\n\n    for customer in unassigned:\n        best_route = None\n        best_improvement = float('inf')\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for j in range(1, len(route)):\n                new_route = np.concatenate([route[:j], [customer], route[j:]])\n                if is_feasible(new_route):\n                    # Calculate improvement (distance reduction)\n                    original_dist = distance_matrix[route[j-1], route[j]]\n                    new_dist = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]]\n                    improvement = new_dist - original_dist\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_route = (i, j, new_route)\n        if best_route:\n            i, j, new_route = best_route\n            new_solution[i] = new_route\n\n    # Step 3: Multi-segment swapping between routes\n    for _ in range(2):  # Perform multiple swaps\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select random segments\n        seg1_start = np.random.randint(1, len(route1)-1)\n        seg1_end = np.random.randint(seg1_start, len(route1))\n        seg2_start = np.random.randint(1, len(route2)-1)\n        seg2_end = np.random.randint(seg2_start, len(route2))\n\n        # Create new routes\n        new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end], route1[seg1_end:]])\n        new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end], route2[seg2_end:]])\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8258975291233287,
            2.772285580635071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(1 / (obj[1] + 1e-6)) * obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Split long routes if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Not just depot-depot\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Reallocate customers between routes\n    all_customers = set(np.arange(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unassigned = list(all_customers - served_customers)\n\n    for customer in unassigned:\n        best_route = None\n        best_improvement = float('inf')\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            for j in range(1, len(route)):\n                new_route = np.concatenate([route[:j], [customer], route[j:]])\n                if is_feasible(new_route):\n                    # Calculate improvement (distance reduction)\n                    original_dist = distance_matrix[route[j-1], route[j]]\n                    new_dist = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]]\n                    improvement = new_dist - original_dist\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_route = (i, j, new_route)\n        if best_route:\n            i, j, new_route = best_route\n            new_solution[i] = new_route\n\n    # Step 3: Multi-segment swapping between routes\n    for _ in range(2):  # Perform multiple swaps\n        route1_idx = np.random.randint(len(new_solution))\n        route2_idx = np.random.randint(len(new_solution))\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select random segments\n        seg1_start = np.random.randint(1, len(route1)-1)\n        seg1_end = np.random.randint(seg1_start, len(route1))\n        seg2_start = np.random.randint(1, len(route2)-1)\n        seg2_end = np.random.randint(seg2_start, len(route2))\n\n        # Create new routes\n        new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end], route1[seg1_end:]])\n        new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end], route2[seg2_end:]])\n\n        if is_feasible(new_route1) and is_feasible(new_route2):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging and partial 2-opt\n    new_solution = []\n    routes = [route.copy() for route in base_solution]\n\n    # Try merging adjacent routes if they don't exceed capacity\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(routes) - 1):\n            if i + 1 >= len(routes):\n                break\n            route1, route2 = routes[i], routes[i+1]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting the last customer of route1 to the first customer of route2\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                routes[i] = merged_route\n                routes.pop(i+1)\n                merged = True\n                break\n\n    # Apply partial 2-opt within each route to reduce distance\n    for i in range(len(routes)):\n        route = routes[i]\n        customers = route[1:-1]\n        n = len(customers)\n\n        if n < 2:\n            new_solution.append(route)\n            continue\n\n        # Select a random segment to optimize\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = customers[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Check capacity constraint\n        if sum(demand[reversed_segment]) <= capacity:\n            new_route = np.concatenate([route[:a+1], reversed_segment, route[b+2:]])\n            routes[i] = new_route\n\n    new_solution = [route for route in routes if len(route) > 2]  # Remove empty routes\n\n    # If no improvement, return original solution\n    if not new_solution:\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5727281605514818,
            1.8291697204113007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route merging and partial 2-opt\n    new_solution = []\n    routes = [route.copy() for route in base_solution]\n\n    # Try merging adjacent routes if they don't exceed capacity\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(routes) - 1):\n            if i + 1 >= len(routes):\n                break\n            route1, route2 = routes[i], routes[i+1]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting the last customer of route1 to the first customer of route2\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                routes[i] = merged_route\n                routes.pop(i+1)\n                merged = True\n                break\n\n    # Apply partial 2-opt within each route to reduce distance\n    for i in range(len(routes)):\n        route = routes[i]\n        customers = route[1:-1]\n        n = len(customers)\n\n        if n < 2:\n            new_solution.append(route)\n            continue\n\n        # Select a random segment to optimize\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = customers[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Check capacity constraint\n        if sum(demand[reversed_segment]) <= capacity:\n            new_route = np.concatenate([route[:a+1], reversed_segment, route[b+2:]])\n            routes[i] = new_route\n\n    new_solution = [route for route in routes if len(route) > 2]  # Remove empty routes\n\n    # If no improvement, return original solution\n    if not new_solution:\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search that combines route splitting, customer reallocation, and cross-route insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and cross-route insertion\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Reallocate customers from part2 to other routes or new routes\n        temp_route = part1.copy()\n        remaining_customers = part2[1:-1]\n\n        # Try to insert remaining customers into existing routes\n        inserted = []\n        for customer in remaining_customers:\n            inserted_customer = False\n            for i, r in enumerate(new_solution):\n                if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(r)):\n                        cost = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert the customer\n                    new_route = np.concatenate([r[:best_pos], [customer], r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted_customer = True\n                    break\n            if not inserted_customer:\n                inserted.append(customer)\n\n        # If any customers couldn't be inserted, create a new route\n        if inserted:\n            new_route = np.concatenate([[0], inserted, [0]])\n            new_solution.append(new_route)\n\n        # Add the modified part1 route\n        new_solution.append(temp_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to new routes\n    while missing_customers:\n        new_route = [0]\n        current_load = 0\n        for customer in list(missing_customers):\n            if current_load + demand[customer] <= capacity:\n                new_route.append(customer)\n                current_load += demand[customer]\n                missing_customers.remove(customer)\n        new_route.append(0)\n        new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
        "score": [
            -0.8198959250277444,
            3.7972024977207184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: route splitting, customer reallocation, and cross-route insertion\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Reallocate customers from part2 to other routes or new routes\n        temp_route = part1.copy()\n        remaining_customers = part2[1:-1]\n\n        # Try to insert remaining customers into existing routes\n        inserted = []\n        for customer in remaining_customers:\n            inserted_customer = False\n            for i, r in enumerate(new_solution):\n                if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(r)):\n                        cost = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert the customer\n                    new_route = np.concatenate([r[:best_pos], [customer], r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted_customer = True\n                    break\n            if not inserted_customer:\n                inserted.append(customer)\n\n        # If any customers couldn't be inserted, create a new route\n        if inserted:\n            new_route = np.concatenate([[0], inserted, [0]])\n            new_solution.append(new_route)\n\n        # Add the modified part1 route\n        new_solution.append(temp_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to new routes\n    while missing_customers:\n        new_route = [0]\n        current_load = 0\n        for customer in list(missing_customers):\n            if current_load + demand[customer] <= capacity:\n                new_route.append(customer)\n                current_load += demand[customer]\n                missing_customers.remove(customer)\n        new_route.append(0)\n        new_solution.append(np.array(new_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to decompose (if it has more than 3 nodes)\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Split the route into two parts\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n\n            # Check capacity constraints for the new routes\n            def is_valid(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if not is_valid(new_route1) or not is_valid(new_route2):\n                # If invalid, revert the split\n                new_solution.pop(route_idx + 1)\n                new_solution[route_idx] = selected_route\n\n    # Apply insertion heuristic to improve distance and makespan\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two nodes to swap (excluding depot)\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            node_i, node_j = route[i], route[j]\n\n            # Check if swapping improves distance\n            original_dist = distance_matrix[route[i-1], node_i] + distance_matrix[node_i, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_j] + distance_matrix[node_j, route[j+1]]\n            new_dist = distance_matrix[route[i-1], node_j] + distance_matrix[node_j, route[i+1]] + \\\n                      distance_matrix[route[j-1], node_i] + distance_matrix[node_i, route[j+1]]\n\n            if new_dist < original_dist:\n                route[i], route[j] = route[j], route[i]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.44261625116127873,
            1.1232611536979675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to decompose (if it has more than 3 nodes)\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Split the route into two parts\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx + 1, new_route2)\n\n            # Check capacity constraints for the new routes\n            def is_valid(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if not is_valid(new_route1) or not is_valid(new_route2):\n                # If invalid, revert the split\n                new_solution.pop(route_idx + 1)\n                new_solution[route_idx] = selected_route\n\n    # Apply insertion heuristic to improve distance and makespan\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two nodes to swap (excluding depot)\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            node_i, node_j = route[i], route[j]\n\n            # Check if swapping improves distance\n            original_dist = distance_matrix[route[i-1], node_i] + distance_matrix[node_i, route[i+1]] + \\\n                           distance_matrix[route[j-1], node_j] + distance_matrix[node_j, route[j+1]]\n            new_dist = distance_matrix[route[i-1], node_j] + distance_matrix[node_j, route[i+1]] + \\\n                      distance_matrix[route[j-1], node_i] + distance_matrix[node_i, route[j+1]]\n\n            if new_dist < original_dist:\n                route[i], route[j] = route[j], route[i]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection considering both objectives, then applies a hybrid local search combining route splitting, customer reinsertion, and a novel \"demand-aware\" 2-opt variant to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_sum = sum(obj[0] for _, obj in archive)\n    makespan_sum = sum(obj[1] for _, obj in archive)\n\n    weights = []\n    for sol, obj in archive:\n        # Weight based on normalized inverse objectives (prefer solutions with better trade-offs)\n        norm_dist = obj[0] / total_distance_sum if total_distance_sum > 0 else 1\n        norm_makespan = obj[1] / makespan_sum if makespan_sum > 0 else 1\n        weight = 1 / (norm_dist + norm_makespan + 1e-6)  # Small epsilon to avoid division by zero\n        weights.append(weight)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split the longest route)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution.pop(longest_route_idx)\n\n        # Find a split point that balances demand and distance\n        total_demand = sum(demand[node] for node in longest_route[1:-1])\n        split_demand = 0\n        split_point = len(longest_route) // 2\n\n        for i in range(1, len(longest_route)-1):\n            split_demand += demand[longest_route[i]]\n            if split_demand > total_demand / 2:\n                split_point = i\n                break\n\n        route1 = np.concatenate([longest_route[:split_point+1], [0]])\n        route2 = np.concatenate([[0], longest_route[split_point+1:]])\n\n        # Check capacity constraints\n        if sum(demand[node] for node in route1[1:-1]) <= capacity and sum(demand[node] for node in route2[1:-1]) <= capacity:\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Step 2: Demand-aware 2-opt variant (consider both distance and demand)\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough customers\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n\n            # Check demand compatibility before swapping\n            segment1 = route[i:j+1]\n            segment2 = route[j:i-1:-1]  # Reverse segment\n\n            # Calculate demand of segments\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            # Only swap if demand is compatible with capacity\n            if demand1 <= capacity and demand2 <= capacity:\n                new_route = np.concatenate([route[:i], segment2, route[j+1:]])\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    route[:] = new_route\n\n    # Step 3: Customer reinsertion (move customers between routes)\n    if len(new_solution) > 1:\n        # Select a random customer from a random route (excluding depot)\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Only if route has customers\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n            if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert into another route\n                other_route_idx = (route_idx + 1) % len(new_solution)\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_cost_increase = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    # Calculate cost increase for insertion\n                    cost_increase = (distance_matrix[other_route[pos-1], customer] +\n                                    distance_matrix[customer, other_route[pos]] -\n                                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if cost_increase < min_cost_increase and sum(demand[node] for node in other_route[1:-1]) + demand[customer] <= capacity:\n                        min_cost_increase = cost_increase\n                        best_pos = pos\n\n                # Insert customer\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.7959313592473363,
            2.254700720310211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_sum = sum(obj[0] for _, obj in archive)\n    makespan_sum = sum(obj[1] for _, obj in archive)\n\n    weights = []\n    for sol, obj in archive:\n        # Weight based on normalized inverse objectives (prefer solutions with better trade-offs)\n        norm_dist = obj[0] / total_distance_sum if total_distance_sum > 0 else 1\n        norm_makespan = obj[1] / makespan_sum if makespan_sum > 0 else 1\n        weight = 1 / (norm_dist + norm_makespan + 1e-6)  # Small epsilon to avoid division by zero\n        weights.append(weight)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split the longest route)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution.pop(longest_route_idx)\n\n        # Find a split point that balances demand and distance\n        total_demand = sum(demand[node] for node in longest_route[1:-1])\n        split_demand = 0\n        split_point = len(longest_route) // 2\n\n        for i in range(1, len(longest_route)-1):\n            split_demand += demand[longest_route[i]]\n            if split_demand > total_demand / 2:\n                split_point = i\n                break\n\n        route1 = np.concatenate([longest_route[:split_point+1], [0]])\n        route2 = np.concatenate([[0], longest_route[split_point+1:]])\n\n        # Check capacity constraints\n        if sum(demand[node] for node in route1[1:-1]) <= capacity and sum(demand[node] for node in route2[1:-1]) <= capacity:\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Step 2: Demand-aware 2-opt variant (consider both distance and demand)\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough customers\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n\n            # Check demand compatibility before swapping\n            segment1 = route[i:j+1]\n            segment2 = route[j:i-1:-1]  # Reverse segment\n\n            # Calculate demand of segments\n            demand1 = sum(demand[node] for node in segment1)\n            demand2 = sum(demand[node] for node in segment2)\n\n            # Only swap if demand is compatible with capacity\n            if demand1 <= capacity and demand2 <= capacity:\n                new_route = np.concatenate([route[:i], segment2, route[j+1:]])\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    route[:] = new_route\n\n    # Step 3: Customer reinsertion (move customers between routes)\n    if len(new_solution) > 1:\n        # Select a random customer from a random route (excluding depot)\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Only if route has customers\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n            if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert into another route\n                other_route_idx = (route_idx + 1) % len(new_solution)\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_cost_increase = float('inf')\n\n                for pos in range(1, len(other_route)):\n                    # Calculate cost increase for insertion\n                    cost_increase = (distance_matrix[other_route[pos-1], customer] +\n                                    distance_matrix[customer, other_route[pos]] -\n                                    distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if cost_increase < min_cost_increase and sum(demand[node] for node in other_route[1:-1]) + demand[customer] <= capacity:\n                        min_cost_increase = cost_increase\n                        best_pos = pos\n\n                # Insert customer\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A hybrid local search strategy that combines route segmentation, demand-aware relocation, and distance-based swaps to intelligently improve both total distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Segment the route into parts and attempt demand-aware relocation\n        if len(route) > 3:  # Ensure route has enough nodes to segment\n            split_pos = random.randint(1, len(route) - 2)\n            segment1 = route[:split_pos + 1]\n            segment2 = route[split_pos:]\n\n            # Try relocating a segment to another route or within the same route\n            if len(new_solution) > 1 and random.random() < 0.5:\n                # Relocate to another route\n                target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx].copy()\n\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment1[1:-1])\n                target_route_demand = sum(demand[node] for node in target_route[1:-1]) + segment_demand\n                if target_route_demand <= capacity:\n                    # Insert segment into target route\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_target_route = np.concatenate([\n                        target_route[:insert_pos],\n                        segment1[1:-1],\n                        target_route[insert_pos:]\n                    ])\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[route_idx] = np.concatenate([segment2, [0]])\n\n                    # Remove empty routes\n                    new_solution = [r for r in new_solution if len(r) > 2]\n            else:\n                # Relocate within the same route\n                new_route = np.concatenate([segment2, segment1[1:-1]])\n                new_solution[route_idx] = new_route\n\n        # Perform distance-based swaps for further improvement\n        if len(route) > 3:\n            i = random.randint(1, len(route) - 2)\n            j = random.randint(1, len(route) - 2)\n            if i != j:\n                # Swap nodes i and j\n                new_route = route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, split the route into two\n            split_pos = 1\n            current_demand = 0\n            for pos in range(1, len(route) - 1):\n                current_demand += demand[route[pos]]\n                if current_demand > capacity:\n                    split_pos = pos\n                    break\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.3184207320890449,
            0.8388261198997498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Segment the route into parts and attempt demand-aware relocation\n        if len(route) > 3:  # Ensure route has enough nodes to segment\n            split_pos = random.randint(1, len(route) - 2)\n            segment1 = route[:split_pos + 1]\n            segment2 = route[split_pos:]\n\n            # Try relocating a segment to another route or within the same route\n            if len(new_solution) > 1 and random.random() < 0.5:\n                # Relocate to another route\n                target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                target_route = new_solution[target_route_idx].copy()\n\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment1[1:-1])\n                target_route_demand = sum(demand[node] for node in target_route[1:-1]) + segment_demand\n                if target_route_demand <= capacity:\n                    # Insert segment into target route\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_target_route = np.concatenate([\n                        target_route[:insert_pos],\n                        segment1[1:-1],\n                        target_route[insert_pos:]\n                    ])\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[route_idx] = np.concatenate([segment2, [0]])\n\n                    # Remove empty routes\n                    new_solution = [r for r in new_solution if len(r) > 2]\n            else:\n                # Relocate within the same route\n                new_route = np.concatenate([segment2, segment1[1:-1]])\n                new_solution[route_idx] = new_route\n\n        # Perform distance-based swaps for further improvement\n        if len(route) > 3:\n            i = random.randint(1, len(route) - 2)\n            j = random.randint(1, len(route) - 2)\n            if i != j:\n                # Swap nodes i and j\n                new_route = route.copy()\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, split the route into two\n            split_pos = 1\n            current_demand = 0\n            for pos in range(1, len(route) - 1):\n                current_demand += demand[route[pos]]\n                if current_demand > capacity:\n                    split_pos = pos\n                    break\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route1\n            new_solution.insert(i + 1, new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting and merging\n    if len(route) > 4:  # Only if the route has enough nodes to perform 2-opt\n        # Perform 2-opt on the route\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:  # Ensure capacity constraint\n            selected_solution[route_idx] = new_route\n    else:\n        # If the route is too short for 2-opt, try to split or merge with another route\n        if len(selected_solution) > 1:\n            # Merge with another route\n            other_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_idx].copy()\n            if np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([route[:-1], other_route[1:]])\n                selected_solution = [r for i, r in enumerate(selected_solution) if i != route_idx and i != other_idx] + [merged_route]\n            else:\n                # If merging is not possible, try splitting the route\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    selected_solution = [r for i, r in enumerate(selected_solution) if i != route_idx] + [new_route1, new_route2]\n\n    return selected_solution\n\n",
        "score": [
            -0.5606372830400698,
            0.7154930531978607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine 2-opt with route splitting and merging\n    if len(route) > 4:  # Only if the route has enough nodes to perform 2-opt\n        # Perform 2-opt on the route\n        i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:  # Ensure capacity constraint\n            selected_solution[route_idx] = new_route\n    else:\n        # If the route is too short for 2-opt, try to split or merge with another route\n        if len(selected_solution) > 1:\n            # Merge with another route\n            other_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_idx].copy()\n            if np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate([route[:-1], other_route[1:]])\n                selected_solution = [r for i, r in enumerate(selected_solution) if i != route_idx and i != other_idx] + [merged_route]\n            else:\n                # If merging is not possible, try splitting the route\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    selected_solution = [r for i, r in enumerate(selected_solution) if i != route_idx] + [new_route1, new_route2]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route swaps, segment inversions, and demand-balanced route splits to generate a feasible neighbor solution while improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route swaps, segment inversions, and demand-balanced splits\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes for potential swap or split\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Option 1: Swap entire routes if feasible\n        if (np.sum(demand[route2[1:-1]]) <= capacity and\n            np.sum(demand[route1[1:-1]]) <= capacity):\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n\n        # Option 2: Split and merge segments between routes\n        else:\n            # Find split points in both routes (avoiding depot)\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Create new segments\n            seg1 = route1[:split1+1]\n            seg2 = route1[split1:]\n            seg3 = route2[:split2+1]\n            seg4 = route2[split2:]\n\n            # Try merging segments in different ways\n            temp_solution = new_solution.copy()\n            temp_solution[route1_idx] = np.concatenate([seg1, seg4])\n            temp_solution[route2_idx] = np.concatenate([seg3, seg2])\n\n            # Check feasibility\n            if (np.sum(demand[temp_solution[route1_idx][1:-1]]) <= capacity and\n                np.sum(demand[temp_solution[route2_idx][1:-1]]) <= capacity):\n                new_solution = temp_solution\n\n    # Step 2: Apply segment inversion to reduce distance\n    for route in new_solution:\n        if len(route) > 3:  # Only invert if route has enough nodes\n            start, end = sorted(random.sample(range(1, len(route)-1), 2))\n            route[start:end+1] = route[start:end+1][::-1]\n\n    # Step 3: Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3 and np.sum(demand[route[1:-1]]) > capacity * 0.7:  # If route is over 70% capacity\n            # Find split point that balances demand\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n            # Create new route\n            new_route = np.concatenate([route[:split_pos+1], [0]])\n            new_solution[i] = np.concatenate([route[:split_pos+1], [0]])\n            new_solution.insert(i+1, np.concatenate([[0], route[split_pos+1:], [0]]))\n\n    return new_solution\n\n",
        "score": [
            -0.7683489576058923,
            1.390491545200348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route swaps, segment inversions, and demand-balanced splits\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes for potential swap or split\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Option 1: Swap entire routes if feasible\n        if (np.sum(demand[route2[1:-1]]) <= capacity and\n            np.sum(demand[route1[1:-1]]) <= capacity):\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n\n        # Option 2: Split and merge segments between routes\n        else:\n            # Find split points in both routes (avoiding depot)\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Create new segments\n            seg1 = route1[:split1+1]\n            seg2 = route1[split1:]\n            seg3 = route2[:split2+1]\n            seg4 = route2[split2:]\n\n            # Try merging segments in different ways\n            temp_solution = new_solution.copy()\n            temp_solution[route1_idx] = np.concatenate([seg1, seg4])\n            temp_solution[route2_idx] = np.concatenate([seg3, seg2])\n\n            # Check feasibility\n            if (np.sum(demand[temp_solution[route1_idx][1:-1]]) <= capacity and\n                np.sum(demand[temp_solution[route2_idx][1:-1]]) <= capacity):\n                new_solution = temp_solution\n\n    # Step 2: Apply segment inversion to reduce distance\n    for route in new_solution:\n        if len(route) > 3:  # Only invert if route has enough nodes\n            start, end = sorted(random.sample(range(1, len(route)-1), 2))\n            route[start:end+1] = route[start:end+1][::-1]\n\n    # Step 3: Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3 and np.sum(demand[route[1:-1]]) > capacity * 0.7:  # If route is over 70% capacity\n            # Find split point that balances demand\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n            # Create new route\n            new_route = np.concatenate([route[:split_pos+1], [0]])\n            new_solution[i] = np.concatenate([route[:split_pos+1], [0]])\n            new_solution.insert(i+1, np.concatenate([[0], route[split_pos+1:], [0]]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a split point\n        split_pos = np.random.randint(1, len(route) - 1)\n        split_node = route[split_pos]\n\n        # Check if splitting the route into two parts is feasible\n        first_part = route[:split_pos + 1]\n        second_part = [0] + route[split_pos + 1:]\n\n        # Check capacity constraints for both parts\n        first_demand = sum(demand[node] for node in first_part if node != 0)\n        second_demand = sum(demand[node] for node in second_part if node != 0)\n\n        if first_demand <= capacity and second_demand <= capacity:\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n\n    # Rebalance routes by moving customers between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        # Randomly select a customer to move\n        move_pos = np.random.randint(1, len(route) - 1)\n        move_node = route[move_pos]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            target_route = new_solution[j]\n            # Find the best insertion position in the target route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for k in range(1, len(target_route)):\n                # Insert move_node between target_route[k-1] and target_route[k]\n                cost = distance_matrix[target_route[k-1], move_node] + distance_matrix[move_node, target_route[k]] - distance_matrix[target_route[k-1], target_route[k]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = k\n\n            # Check capacity constraint\n            current_demand = sum(demand[node] for node in target_route if node != 0)\n            if current_demand + demand[move_node] <= capacity:\n                # Perform the move\n                route = np.delete(route, move_pos)\n                new_solution[i] = route\n\n                target_route = np.insert(target_route, best_pos, move_node)\n                new_solution[j] = target_route\n\n                break  # Move one customer at a time\n\n    return new_solution\n\n",
        "score": [
            -0.6074808069684239,
            6.107549756765366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Randomly select a split point\n        split_pos = np.random.randint(1, len(route) - 1)\n        split_node = route[split_pos]\n\n        # Check if splitting the route into two parts is feasible\n        first_part = route[:split_pos + 1]\n        second_part = [0] + route[split_pos + 1:]\n\n        # Check capacity constraints for both parts\n        first_demand = sum(demand[node] for node in first_part if node != 0)\n        second_demand = sum(demand[node] for node in second_part if node != 0)\n\n        if first_demand <= capacity and second_demand <= capacity:\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n\n    # Rebalance routes by moving customers between routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 2:  # Skip empty or single-customer routes\n            continue\n\n        # Randomly select a customer to move\n        move_pos = np.random.randint(1, len(route) - 1)\n        move_node = route[move_pos]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            target_route = new_solution[j]\n            # Find the best insertion position in the target route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for k in range(1, len(target_route)):\n                # Insert move_node between target_route[k-1] and target_route[k]\n                cost = distance_matrix[target_route[k-1], move_node] + distance_matrix[move_node, target_route[k]] - distance_matrix[target_route[k-1], target_route[k]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = k\n\n            # Check capacity constraint\n            current_demand = sum(demand[node] for node in target_route if node != 0)\n            if current_demand + demand[move_node] <= capacity:\n                # Perform the move\n                route = np.delete(route, move_pos)\n                new_solution[i] = route\n\n                target_route = np.insert(target_route, best_pos, move_node)\n                new_solution[j] = target_route\n\n                break  # Move one customer at a time\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower total distance or makespan, then applies a hybrid local search combining route merging, customer reallocation, and adaptive 2-opt to reduce both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and adaptive 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Merging - Try to merge two routes if their total demand fits capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Customer Reallocation - Move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        source_route_idx = random.choice(range(len(new_solution)))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure route has customers to move\n            customer_to_move = random.choice(source_route[1:-1])\n            for target_route_idx, target_route in enumerate(new_solution):\n                if target_route_idx != source_route_idx:\n                    # Check if adding customer to target route is feasible\n                    if sum(demand[target_route[1:-1]]) + demand[customer_to_move] <= capacity:\n                        # Find best insertion point in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(target_route)):\n                            cost = (distance_matrix[target_route[pos-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][target_route[pos]] -\n                                    distance_matrix[target_route[pos-1]][target_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        # Insert customer and update routes\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move))\n                        new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                        new_solution[source_route_idx] = new_source_route\n                        new_solution[target_route_idx] = new_target_route\n                        break\n\n    # Step 3: Adaptive 2-opt - Apply 2-opt to routes with high individual distance\n    for route_idx, route in enumerate(new_solution):\n        if len(route) > 4:  # Only apply if route has enough customers\n            # Find the segment with highest distance\n            max_dist = -1\n            max_i = 1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            # Apply 2-opt on this segment\n            new_route = route.copy()\n            new_route[max_i:max_i+2] = new_route[max_i+1], new_route[max_i]\n            # Check feasibility (no capacity issues as we're only reordering)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5128047462529729,
            1.301836609840393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and adaptive 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Merging - Try to merge two routes if their total demand fits capacity\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Customer Reallocation - Move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        source_route_idx = random.choice(range(len(new_solution)))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure route has customers to move\n            customer_to_move = random.choice(source_route[1:-1])\n            for target_route_idx, target_route in enumerate(new_solution):\n                if target_route_idx != source_route_idx:\n                    # Check if adding customer to target route is feasible\n                    if sum(demand[target_route[1:-1]]) + demand[customer_to_move] <= capacity:\n                        # Find best insertion point in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(target_route)):\n                            cost = (distance_matrix[target_route[pos-1]][customer_to_move] +\n                                    distance_matrix[customer_to_move][target_route[pos]] -\n                                    distance_matrix[target_route[pos-1]][target_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        # Insert customer and update routes\n                        new_source_route = np.delete(source_route, np.where(source_route == customer_to_move))\n                        new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                        new_solution[source_route_idx] = new_source_route\n                        new_solution[target_route_idx] = new_target_route\n                        break\n\n    # Step 3: Adaptive 2-opt - Apply 2-opt to routes with high individual distance\n    for route_idx, route in enumerate(new_solution):\n        if len(route) > 4:  # Only apply if route has enough customers\n            # Find the segment with highest distance\n            max_dist = -1\n            max_i = 1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            # Apply 2-opt on this segment\n            new_route = route.copy()\n            new_route[max_i:max_i+2] = new_route[max_i+1], new_route[max_i]\n            # Check feasibility (no capacity issues as we're only reordering)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: Route Swap + 2-Opt* with Capacity Check\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two distinct routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = np.random.choice(len(new_solution), 2, replace=False)\n    route1_idx, route2_idx = route_indices\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Step 2: Randomly select a segment from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select a segment from route1\n    start1 = np.random.randint(1, len(route1) - 1)\n    end1 = np.random.randint(start1, len(route1))\n    segment1 = route1[start1:end1]\n\n    # Select a segment from route2\n    start2 = np.random.randint(1, len(route2) - 1)\n    end2 = np.random.randint(start2, len(route2))\n    segment2 = route2[start2:end2]\n\n    # Step 3: Check capacity constraints for the new segments\n    def check_capacity(segment, demand):\n        total = sum(demand[node] for node in segment)\n        return total <= capacity\n\n    if not (check_capacity(segment1, demand) and check_capacity(segment2, demand)):\n        return new_solution\n\n    # Step 4: Swap the segments between routes\n    new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n    new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n    # Step 5: Apply 2-Opt* within each new route to improve locally\n    def two_opt_star(route, distance_matrix):\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route) - 1):\n                    # Check if reversing the segment improves distance\n                    original_dist = (distance_matrix[route[i-1], route[i]] +\n                                    distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_dist < original_dist:\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        return route\n\n    new_route1 = two_opt_star(new_route1, distance_matrix)\n    new_route2 = two_opt_star(new_route2, distance_matrix)\n\n    # Step 6: Update the solution\n    new_solution[route1_idx] = new_route1\n    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.47705833882317444,
            3.112519085407257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: Route Swap + 2-Opt* with Capacity Check\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two distinct routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = np.random.choice(len(new_solution), 2, replace=False)\n    route1_idx, route2_idx = route_indices\n    route1 = new_solution[route1_idx].copy()\n    route2 = new_solution[route2_idx].copy()\n\n    # Step 2: Randomly select a segment from each route (excluding depot)\n    if len(route1) <= 2 or len(route2) <= 2:\n        return new_solution\n\n    # Select a segment from route1\n    start1 = np.random.randint(1, len(route1) - 1)\n    end1 = np.random.randint(start1, len(route1))\n    segment1 = route1[start1:end1]\n\n    # Select a segment from route2\n    start2 = np.random.randint(1, len(route2) - 1)\n    end2 = np.random.randint(start2, len(route2))\n    segment2 = route2[start2:end2]\n\n    # Step 3: Check capacity constraints for the new segments\n    def check_capacity(segment, demand):\n        total = sum(demand[node] for node in segment)\n        return total <= capacity\n\n    if not (check_capacity(segment1, demand) and check_capacity(segment2, demand)):\n        return new_solution\n\n    # Step 4: Swap the segments between routes\n    new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n    new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n    # Step 5: Apply 2-Opt* within each new route to improve locally\n    def two_opt_star(route, distance_matrix):\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route) - 1):\n                    # Check if reversing the segment improves distance\n                    original_dist = (distance_matrix[route[i-1], route[i]] +\n                                    distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_dist < original_dist:\n                        route[i:j+1] = route[i:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n        return route\n\n    new_route1 = two_opt_star(new_route1, distance_matrix)\n    new_route2 = two_opt_star(new_route2, distance_matrix)\n\n    # Step 6: Update the solution\n    new_solution[route1_idx] = new_route1\n    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search operator that combines route splitting, merging, and demand-aware node swaps to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 8:  # Arbitrary threshold for splitting\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Route merging (if two routes are short)\n    for i in range(len(new_solution)-1):\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        if len(route1) < 5 and len(route2) < 5:  # Arbitrary threshold for merging\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if is_feasible(merged_route):\n                new_solution[i] = merged_route\n                del new_solution[i+1]\n                break\n\n    # Step 3: Demand-aware node swap\n    for _ in range(3):  # Try 3 times\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            pos1, pos2 = random.sample(range(1, len(route)-1), 2)\n            new_route = route.copy()\n            new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n                break\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.8495857821506059,
            0.3910481631755829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 8:  # Arbitrary threshold for splitting\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Route merging (if two routes are short)\n    for i in range(len(new_solution)-1):\n        route1 = new_solution[i]\n        route2 = new_solution[i+1]\n\n        if len(route1) < 5 and len(route2) < 5:  # Arbitrary threshold for merging\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if is_feasible(merged_route):\n                new_solution[i] = merged_route\n                del new_solution[i+1]\n                break\n\n    # Step 3: Demand-aware node swap\n    for _ in range(3):  # Try 3 times\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            pos1, pos2 = random.sample(range(1, len(route)-1), 2)\n            new_route = route.copy()\n            new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n                break\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route merging, insertion-based relocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1 / (1 + obj[0] + obj[1]) for (_, obj) in archive])\n    weights = weights / weights.sum()\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = [route.copy() for route in archive[base_idx][0]]\n\n    # Hybrid local search: merge routes, relocate customers, and perform capacity-aware swaps\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge two routes if the combined capacity is feasible\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            new_solution[r1] = merged_route\n            new_solution.pop(r2)\n\n    # Step 2: Relocate a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure route has at least one customer to relocate\n            customer_pos = random.randint(1, len(src_route) - 2)\n            customer = src_route[customer_pos]\n\n            # Try inserting into a different route\n            for _ in range(3):  # Try up to 3 routes\n                dst_route_idx = random.randint(0, len(new_solution) - 1)\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n\n                # Find best insertion position in destination route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(dst_route)):\n                    new_route = np.insert(dst_route, pos, customer)\n                    total_demand = sum(demand[node] for node in new_route if node != 0)\n                    if total_demand > capacity:\n                        continue\n                    cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_dst_route = np.insert(dst_route, best_pos, customer)\n                    new_src_route = np.delete(src_route, customer_pos)\n                    new_solution[dst_route_idx] = new_dst_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    # Step 3: Perform a capacity-aware 2-opt swap within a route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for a 2-opt swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Check if swap is feasible\n            segment = route[i:j+1]\n            reversed_segment = np.concatenate([[route[i-1]], segment[::-1], [route[j+1]]])\n            total_demand = sum(demand[node] for node in reversed_segment if node != 0)\n\n            if total_demand <= capacity:\n                new_route = np.concatenate([route[:i], segment[::-1], route[j+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5948200513010484,
            3.344955861568451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([1 / (1 + obj[0] + obj[1]) for (_, obj) in archive])\n    weights = weights / weights.sum()\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = [route.copy() for route in archive[base_idx][0]]\n\n    # Hybrid local search: merge routes, relocate customers, and perform capacity-aware swaps\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge two routes if the combined capacity is feasible\n    if len(new_solution) > 1:\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            new_solution[r1] = merged_route\n            new_solution.pop(r2)\n\n    # Step 2: Relocate a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        src_route_idx = random.randint(0, len(new_solution) - 1)\n        src_route = new_solution[src_route_idx]\n        if len(src_route) > 3:  # Ensure route has at least one customer to relocate\n            customer_pos = random.randint(1, len(src_route) - 2)\n            customer = src_route[customer_pos]\n\n            # Try inserting into a different route\n            for _ in range(3):  # Try up to 3 routes\n                dst_route_idx = random.randint(0, len(new_solution) - 1)\n                if dst_route_idx == src_route_idx:\n                    continue\n                dst_route = new_solution[dst_route_idx]\n\n                # Find best insertion position in destination route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(dst_route)):\n                    new_route = np.insert(dst_route, pos, customer)\n                    total_demand = sum(demand[node] for node in new_route if node != 0)\n                    if total_demand > capacity:\n                        continue\n                    cost = distance_matrix[new_route[pos-1], customer] + distance_matrix[customer, new_route[pos+1]] - distance_matrix[new_route[pos-1], new_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_dst_route = np.insert(dst_route, best_pos, customer)\n                    new_src_route = np.delete(src_route, customer_pos)\n                    new_solution[dst_route_idx] = new_dst_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n    # Step 3: Perform a capacity-aware 2-opt swap within a route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for a 2-opt swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Check if swap is feasible\n            segment = route[i:j+1]\n            reversed_segment = np.concatenate([[route[i-1]], segment[::-1], [route[j+1]]])\n            total_demand = sum(demand[node] for node in reversed_segment if node != 0)\n\n            if total_demand <= capacity:\n                new_route = np.concatenate([route[:i], segment[::-1], route[j+1:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to fragment\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Split the route into two segments at a random point (excluding depot)\n    split_pos = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_pos]\n    segment2 = route[split_pos:]\n\n    # Reinsert segments into the solution while respecting capacity\n    def reinsert_segment(segment):\n        best_insertion = None\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue  # Skip the original route\n            route_to_insert = new_solution[i]\n            for pos in range(1, len(route_to_insert)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                if sum(demand[node] for node in route_to_insert) + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                insertion_cost = (\n                    distance_matrix[route_to_insert[pos - 1], segment[0]] +\n                    distance_matrix[segment[-1], route_to_insert[pos]] -\n                    distance_matrix[route_to_insert[pos - 1], route_to_insert[pos]]\n                )\n\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_insertion = (i, pos, segment)\n\n        if best_insertion:\n            i, pos, segment = best_insertion\n            new_solution[i] = np.concatenate([new_solution[i][:pos], segment, new_solution[i][pos:]])\n            return True\n        return False\n\n    # Attempt to reinsert both segments\n    reinserted1 = reinsert_segment(segment1)\n    reinserted2 = reinsert_segment(segment2)\n\n    # If neither segment could be reinserted, try merging with another route\n    if not reinserted1 or not reinserted2:\n        # Find the route with the smallest makespan to merge into\n        target_route_idx = min(\n            range(len(new_solution)),\n            key=lambda i: distance_matrix[new_solution[i][-2], 0] + distance_matrix[0, new_solution[i][1]]\n        )\n        target_route = new_solution[target_route_idx]\n\n        # Merge the segments into the target route if capacity allows\n        if sum(demand[node] for node in segment1) + sum(demand[node] for node in segment2) + sum(demand[node] for node in target_route) <= capacity:\n            new_solution[target_route_idx] = np.concatenate([target_route, segment1, segment2])\n            new_solution.pop(route_idx) if route_idx != target_route_idx else None\n\n    return new_solution\n\n",
        "score": [
            -0.6807445045041773,
            6.792108833789825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to fragment\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Split the route into two segments at a random point (excluding depot)\n    split_pos = np.random.randint(1, len(route) - 1)\n    segment1 = route[:split_pos]\n    segment2 = route[split_pos:]\n\n    # Reinsert segments into the solution while respecting capacity\n    def reinsert_segment(segment):\n        best_insertion = None\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue  # Skip the original route\n            route_to_insert = new_solution[i]\n            for pos in range(1, len(route_to_insert)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                if sum(demand[node] for node in route_to_insert) + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                insertion_cost = (\n                    distance_matrix[route_to_insert[pos - 1], segment[0]] +\n                    distance_matrix[segment[-1], route_to_insert[pos]] -\n                    distance_matrix[route_to_insert[pos - 1], route_to_insert[pos]]\n                )\n\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_insertion = (i, pos, segment)\n\n        if best_insertion:\n            i, pos, segment = best_insertion\n            new_solution[i] = np.concatenate([new_solution[i][:pos], segment, new_solution[i][pos:]])\n            return True\n        return False\n\n    # Attempt to reinsert both segments\n    reinserted1 = reinsert_segment(segment1)\n    reinserted2 = reinsert_segment(segment2)\n\n    # If neither segment could be reinserted, try merging with another route\n    if not reinserted1 or not reinserted2:\n        # Find the route with the smallest makespan to merge into\n        target_route_idx = min(\n            range(len(new_solution)),\n            key=lambda i: distance_matrix[new_solution[i][-2], 0] + distance_matrix[0, new_solution[i][1]]\n        )\n        target_route = new_solution[target_route_idx]\n\n        # Merge the segments into the target route if capacity allows\n        if sum(demand[node] for node in segment1) + sum(demand[node] for node in segment2) + sum(demand[node] for node in target_route) <= capacity:\n            new_solution[target_route_idx] = np.concatenate([target_route, segment1, segment2])\n            new_solution.pop(route_idx) if route_idx != target_route_idx else None\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # Identify the most distant customer in the route (potential for improvement)\n    max_dist = -1\n    swap_candidate = -1\n    for i in range(1, len(route)-1):\n        dist = distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]]\n        if dist > max_dist:\n            max_dist = dist\n            swap_candidate = i\n\n    if swap_candidate != -1:\n        # Find the closest feasible insertion point in another route\n        best_insert_route = -1\n        best_insert_pos = -1\n        min_insert_cost = float('inf')\n\n        for r in range(len(new_solution)):\n            if r == route_idx:\n                continue\n            other_route = new_solution[r]\n            current_load = sum(demand[node] for node in other_route[1:-1])\n\n            for pos in range(1, len(other_route)):\n                # Check capacity constraint\n                if current_load + demand[route[swap_candidate]] <= capacity:\n                    # Calculate insertion cost\n                    insert_cost = (distance_matrix[other_route[pos-1]][route[swap_candidate]] +\n                                 distance_matrix[route[swap_candidate]][other_route[pos]] -\n                                 distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if insert_cost < min_insert_cost:\n                        min_insert_cost = insert_cost\n                        best_insert_route = r\n                        best_insert_pos = pos\n\n        # Perform the swap if feasible\n        if best_insert_route != -1:\n            # Remove from original route\n            removed_node = route[swap_candidate]\n            new_solution[route_idx] = np.concatenate([\n                route[:swap_candidate],\n                route[swap_candidate+1:]\n            ])\n\n            # Insert into new route\n            other_route = new_solution[best_insert_route]\n            new_solution[best_insert_route] = np.concatenate([\n                other_route[:best_insert_pos],\n                [removed_node],\n                other_route[best_insert_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7960208564367537,
            3.2111796140670776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # Identify the most distant customer in the route (potential for improvement)\n    max_dist = -1\n    swap_candidate = -1\n    for i in range(1, len(route)-1):\n        dist = distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]]\n        if dist > max_dist:\n            max_dist = dist\n            swap_candidate = i\n\n    if swap_candidate != -1:\n        # Find the closest feasible insertion point in another route\n        best_insert_route = -1\n        best_insert_pos = -1\n        min_insert_cost = float('inf')\n\n        for r in range(len(new_solution)):\n            if r == route_idx:\n                continue\n            other_route = new_solution[r]\n            current_load = sum(demand[node] for node in other_route[1:-1])\n\n            for pos in range(1, len(other_route)):\n                # Check capacity constraint\n                if current_load + demand[route[swap_candidate]] <= capacity:\n                    # Calculate insertion cost\n                    insert_cost = (distance_matrix[other_route[pos-1]][route[swap_candidate]] +\n                                 distance_matrix[route[swap_candidate]][other_route[pos]] -\n                                 distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                    if insert_cost < min_insert_cost:\n                        min_insert_cost = insert_cost\n                        best_insert_route = r\n                        best_insert_pos = pos\n\n        # Perform the swap if feasible\n        if best_insert_route != -1:\n            # Remove from original route\n            removed_node = route[swap_candidate]\n            new_solution[route_idx] = np.concatenate([\n                route[:swap_candidate],\n                route[swap_candidate+1:]\n            ])\n\n            # Insert into new route\n            other_route = new_solution[best_insert_route]\n            new_solution[best_insert_route] = np.concatenate([\n                other_route[:best_insert_pos],\n                [removed_node],\n                other_route[best_insert_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap customers between routes and reverse partial routes\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reverse\n        start, end = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        reversed_segment = route[start:end+1][::-1]\n        new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n        # Check capacity constraint\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Attempt route swapping between two routes\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Find a feasible swap\n        for k in range(1, len(route_i)-1):\n            for l in range(1, len(route_j)-1):\n                # Swap customers i_k and j_l\n                new_route_i = np.concatenate([route_i[:k], [route_j[l]], route_i[k+1:]])\n                new_route_j = np.concatenate([route_j[:l], [route_i[k]], route_j[l+1:]])\n\n                # Check capacity constraints\n                if (sum(demand[new_route_i[1:-1]]) <= capacity and\n                    sum(demand[new_route_j[1:-1]]) <= capacity):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8038709334542714,
            3.154851347208023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap customers between routes and reverse partial routes\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reverse\n        start, end = sorted(np.random.choice(range(1, len(route)-1), size=2, replace=False))\n        reversed_segment = route[start:end+1][::-1]\n        new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n        # Check capacity constraint\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Attempt route swapping between two routes\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Find a feasible swap\n        for k in range(1, len(route_i)-1):\n            for l in range(1, len(route_j)-1):\n                # Swap customers i_k and j_l\n                new_route_i = np.concatenate([route_i[:k], [route_j[l]], route_i[k+1:]])\n                new_route_j = np.concatenate([route_j[:l], [route_i[k]], route_j[l+1:]])\n\n                # Check capacity constraints\n                if (sum(demand[new_route_i[1:-1]]) <= capacity and\n                    sum(demand[new_route_j[1:-1]]) <= capacity):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This function implements a hybrid local search strategy that combines route fragmentation and intelligent route merging to balance distance and makespan objectives, while ensuring feasibility through capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to fragment\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx]\n\n    # Find a split point that maintains feasibility\n    total_demand = np.sum(demand[selected_route[1:-1]])\n    if total_demand <= capacity:\n        # If route is already optimal, try merging with another route\n        if len(selected_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx]\n\n            # Check if merging is feasible\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[selected_route[1:-1]]) <= capacity:\n                # Merge routes by inserting the selected route into the other route\n                insertion_pos = np.random.randint(1, len(other_route))\n                new_route = np.concatenate([\n                    other_route[:insertion_pos],\n                    selected_route[1:-1],\n                    other_route[insertion_pos:]\n                ])\n                # Remove the original routes and add the new one\n                new_solution = [r for i, r in enumerate(selected_solution) if i not in {route_idx, other_route_idx}]\n                new_solution.append(new_route)\n                return new_solution\n        return selected_solution\n\n    # Fragment the route into two parts\n    split_pos = np.random.randint(1, len(selected_route) - 1)\n    new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n    new_route2 = np.concatenate([[0], selected_route[split_pos:-1]])\n\n    # Check capacity feasibility\n    demand1 = np.sum(demand[new_route1[1:-1]])\n    demand2 = np.sum(demand[new_route2[1:-1]])\n\n    if demand1 <= capacity and demand2 <= capacity:\n        # Replace the original route with the two new routes\n        new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n        new_solution.append(new_route1)\n        new_solution.append(new_route2)\n        return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.8720884680264522,
            0.7340504229068756
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to fragment\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx]\n\n    # Find a split point that maintains feasibility\n    total_demand = np.sum(demand[selected_route[1:-1]])\n    if total_demand <= capacity:\n        # If route is already optimal, try merging with another route\n        if len(selected_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n            other_route = selected_solution[other_route_idx]\n\n            # Check if merging is feasible\n            if np.sum(demand[other_route[1:-1]]) + np.sum(demand[selected_route[1:-1]]) <= capacity:\n                # Merge routes by inserting the selected route into the other route\n                insertion_pos = np.random.randint(1, len(other_route))\n                new_route = np.concatenate([\n                    other_route[:insertion_pos],\n                    selected_route[1:-1],\n                    other_route[insertion_pos:]\n                ])\n                # Remove the original routes and add the new one\n                new_solution = [r for i, r in enumerate(selected_solution) if i not in {route_idx, other_route_idx}]\n                new_solution.append(new_route)\n                return new_solution\n        return selected_solution\n\n    # Fragment the route into two parts\n    split_pos = np.random.randint(1, len(selected_route) - 1)\n    new_route1 = np.concatenate([selected_route[:split_pos + 1], [0]])\n    new_route2 = np.concatenate([[0], selected_route[split_pos:-1]])\n\n    # Check capacity feasibility\n    demand1 = np.sum(demand[new_route1[1:-1]])\n    demand2 = np.sum(demand[new_route2[1:-1]])\n\n    if demand1 <= capacity and demand2 <= capacity:\n        # Replace the original route with the two new routes\n        new_solution = [r for i, r in enumerate(selected_solution) if i != route_idx]\n        new_solution.append(new_route1)\n        new_solution.append(new_route2)\n        return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random split point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split is feasible (demand constraints)\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n            # Rebalance the solution by merging small routes\n            for j in range(len(new_solution)):\n                if len(new_solution[j]) <= 3:  # Small route\n                    # Find the nearest route to merge with\n                    nearest_route = None\n                    min_distance = float('inf')\n                    for k in range(len(new_solution)):\n                        if j != k and len(new_solution[k]) > 3:\n                            # Distance between last node of j and first node of k\n                            dist = distance_matrix[new_solution[j][-2], new_solution[k][1]]\n                            if dist < min_distance:\n                                min_distance = dist\n                                nearest_route = k\n\n                    if nearest_route is not None:\n                        # Merge the small route into the nearest route\n                        merged_route = np.concatenate((new_solution[j][:-1], new_solution[nearest_route][1:]))\n                        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                            new_solution[nearest_route] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.6787861265929046,
            1.4578132927417755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: route splitting and rebalancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random split point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check if the split is feasible (demand constraints)\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n            # Rebalance the solution by merging small routes\n            for j in range(len(new_solution)):\n                if len(new_solution[j]) <= 3:  # Small route\n                    # Find the nearest route to merge with\n                    nearest_route = None\n                    min_distance = float('inf')\n                    for k in range(len(new_solution)):\n                        if j != k and len(new_solution[k]) > 3:\n                            # Distance between last node of j and first node of k\n                            dist = distance_matrix[new_solution[j][-2], new_solution[k][1]]\n                            if dist < min_distance:\n                                min_distance = dist\n                                nearest_route = k\n\n                    if nearest_route is not None:\n                        # Merge the small route into the nearest route\n                        merged_route = np.concatenate((new_solution[j][:-1], new_solution[nearest_route][1:]))\n                        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                            new_solution[nearest_route] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{My algorithm intelligently selects a solution from the archive by prioritizing those with high total distance or makespan, then applies a hybrid local search combining route merging, partial route reversal, and demand-aware node swaps to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Make a deep copy to avoid modifying the original solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if their total demand fits in capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # 2. Partial route reversal: Reverse a segment of a route to potentially reduce distance\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot, one customer, depot)\n            start, end = np.random.choice(range(1, len(route)-1), 2, replace=False)\n            if start > end:\n                start, end = end, start\n            new_solution[route_idx] = np.concatenate([route[:start], route[start:end+1][::-1], route[end+1:]])\n\n    # 3. Demand-aware node swap: Swap customers between routes if capacity allows\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depots)\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check if swapping demands would keep both routes under capacity\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            if (demand1 - demand[cust1] + demand[cust2] <= capacity and\n                demand2 - demand[cust2] + demand[cust1] <= capacity):\n                # Perform the swap\n                idx1 = np.where(route1 == cust1)[0][0]\n                idx2 = np.where(route2 == cust2)[0][0]\n                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    # Ensure all routes remain feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route becomes infeasible, split it into two\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n",
        "score": [
            -0.7692836140296306,
            0.7169490456581116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Make a deep copy to avoid modifying the original solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route merging: Combine two routes if their total demand fits in capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # 2. Partial route reversal: Reverse a segment of a route to potentially reduce distance\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot, one customer, depot)\n            start, end = np.random.choice(range(1, len(route)-1), 2, replace=False)\n            if start > end:\n                start, end = end, start\n            new_solution[route_idx] = np.concatenate([route[:start], route[start:end+1][::-1], route[end+1:]])\n\n    # 3. Demand-aware node swap: Swap customers between routes if capacity allows\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depots)\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n            # Check if swapping demands would keep both routes under capacity\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            if (demand1 - demand[cust1] + demand[cust2] <= capacity and\n                demand2 - demand[cust2] + demand[cust1] <= capacity):\n                # Perform the swap\n                idx1 = np.where(route1 == cust1)[0][0]\n                idx2 = np.where(route2 == cust2)[0][0]\n                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    # Ensure all routes remain feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route becomes infeasible, split it into two\n            split_pos = np.argmax(np.cumsum(demand[route[1:-1]]) > capacity)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search steps\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route Splitting (split long routes into two)\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = [route[0]] + route[split_pos:]\n\n        # Ensure capacity constraints are met\n        def is_valid(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_valid(route1) and is_valid(route2):\n            new_solution.extend([route1, route2])\n            continue\n\n        # Step 2: Customer Reallocation (move customers between routes)\n        if len(selected_solution) > 1:\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Try to insert customer into another route\n                for other_route in selected_solution:\n                    if other_route is route:\n                        continue\n                    # Find insertion points\n                    for j in range(1, len(other_route)):\n                        new_route = other_route.copy()\n                        new_route.insert(j, customer)\n                        if is_valid(new_route):\n                            # Remove from original route\n                            new_route1 = route.copy()\n                            new_route1.remove(customer)\n                            if is_valid(new_route1):\n                                new_solution.extend([new_route1, new_route])\n                                break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                break\n\n        new_solution.append(route.copy())\n\n    # Step 3: Route Merging (merge short routes if possible)\n    if len(new_solution) < len(selected_solution):\n        merged_solution = []\n        used_routes = set()\n\n        for i in range(len(new_solution)):\n            if i in used_routes:\n                continue\n            current_route = new_solution[i].copy()\n\n            for j in range(i + 1, len(new_solution)):\n                if j in used_routes:\n                    continue\n                candidate_route = new_solution[j].copy()\n\n                # Try merging current_route and candidate_route\n                merged = current_route[:-1] + candidate_route[1:]\n                if is_valid(merged):\n                    merged_solution.append(merged)\n                    used_routes.add(j)\n                    break\n            else:\n                merged_solution.append(current_route)\n\n        new_solution = merged_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7183718843637908,
            0.49821263551712036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search steps\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route Splitting (split long routes into two)\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = [route[0]] + route[split_pos:]\n\n        # Ensure capacity constraints are met\n        def is_valid(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if is_valid(route1) and is_valid(route2):\n            new_solution.extend([route1, route2])\n            continue\n\n        # Step 2: Customer Reallocation (move customers between routes)\n        if len(selected_solution) > 1:\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                # Try to insert customer into another route\n                for other_route in selected_solution:\n                    if other_route is route:\n                        continue\n                    # Find insertion points\n                    for j in range(1, len(other_route)):\n                        new_route = other_route.copy()\n                        new_route.insert(j, customer)\n                        if is_valid(new_route):\n                            # Remove from original route\n                            new_route1 = route.copy()\n                            new_route1.remove(customer)\n                            if is_valid(new_route1):\n                                new_solution.extend([new_route1, new_route])\n                                break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                break\n\n        new_solution.append(route.copy())\n\n    # Step 3: Route Merging (merge short routes if possible)\n    if len(new_solution) < len(selected_solution):\n        merged_solution = []\n        used_routes = set()\n\n        for i in range(len(new_solution)):\n            if i in used_routes:\n                continue\n            current_route = new_solution[i].copy()\n\n            for j in range(i + 1, len(new_solution)):\n                if j in used_routes:\n                    continue\n                candidate_route = new_solution[j].copy()\n\n                # Try merging current_route and candidate_route\n                merged = current_route[:-1] + candidate_route[1:]\n                if is_valid(merged):\n                    merged_solution.append(merged)\n                    used_routes.add(j)\n                    break\n            else:\n                merged_solution.append(current_route)\n\n        new_solution = merged_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{A novel hybrid local search operator combines route merging, customer reallocation, and adaptive 3-opt moves to improve both total distance and makespan by intelligently balancing route length and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with high total distance and high makespan (potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them at depot\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Step 2: Customer reallocation (move customers between routes)\n    if len(new_solution) > 1:\n        route_from_idx = random.randint(0, len(new_solution) - 1)\n        route_to_idx = random.randint(0, len(new_solution) - 1)\n        if route_from_idx != route_to_idx:\n            route_from = new_solution[route_from_idx]\n            route_to = new_solution[route_to_idx]\n            if len(route_from) > 3:  # Ensure we don't remove all customers from a route\n                # Select a random customer from route_from (excluding depots)\n                customer_idx = random.randint(1, len(route_from) - 2)\n                customer = route_from[customer_idx]\n                # Check if adding this customer to route_to doesn't exceed capacity\n                if sum(demand[route_to[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route_from\n                    new_route_from = np.delete(route_from, customer_idx)\n                    new_solution[route_from_idx] = new_route_from\n                    # Add customer to route_to (insert at random position)\n                    insert_pos = random.randint(1, len(route_to) - 1)\n                    new_route_to = np.insert(route_to, insert_pos, customer)\n                    new_solution[route_to_idx] = new_route_to\n\n    # Step 3: Adaptive 3-opt (selective 3-opt on long routes)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply to routes with enough customers\n            # Select three random edges to reconnect\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Create three possible reconnections\n            option1 = np.concatenate((route[:a+1], route[b:c+1], route[a+1:b+1], route[c+1:]))\n            option2 = np.concatenate((route[:a+1], route[b:c+1][::-1], route[a+1:b+1], route[c+1:]))\n            option3 = np.concatenate((route[:a+1], route[a+1:b+1], route[b:c+1][::-1], route[c+1:]))\n            # Evaluate all options\n            options = [option1, option2, option3]\n            best_option = min(options, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n            # Check if best option is feasible\n            if sum(demand[best_option[1:-1]]) <= capacity:\n                new_solution[i] = best_option\n\n    # Ensure all routes are valid (start and end at depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate(([0], new_solution[i][1:-1], [0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7343115374209249,
            1.9781689643859863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with high total distance and high makespan (potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them at depot\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Step 2: Customer reallocation (move customers between routes)\n    if len(new_solution) > 1:\n        route_from_idx = random.randint(0, len(new_solution) - 1)\n        route_to_idx = random.randint(0, len(new_solution) - 1)\n        if route_from_idx != route_to_idx:\n            route_from = new_solution[route_from_idx]\n            route_to = new_solution[route_to_idx]\n            if len(route_from) > 3:  # Ensure we don't remove all customers from a route\n                # Select a random customer from route_from (excluding depots)\n                customer_idx = random.randint(1, len(route_from) - 2)\n                customer = route_from[customer_idx]\n                # Check if adding this customer to route_to doesn't exceed capacity\n                if sum(demand[route_to[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route_from\n                    new_route_from = np.delete(route_from, customer_idx)\n                    new_solution[route_from_idx] = new_route_from\n                    # Add customer to route_to (insert at random position)\n                    insert_pos = random.randint(1, len(route_to) - 1)\n                    new_route_to = np.insert(route_to, insert_pos, customer)\n                    new_solution[route_to_idx] = new_route_to\n\n    # Step 3: Adaptive 3-opt (selective 3-opt on long routes)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only apply to routes with enough customers\n            # Select three random edges to reconnect\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Create three possible reconnections\n            option1 = np.concatenate((route[:a+1], route[b:c+1], route[a+1:b+1], route[c+1:]))\n            option2 = np.concatenate((route[:a+1], route[b:c+1][::-1], route[a+1:b+1], route[c+1:]))\n            option3 = np.concatenate((route[:a+1], route[a+1:b+1], route[b:c+1][::-1], route[c+1:]))\n            # Evaluate all options\n            options = [option1, option2, option3]\n            best_option = min(options, key=lambda x: sum(distance_matrix[x[:-1], x[1:]]))\n            # Check if best option is feasible\n            if sum(demand[best_option[1:-1]]) <= capacity:\n                new_solution[i] = best_option\n\n    # Ensure all routes are valid (start and end at depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate(([0], new_solution[i][1:-1], [0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with no meaningful nodes\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: Combine route segmentation with node reinsertion\n        # Step 1: Randomly split the route into segments\n        split_points = sorted(random.sample(range(1, len(route)-1), min(2, len(route)-2)))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(route[prev:point+1])\n            prev = point\n        segments.append(route[prev:])\n\n        # Step 2: Randomly select a segment and apply node reinsertion\n        segment_idx = random.randint(0, len(segments)-1)\n        selected_segment = segments[segment_idx]\n        if len(selected_segment) <= 2:  # Skip if segment is too small\n            new_solution.append(route.copy())\n            continue\n\n        # Step 3: Remove the selected segment and reinsert nodes in a different order\n        remaining_route = [node for i, node in enumerate(route) if node not in selected_segment]\n        reinserted_nodes = selected_segment[1:-1]  # Exclude depot\n        random.shuffle(reinserted_nodes)\n\n        # Find feasible insertion points for reinserted nodes\n        for node in reinserted_nodes:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(remaining_route)):\n                # Check capacity constraint\n                if sum(demand[remaining_route[j]] for j in range(1, i)) + demand[node] > capacity:\n                    continue\n                # Calculate insertion cost\n                cost = (distance_matrix[remaining_route[i-1]][node] +\n                        distance_matrix[node][remaining_route[i]] -\n                        distance_matrix[remaining_route[i-1]][remaining_route[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            remaining_route.insert(best_pos, node)\n\n        # Reconstruct the route\n        new_route = remaining_route.copy()\n        new_solution.append(new_route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Fallback: Reconstruct solution if coverage is lost\n        new_solution = [route.copy() for route in selected_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7872032285585159,
            4.799163967370987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with no meaningful nodes\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: Combine route segmentation with node reinsertion\n        # Step 1: Randomly split the route into segments\n        split_points = sorted(random.sample(range(1, len(route)-1), min(2, len(route)-2)))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(route[prev:point+1])\n            prev = point\n        segments.append(route[prev:])\n\n        # Step 2: Randomly select a segment and apply node reinsertion\n        segment_idx = random.randint(0, len(segments)-1)\n        selected_segment = segments[segment_idx]\n        if len(selected_segment) <= 2:  # Skip if segment is too small\n            new_solution.append(route.copy())\n            continue\n\n        # Step 3: Remove the selected segment and reinsert nodes in a different order\n        remaining_route = [node for i, node in enumerate(route) if node not in selected_segment]\n        reinserted_nodes = selected_segment[1:-1]  # Exclude depot\n        random.shuffle(reinserted_nodes)\n\n        # Find feasible insertion points for reinserted nodes\n        for node in reinserted_nodes:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(remaining_route)):\n                # Check capacity constraint\n                if sum(demand[remaining_route[j]] for j in range(1, i)) + demand[node] > capacity:\n                    continue\n                # Calculate insertion cost\n                cost = (distance_matrix[remaining_route[i-1]][node] +\n                        distance_matrix[node][remaining_route[i]] -\n                        distance_matrix[remaining_route[i-1]][remaining_route[i]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            remaining_route.insert(best_pos, node)\n\n        # Reconstruct the route\n        new_route = remaining_route.copy()\n        new_solution.append(new_route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Fallback: Reconstruct solution if coverage is lost\n        new_solution = [route.copy() for route in selected_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid approach combining route-based and demand-based criteria, then applies a novel local search operator that intelligently rebalances route segments while preserving feasibility, ensuring both total distance and makespan are improved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Novel local search: Route Segment Transfer with Capacity-Aware Rebalancing\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Calculate remaining capacity for each segment\n        capacity1 = capacity - np.sum(demand[segment1[1:-1]])\n        capacity2 = capacity - np.sum(demand[segment2[1:-1]])\n\n        # Attempt to transfer customers between segments if feasible\n        for i in range(1, len(segment1) - 1):\n            customer = segment1[i]\n            if demand[customer] <= capacity2:\n                # Transfer customer to segment2\n                segment1 = np.delete(segment1, i)\n                segment2 = np.insert(segment2, 1, customer)\n                capacity1 += demand[customer]\n                capacity2 -= demand[customer]\n                break\n\n        new_solution.append(segment1)\n        new_solution.append(segment2)\n\n    # Merge routes if possible (simple heuristic)\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 2:  # Skip empty or depot-only routes\n            continue\n\n        # Try to merge with the last route in merged_solution\n        if merged_solution:\n            last_route = merged_solution[-1]\n            total_demand = np.sum(demand[last_route[1:-1]]) + np.sum(demand[route[1:-1]])\n            if total_demand <= capacity:\n                # Calculate distance between last customer of last_route and first customer of route\n                last_customer = last_route[-2]\n                first_customer = route[1]\n                if distance_matrix[last_customer][first_customer] < distance_matrix[last_customer][0] + distance_matrix[0][first_customer]:\n                    # Merge routes\n                    merged_route = np.concatenate([last_route[:-1], route[1:]])\n                    merged_solution[-1] = merged_route\n                    continue\n\n        merged_solution.append(route)\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(coords))) - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            if demand[customer] <= capacity:\n                merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7115197314485098,
            3.4952980279922485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Novel local search: Route Segment Transfer with Capacity-Aware Rebalancing\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Calculate remaining capacity for each segment\n        capacity1 = capacity - np.sum(demand[segment1[1:-1]])\n        capacity2 = capacity - np.sum(demand[segment2[1:-1]])\n\n        # Attempt to transfer customers between segments if feasible\n        for i in range(1, len(segment1) - 1):\n            customer = segment1[i]\n            if demand[customer] <= capacity2:\n                # Transfer customer to segment2\n                segment1 = np.delete(segment1, i)\n                segment2 = np.insert(segment2, 1, customer)\n                capacity1 += demand[customer]\n                capacity2 -= demand[customer]\n                break\n\n        new_solution.append(segment1)\n        new_solution.append(segment2)\n\n    # Merge routes if possible (simple heuristic)\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 2:  # Skip empty or depot-only routes\n            continue\n\n        # Try to merge with the last route in merged_solution\n        if merged_solution:\n            last_route = merged_solution[-1]\n            total_demand = np.sum(demand[last_route[1:-1]]) + np.sum(demand[route[1:-1]])\n            if total_demand <= capacity:\n                # Calculate distance between last customer of last_route and first customer of route\n                last_customer = last_route[-2]\n                first_customer = route[1]\n                if distance_matrix[last_customer][first_customer] < distance_matrix[last_customer][0] + distance_matrix[0][first_customer]:\n                    # Merge routes\n                    merged_route = np.concatenate([last_route[:-1], route[1:]])\n                    merged_solution[-1] = merged_route\n                    continue\n\n        merged_solution.append(route)\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(coords))) - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            if demand[customer] <= capacity:\n                merged_solution.append(new_route)\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reinsert part2 into the solution as a new route\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Check feasibility and adjust if necessary\n    for i in range(len(new_solution)):\n        total_demand = sum(demand[node] for node in new_solution[i][1:-1])\n        if total_demand > capacity:\n            # If over capacity, try to redistribute customers\n            excess = total_demand - capacity\n            for j in range(len(new_solution[i]) - 2, 0, -1):\n                node = new_solution[i][j]\n                if demand[node] <= excess:\n                    # Move the node to a new route\n                    new_route = np.array([0, node, 0])\n                    new_solution.append(new_route)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    excess -= demand[node]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8480917649653388,
            0.33744528889656067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Reinsert part2 into the solution as a new route\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Check feasibility and adjust if necessary\n    for i in range(len(new_solution)):\n        total_demand = sum(demand[node] for node in new_solution[i][1:-1])\n        if total_demand > capacity:\n            # If over capacity, try to redistribute customers\n            excess = total_demand - capacity\n            for j in range(len(new_solution[i]) - 2, 0, -1):\n                node = new_solution[i][j]\n                if demand[node] <= excess:\n                    # Move the node to a new route\n                    new_route = np.array([0, node, 0])\n                    new_solution.append(new_route)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    excess -= demand[node]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # 1. Merge two shortest routes if their combined load is within capacity\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(new_solution)), key=lambda i: route_lengths[i])\n\n        for i in range(len(sorted_indices) - 1):\n            for j in range(i + 1, len(sorted_indices)):\n                route1 = new_solution[sorted_indices[i]]\n                route2 = new_solution[sorted_indices[j]]\n                combined_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_load <= capacity:\n                    # Merge routes by inserting route2 into route1 at the closest position\n                    min_insert_cost = float('inf')\n                    best_insert_pos = 0\n\n                    for pos in range(1, len(route1)):\n                        cost = (distance_matrix[route1[pos-1], route2[1]] +\n                               distance_matrix[route2[-2], route1[pos]] -\n                               distance_matrix[route1[pos-1], route1[pos]])\n\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = pos\n\n                    merged_route = np.concatenate([\n                        route1[:best_insert_pos],\n                        route2[1:-1],\n                        route1[best_insert_pos:]\n                    ])\n\n                    new_solution[sorted_indices[i]] = merged_route\n                    new_solution.pop(sorted_indices[j])\n                    break\n\n    # 2. Reallocate customers from the longest route to others if it improves objectives\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        for customer in longest_route[1:-1]:\n            current_load = sum(demand[longest_route[1:-1]])\n            new_load = current_load - demand[customer]\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n\n                route_load = sum(demand[route[1:-1]])\n                if route_load + demand[customer] <= capacity:\n                    # Find best insertion position in the target route\n                    min_insert_cost = float('inf')\n                    best_insert_pos = 0\n\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]] -\n                               distance_matrix[route[pos-1], route[pos]])\n\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = pos\n\n                    # Check if reallocation improves objectives\n                    current_distance = sum(distance_matrix[longest_route[:-1], longest_route[1:]]) + sum(distance_matrix[route[:-1], route[1:]])\n                    new_distance = (sum(distance_matrix[longest_route[:-1], longest_route[1:]]) -\n                                   distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], customer] -\n                                   distance_matrix[customer, longest_route[np.where(longest_route == customer)[0][0]+1]] +\n                                   distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], longest_route[np.where(longest_route == customer)[0][0]+1]]) + \\\n                                  (sum(distance_matrix[route[:-1], route[1:]]) +\n                                   distance_matrix[route[best_insert_pos-1], customer] +\n                                   distance_matrix[customer, route[best_insert_pos]] -\n                                   distance_matrix[route[best_insert_pos-1], route[best_insert_pos]])\n\n                    if new_distance < current_distance:\n                        # Perform reallocation\n                        new_longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_route = np.insert(route, best_insert_pos, customer)\n\n                        new_solution[longest_route_idx] = new_longest_route\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8244173585209791,
            5.647386759519577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # 1. Merge two shortest routes if their combined load is within capacity\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(new_solution)), key=lambda i: route_lengths[i])\n\n        for i in range(len(sorted_indices) - 1):\n            for j in range(i + 1, len(sorted_indices)):\n                route1 = new_solution[sorted_indices[i]]\n                route2 = new_solution[sorted_indices[j]]\n                combined_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if combined_load <= capacity:\n                    # Merge routes by inserting route2 into route1 at the closest position\n                    min_insert_cost = float('inf')\n                    best_insert_pos = 0\n\n                    for pos in range(1, len(route1)):\n                        cost = (distance_matrix[route1[pos-1], route2[1]] +\n                               distance_matrix[route2[-2], route1[pos]] -\n                               distance_matrix[route1[pos-1], route1[pos]])\n\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = pos\n\n                    merged_route = np.concatenate([\n                        route1[:best_insert_pos],\n                        route2[1:-1],\n                        route1[best_insert_pos:]\n                    ])\n\n                    new_solution[sorted_indices[i]] = merged_route\n                    new_solution.pop(sorted_indices[j])\n                    break\n\n    # 2. Reallocate customers from the longest route to others if it improves objectives\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        for customer in longest_route[1:-1]:\n            current_load = sum(demand[longest_route[1:-1]])\n            new_load = current_load - demand[customer]\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n\n                route_load = sum(demand[route[1:-1]])\n                if route_load + demand[customer] <= capacity:\n                    # Find best insertion position in the target route\n                    min_insert_cost = float('inf')\n                    best_insert_pos = 0\n\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]] -\n                               distance_matrix[route[pos-1], route[pos]])\n\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = pos\n\n                    # Check if reallocation improves objectives\n                    current_distance = sum(distance_matrix[longest_route[:-1], longest_route[1:]]) + sum(distance_matrix[route[:-1], route[1:]])\n                    new_distance = (sum(distance_matrix[longest_route[:-1], longest_route[1:]]) -\n                                   distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], customer] -\n                                   distance_matrix[customer, longest_route[np.where(longest_route == customer)[0][0]+1]] +\n                                   distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], longest_route[np.where(longest_route == customer)[0][0]+1]]) + \\\n                                  (sum(distance_matrix[route[:-1], route[1:]]) +\n                                   distance_matrix[route[best_insert_pos-1], customer] +\n                                   distance_matrix[customer, route[best_insert_pos]] -\n                                   distance_matrix[route[best_insert_pos-1], route[best_insert_pos]])\n\n                    if new_distance < current_distance:\n                        # Perform reallocation\n                        new_longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_route = np.insert(route, best_insert_pos, customer)\n\n                        new_solution[longest_route_idx] = new_longest_route\n                        new_solution[i] = new_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (len(x[0]) + 1))  # Prefer solutions with higher combined objective values but with fewer routes\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Route Splitting + Cross-Route Swap + 2-Opt*\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Route Splitting - Split long routes into two shorter ones\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n                if all(sum(demand[r[1:-1]]) <= capacity for r in [new_route1, new_route2]):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Cross-Route Swap - Swap customers between routes to balance makespan\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                pos1, pos2 = np.random.randint(1, len(route1)-1), np.random.randint(1, len(route2)-1)\n                if (sum(demand[route1[1:-1]]) - demand[route1[pos1]] + demand[route2[pos2]] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[route2[pos2]] + demand[route1[pos1]] <= capacity):\n                    route1[pos1], route2[pos2] = route2[pos2], route1[pos1]\n\n        # Step 3: 2-Opt* - Improved 2-opt operator that considers both distance and makespan\n        for route in new_solution:\n            if len(route) > 4:\n                i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                if i+1 < j:\n                    # Try both possible 2-opt moves and choose the one that improves both objectives\n                    original_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[j-1], route[j]]\n                    new_dist1 = distance_matrix[route[i-1], route[j-1]] + distance_matrix[route[i], route[j]]\n                    new_dist2 = distance_matrix[route[i-1], route[j]] + distance_matrix[route[j-1], route[i]]\n\n                    if new_dist1 < original_dist or new_dist2 < original_dist:\n                        if new_dist1 < new_dist2:\n                            route[i:j] = route[i:j][::-1]\n                        else:\n                            route[i:j] = route[i:j][::-1]\n                            route[i], route[j-1] = route[j-1], route[i]\n\n    # Verify feasibility and return\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution - capacity exceeded\")\n\n    return new_solution\n\n",
        "score": [
            -0.6267211427319769,
            2.9545031785964966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (len(x[0]) + 1))  # Prefer solutions with higher combined objective values but with fewer routes\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Route Splitting + Cross-Route Swap + 2-Opt*\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Route Splitting - Split long routes into two shorter ones\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n                if all(sum(demand[r[1:-1]]) <= capacity for r in [new_route1, new_route2]):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Cross-Route Swap - Swap customers between routes to balance makespan\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            if len(route1) > 3 and len(route2) > 3:\n                pos1, pos2 = np.random.randint(1, len(route1)-1), np.random.randint(1, len(route2)-1)\n                if (sum(demand[route1[1:-1]]) - demand[route1[pos1]] + demand[route2[pos2]] <= capacity and\n                    sum(demand[route2[1:-1]]) - demand[route2[pos2]] + demand[route1[pos1]] <= capacity):\n                    route1[pos1], route2[pos2] = route2[pos2], route1[pos1]\n\n        # Step 3: 2-Opt* - Improved 2-opt operator that considers both distance and makespan\n        for route in new_solution:\n            if len(route) > 4:\n                i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                if i+1 < j:\n                    # Try both possible 2-opt moves and choose the one that improves both objectives\n                    original_dist = distance_matrix[route[i-1], route[i]] + distance_matrix[route[j-1], route[j]]\n                    new_dist1 = distance_matrix[route[i-1], route[j-1]] + distance_matrix[route[i], route[j]]\n                    new_dist2 = distance_matrix[route[i-1], route[j]] + distance_matrix[route[j-1], route[i]]\n\n                    if new_dist1 < original_dist or new_dist2 < original_dist:\n                        if new_dist1 < new_dist2:\n                            route[i:j] = route[i:j][::-1]\n                        else:\n                            route[i:j] = route[i:j][::-1]\n                            route[i], route[j-1] = route[j-1], route[i]\n\n    # Verify feasibility and return\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution - capacity exceeded\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{The novel local search strategy combines route merging and splitting with a demand-aware relocation heuristic to balance distance and makespan objectives, while ensuring feasibility through capacity checks and iterative route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_indices = list(range(len(base_solution)))\n    i = random.choice(route_indices)\n    route_i = base_solution[i]\n\n    # Try merging with another route if possible\n    for j in route_indices:\n        if i == j:\n            continue\n        route_j = base_solution[j]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Perform the merge\n            new_solution = [r for idx, r in enumerate(base_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging is not possible, try splitting a route\n    if len(route_i) > 3:  # Ensure the route has enough nodes to split\n        split_pos = random.randint(1, len(route_i) - 2)\n        split_route1 = np.concatenate([route_i[:split_pos+1], [0]])\n        split_route2 = np.concatenate([[0], route_i[split_pos+1:]])\n\n        # Check feasibility\n        if np.sum(demand[split_route1[1:-1]]) <= capacity and np.sum(demand[split_route2[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(base_solution) if idx != i]\n            new_solution.extend([split_route1, split_route2])\n            return new_solution\n\n    # If no merge or split is possible, perform a demand-aware relocation\n    for route in base_solution:\n        if len(route) > 3:\n            # Find a customer with high demand to relocate\n            customers = route[1:-1]\n            high_demand_customers = [c for c in customers if demand[c] > capacity * 0.4]\n            if high_demand_customers:\n                customer = random.choice(high_demand_customers)\n                # Try to relocate to another route\n                for target_route in base_solution:\n                    if len(target_route) > 2 and target_route[0] == 0 and target_route[-1] == 0:\n                        # Check if adding the customer is feasible\n                        if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                            # Perform relocation\n                            new_route = np.concatenate([target_route[:-1], [customer], [0]])\n                            new_solution = [r for r in base_solution if not np.array_equal(r, target_route)]\n                            new_solution.append(new_route)\n                            # Remove customer from original route\n                            original_route = np.array([c for c in route if c != customer])\n                            if len(original_route) > 2:\n                                new_solution.append(original_route)\n                            return new_solution\n\n    # If no improvement, return the base solution\n    return base_solution\n\n",
        "score": [
            -0.6552042354247158,
            4.787985444068909
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(base_solution) < 2:\n        return base_solution\n\n    route_indices = list(range(len(base_solution)))\n    i = random.choice(route_indices)\n    route_i = base_solution[i]\n\n    # Try merging with another route if possible\n    for j in route_indices:\n        if i == j:\n            continue\n        route_j = base_solution[j]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Perform the merge\n            new_solution = [r for idx, r in enumerate(base_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging is not possible, try splitting a route\n    if len(route_i) > 3:  # Ensure the route has enough nodes to split\n        split_pos = random.randint(1, len(route_i) - 2)\n        split_route1 = np.concatenate([route_i[:split_pos+1], [0]])\n        split_route2 = np.concatenate([[0], route_i[split_pos+1:]])\n\n        # Check feasibility\n        if np.sum(demand[split_route1[1:-1]]) <= capacity and np.sum(demand[split_route2[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(base_solution) if idx != i]\n            new_solution.extend([split_route1, split_route2])\n            return new_solution\n\n    # If no merge or split is possible, perform a demand-aware relocation\n    for route in base_solution:\n        if len(route) > 3:\n            # Find a customer with high demand to relocate\n            customers = route[1:-1]\n            high_demand_customers = [c for c in customers if demand[c] > capacity * 0.4]\n            if high_demand_customers:\n                customer = random.choice(high_demand_customers)\n                # Try to relocate to another route\n                for target_route in base_solution:\n                    if len(target_route) > 2 and target_route[0] == 0 and target_route[-1] == 0:\n                        # Check if adding the customer is feasible\n                        if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                            # Perform relocation\n                            new_route = np.concatenate([target_route[:-1], [customer], [0]])\n                            new_solution = [r for r in base_solution if not np.array_equal(r, target_route)]\n                            new_solution.append(new_route)\n                            # Remove customer from original route\n                            original_route = np.array([c for c in route if c != customer])\n                            if len(original_route) > 2:\n                                new_solution.append(original_route)\n                            return new_solution\n\n    # If no improvement, return the base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route segmentation and inter-route insertion to explore high-quality neighbors while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential exchange\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Segment route_i into two parts\n        if len(route_i) > 3:  # Ensure at least one customer in each segment\n            split_point = random.randint(1, len(route_i) - 2)\n            segment1 = route_i[:split_point + 1]\n            segment2 = route_i[split_point:]\n\n            # Check capacity constraints for segments\n            demand_segment1 = sum(demand[node] for node in segment1[1:-1])\n            demand_segment2 = sum(demand[node] for node in segment2[1:-1])\n\n            if demand_segment1 <= capacity and demand_segment2 <= capacity:\n                # Attempt to insert segment2 into route_j\n                for k in range(1, len(route_j)):\n                    # Try inserting segment2 after position k in route_j\n                    new_route_j = np.concatenate([route_j[:k+1], segment2[1:-1], route_j[k+1:]])\n                    demand_new_route_j = sum(demand[node] for node in new_route_j[1:-1])\n\n                    if demand_new_route_j <= capacity:\n                        # Update routes\n                        new_solution[i] = segment1\n                        new_solution[j] = new_route_j\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4807969450027198,
            7.027748942375183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and inter-route insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential exchange\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Segment route_i into two parts\n        if len(route_i) > 3:  # Ensure at least one customer in each segment\n            split_point = random.randint(1, len(route_i) - 2)\n            segment1 = route_i[:split_point + 1]\n            segment2 = route_i[split_point:]\n\n            # Check capacity constraints for segments\n            demand_segment1 = sum(demand[node] for node in segment1[1:-1])\n            demand_segment2 = sum(demand[node] for node in segment2[1:-1])\n\n            if demand_segment1 <= capacity and demand_segment2 <= capacity:\n                # Attempt to insert segment2 into route_j\n                for k in range(1, len(route_j)):\n                    # Try inserting segment2 after position k in route_j\n                    new_route_j = np.concatenate([route_j[:k+1], segment2[1:-1], route_j[k+1:]])\n                    demand_new_route_j = sum(demand[node] for node in new_route_j[1:-1])\n\n                    if demand_new_route_j <= capacity:\n                        # Update routes\n                        new_solution[i] = segment1\n                        new_solution[j] = new_route_j\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with capacity-aware demand balancing to generate high-quality neighbors by intelligently reallocating customers across routes while minimizing both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Sort by makespan and total distance, then pick a solution with good potential\n    sorted_by_makespan = sorted(zip(archive_solutions, archive_objectives), key=lambda x: x[1][1])\n    sorted_by_distance = sorted(zip(archive_solutions, archive_objectives), key=lambda x: x[1][0])\n\n    # Combine scores and select a solution with high potential\n    combined_scores = []\n    for sol, obj in zip(archive_solutions, archive_objectives):\n        # Score is inverse of makespan and inverse of distance\n        score = (1 / (obj[1] + 1e-6)) + (1 / (obj[0] + 1e-6))\n        combined_scores.append(score)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search: route segment swap with demand balancing\n    new_solution = base_solution.copy()\n\n    # Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = list(range(len(new_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Find feasible swap segments\n    def find_feasible_segments(route, capacity):\n        segments = []\n        for i in range(1, len(route) - 1):  # Exclude depot\n            for j in range(i + 1, len(route)):\n                segment_demand = np.sum(demand[route[i:j+1]])\n                if segment_demand <= capacity:\n                    segments.append((i, j))\n        return segments\n\n    segments1 = find_feasible_segments(route1, capacity)\n    segments2 = find_feasible_segments(route2, capacity)\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Randomly select segments\n    seg1_start, seg1_end = random.choice(segments1)\n    seg2_start, seg2_end = random.choice(segments2)\n\n    # Swap segments\n    new_route1 = np.concatenate([\n        route1[:seg1_start],\n        route2[seg2_start:seg2_end+1],\n        route1[seg1_end+1:]\n    ])\n\n    new_route2 = np.concatenate([\n        route2[:seg2_start],\n        route1[seg1_start:seg1_end+1],\n        route2[seg2_end+1:]\n    ])\n\n    # Check feasibility and update solution\n    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n        np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Optional: Apply demand balancing between routes\n    def balance_demands(route1, route2, capacity):\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 + demand2 <= capacity:\n            # Merge routes if possible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            return [merged_route], True\n\n        # Try to reallocate customers to balance demands\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                if (demand1 - demand[route1[i]] + demand[route2[j]] <= capacity and\n                    demand2 - demand[route2[j]] + demand[route1[i]] <= capacity):\n\n                    new_route1 = np.concatenate([\n                        route1[:i],\n                        [route2[j]],\n                        route1[i+1:]\n                    ])\n\n                    new_route2 = np.concatenate([\n                        route2[:j],\n                        [route1[i]],\n                        route2[j+1:]\n                    ])\n\n                    return [new_route1, new_route2], False\n\n        return [route1, route2], False\n\n    balanced_routes, merged = balance_demands(new_solution[route1_idx], new_solution[route2_idx], capacity)\n\n    if merged:\n        new_solution.pop(route2_idx)\n        new_solution[route1_idx] = balanced_routes[0]\n    else:\n        new_solution[route1_idx] = balanced_routes[0]\n        new_solution[route2_idx] = balanced_routes[1]\n\n    return new_solution\n\n",
        "score": [
            -0.4997702820574678,
            2.490744650363922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Sort by makespan and total distance, then pick a solution with good potential\n    sorted_by_makespan = sorted(zip(archive_solutions, archive_objectives), key=lambda x: x[1][1])\n    sorted_by_distance = sorted(zip(archive_solutions, archive_objectives), key=lambda x: x[1][0])\n\n    # Combine scores and select a solution with high potential\n    combined_scores = []\n    for sol, obj in zip(archive_solutions, archive_objectives):\n        # Score is inverse of makespan and inverse of distance\n        score = (1 / (obj[1] + 1e-6)) + (1 / (obj[0] + 1e-6))\n        combined_scores.append(score)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search: route segment swap with demand balancing\n    new_solution = base_solution.copy()\n\n    # Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = list(range(len(new_solution)))\n    random.shuffle(route_indices)\n    route1_idx, route2_idx = route_indices[:2]\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Find feasible swap segments\n    def find_feasible_segments(route, capacity):\n        segments = []\n        for i in range(1, len(route) - 1):  # Exclude depot\n            for j in range(i + 1, len(route)):\n                segment_demand = np.sum(demand[route[i:j+1]])\n                if segment_demand <= capacity:\n                    segments.append((i, j))\n        return segments\n\n    segments1 = find_feasible_segments(route1, capacity)\n    segments2 = find_feasible_segments(route2, capacity)\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Randomly select segments\n    seg1_start, seg1_end = random.choice(segments1)\n    seg2_start, seg2_end = random.choice(segments2)\n\n    # Swap segments\n    new_route1 = np.concatenate([\n        route1[:seg1_start],\n        route2[seg2_start:seg2_end+1],\n        route1[seg1_end+1:]\n    ])\n\n    new_route2 = np.concatenate([\n        route2[:seg2_start],\n        route1[seg1_start:seg1_end+1],\n        route2[seg2_end+1:]\n    ])\n\n    # Check feasibility and update solution\n    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n        np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    # Optional: Apply demand balancing between routes\n    def balance_demands(route1, route2, capacity):\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 + demand2 <= capacity:\n            # Merge routes if possible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            return [merged_route], True\n\n        # Try to reallocate customers to balance demands\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                if (demand1 - demand[route1[i]] + demand[route2[j]] <= capacity and\n                    demand2 - demand[route2[j]] + demand[route1[i]] <= capacity):\n\n                    new_route1 = np.concatenate([\n                        route1[:i],\n                        [route2[j]],\n                        route1[i+1:]\n                    ])\n\n                    new_route2 = np.concatenate([\n                        route2[:j],\n                        [route1[i]],\n                        route2[j+1:]\n                    ])\n\n                    return [new_route1, new_route2], False\n\n        return [route1, route2], False\n\n    balanced_routes, merged = balance_demands(new_solution[route1_idx], new_solution[route2_idx], capacity)\n\n    if merged:\n        new_solution.pop(route2_idx)\n        new_solution[route1_idx] = balanced_routes[0]\n    else:\n        new_solution[route1_idx] = balanced_routes[0]\n        new_solution[route2_idx] = balanced_routes[1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware edge swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot -> customer -> depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reallocate customers between the two parts while respecting capacity\n        current_capacity = sum(demand[part1])\n        for i in range(len(part2) - 1):\n            customer = part2[i + 1]\n            if current_capacity + demand[customer] <= capacity:\n                part1 = np.append(part1, customer)\n                current_capacity += demand[customer]\n            else:\n                break\n\n        # Remove reallocated customers from part2\n        part2 = np.array([part2[0]] + [c for c in part2[1:] if c not in part1])\n\n        # Ensure both parts are valid routes\n        if len(part1) > 2:\n            new_solution.append(part1)\n        if len(part2) > 2:\n            new_solution.append(part2)\n\n    # Perform capacity-aware edge swaps between routes\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select random customers from each route (excluding depots)\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_idx = random.randint(1, len(route1) - 2)\n                cust2_idx = random.randint(1, len(route2) - 2)\n\n                # Swap customers if capacity constraints are satisfied\n                temp_route1 = route1.copy()\n                temp_route2 = route2.copy()\n                temp_route1[cust1_idx], temp_route2[cust2_idx] = temp_route2[cust2_idx], temp_route1[cust1_idx]\n\n                # Check capacity constraints\n                if (sum(demand[temp_route1]) <= capacity and\n                    sum(demand[temp_route2]) <= capacity):\n                    new_solution[route1_idx] = temp_route1\n                    new_solution[route2_idx] = temp_route2\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reconstruct solution if some customers are missing\n        unserved = list(all_customers - served_customers)\n        random.shuffle(unserved)\n        for customer in unserved:\n            best_route = None\n            best_capacity = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route]) + demand[customer] <= capacity:\n                    if sum(demand[route]) < best_capacity:\n                        best_route = i\n                        best_capacity = sum(demand[route])\n            if best_route is not None:\n                # Insert customer at the best position\n                best_pos = 1\n                best_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.42157763663957526,
            3.366835504770279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = []\n\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot -> customer -> depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reallocate customers between the two parts while respecting capacity\n        current_capacity = sum(demand[part1])\n        for i in range(len(part2) - 1):\n            customer = part2[i + 1]\n            if current_capacity + demand[customer] <= capacity:\n                part1 = np.append(part1, customer)\n                current_capacity += demand[customer]\n            else:\n                break\n\n        # Remove reallocated customers from part2\n        part2 = np.array([part2[0]] + [c for c in part2[1:] if c not in part1])\n\n        # Ensure both parts are valid routes\n        if len(part1) > 2:\n            new_solution.append(part1)\n        if len(part2) > 2:\n            new_solution.append(part2)\n\n    # Perform capacity-aware edge swaps between routes\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select random customers from each route (excluding depots)\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_idx = random.randint(1, len(route1) - 2)\n                cust2_idx = random.randint(1, len(route2) - 2)\n\n                # Swap customers if capacity constraints are satisfied\n                temp_route1 = route1.copy()\n                temp_route2 = route2.copy()\n                temp_route1[cust1_idx], temp_route2[cust2_idx] = temp_route2[cust2_idx], temp_route1[cust1_idx]\n\n                # Check capacity constraints\n                if (sum(demand[temp_route1]) <= capacity and\n                    sum(demand[temp_route2]) <= capacity):\n                    new_solution[route1_idx] = temp_route1\n                    new_solution[route2_idx] = temp_route2\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Reconstruct solution if some customers are missing\n        unserved = list(all_customers - served_customers)\n        random.shuffle(unserved)\n        for customer in unserved:\n            best_route = None\n            best_capacity = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route]) + demand[customer] <= capacity:\n                    if sum(demand[route]) < best_capacity:\n                        best_route = i\n                        best_capacity = sum(demand[route])\n            if best_route is not None:\n                # Insert customer at the best position\n                best_pos = 1\n                best_dist = float('inf')\n                for pos in range(1, len(new_solution[best_route])):\n                    dist = (distance_matrix[new_solution[best_route][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route][pos]] -\n                            distance_matrix[new_solution[best_route][pos-1], new_solution[best_route][pos]])\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos = pos\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search operator that combines route segment swaps and demand-balanced route merges to generate a neighbor solution while respecting vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = [obj[0] * 0.3 + obj[1] * 0.7 for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route segment swap between two routes\n    if len(base_solution) >= 2:\n        route1_idx = np.random.randint(0, len(base_solution))\n        route2_idx = np.random.randint(0, len(base_solution))\n        while route2_idx == route1_idx and len(base_solution) > 1:\n            route2_idx = np.random.randint(0, len(base_solution))\n\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try multiple times to find feasible swap\n            # Randomly select segments from both routes (excluding depots)\n            start1 = np.random.randint(1, len(route1)-1)\n            end1 = np.random.randint(start1, len(route1)-1)\n            segment1 = route1[start1:end1+1]\n\n            start2 = np.random.randint(1, len(route2)-1)\n            end2 = np.random.randint(start2, len(route2)-1)\n            segment2 = route2[start2:end2+1]\n\n            # Check capacity constraints for both routes after swap\n            demand1_after = np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])\n            demand2_after = np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])\n\n            if demand1_after <= capacity and demand2_after <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                base_solution[route1_idx] = new_route1\n                base_solution[route2_idx] = new_route2\n                break\n\n    # Step 2: Demand-balanced route merge (if possible)\n    if len(base_solution) > 1:\n        # Find the two routes with the lowest total demand\n        demands = [np.sum(demand[route]) for route in base_solution]\n        sorted_indices = np.argsort(demands)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Check if merging these two routes would exceed capacity\n        if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n            # Merge the routes (excluding one depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update the solution\n            base_solution[route1_idx] = merged_route\n            base_solution = np.delete(base_solution, route2_idx, axis=0)\n\n    # Ensure all routes have depot at both ends\n    for i in range(len(base_solution)):\n        if base_solution[i][0] != 0 or base_solution[i][-1] != 0:\n            # Fix depot violation\n            if base_solution[i][0] != 0:\n                base_solution[i] = np.concatenate([[0], base_solution[i]])\n            if base_solution[i][-1] != 0:\n                base_solution[i] = np.concatenate([base_solution[i], [0]])\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in base_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.3541264453868824,
            1.7000144124031067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = [obj[0] * 0.3 + obj[1] * 0.7 for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route segment swap between two routes\n    if len(base_solution) >= 2:\n        route1_idx = np.random.randint(0, len(base_solution))\n        route2_idx = np.random.randint(0, len(base_solution))\n        while route2_idx == route1_idx and len(base_solution) > 1:\n            route2_idx = np.random.randint(0, len(base_solution))\n\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Find feasible segments to swap\n        for _ in range(10):  # Try multiple times to find feasible swap\n            # Randomly select segments from both routes (excluding depots)\n            start1 = np.random.randint(1, len(route1)-1)\n            end1 = np.random.randint(start1, len(route1)-1)\n            segment1 = route1[start1:end1+1]\n\n            start2 = np.random.randint(1, len(route2)-1)\n            end2 = np.random.randint(start2, len(route2)-1)\n            segment2 = route2[start2:end2+1]\n\n            # Check capacity constraints for both routes after swap\n            demand1_after = np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])\n            demand2_after = np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])\n\n            if demand1_after <= capacity and demand2_after <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                base_solution[route1_idx] = new_route1\n                base_solution[route2_idx] = new_route2\n                break\n\n    # Step 2: Demand-balanced route merge (if possible)\n    if len(base_solution) > 1:\n        # Find the two routes with the lowest total demand\n        demands = [np.sum(demand[route]) for route in base_solution]\n        sorted_indices = np.argsort(demands)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n\n        route1 = base_solution[route1_idx].copy()\n        route2 = base_solution[route2_idx].copy()\n\n        # Check if merging these two routes would exceed capacity\n        if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n            # Merge the routes (excluding one depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update the solution\n            base_solution[route1_idx] = merged_route\n            base_solution = np.delete(base_solution, route2_idx, axis=0)\n\n    # Ensure all routes have depot at both ends\n    for i in range(len(base_solution)):\n        if base_solution[i][0] != 0 or base_solution[i][-1] != 0:\n            # Fix depot violation\n            if base_solution[i][0] != 0:\n                base_solution[i] = np.concatenate([[0], base_solution[i]])\n            if base_solution[i][-1] != 0:\n                base_solution[i] = np.concatenate([base_solution[i], [0]])\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in base_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive with the highest potential for improvement by combining route balancing and distance reduction through a novel hybrid local search that alternates between route merging and split operations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = archive[np.argmin([obj[1] for _, obj in archive])][0]  # Select solution with minimal makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: alternate between route merging and splitting\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Attempt route merging if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Try merging by connecting the two routes via the closest nodes\n                best_merge = None\n                min_distance = float('inf')\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        # Calculate distance between route1[i] and route2[j]\n                        dist = distance_matrix[route1[i]][route2[j]]\n                        if dist < min_distance:\n                            min_distance = dist\n                            best_merge = (i, j)\n\n                if best_merge:\n                    i, j = best_merge\n                    # Merge routes by inserting route2[j] after route1[i]\n                    merged_route = np.concatenate((\n                        route1[:i+1],\n                        route2[j:-1],\n                        route1[i+1:]\n                    ))\n                    # Remove duplicate depot and update solution\n                    merged_route = np.unique(merged_route, axis=0)\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n                    continue\n\n        # Step 2: Attempt route splitting if merging didn't happen\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Can't split a route with only depot and one customer\n                # Find the split point that balances demands and reduces makespan\n                best_split = None\n                min_imbalance = float('inf')\n\n                for k in range(2, len(route)-2):\n                    demand1 = sum(demand[route[1:k]])\n                    demand2 = sum(demand[route[k:-1]])\n                    imbalance = abs(demand1 - demand2)\n                    if imbalance < min_imbalance and demand1 <= capacity and demand2 <= capacity:\n                        min_imbalance = imbalance\n                        best_split = k\n\n                if best_split:\n                    # Split the route into two parts\n                    split_route1 = np.concatenate((route[:best_split], [0]))\n                    split_route2 = np.concatenate(([0], route[best_split:-1], [0]))\n                    new_solution[route_idx] = split_route1\n                    new_solution.insert(route_idx+1, split_route2)\n                    continue\n\n    # Step 3: Apply 2-opt within each route to further improve\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check if 2-opt is feasible\n            if sum(demand[route[i:j+1]]) <= capacity:\n                new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7585297837403482,
            1.877726972103119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = archive[np.argmin([obj[1] for _, obj in archive])][0]  # Select solution with minimal makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: alternate between route merging and splitting\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Step 1: Attempt route merging if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Try merging by connecting the two routes via the closest nodes\n                best_merge = None\n                min_distance = float('inf')\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        # Calculate distance between route1[i] and route2[j]\n                        dist = distance_matrix[route1[i]][route2[j]]\n                        if dist < min_distance:\n                            min_distance = dist\n                            best_merge = (i, j)\n\n                if best_merge:\n                    i, j = best_merge\n                    # Merge routes by inserting route2[j] after route1[i]\n                    merged_route = np.concatenate((\n                        route1[:i+1],\n                        route2[j:-1],\n                        route1[i+1:]\n                    ))\n                    # Remove duplicate depot and update solution\n                    merged_route = np.unique(merged_route, axis=0)\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n                    continue\n\n        # Step 2: Attempt route splitting if merging didn't happen\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Can't split a route with only depot and one customer\n                # Find the split point that balances demands and reduces makespan\n                best_split = None\n                min_imbalance = float('inf')\n\n                for k in range(2, len(route)-2):\n                    demand1 = sum(demand[route[1:k]])\n                    demand2 = sum(demand[route[k:-1]])\n                    imbalance = abs(demand1 - demand2)\n                    if imbalance < min_imbalance and demand1 <= capacity and demand2 <= capacity:\n                        min_imbalance = imbalance\n                        best_split = k\n\n                if best_split:\n                    # Split the route into two parts\n                    split_route1 = np.concatenate((route[:best_split], [0]))\n                    split_route2 = np.concatenate(([0], route[best_split:-1], [0]))\n                    new_solution[route_idx] = split_route1\n                    new_solution.insert(route_idx+1, split_route2)\n                    continue\n\n    # Step 3: Apply 2-opt within each route to further improve\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check if 2-opt is feasible\n            if sum(demand[route[i:j+1]]) <= capacity:\n                new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm selects a high-performing solution from the archive, applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route splitting, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Route splitting: Split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        new_solution.append(np.concatenate([long_route[:split_pos], [0]]))\n        new_solution[long_route_idx] = np.concatenate([[0], long_route[split_pos:]])\n\n    # Customer reallocation: Move customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Try moving a customer from route_i to route_j\n            customer_to_move = route_i[1]  # Move the first customer in route_i\n            new_route_i = np.delete(route_i, 1)\n            new_route_j = np.insert(route_j, -1, customer_to_move)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route_i]) <= capacity and\n                np.sum(demand[new_route_j]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n                break\n\n    # Capacity-aware swaps: Swap customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Try swapping two customers\n            customer_i = route_i[1]\n            customer_j = route_j[1]\n            new_route_i = np.concatenate([[0], [customer_j], route_i[2:]])\n            new_route_j = np.concatenate([[0], [customer_i], route_j[2:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route_i]) <= capacity and\n                np.sum(demand[new_route_j]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7518320134609416,
            8.623448967933655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route splitting, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Route splitting: Split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        split_pos = len(long_route) // 2\n        new_solution.append(np.concatenate([long_route[:split_pos], [0]]))\n        new_solution[long_route_idx] = np.concatenate([[0], long_route[split_pos:]])\n\n    # Customer reallocation: Move customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Try moving a customer from route_i to route_j\n            customer_to_move = route_i[1]  # Move the first customer in route_i\n            new_route_i = np.delete(route_i, 1)\n            new_route_j = np.insert(route_j, -1, customer_to_move)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route_i]) <= capacity and\n                np.sum(demand[new_route_j]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n                break\n\n    # Capacity-aware swaps: Swap customers between routes if beneficial\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Try swapping two customers\n            customer_i = route_i[1]\n            customer_j = route_j[1]\n            new_route_i = np.concatenate([[0], [customer_j], route_i[2:]])\n            new_route_j = np.concatenate([[0], [customer_i], route_j[2:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route_i]) <= capacity and\n                np.sum(demand[new_route_j]) <= capacity):\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Simple sum of objectives for selection\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break  # Only apply once to maintain diversity\n\n    # Customer reallocation: move a customer from one route to another if it improves both objectives\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Randomly select a customer from route_i and route_j\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Calculate new demands for both routes\n            new_demand_i = np.sum(demand[route_i[1:-1]]) - demand[cust_i] + demand[cust_j]\n            new_demand_j = np.sum(demand[route_j[1:-1]]) - demand[cust_j] + demand[cust_i]\n\n            if new_demand_i <= capacity and new_demand_j <= capacity:\n                # Swap customers\n                route_i = route_i.tolist()\n                route_j = route_j.tolist()\n\n                idx_i = route_i.index(cust_i)\n                idx_j = route_j.index(cust_j)\n\n                route_i[idx_i], route_j[idx_j] = route_j[idx_j], route_i[idx_i]\n\n                new_solution[i] = np.array(route_i)\n                new_solution[j] = np.array(route_j)\n\n                # Only apply one swap to maintain diversity\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7593597590653317,
            2.471518248319626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Simple sum of objectives for selection\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break  # Only apply once to maintain diversity\n\n    # Customer reallocation: move a customer from one route to another if it improves both objectives\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Randomly select a customer from route_i and route_j\n            cust_i = np.random.choice(route_i[1:-1])\n            cust_j = np.random.choice(route_j[1:-1])\n\n            # Calculate new demands for both routes\n            new_demand_i = np.sum(demand[route_i[1:-1]]) - demand[cust_i] + demand[cust_j]\n            new_demand_j = np.sum(demand[route_j[1:-1]]) - demand[cust_j] + demand[cust_i]\n\n            if new_demand_i <= capacity and new_demand_j <= capacity:\n                # Swap customers\n                route_i = route_i.tolist()\n                route_j = route_j.tolist()\n\n                idx_i = route_i.index(cust_i)\n                idx_j = route_j.index(cust_j)\n\n                route_i[idx_i], route_j[idx_j] = route_j[idx_j], route_i[idx_i]\n\n                new_solution[i] = np.array(route_i)\n                new_solution[j] = np.array(route_j)\n\n                # Only apply one swap to maintain diversity\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by evaluating both objectives and applies a hybrid local search combining route segmentation and insertion heuristics to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, (total_dist, makespan) in archive:\n        # Prioritize solutions with high makespan or high total distance\n        score = makespan + 0.5 * total_dist\n        candidates.append((score, sol))\n\n    # Sort by score (descending) and pick the top few\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = candidates[0][1].copy()\n\n    # Hybrid local search: segment and reinsert\n    new_solution = selected_solution.copy()\n    num_routes = len(new_solution)\n\n    # Randomly select a route to modify\n    if num_routes > 1:\n        route_idx = random.randint(0, num_routes - 1)\n        route = new_solution[route_idx].copy()\n\n        # Split the route into segments\n        split_pos = random.randint(1, len(route) - 2)\n        segment1 = route[:split_pos + 1]  # Includes depot\n        segment2 = route[split_pos:]\n\n        # Reinsert segment2 into another route or create a new route\n        if num_routes > 1 and random.random() < 0.7:\n            # Try to merge with another route\n            other_route_idx = (route_idx + random.randint(1, num_routes - 1)) % num_routes\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check if merging is feasible\n            total_demand = np.sum(demand[segment2[1:-1]]) + np.sum(demand[other_route[1:-1]])\n            if total_demand <= capacity:\n                # Merge segment2 into other_route\n                merged_route = np.concatenate([other_route[:-1], segment2[1:]])\n                new_solution[other_route_idx] = merged_route\n                new_solution[route_idx] = segment1\n        else:\n            # Create a new route with segment2\n            if np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution[route_idx] = segment1\n                new_solution.append(segment2)\n\n    # Ensure all customers are served and routes are valid\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Recover missing customers by reinserting them\n        missing = all_customers - served_customers\n        for customer in missing:\n            best_route = None\n            best_insert_pos = None\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for j in range(len(route) - 1):\n                    # Check if inserting customer between route[j] and route[j+1] is feasible\n                    new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                    if new_demand <= capacity:\n                        # Calculate the increase in distance\n                        dist_increase = (distance_matrix[route[j]][customer] +\n                                       distance_matrix[customer][route[j+1]] -\n                                       distance_matrix[route[j]][route[j+1]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_route = i\n                            best_insert_pos = j + 1\n\n            if best_route is not None:\n                # Insert the customer into the best position\n                route = new_solution[best_route].copy()\n                new_route = np.concatenate([route[:best_insert_pos], [customer], route[best_insert_pos:]])\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7645305114521218,
            1.7554824948310852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, (total_dist, makespan) in archive:\n        # Prioritize solutions with high makespan or high total distance\n        score = makespan + 0.5 * total_dist\n        candidates.append((score, sol))\n\n    # Sort by score (descending) and pick the top few\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = candidates[0][1].copy()\n\n    # Hybrid local search: segment and reinsert\n    new_solution = selected_solution.copy()\n    num_routes = len(new_solution)\n\n    # Randomly select a route to modify\n    if num_routes > 1:\n        route_idx = random.randint(0, num_routes - 1)\n        route = new_solution[route_idx].copy()\n\n        # Split the route into segments\n        split_pos = random.randint(1, len(route) - 2)\n        segment1 = route[:split_pos + 1]  # Includes depot\n        segment2 = route[split_pos:]\n\n        # Reinsert segment2 into another route or create a new route\n        if num_routes > 1 and random.random() < 0.7:\n            # Try to merge with another route\n            other_route_idx = (route_idx + random.randint(1, num_routes - 1)) % num_routes\n            other_route = new_solution[other_route_idx].copy()\n\n            # Check if merging is feasible\n            total_demand = np.sum(demand[segment2[1:-1]]) + np.sum(demand[other_route[1:-1]])\n            if total_demand <= capacity:\n                # Merge segment2 into other_route\n                merged_route = np.concatenate([other_route[:-1], segment2[1:]])\n                new_solution[other_route_idx] = merged_route\n                new_solution[route_idx] = segment1\n        else:\n            # Create a new route with segment2\n            if np.sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution[route_idx] = segment1\n                new_solution.append(segment2)\n\n    # Ensure all customers are served and routes are valid\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Recover missing customers by reinserting them\n        missing = all_customers - served_customers\n        for customer in missing:\n            best_route = None\n            best_insert_pos = None\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                for j in range(len(route) - 1):\n                    # Check if inserting customer between route[j] and route[j+1] is feasible\n                    new_demand = np.sum(demand[route[1:-1]]) + demand[customer]\n                    if new_demand <= capacity:\n                        # Calculate the increase in distance\n                        dist_increase = (distance_matrix[route[j]][customer] +\n                                       distance_matrix[customer][route[j+1]] -\n                                       distance_matrix[route[j]][route[j+1]])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_route = i\n                            best_insert_pos = j + 1\n\n            if best_route is not None:\n                # Insert the customer into the best position\n                route = new_solution[best_route].copy()\n                new_route = np.concatenate([route[:best_insert_pos], [customer], route[best_insert_pos:]])\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: split the route into two parts and reinsert customers\n    split_pos = np.random.randint(1, len(route) - 2)  # Ensure at least one customer on each side\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos + 1:]\n\n    # Reconstruct the route by alternating between part1 and part2\n    new_route = [0]\n    i, j = 1, 1\n    while i < len(part1) - 1 or j < len(part2) - 1:\n        if i < len(part1) - 1 and (j >= len(part2) - 1 or np.random.rand() > 0.5):\n            new_route.append(part1[i])\n            i += 1\n        elif j < len(part2) - 1:\n            new_route.append(part2[j])\n            j += 1\n    new_route.append(0)\n\n    # Ensure capacity constraints are met\n    total_demand = sum(demand[customer] for customer in new_route[1:-1])\n    if total_demand > capacity:\n        # If capacity is exceeded, revert to the original route\n        new_route = route.copy()\n\n    # Update the solution\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = np.array(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7879049937606702,
            0.18775567412376404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][0])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # Apply a hybrid local search: split the route into two parts and reinsert customers\n    split_pos = np.random.randint(1, len(route) - 2)  # Ensure at least one customer on each side\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos + 1:]\n\n    # Reconstruct the route by alternating between part1 and part2\n    new_route = [0]\n    i, j = 1, 1\n    while i < len(part1) - 1 or j < len(part2) - 1:\n        if i < len(part1) - 1 and (j >= len(part2) - 1 or np.random.rand() > 0.5):\n            new_route.append(part1[i])\n            i += 1\n        elif j < len(part2) - 1:\n            new_route.append(part2[j])\n            j += 1\n    new_route.append(0)\n\n    # Ensure capacity constraints are met\n    total_demand = sum(demand[customer] for customer in new_route[1:-1])\n    if total_demand > capacity:\n        # If capacity is exceeded, revert to the original route\n        new_route = route.copy()\n\n    # Update the solution\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = np.array(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid approach combining distance-based selection and makespan-aware perturbation, then applies a novel route-segment swap and reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then pick a solution with good balance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = min(len(archive_sorted) - 1, int(0.3 * len(archive_sorted)))\n        selected_solution = archive_sorted[selected_idx][0]\n    else:\n        selected_solution = archive[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search operator\n    if len(new_solution) > 1:\n        # Select two routes to modify\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find segments to swap or reverse\n        if len(route1) > 3 and len(route2) > 3:\n            # Randomly select segments from both routes (excluding depot)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end + 1]\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Check capacity constraints\n            if (np.sum(demand[seg1]) + np.sum(demand[route2]) - np.sum(demand[seg2]) <= capacity and\n                np.sum(demand[seg2]) + np.sum(demand[route1]) - np.sum(demand[seg1]) <= capacity):\n\n                # Swap segments and optionally reverse one\n                if random.random() > 0.5:\n                    seg1 = seg1[::-1]\n\n                # Replace segments\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8042088082802399,
            0.9194480776786804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then pick a solution with good balance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = min(len(archive_sorted) - 1, int(0.3 * len(archive_sorted)))\n        selected_solution = archive_sorted[selected_idx][0]\n    else:\n        selected_solution = archive[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search operator\n    if len(new_solution) > 1:\n        # Select two routes to modify\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find segments to swap or reverse\n        if len(route1) > 3 and len(route2) > 3:\n            # Randomly select segments from both routes (excluding depot)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end + 1]\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Check capacity constraints\n            if (np.sum(demand[seg1]) + np.sum(demand[route2]) - np.sum(demand[seg2]) <= capacity and\n                np.sum(demand[seg2]) + np.sum(demand[route1]) - np.sum(demand[seg1]) <= capacity):\n\n                # Swap segments and optionally reverse one\n                if random.random() > 0.5:\n                    seg1 = seg1[::-1]\n\n                # Replace segments\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive[-1][0].copy()  # Pick the solution with highest total distance (most promising for improvement)\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random customer\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Try to reallocate customers from part2 to existing routes or new routes\n        for i, customer in enumerate(part2[1:-1]):  # Skip depot nodes\n            best_route = None\n            best_cost = float('inf')\n            for j, existing_route in enumerate(new_solution):\n                # Check if adding customer to existing_route is feasible\n                if np.sum(demand[existing_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate insertion cost (simplified)\n                    insertion_cost = distance_matrix[existing_route[-2], customer] + distance_matrix[customer, existing_route[-1]] - distance_matrix[existing_route[-2], existing_route[-1]]\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_route = j\n\n            if best_route is not None:\n                # Insert customer into the best route\n                new_solution[best_route] = np.insert(new_solution[best_route], -1, customer)\n            else:\n                # Create a new route if no feasible insertion found\n                new_solution.append(np.array([0, customer, 0]))\n\n        # Add the remaining part1 to the new solution\n        new_solution.append(part1)\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7317827516391042,
            9.660946607589722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive[-1][0].copy()  # Pick the solution with highest total distance (most promising for improvement)\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random customer\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Try to reallocate customers from part2 to existing routes or new routes\n        for i, customer in enumerate(part2[1:-1]):  # Skip depot nodes\n            best_route = None\n            best_cost = float('inf')\n            for j, existing_route in enumerate(new_solution):\n                # Check if adding customer to existing_route is feasible\n                if np.sum(demand[existing_route[1:-1]]) + demand[customer] <= capacity:\n                    # Calculate insertion cost (simplified)\n                    insertion_cost = distance_matrix[existing_route[-2], customer] + distance_matrix[customer, existing_route[-1]] - distance_matrix[existing_route[-2], existing_route[-1]]\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_route = j\n\n            if best_route is not None:\n                # Insert customer into the best route\n                new_solution[best_route] = np.insert(new_solution[best_route], -1, customer)\n            else:\n                # Create a new route if no feasible insertion found\n                new_solution.append(np.array([0, customer, 0]))\n\n        # Add the remaining part1 to the new solution\n        new_solution.append(part1)\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{A hybrid local search operator that combines route swapping with demand-balanced route splitting to improve both total distance and makespan by intelligently redistributing customers across routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route swapping + demand-balanced splitting\n    if len(new_solution) > 1:\n        # Select two routes for swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to split and merge routes to balance demands\n        split_pos1 = np.random.randint(1, len(route1) - 1)\n        split_pos2 = np.random.randint(1, len(route2) - 1)\n\n        # Create new routes by splitting\n        new_route1_part1 = route1[:split_pos1 + 1]\n        new_route1_part2 = route1[split_pos1:]\n        new_route2_part1 = route2[:split_pos2 + 1]\n        new_route2_part2 = route2[split_pos2:]\n\n        # Check capacity constraints\n        def check_capacity(route):\n            return sum(demand[node] for node in route[1:-1]) <= capacity\n\n        if check_capacity(new_route1_part1) and check_capacity(new_route2_part2):\n            # Swap parts between routes\n            new_route1 = np.concatenate([new_route1_part1, new_route2_part2])\n            new_route2 = np.concatenate([new_route2_part1, new_route1_part2])\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Additional improvement: Try to move a customer to a different route if it improves makespan\n    for route in new_solution:\n        if len(route) > 3:  # If route has more than just depot and one customer\n            customer_to_move = np.random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is not route:\n                    new_route = np.concatenate([other_route[:-1], [customer_to_move], [0]])\n                    if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                        # Update routes\n                        route = np.delete(route, np.where(route == customer_to_move)[0][0])\n                        other_route = new_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7028419851083627,
            4.300938695669174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route swapping + demand-balanced splitting\n    if len(new_solution) > 1:\n        # Select two routes for swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to split and merge routes to balance demands\n        split_pos1 = np.random.randint(1, len(route1) - 1)\n        split_pos2 = np.random.randint(1, len(route2) - 1)\n\n        # Create new routes by splitting\n        new_route1_part1 = route1[:split_pos1 + 1]\n        new_route1_part2 = route1[split_pos1:]\n        new_route2_part1 = route2[:split_pos2 + 1]\n        new_route2_part2 = route2[split_pos2:]\n\n        # Check capacity constraints\n        def check_capacity(route):\n            return sum(demand[node] for node in route[1:-1]) <= capacity\n\n        if check_capacity(new_route1_part1) and check_capacity(new_route2_part2):\n            # Swap parts between routes\n            new_route1 = np.concatenate([new_route1_part1, new_route2_part2])\n            new_route2 = np.concatenate([new_route2_part1, new_route1_part2])\n\n            if check_capacity(new_route1) and check_capacity(new_route2):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Additional improvement: Try to move a customer to a different route if it improves makespan\n    for route in new_solution:\n        if len(route) > 3:  # If route has more than just depot and one customer\n            customer_to_move = np.random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is not route:\n                    new_route = np.concatenate([other_route[:-1], [customer_to_move], [0]])\n                    if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                        # Update routes\n                        route = np.delete(route, np.where(route == customer_to_move)[0][0])\n                        other_route = new_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A hybrid local search operator that combines adaptive route merging, demand-aware node relocations, and capacity-constrained route splitting to generate high-quality neighbors by intelligently balancing distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] + x[1][0], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine adaptive route merging, demand-aware node relocations, and capacity-constrained route splitting\n    new_solution = []\n\n    # Step 1: Adaptive route merging (merge short routes to reduce makespan)\n    routes = [route.copy() for route in selected_solution]\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(routes)):\n            if len(routes[i]) <= 3:  # Skip trivial routes\n                continue\n            for j in range(len(routes)):\n                if i == j:\n                    continue\n                if len(routes[j]) <= 3:\n                    continue\n                # Check if merging routes i and j is feasible\n                if sum(demand[routes[i][1:-1]]) + sum(demand[routes[j][1:-1]]) <= capacity:\n                    # Merge routes i and j\n                    merged_route = np.concatenate([routes[i][:-1], routes[j][1:]])\n                    new_solution.append(merged_route)\n                    routes[i] = np.array([0])  # Mark as merged\n                    routes[j] = np.array([0])  # Mark as merged\n                    merged = True\n                    break\n            if merged:\n                break\n        if merged:\n            routes = [r for r in routes if len(r) > 1]  # Remove merged routes\n\n    # Add remaining routes\n    new_solution.extend([r for r in routes if len(r) > 1])\n\n    # Step 2: Demand-aware node relocations (move nodes to reduce total distance)\n    for route in new_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n        # Randomly select a node to relocate\n        node_idx = random.randint(1, len(route) - 2)\n        node = route[node_idx]\n        # Find the best position to insert the node in another route\n        best_route = None\n        best_pos = None\n        best_improvement = 0\n        for other_route in new_solution:\n            if np.array_equal(other_route, route):\n                continue\n            if sum(demand[other_route[1:-1]]) + demand[node] > capacity:\n                continue\n            # Try inserting node into other_route at all possible positions\n            for pos in range(1, len(other_route)):\n                # Calculate the change in distance\n                prev_node = other_route[pos - 1]\n                next_node = other_route[pos]\n                old_distance = distance_matrix[prev_node, next_node]\n                new_distance = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                improvement = old_distance - new_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = other_route\n                    best_pos = pos\n        # Perform the relocation if beneficial\n        if best_route is not None and best_pos is not None:\n            # Remove node from current route\n            route = np.delete(route, node_idx)\n            # Insert node into best_route\n            best_route = np.insert(best_route, best_pos, node)\n\n    # Step 3: Capacity-constrained route splitting (split overloaded routes)\n    final_solution = []\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) <= capacity:\n            final_solution.append(route)\n        else:\n            # Split the route into multiple feasible parts\n            current_load = 0\n            current_route = [0]\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_load += demand[node]\n                else:\n                    current_route.append(0)\n                    final_solution.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_load = demand[node]\n            current_route.append(0)\n            final_solution.append(np.array(current_route))\n\n    return np.array(final_solution, dtype=object)\n\n",
        "score": [
            -0.7938063009501954,
            6.658511608839035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] + x[1][0], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine adaptive route merging, demand-aware node relocations, and capacity-constrained route splitting\n    new_solution = []\n\n    # Step 1: Adaptive route merging (merge short routes to reduce makespan)\n    routes = [route.copy() for route in selected_solution]\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(routes)):\n            if len(routes[i]) <= 3:  # Skip trivial routes\n                continue\n            for j in range(len(routes)):\n                if i == j:\n                    continue\n                if len(routes[j]) <= 3:\n                    continue\n                # Check if merging routes i and j is feasible\n                if sum(demand[routes[i][1:-1]]) + sum(demand[routes[j][1:-1]]) <= capacity:\n                    # Merge routes i and j\n                    merged_route = np.concatenate([routes[i][:-1], routes[j][1:]])\n                    new_solution.append(merged_route)\n                    routes[i] = np.array([0])  # Mark as merged\n                    routes[j] = np.array([0])  # Mark as merged\n                    merged = True\n                    break\n            if merged:\n                break\n        if merged:\n            routes = [r for r in routes if len(r) > 1]  # Remove merged routes\n\n    # Add remaining routes\n    new_solution.extend([r for r in routes if len(r) > 1])\n\n    # Step 2: Demand-aware node relocations (move nodes to reduce total distance)\n    for route in new_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n        # Randomly select a node to relocate\n        node_idx = random.randint(1, len(route) - 2)\n        node = route[node_idx]\n        # Find the best position to insert the node in another route\n        best_route = None\n        best_pos = None\n        best_improvement = 0\n        for other_route in new_solution:\n            if np.array_equal(other_route, route):\n                continue\n            if sum(demand[other_route[1:-1]]) + demand[node] > capacity:\n                continue\n            # Try inserting node into other_route at all possible positions\n            for pos in range(1, len(other_route)):\n                # Calculate the change in distance\n                prev_node = other_route[pos - 1]\n                next_node = other_route[pos]\n                old_distance = distance_matrix[prev_node, next_node]\n                new_distance = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                improvement = old_distance - new_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route = other_route\n                    best_pos = pos\n        # Perform the relocation if beneficial\n        if best_route is not None and best_pos is not None:\n            # Remove node from current route\n            route = np.delete(route, node_idx)\n            # Insert node into best_route\n            best_route = np.insert(best_route, best_pos, node)\n\n    # Step 3: Capacity-constrained route splitting (split overloaded routes)\n    final_solution = []\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) <= capacity:\n            final_solution.append(route)\n        else:\n            # Split the route into multiple feasible parts\n            current_load = 0\n            current_route = [0]\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_load += demand[node]\n                else:\n                    current_route.append(0)\n                    final_solution.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_load = demand[node]\n            current_route.append(0)\n            final_solution.append(np.array(current_route))\n\n    return np.array(final_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, applies a hybrid local search combining route splitting, customer relocation, and capacity-aware merging to generate a neighbor solution while ensuring feasibility and balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process 3 times\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(1, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Step 3: Relocate a customer to another route if possible\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 2:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if adding the customer to the other route is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route at the best position\n                    best_pos = 1\n                    min_dist_increase = float('inf')\n                    for i in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[i-1], customer] +\n                                distance_matrix[customer, other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]])\n                        if dist < min_dist_increase:\n                            min_dist_increase = dist\n                            best_pos = i\n\n                    # Update routes\n                    new_route = np.insert(route, customer_pos, customer)\n                    new_route = np.delete(new_route, customer_pos + 1)\n                    new_solution[route_idx] = new_route\n\n                    new_other_route = np.insert(other_route, best_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n    # Step 4: Merge routes if possible to reduce makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Try to connect the two routes\n                best_dist = float('inf')\n                best_merge = None\n\n                # Try connecting route1 to route2\n                for pos1 in range(1, len(route1)):\n                    for pos2 in range(1, len(route2)):\n                        dist = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                               distance_matrix[route2[pos2-1], route1[pos1]] -\n                               distance_matrix[route1[pos1-1], route1[pos1]] -\n                               distance_matrix[route2[pos2-1], route2[pos2]])\n\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_merge = (pos1, pos2)\n\n                if best_merge is not None:\n                    pos1, pos2 = best_merge\n                    merged_route = np.concatenate([\n                        route1[:pos1],\n                        route2[pos2:],\n                        route1[pos1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8637341286981528,
            2.636901080608368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process 3 times\n        # Step 1: Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(1, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Step 3: Relocate a customer to another route if possible\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 2:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if adding the customer to the other route is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route at the best position\n                    best_pos = 1\n                    min_dist_increase = float('inf')\n                    for i in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[i-1], customer] +\n                                distance_matrix[customer, other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]])\n                        if dist < min_dist_increase:\n                            min_dist_increase = dist\n                            best_pos = i\n\n                    # Update routes\n                    new_route = np.insert(route, customer_pos, customer)\n                    new_route = np.delete(new_route, customer_pos + 1)\n                    new_solution[route_idx] = new_route\n\n                    new_other_route = np.insert(other_route, best_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n    # Step 4: Merge routes if possible to reduce makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Try to connect the two routes\n                best_dist = float('inf')\n                best_merge = None\n\n                # Try connecting route1 to route2\n                for pos1 in range(1, len(route1)):\n                    for pos2 in range(1, len(route2)):\n                        dist = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                               distance_matrix[route2[pos2-1], route1[pos1]] -\n                               distance_matrix[route1[pos1-1], route1[pos1]] -\n                               distance_matrix[route2[pos2-1], route2[pos2]])\n\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_merge = (pos1, pos2)\n\n                if best_merge is not None:\n                    pos1, pos2 = best_merge\n                    merged_route = np.concatenate([\n                        route1[:pos1],\n                        route2[pos2:],\n                        route1[pos1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply a hybrid local search operator: Split the longest route into two parts and reinsert nodes\n    # Find the split point with the smallest total distance between the two parts\n    split_candidates = range(1, len(longest_route) - 1)\n    split_scores = []\n    for split in split_candidates:\n        part1 = longest_route[:split + 1]\n        part2 = longest_route[split:]\n        part1_distance = np.sum(distance_matrix[part1[:-1], part1[1:]])\n        part2_distance = np.sum(distance_matrix[part2[:-1], part2[1:]])\n        split_scores.append(part1_distance + part2_distance)\n    best_split = split_candidates[np.argmin(split_scores)]\n\n    # Split the route into two parts\n    part1 = longest_route[:best_split + 1]\n    part2 = longest_route[best_split:]\n\n    # Step 4: Reinsert nodes from the longer part into the shorter part while respecting capacity\n    nodes_to_reinsert = part2[1:-1]  # Exclude depots\n    np.random.shuffle(nodes_to_reinsert)\n\n    for node in nodes_to_reinsert:\n        best_pos = -1\n        min_increase = float('inf')\n        # Try inserting the node into part1\n        for i in range(1, len(part1)):\n            new_part1 = np.insert(part1, i, node)\n            new_distance = np.sum(distance_matrix[new_part1[:-1], new_part1[1:]])\n            if new_distance < min_increase and np.sum(demand[new_part1[1:-1]]) <= capacity:\n                min_increase = new_distance\n                best_pos = i\n        if best_pos != -1:\n            part1 = np.insert(part1, best_pos, node)\n\n    # Step 5: Update the solution with the modified routes\n    new_solution = selected_solution.copy()\n    new_solution[longest_route_idx] = part1\n    new_solution.append(part2)\n\n    # Step 6: Validate and ensure feasibility\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to the original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8008649557542371,
            6.771838963031769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply a hybrid local search operator: Split the longest route into two parts and reinsert nodes\n    # Find the split point with the smallest total distance between the two parts\n    split_candidates = range(1, len(longest_route) - 1)\n    split_scores = []\n    for split in split_candidates:\n        part1 = longest_route[:split + 1]\n        part2 = longest_route[split:]\n        part1_distance = np.sum(distance_matrix[part1[:-1], part1[1:]])\n        part2_distance = np.sum(distance_matrix[part2[:-1], part2[1:]])\n        split_scores.append(part1_distance + part2_distance)\n    best_split = split_candidates[np.argmin(split_scores)]\n\n    # Split the route into two parts\n    part1 = longest_route[:best_split + 1]\n    part2 = longest_route[best_split:]\n\n    # Step 4: Reinsert nodes from the longer part into the shorter part while respecting capacity\n    nodes_to_reinsert = part2[1:-1]  # Exclude depots\n    np.random.shuffle(nodes_to_reinsert)\n\n    for node in nodes_to_reinsert:\n        best_pos = -1\n        min_increase = float('inf')\n        # Try inserting the node into part1\n        for i in range(1, len(part1)):\n            new_part1 = np.insert(part1, i, node)\n            new_distance = np.sum(distance_matrix[new_part1[:-1], new_part1[1:]])\n            if new_distance < min_increase and np.sum(demand[new_part1[1:-1]]) <= capacity:\n                min_increase = new_distance\n                best_pos = i\n        if best_pos != -1:\n            part1 = np.insert(part1, best_pos, node)\n\n    # Step 5: Update the solution with the modified routes\n    new_solution = selected_solution.copy()\n    new_solution[longest_route_idx] = part1\n    new_solution.append(part2)\n\n    # Step 6: Validate and ensure feasibility\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, revert to the original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware 3-opt moves to generate a neighbor solution while balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [total_dist + makespan for _, (total_dist, makespan) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # More than just depot-depot\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos:]])\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # 2. Customer reallocation: Move customers between routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i != j:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                current_cap_i = sum(demand[route_i[1:-1]])\n                current_cap_j = sum(demand[route_j[1:-1]])\n\n                for customer in route_i[1:-1]:\n                    if current_cap_j + demand[customer] <= capacity:\n                        # Try moving customer to route_j\n                        temp_route_i = route_i[route_i != customer]\n                        temp_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n                        # Check feasibility\n                        if len(temp_route_i) > 1:  # At least depot-depot\n                            new_solution[i] = temp_route_i\n                            new_solution[j] = temp_route_j\n                            break\n\n    # 3. Capacity-aware 3-opt: Apply 3-opt within a single route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes (depot + 3 customers)\n            # Select three random segments to reverse\n            i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n            new_route = np.concatenate([\n                route[:i],\n                route[i:j][::-1],\n                route[j:k][::-1],\n                route[k:]\n            ])\n\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6537484946096798,
            9.771344184875488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [total_dist + makespan for _, (total_dist, makespan) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:  # More than just depot-depot\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos:]])\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # 2. Customer reallocation: Move customers between routes if capacity allows\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i != j:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                current_cap_i = sum(demand[route_i[1:-1]])\n                current_cap_j = sum(demand[route_j[1:-1]])\n\n                for customer in route_i[1:-1]:\n                    if current_cap_j + demand[customer] <= capacity:\n                        # Try moving customer to route_j\n                        temp_route_i = route_i[route_i != customer]\n                        temp_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n\n                        # Check feasibility\n                        if len(temp_route_i) > 1:  # At least depot-depot\n                            new_solution[i] = temp_route_i\n                            new_solution[j] = temp_route_j\n                            break\n\n    # 3. Capacity-aware 3-opt: Apply 3-opt within a single route\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes (depot + 3 customers)\n            # Select three random segments to reverse\n            i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n            new_route = np.concatenate([\n                route[:i],\n                route[i:j][::-1],\n                route[j:k][::-1],\n                route[k:]\n            ])\n\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, then applies a hybrid local search combining route splitting, customer reinsertion with capacity-aware swaps, and adaptive route merging to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and compute weights\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n\n        # Normalize objectives\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n        if max_dist > min_dist:\n            normalized_dist = (max_dist - distances) / (max_dist - min_dist)\n        else:\n            normalized_dist = np.ones_like(distances)\n\n        if max_makespan > min_makespan:\n            normalized_makespan = (max_makespan - makespans) / (max_makespan - min_makespan)\n        else:\n            normalized_makespan = np.ones_like(makespans)\n\n        # Compute weights (higher weight for better solutions)\n        weights = normalized_dist + normalized_makespan\n        weights = weights / np.sum(weights)\n\n        # Randomly select a solution based on weights\n        selected_idx = np.random.choice(len(archive), p=weights)\n        selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Split, Reinsert, Merge\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n        else:\n            route_idx = 0\n\n        route = new_solution[route_idx].copy()\n\n        # Split the route at a random point\n        if len(route) > 3:  # Need at least 3 nodes (0, customer, 0)\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            # Check capacity constraints\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n            else:\n                # If split violates capacity, try reinsertion instead\n                # Remove a random customer and reinsert elsewhere\n                if len(route) > 3:\n                    customer_pos = random.randint(1, len(route) - 2)\n                    customer = route[customer_pos]\n\n                    # Remove customer from the route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                    # Find feasible insertion points in other routes\n                    feasible_insertions = []\n                    for i, r in enumerate(new_solution):\n                        if i == route_idx:\n                            continue\n                        for j in range(1, len(r)):\n                            # Insert customer between r[j-1] and r[j]\n                            temp_route = np.concatenate([r[:j], [customer], r[j:]])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                feasible_insertions.append((i, j, temp_route))\n\n                    if feasible_insertions:\n                        # Select a random feasible insertion\n                        insert_route_idx, insert_pos, insert_route = random.choice(feasible_insertions)\n                        new_solution[route_idx] = new_route\n                        new_solution[insert_route_idx] = insert_route\n\n        # Merge adjacent routes if possible\n        if len(new_solution) > 1:\n            # Try to merge with the next route\n            if route_idx < len(new_solution) - 1:\n                next_route = new_solution[route_idx + 1]\n                merged_route = np.concatenate([new_solution[route_idx][:-1], next_route[1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = merged_route\n                    new_solution.pop(route_idx + 1)\n\n            # Try to merge with the previous route\n            elif route_idx > 0:\n                prev_route = new_solution[route_idx - 1]\n                merged_route = np.concatenate([prev_route[:-1], new_solution[route_idx][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[route_idx - 1] = merged_route\n                    new_solution.pop(route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.7833151193435377,
            0.6667830646038055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and compute weights\n        distances = np.array([obj[0] for _, obj in archive])\n        makespans = np.array([obj[1] for _, obj in archive])\n\n        # Normalize objectives\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n        if max_dist > min_dist:\n            normalized_dist = (max_dist - distances) / (max_dist - min_dist)\n        else:\n            normalized_dist = np.ones_like(distances)\n\n        if max_makespan > min_makespan:\n            normalized_makespan = (max_makespan - makespans) / (max_makespan - min_makespan)\n        else:\n            normalized_makespan = np.ones_like(makespans)\n\n        # Compute weights (higher weight for better solutions)\n        weights = normalized_dist + normalized_makespan\n        weights = weights / np.sum(weights)\n\n        # Randomly select a solution based on weights\n        selected_idx = np.random.choice(len(archive), p=weights)\n        selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Split, Reinsert, Merge\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n        else:\n            route_idx = 0\n\n        route = new_solution[route_idx].copy()\n\n        # Split the route at a random point\n        if len(route) > 3:  # Need at least 3 nodes (0, customer, 0)\n            split_pos = random.randint(1, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            # Check capacity constraints\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n            else:\n                # If split violates capacity, try reinsertion instead\n                # Remove a random customer and reinsert elsewhere\n                if len(route) > 3:\n                    customer_pos = random.randint(1, len(route) - 2)\n                    customer = route[customer_pos]\n\n                    # Remove customer from the route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                    # Find feasible insertion points in other routes\n                    feasible_insertions = []\n                    for i, r in enumerate(new_solution):\n                        if i == route_idx:\n                            continue\n                        for j in range(1, len(r)):\n                            # Insert customer between r[j-1] and r[j]\n                            temp_route = np.concatenate([r[:j], [customer], r[j:]])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                feasible_insertions.append((i, j, temp_route))\n\n                    if feasible_insertions:\n                        # Select a random feasible insertion\n                        insert_route_idx, insert_pos, insert_route = random.choice(feasible_insertions)\n                        new_solution[route_idx] = new_route\n                        new_solution[insert_route_idx] = insert_route\n\n        # Merge adjacent routes if possible\n        if len(new_solution) > 1:\n            # Try to merge with the next route\n            if route_idx < len(new_solution) - 1:\n                next_route = new_solution[route_idx + 1]\n                merged_route = np.concatenate([new_solution[route_idx][:-1], next_route[1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = merged_route\n                    new_solution.pop(route_idx + 1)\n\n            # Try to merge with the previous route\n            elif route_idx > 0:\n                prev_route = new_solution[route_idx - 1]\n                merged_route = np.concatenate([prev_route[:-1], new_solution[route_idx][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[route_idx - 1] = merged_route\n                    new_solution.pop(route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route shortening and demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        # Step 1: Try to shorten the route by removing non-critical customers\n        for j in range(1, len(route)-1):\n            if len(route) > 3:  # Keep at least one customer\n                temp_route = np.delete(route, j)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Check if distance is reduced\n                    dist = sum(distance_matrix[temp_route[k]][temp_route[k+1]] for k in range(len(temp_route)-1))\n                    original_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                    if dist < original_dist:\n                        route = temp_route\n                        break\n        # Step 2: Balance demands between routes by moving customers\n        if i < len(new_solution)-1:\n            next_route = new_solution[i+1]\n            current_demand = np.sum(demand[route[1:-1]])\n            next_demand = np.sum(demand[next_route[1:-1]])\n            if abs(current_demand - next_demand) > capacity * 0.2:  # Significant imbalance\n                # Find a customer to move\n                for j in range(1, len(route)-1):\n                    customer = route[j]\n                    if demand[customer] <= capacity - next_demand:\n                        # Check if moving improves makespan\n                        new_next_route = np.insert(next_route, -1, customer)\n                        new_route = np.delete(route, j)\n                        new_current_demand = np.sum(demand[new_route[1:-1]])\n                        new_next_demand = np.sum(demand[new_next_route[1:-1]])\n                        if new_current_demand <= capacity and new_next_demand <= capacity:\n                            # Check if makespan is improved\n                            current_max = max(sum(distance_matrix[r[k]][r[k+1]] for k in range(len(r)-1)) for r in new_solution)\n                            new_max = max(\n                                sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1)),\n                                sum(distance_matrix[new_next_route[k]][new_next_route[k+1]] for k in range(len(new_next_route)-1))\n                            )\n                            if new_max <= current_max:\n                                new_solution[i] = new_route\n                                new_solution[i+1] = new_next_route\n                                break\n    return new_solution\n\n",
        "score": [
            -0.7106888451919057,
            2.5450479686260223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route shortening and demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        # Step 1: Try to shorten the route by removing non-critical customers\n        for j in range(1, len(route)-1):\n            if len(route) > 3:  # Keep at least one customer\n                temp_route = np.delete(route, j)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Check if distance is reduced\n                    dist = sum(distance_matrix[temp_route[k]][temp_route[k+1]] for k in range(len(temp_route)-1))\n                    original_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                    if dist < original_dist:\n                        route = temp_route\n                        break\n        # Step 2: Balance demands between routes by moving customers\n        if i < len(new_solution)-1:\n            next_route = new_solution[i+1]\n            current_demand = np.sum(demand[route[1:-1]])\n            next_demand = np.sum(demand[next_route[1:-1]])\n            if abs(current_demand - next_demand) > capacity * 0.2:  # Significant imbalance\n                # Find a customer to move\n                for j in range(1, len(route)-1):\n                    customer = route[j]\n                    if demand[customer] <= capacity - next_demand:\n                        # Check if moving improves makespan\n                        new_next_route = np.insert(next_route, -1, customer)\n                        new_route = np.delete(route, j)\n                        new_current_demand = np.sum(demand[new_route[1:-1]])\n                        new_next_demand = np.sum(demand[new_next_route[1:-1]])\n                        if new_current_demand <= capacity and new_next_demand <= capacity:\n                            # Check if makespan is improved\n                            current_max = max(sum(distance_matrix[r[k]][r[k+1]] for k in range(len(r)-1)) for r in new_solution)\n                            new_max = max(\n                                sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1)),\n                                sum(distance_matrix[new_next_route[k]][new_next_route[k+1]] for k in range(len(new_next_route)-1))\n                            )\n                            if new_max <= current_max:\n                                new_solution[i] = new_route\n                                new_solution[i+1] = new_next_route\n                                break\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        base_solution = random.choice(archive_sorted[:max(1, len(archive) // 2)])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Cross-route segment relocation + cross-route segment swap\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Extract a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check if segment can be moved to route2 without exceeding capacity\n            if (sum(demand[segment]) + sum(demand[route2[1:-1]])) <= capacity:\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Insert segment into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        # Cross-route segment swap\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments from both routes\n            start1 = random.randint(1, len(route1) - 3)\n            end1 = random.randint(start1 + 1, len(route1) - 2)\n            start2 = random.randint(1, len(route2) - 3)\n            end2 = random.randint(start2 + 1, len(route2) - 2)\n\n            segment1 = route1[start1:end1]\n            segment2 = route2[start2:end2]\n\n            # Check capacity constraints\n            if (sum(demand[segment1]) + sum(demand[route2[1:-1]]) - sum(demand[segment2])) <= capacity and \\\n               (sum(demand[segment2]) + sum(demand[route1[1:-1]]) - sum(demand[segment1])) <= capacity:\n\n                # Perform swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8630900629624585,
            0.7752290368080139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        base_solution = random.choice(archive_sorted[:max(1, len(archive) // 2)])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Cross-route segment relocation + cross-route segment swap\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Extract a random segment from route1 (excluding depot)\n        if len(route1) > 3:\n            start_idx = random.randint(1, len(route1) - 3)\n            end_idx = random.randint(start_idx + 1, len(route1) - 2)\n            segment = route1[start_idx:end_idx]\n\n            # Check if segment can be moved to route2 without exceeding capacity\n            if (sum(demand[segment]) + sum(demand[route2[1:-1]])) <= capacity:\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx:]])\n\n                # Insert segment into route2 at a random position\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        # Cross-route segment swap\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments from both routes\n            start1 = random.randint(1, len(route1) - 3)\n            end1 = random.randint(start1 + 1, len(route1) - 2)\n            start2 = random.randint(1, len(route2) - 3)\n            end2 = random.randint(start2 + 1, len(route2) - 2)\n\n            segment1 = route1[start1:end1]\n            segment2 = route2[start2:end2]\n\n            # Check capacity constraints\n            if (sum(demand[segment1]) + sum(demand[route2[1:-1]]) - sum(demand[segment2])) <= capacity and \\\n               (sum(demand[segment2]) + sum(demand[route1[1:-1]]) - sum(demand[segment1])) <= capacity:\n\n                # Perform swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: route merging and 3-opt* with capacity constraints\n    new_solution = base_solution.copy()\n    num_routes = len(new_solution)\n\n    # Step 1: Route Merging - Merge two routes if their combined demand is <= capacity\n    if num_routes > 1:\n        for i in range(num_routes):\n            for j in range(i + 1, num_routes):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes by inserting route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if k in (i, j) else route for k, route in enumerate(new_solution)]\n                    new_solution = [route for route in new_solution if len(route) > 2]  # Remove empty routes\n                    break\n\n    # Step 2: 3-opt* with Capacity Constraints - Apply to a randomly selected route\n    if len(new_solution) > 0:\n        selected_route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[selected_route_idx][1:-1]  # Exclude depot\n\n        # Randomly select 3 distinct segments from the route\n        n = len(selected_route)\n        if n >= 3:\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            segment1 = selected_route[:a]\n            segment2 = selected_route[a:b]\n            segment3 = selected_route[b:c]\n            segment4 = selected_route[c:]\n\n            # Generate all possible permutations of these segments\n            permutations = [\n                np.concatenate([segment1, segment2, segment3, segment4]),\n                np.concatenate([segment1, segment3, segment2, segment4]),\n                np.concatenate([segment2, segment1, segment3, segment4]),\n                np.concatenate([segment2, segment3, segment1, segment4]),\n                np.concatenate([segment3, segment1, segment2, segment4]),\n                np.concatenate([segment3, segment2, segment1, segment4])\n            ]\n\n            # Evaluate each permutation and check capacity constraints\n            best_permutation = None\n            min_distance = float('inf')\n            for perm in permutations:\n                # Reconstruct the route with depot\n                candidate_route = np.concatenate([[0], perm, [0]])\n                # Check capacity constraint\n                if sum(demand[perm]) <= capacity:\n                    # Calculate distance of the candidate route\n                    dist = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_permutation = candidate_route\n\n            if best_permutation is not None:\n                new_solution[selected_route_idx] = best_permutation\n\n    # Step 3: Random Swap with Capacity Check - Swap two customers between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depot)\n            cust1 = np.random.randint(1, len(route1)-1)\n            cust2 = np.random.randint(1, len(route2)-1)\n\n            # Swap the customers\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n            new_route1[cust1], new_route2[cust2] = new_route2[cust2], new_route1[cust1]\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.589236459635875,
            2.3555933237075806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: route merging and 3-opt* with capacity constraints\n    new_solution = base_solution.copy()\n    num_routes = len(new_solution)\n\n    # Step 1: Route Merging - Merge two routes if their combined demand is <= capacity\n    if num_routes > 1:\n        for i in range(num_routes):\n            for j in range(i + 1, num_routes):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes by inserting route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if k in (i, j) else route for k, route in enumerate(new_solution)]\n                    new_solution = [route for route in new_solution if len(route) > 2]  # Remove empty routes\n                    break\n\n    # Step 2: 3-opt* with Capacity Constraints - Apply to a randomly selected route\n    if len(new_solution) > 0:\n        selected_route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[selected_route_idx][1:-1]  # Exclude depot\n\n        # Randomly select 3 distinct segments from the route\n        n = len(selected_route)\n        if n >= 3:\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            segment1 = selected_route[:a]\n            segment2 = selected_route[a:b]\n            segment3 = selected_route[b:c]\n            segment4 = selected_route[c:]\n\n            # Generate all possible permutations of these segments\n            permutations = [\n                np.concatenate([segment1, segment2, segment3, segment4]),\n                np.concatenate([segment1, segment3, segment2, segment4]),\n                np.concatenate([segment2, segment1, segment3, segment4]),\n                np.concatenate([segment2, segment3, segment1, segment4]),\n                np.concatenate([segment3, segment1, segment2, segment4]),\n                np.concatenate([segment3, segment2, segment1, segment4])\n            ]\n\n            # Evaluate each permutation and check capacity constraints\n            best_permutation = None\n            min_distance = float('inf')\n            for perm in permutations:\n                # Reconstruct the route with depot\n                candidate_route = np.concatenate([[0], perm, [0]])\n                # Check capacity constraint\n                if sum(demand[perm]) <= capacity:\n                    # Calculate distance of the candidate route\n                    dist = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_permutation = candidate_route\n\n            if best_permutation is not None:\n                new_solution[selected_route_idx] = best_permutation\n\n    # Step 3: Random Swap with Capacity Check - Swap two customers between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depot)\n            cust1 = np.random.randint(1, len(route1)-1)\n            cust2 = np.random.randint(1, len(route2)-1)\n\n            # Swap the customers\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n            new_route1[cust1], new_route2[cust2] = new_route2[cust2], new_route1[cust1]\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraint for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two parts\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        if len(longest_route) > 3:\n            # Select a random customer to reinsert\n            reinsert_pos = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[reinsert_pos]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                candidate_route = new_solution[j].copy()\n                # Try inserting at all possible positions\n                for k in range(1, len(candidate_route)):\n                    new_route = np.insert(candidate_route, k, customer)\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[j] = new_route\n                        new_solution[longest_route_idx] = np.delete(longest_route, reinsert_pos)\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7479215115377527,
            0.31913071870803833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])  # Sort by makespan descending\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraint for both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two parts\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Reinsert customers from the longest route to balance makespan\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        if len(longest_route) > 3:\n            # Select a random customer to reinsert\n            reinsert_pos = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[reinsert_pos]\n\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                candidate_route = new_solution[j].copy()\n                # Try inserting at all possible positions\n                for k in range(1, len(candidate_route)):\n                    new_route = np.insert(candidate_route, k, customer)\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[j] = new_route\n                        new_solution[longest_route_idx] = np.delete(longest_route, reinsert_pos)\n                        return new_solution\n\n    return new_solution\n\n"
    }
]