[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route merging with demand-aware customer reallocation, followed by a makespan-balancing swap, to simultaneously reduce total distance and improve route balance while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.49188128915382856,
            2.588647037744522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route merging with demand-aware customer reallocation, followed by a makespan-balancing swap, to simultaneously reduce total distance and improve route balance while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.49188128915382856,
            2.588647037744522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines route merging with demand-aware customer reallocation, followed by a makespan-balancing swap, to simultaneously reduce total distance and improve route balance while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.49188128915382856,
            2.588647037744522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Step 1: Route merging with demand-aware customer reallocation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Try to merge routes if capacity allows\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Reallocate customers between routes to balance demand\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Shuffle customers to find a feasible order\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)\n            # Reconstruct route with shuffled customers\n            current_load = 0\n            new_route = [0]\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            new_solution.append(new_route)\n            # Remove original routes\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n\n    # Step 2: Makespan-balancing swap\n    if len(new_solution) > 1:\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n        longest_indices = np.argsort(route_lengths)[-2:]\n        route1, route2 = new_solution[longest_indices[0]], new_solution[longest_indices[1]]\n\n        # Try to swap customers between routes to balance makespan\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route\n                cust1 = np.random.choice(route1[1:-1])\n                cust2 = np.random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_load1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_load2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_load1 <= capacity and new_load2 <= capacity:\n                    # Perform swap\n                    idx1 = np.where(route1 == cust1)[0][0]\n                    idx2 = np.where(route2 == cust2)[0][0]\n                    route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines route splitting with demand-aware node reinsertion, dynamically balancing distance reduction and makespan minimization by selectively merging or splitting routes based on demand and distance trade-offs, while ensuring feasibility through capacity-constrained reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.median([s[1][0] for s in archive]) or sol[1][1] > np.median([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    base_solution = random.choice(candidates)[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split and Reinsert with Demand Awareness\n    for _ in range(2):  # Perform multiple iterations\n        # Select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Find split point with demand balance\n        split_pos = 1\n        min_diff = float('inf')\n        for i in range(1, len(route) - 1):\n            demand_sum = np.sum(demand[route[:i+1]])\n            if demand_sum <= capacity:\n                diff = abs(demand_sum - capacity / 2)\n                if diff < min_diff:\n                    min_diff = diff\n                    split_pos = i\n\n        # Split the route\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Remove original route and add parts\n        new_solution.pop(route_idx)\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n        # Reinsert nodes from the new route with demand-aware heuristic\n        for route_to_fix in [part1, part2]:\n            if len(route_to_fix) <= 2:\n                continue\n\n            # Try to reinsert nodes from the other part\n            for node in route_to_fix[1:-1]:\n                # Find best insertion position in other routes\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for r_idx, r in enumerate(new_solution):\n                    if r_idx == route_idx or len(r) == 2:\n                        continue\n\n                    # Check capacity constraint\n                    current_demand = np.sum(demand[r[1:-1]])\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Evaluate insertion positions\n                    for pos in range(1, len(r)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[r[pos-1], node] +\n                                distance_matrix[node, r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = r_idx\n                            best_pos = pos\n\n                # Perform insertion if beneficial\n                if best_route is not None and best_cost < 0:\n                    # Remove from current route\n                    route_to_fix = np.delete(route_to_fix, np.where(route_to_fix == node)[0][0])\n\n                    # Insert into best position\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8308365999917513,
            9.465745568275452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.median([s[1][0] for s in archive]) or sol[1][1] > np.median([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    base_solution = random.choice(candidates)[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split and Reinsert with Demand Awareness\n    for _ in range(2):  # Perform multiple iterations\n        # Select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Find split point with demand balance\n        split_pos = 1\n        min_diff = float('inf')\n        for i in range(1, len(route) - 1):\n            demand_sum = np.sum(demand[route[:i+1]])\n            if demand_sum <= capacity:\n                diff = abs(demand_sum - capacity / 2)\n                if diff < min_diff:\n                    min_diff = diff\n                    split_pos = i\n\n        # Split the route\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Remove original route and add parts\n        new_solution.pop(route_idx)\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n        # Reinsert nodes from the new route with demand-aware heuristic\n        for route_to_fix in [part1, part2]:\n            if len(route_to_fix) <= 2:\n                continue\n\n            # Try to reinsert nodes from the other part\n            for node in route_to_fix[1:-1]:\n                # Find best insertion position in other routes\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for r_idx, r in enumerate(new_solution):\n                    if r_idx == route_idx or len(r) == 2:\n                        continue\n\n                    # Check capacity constraint\n                    current_demand = np.sum(demand[r[1:-1]])\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Evaluate insertion positions\n                    for pos in range(1, len(r)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[r[pos-1], node] +\n                                distance_matrix[node, r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = r_idx\n                            best_pos = pos\n\n                # Perform insertion if beneficial\n                if best_route is not None and best_cost < 0:\n                    # Remove from current route\n                    route_to_fix = np.delete(route_to_fix, np.where(route_to_fix == node)[0][0])\n\n                    # Insert into best position\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines route splitting with demand-aware node reinsertion, dynamically balancing distance reduction and makespan minimization by selectively merging or splitting routes based on demand and distance trade-offs, while ensuring feasibility through capacity-constrained reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.median([s[1][0] for s in archive]) or sol[1][1] > np.median([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    base_solution = random.choice(candidates)[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split and Reinsert with Demand Awareness\n    for _ in range(2):  # Perform multiple iterations\n        # Select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Find split point with demand balance\n        split_pos = 1\n        min_diff = float('inf')\n        for i in range(1, len(route) - 1):\n            demand_sum = np.sum(demand[route[:i+1]])\n            if demand_sum <= capacity:\n                diff = abs(demand_sum - capacity / 2)\n                if diff < min_diff:\n                    min_diff = diff\n                    split_pos = i\n\n        # Split the route\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Remove original route and add parts\n        new_solution.pop(route_idx)\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n        # Reinsert nodes from the new route with demand-aware heuristic\n        for route_to_fix in [part1, part2]:\n            if len(route_to_fix) <= 2:\n                continue\n\n            # Try to reinsert nodes from the other part\n            for node in route_to_fix[1:-1]:\n                # Find best insertion position in other routes\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for r_idx, r in enumerate(new_solution):\n                    if r_idx == route_idx or len(r) == 2:\n                        continue\n\n                    # Check capacity constraint\n                    current_demand = np.sum(demand[r[1:-1]])\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Evaluate insertion positions\n                    for pos in range(1, len(r)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[r[pos-1], node] +\n                                distance_matrix[node, r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = r_idx\n                            best_pos = pos\n\n                # Perform insertion if beneficial\n                if best_route is not None and best_cost < 0:\n                    # Remove from current route\n                    route_to_fix = np.delete(route_to_fix, np.where(route_to_fix == node)[0][0])\n\n                    # Insert into best position\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8308365999917513,
            9.465745568275452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][0] > np.median([s[1][0] for s in archive]) or sol[1][1] > np.median([s[1][1] for s in archive])]\n    if not candidates:\n        candidates = archive\n    base_solution = random.choice(candidates)[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split and Reinsert with Demand Awareness\n    for _ in range(2):  # Perform multiple iterations\n        # Select a route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Find split point with demand balance\n        split_pos = 1\n        min_diff = float('inf')\n        for i in range(1, len(route) - 1):\n            demand_sum = np.sum(demand[route[:i+1]])\n            if demand_sum <= capacity:\n                diff = abs(demand_sum - capacity / 2)\n                if diff < min_diff:\n                    min_diff = diff\n                    split_pos = i\n\n        # Split the route\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Remove original route and add parts\n        new_solution.pop(route_idx)\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n        # Reinsert nodes from the new route with demand-aware heuristic\n        for route_to_fix in [part1, part2]:\n            if len(route_to_fix) <= 2:\n                continue\n\n            # Try to reinsert nodes from the other part\n            for node in route_to_fix[1:-1]:\n                # Find best insertion position in other routes\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for r_idx, r in enumerate(new_solution):\n                    if r_idx == route_idx or len(r) == 2:\n                        continue\n\n                    # Check capacity constraint\n                    current_demand = np.sum(demand[r[1:-1]])\n                    if current_demand + demand[node] > capacity:\n                        continue\n\n                    # Evaluate insertion positions\n                    for pos in range(1, len(r)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[r[pos-1], node] +\n                                distance_matrix[node, r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = r_idx\n                            best_pos = pos\n\n                # Perform insertion if beneficial\n                if best_route is not None and best_cost < 0:\n                    # Remove from current route\n                    route_to_fix = np.delete(route_to_fix, np.where(route_to_fix == node)[0][0])\n\n                    # Insert into best position\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n    # Ensure all routes are valid (start and end with depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if possible (randomly choose a split point)\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, perform 2-opt on the original route\n            improved_route = route.copy()\n            for i in range(1, len(improved_route) - 2):\n                for j in range(i + 1, len(improved_route) - 1):\n                    new_route = improved_route[:i] + improved_route[i:j][::-1] + improved_route[j:]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        improved_route = new_route\n            new_solution.append(improved_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7474435658511475,
            0.6053726077079773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if possible (randomly choose a split point)\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, perform 2-opt on the original route\n            improved_route = route.copy()\n            for i in range(1, len(improved_route) - 2):\n                for j in range(i + 1, len(improved_route) - 1):\n                    new_route = improved_route[:i] + improved_route[i:j][::-1] + improved_route[j:]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        improved_route = new_route\n            new_solution.append(improved_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if possible (randomly choose a split point)\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, perform 2-opt on the original route\n            improved_route = route.copy()\n            for i in range(1, len(improved_route) - 2):\n                for j in range(i + 1, len(improved_route) - 1):\n                    new_route = improved_route[:i] + improved_route[i:j][::-1] + improved_route[j:]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        improved_route = new_route\n            new_solution.append(improved_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7474435658511475,
            0.6053726077079773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and 2-opt with capacity checks\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route if possible (randomly choose a split point)\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, perform 2-opt on the original route\n            improved_route = route.copy()\n            for i in range(1, len(improved_route) - 2):\n                for j in range(i + 1, len(improved_route) - 1):\n                    new_route = improved_route[:i] + improved_route[i:j][::-1] + improved_route[j:]\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        improved_route = new_route\n            new_solution.append(improved_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy combines route splitting with demand-aware customer reinsertion, dynamically balancing distance and makespan objectives by selectively reallocating high-demand customers to underutilized routes while minimizing detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (ascending) and distance (descending) to prioritize solutions with long routes\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n        selected_solution = sorted_archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route splitting + demand-aware reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Calculate current route demand\n        route_demand = sum(demand[node] for node in route[1:-1])\n\n        # Split route if capacity is underutilized\n        if route_demand < capacity * 0.7:  # Threshold for underutilization\n            # Find a candidate customer to move to another route\n            candidates = [node for node in route[1:-1] if demand[node] > 0]\n            if not candidates:\n                continue\n\n            # Select a customer with high demand to reinsert\n            candidate_node = max(candidates, key=lambda x: demand[x])\n\n            # Find the best insertion position in other routes\n            best_route = None\n            best_position = None\n            best_cost = float('inf')\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check if adding the candidate would exceed capacity\n                other_route_demand = sum(demand[node] for node in other_route[1:-1])\n                if other_route_demand + demand[candidate_node] > capacity:\n                    continue\n\n                # Try inserting candidate in all possible positions in other_route\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost (detour)\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    detour = distance_matrix[prev_node][candidate_node] + distance_matrix[candidate_node][next_node] - distance_matrix[prev_node][next_node]\n\n                    if detour < best_cost:\n                        best_cost = detour\n                        best_route = other_route_idx\n                        best_position = pos\n\n            # Perform the insertion if beneficial\n            if best_route is not None:\n                # Remove from original route\n                new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == candidate_node))\n\n                # Insert into best position in other route\n                new_solution[best_route] = np.insert(new_solution[best_route], best_position, candidate_node)\n\n                # Rebuild routes to maintain depot starts/ends\n                for route in new_solution:\n                    if route[0] != 0 or route[-1] != 0:\n                        route[0] = 0\n                        route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.43305716256945026,
            10.963969379663467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan (ascending) and distance (descending) to prioritize solutions with long routes\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n        selected_solution = sorted_archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route splitting + demand-aware reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Calculate current route demand\n        route_demand = sum(demand[node] for node in route[1:-1])\n\n        # Split route if capacity is underutilized\n        if route_demand < capacity * 0.7:  # Threshold for underutilization\n            # Find a candidate customer to move to another route\n            candidates = [node for node in route[1:-1] if demand[node] > 0]\n            if not candidates:\n                continue\n\n            # Select a customer with high demand to reinsert\n            candidate_node = max(candidates, key=lambda x: demand[x])\n\n            # Find the best insertion position in other routes\n            best_route = None\n            best_position = None\n            best_cost = float('inf')\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Check if adding the candidate would exceed capacity\n                other_route_demand = sum(demand[node] for node in other_route[1:-1])\n                if other_route_demand + demand[candidate_node] > capacity:\n                    continue\n\n                # Try inserting candidate in all possible positions in other_route\n                for pos in range(1, len(other_route)):\n                    # Calculate insertion cost (detour)\n                    prev_node = other_route[pos-1]\n                    next_node = other_route[pos]\n                    detour = distance_matrix[prev_node][candidate_node] + distance_matrix[candidate_node][next_node] - distance_matrix[prev_node][next_node]\n\n                    if detour < best_cost:\n                        best_cost = detour\n                        best_route = other_route_idx\n                        best_position = pos\n\n            # Perform the insertion if beneficial\n            if best_route is not None:\n                # Remove from original route\n                new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == candidate_node))\n\n                # Insert into best position in other route\n                new_solution[best_route] = np.insert(new_solution[best_route], best_position, candidate_node)\n\n                # Rebuild routes to maintain depot starts/ends\n                for route in new_solution:\n                    if route[0] != 0 or route[-1] != 0:\n                        route[0] = 0\n                        route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines route splitting, merging, and cross-exchange moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and pick a solution that is not the best in both objectives\n        sorted_by_makespan = sorted(archive, key=lambda x: x[1][1])\n        candidate_indices = [i for i in range(1, len(sorted_by_makespan)) if sorted_by_makespan[i][1][0] > sorted_by_makespan[0][1][0]]\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = sorted_by_makespan[selected_idx][0].copy()\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) >= 2:\n        # Step 1: Select two routes for potential merging or cross-exchange\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Step 2: Check if merging is feasible\n        total_demand_i = sum(demand[node] for node in route_i[1:-1])\n        total_demand_j = sum(demand[node] for node in route_j[1:-1])\n        if total_demand_i + total_demand_j <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # Perform cross-exchange between the two routes\n            # Select a segment from each route\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select a segment from route_i\n                start_i = random.randint(1, len(route_i) - 3)\n                end_i = random.randint(start_i + 1, len(route_i) - 2)\n                segment_i = route_i[start_i:end_i]\n\n                # Select a segment from route_j\n                start_j = random.randint(1, len(route_j) - 3)\n                end_j = random.randint(start_j + 1, len(route_j) - 2)\n                segment_j = route_j[start_j:end_j]\n\n                # Check feasibility after exchange\n                demand_i_removed = sum(demand[node] for node in segment_i)\n                demand_j_removed = sum(demand[node] for node in segment_j)\n                demand_i_added = sum(demand[node] for node in segment_j)\n                demand_j_added = sum(demand[node] for node in segment_i)\n\n                current_demand_i = sum(demand[node] for node in route_i[1:-1])\n                current_demand_j = sum(demand[node] for node in route_j[1:-1])\n\n                if (current_demand_i - demand_i_removed + demand_i_added <= capacity and\n                    current_demand_j - demand_j_removed + demand_j_added <= capacity):\n                    # Perform the exchange\n                    new_route_i = np.concatenate([route_i[:start_i], segment_j, route_i[end_i:]])\n                    new_route_j = np.concatenate([route_j[:start_j], segment_i, route_j[end_j:]])\n\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Step 3: Apply route splitting if a route is too long\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 4:  # Only consider splitting if route has more than 2 customers\n            # Find the best split point that balances demand\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity / 2:  # Only split if demand is high\n                best_split = None\n                best_balance = float('inf')\n\n                for m in range(2, len(route) - 2):\n                    demand_part1 = sum(demand[node] for node in route[1:m])\n                    demand_part2 = sum(demand[node] for node in route[m:-1])\n                    balance = abs(demand_part1 - demand_part2)\n\n                    if balance < best_balance and demand_part1 <= capacity and demand_part2 <= capacity:\n                        best_balance = balance\n                        best_split = m\n\n                if best_split is not None:\n                    # Split the route\n                    route1 = np.concatenate([route[:best_split], [0]])\n                    route2 = np.concatenate([[0], route[best_split:]])\n                    new_solution[k] = route1\n                    new_solution.insert(k + 1, route2)\n                    break  # Only split one route per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.6141428066725726,
            0.8852093517780304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by makespan and pick a solution that is not the best in both objectives\n        sorted_by_makespan = sorted(archive, key=lambda x: x[1][1])\n        candidate_indices = [i for i in range(1, len(sorted_by_makespan)) if sorted_by_makespan[i][1][0] > sorted_by_makespan[0][1][0]]\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = sorted_by_makespan[selected_idx][0].copy()\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) >= 2:\n        # Step 1: Select two routes for potential merging or cross-exchange\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Step 2: Check if merging is feasible\n        total_demand_i = sum(demand[node] for node in route_i[1:-1])\n        total_demand_j = sum(demand[node] for node in route_j[1:-1])\n        if total_demand_i + total_demand_j <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # Perform cross-exchange between the two routes\n            # Select a segment from each route\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select a segment from route_i\n                start_i = random.randint(1, len(route_i) - 3)\n                end_i = random.randint(start_i + 1, len(route_i) - 2)\n                segment_i = route_i[start_i:end_i]\n\n                # Select a segment from route_j\n                start_j = random.randint(1, len(route_j) - 3)\n                end_j = random.randint(start_j + 1, len(route_j) - 2)\n                segment_j = route_j[start_j:end_j]\n\n                # Check feasibility after exchange\n                demand_i_removed = sum(demand[node] for node in segment_i)\n                demand_j_removed = sum(demand[node] for node in segment_j)\n                demand_i_added = sum(demand[node] for node in segment_j)\n                demand_j_added = sum(demand[node] for node in segment_i)\n\n                current_demand_i = sum(demand[node] for node in route_i[1:-1])\n                current_demand_j = sum(demand[node] for node in route_j[1:-1])\n\n                if (current_demand_i - demand_i_removed + demand_i_added <= capacity and\n                    current_demand_j - demand_j_removed + demand_j_added <= capacity):\n                    # Perform the exchange\n                    new_route_i = np.concatenate([route_i[:start_i], segment_j, route_i[end_i:]])\n                    new_route_j = np.concatenate([route_j[:start_j], segment_i, route_j[end_j:]])\n\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Step 3: Apply route splitting if a route is too long\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 4:  # Only consider splitting if route has more than 2 customers\n            # Find the best split point that balances demand\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > capacity / 2:  # Only split if demand is high\n                best_split = None\n                best_balance = float('inf')\n\n                for m in range(2, len(route) - 2):\n                    demand_part1 = sum(demand[node] for node in route[1:m])\n                    demand_part2 = sum(demand[node] for node in route[m:-1])\n                    balance = abs(demand_part1 - demand_part2)\n\n                    if balance < best_balance and demand_part1 <= capacity and demand_part2 <= capacity:\n                        best_balance = balance\n                        best_split = m\n\n                if best_split is not None:\n                    # Split the route\n                    route1 = np.concatenate([route[:best_split], [0]])\n                    route2 = np.concatenate([[0], route[best_split:]])\n                    new_solution[k] = route1\n                    new_solution.insert(k + 1, route2)\n                    break  # Only split one route per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging and intra-route 2.5-opt with demand-aware swaps\n    if len(new_solution) > 1:\n        # Merge two shortest routes if their combined demand is within capacity\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_indices = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])\n\n        for i in range(len(sorted_indices)-1):\n            route1_idx, route2_idx = sorted_indices[i], sorted_indices[i+1]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n                break\n\n    # Apply demand-aware 2.5-opt (insertion and removal) on the longest route\n    if len(new_solution) > 0:\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1)))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure enough nodes for 2.5-opt\n            # Select 5 random nodes (excluding depot) and attempt a 2.5-opt move\n            nodes = longest_route[1:-1]\n            if len(nodes) >= 5:\n                selected_indices = sorted(random.sample(range(len(nodes)), 5))\n                segment1 = nodes[selected_indices[0]:selected_indices[2]+1]\n                segment2 = nodes[selected_indices[2]+1:selected_indices[4]+1]\n\n                # Try reversing segments and check feasibility\n                reversed_segment1 = segment1[::-1]\n                reversed_segment2 = segment2[::-1]\n\n                if (sum(demand[reversed_segment1]) <= capacity and\n                    sum(demand[reversed_segment2]) <= capacity):\n                    # Apply the move\n                    new_route = np.concatenate([\n                        longest_route[:selected_indices[0]+1],\n                        reversed_segment1,\n                        reversed_segment2,\n                        longest_route[selected_indices[4]+2:]\n                    ])\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.432641285041904,
            1.3751311898231506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging and intra-route 2.5-opt with demand-aware swaps\n    if len(new_solution) > 1:\n        # Merge two shortest routes if their combined demand is within capacity\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_indices = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])\n\n        for i in range(len(sorted_indices)-1):\n            route1_idx, route2_idx = sorted_indices[i], sorted_indices[i+1]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n                break\n\n    # Apply demand-aware 2.5-opt (insertion and removal) on the longest route\n    if len(new_solution) > 0:\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1)))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure enough nodes for 2.5-opt\n            # Select 5 random nodes (excluding depot) and attempt a 2.5-opt move\n            nodes = longest_route[1:-1]\n            if len(nodes) >= 5:\n                selected_indices = sorted(random.sample(range(len(nodes)), 5))\n                segment1 = nodes[selected_indices[0]:selected_indices[2]+1]\n                segment2 = nodes[selected_indices[2]+1:selected_indices[4]+1]\n\n                # Try reversing segments and check feasibility\n                reversed_segment1 = segment1[::-1]\n                reversed_segment2 = segment2[::-1]\n\n                if (sum(demand[reversed_segment1]) <= capacity and\n                    sum(demand[reversed_segment2]) <= capacity):\n                    # Apply the move\n                    new_route = np.concatenate([\n                        longest_route[:selected_indices[0]+1],\n                        reversed_segment1,\n                        reversed_segment2,\n                        longest_route[selected_indices[4]+2:]\n                    ])\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel hybrid criterion combining objective values and solution structure, then applies a custom local search that combines route splitting, customer reallocation, and route merging to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) * (1 + 0.1 * len(sol)) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Custom local search: hybrid route transformation\n    for _ in range(3):  # Repeat the process a few times\n        # Step 1: Select a route to modify\n        if len(new_solution) <= 1:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Attempt to split the route at a feasible point\n        if len(route) > 4:  # Only split if route is long enough\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2[0] = 0  # Ensure new route starts at depot\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                route = new_route1  # Update for next steps\n\n        # Step 3: Attempt to reallocate customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find a customer in the selected route to move\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving this customer to another route is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route at a random position\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_route = np.delete(route, customer_pos)\n\n                    # Update solution\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n        # Step 4: Attempt to merge routes if possible\n        if len(new_solution) > 1:\n            # Find two consecutive routes that can be merged\n            for i in range(len(new_solution) - 1):\n                route1 = new_solution[i]\n                route2 = new_solution[i + 1]\n\n                # Check if merging is feasible\n                if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[i + 1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6924943509427527,
            0.8751875162124634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) * (1 + 0.1 * len(sol)) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Custom local search: hybrid route transformation\n    for _ in range(3):  # Repeat the process a few times\n        # Step 1: Select a route to modify\n        if len(new_solution) <= 1:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Step 2: Attempt to split the route at a feasible point\n        if len(route) > 4:  # Only split if route is long enough\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            new_route2[0] = 0  # Ensure new route starts at depot\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                route = new_route1  # Update for next steps\n\n        # Step 3: Attempt to reallocate customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find a customer in the selected route to move\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving this customer to another route is feasible\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route at a random position\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_route = np.delete(route, customer_pos)\n\n                    # Update solution\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n        # Step 4: Attempt to merge routes if possible\n        if len(new_solution) > 1:\n            # Find two consecutive routes that can be merged\n            for i in range(len(new_solution) - 1):\n                route1 = new_solution[i]\n                route2 = new_solution[i + 1]\n\n                # Check if merging is feasible\n                if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[i + 1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = random.choice(archive[:max(1, len(archive)//2)])[0].copy()  # Randomly pick from top half\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split long routes into two parts\n        split_pos = len(route) // 2\n        new_route1 = np.concatenate((route[:split_pos], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity feasibility\n        demand1 = sum(demand[node] for node in new_route1[1:-1])\n        demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Try multiple reallocations\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        second_longest_idx = np.argmax([l if i != longest_idx else -1 for i, l in enumerate(route_lengths)])\n\n        if longest_idx == second_longest_idx:\n            break\n\n        longest_route = new_solution[longest_idx][1:-1]  # Exclude depot\n        second_route = new_solution[second_longest_idx]\n\n        # Try moving a customer from longest to second route\n        for node in longest_route:\n            new_second_route = np.concatenate((second_route[:-1], [node], [0]))\n            new_demand = sum(demand[n] for n in new_second_route[1:-1])\n\n            if new_demand <= capacity:\n                # Update routes\n                new_solution[longest_idx] = np.concatenate(([0], [n for n in longest_route if n != node], [0]))\n                new_solution[second_longest_idx] = new_second_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6962058638150768,
            1.9082821607589722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = random.choice(archive[:max(1, len(archive)//2)])[0].copy()  # Randomly pick from top half\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split long routes into two parts\n        split_pos = len(route) // 2\n        new_route1 = np.concatenate((route[:split_pos], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos:]))\n\n        # Check capacity feasibility\n        demand1 = sum(demand[node] for node in new_route1[1:-1])\n        demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for _ in range(3):  # Try multiple reallocations\n        # Find the two longest routes\n        route_lengths = [sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        second_longest_idx = np.argmax([l if i != longest_idx else -1 for i, l in enumerate(route_lengths)])\n\n        if longest_idx == second_longest_idx:\n            break\n\n        longest_route = new_solution[longest_idx][1:-1]  # Exclude depot\n        second_route = new_solution[second_longest_idx]\n\n        # Try moving a customer from longest to second route\n        for node in longest_route:\n            new_second_route = np.concatenate((second_route[:-1], [node], [0]))\n            new_demand = sum(demand[n] for n in new_second_route[1:-1])\n\n            if new_demand <= capacity:\n                # Update routes\n                new_solution[longest_idx] = np.concatenate(([0], [n for n in longest_route if n != node], [0]))\n                new_solution[second_longest_idx] = new_second_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Split the longest route into two parts and reinsert customers into the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Reinsert the customers from the split parts into the solution\n    new_solution = []\n    for route in selected_solution:\n        if not np.array_equal(route, longest_route):\n            new_solution.append(route)\n\n    # Check capacity feasibility for part1 and part2\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try to reinsert customers individually\n        customers = part1[1:-1].tolist() + part2[1:-1].tolist()\n        np.random.shuffle(customers)\n        for customer in customers:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7905033398417094,
            0.4199409782886505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Split the longest route into two parts and reinsert customers into the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Reinsert the customers from the split parts into the solution\n    new_solution = []\n    for route in selected_solution:\n        if not np.array_equal(route, longest_route):\n            new_solution.append(route)\n\n    # Check capacity feasibility for part1 and part2\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try to reinsert customers individually\n        customers = part1[1:-1].tolist() + part2[1:-1].tolist()\n        np.random.shuffle(customers)\n        for customer in customers:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Split the longest route into two parts and reinsert customers into the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Reinsert the customers from the split parts into the solution\n    new_solution = []\n    for route in selected_solution:\n        if not np.array_equal(route, longest_route):\n            new_solution.append(route)\n\n    # Check capacity feasibility for part1 and part2\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try to reinsert customers individually\n        customers = part1[1:-1].tolist() + part2[1:-1].tolist()\n        np.random.shuffle(customers)\n        for customer in customers:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7905033398417094,
            0.4199409782886505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Split the longest route into two parts and reinsert customers into the solution\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Reinsert the customers from the split parts into the solution\n    new_solution = []\n    for route in selected_solution:\n        if not np.array_equal(route, longest_route):\n            new_solution.append(route)\n\n    # Check capacity feasibility for part1 and part2\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        new_solution.append(part1)\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try to reinsert customers individually\n        customers = part1[1:-1].tolist() + part2[1:-1].tolist()\n        np.random.shuffle(customers)\n        for customer in customers:\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] if np.random.rand() < 0.5 else x[1][0])[0].copy()\n\n    # Hybrid local search: combine route merging and split with 2-opt intra-route improvement\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 4:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly choose between merging or splitting\n        if np.random.rand() < 0.5:\n            # Route splitting: try to split a long route into two balanced routes\n            split_pos = len(route) // 2\n            route1 = np.concatenate((route[:split_pos + 1], [0]))\n            route2 = np.concatenate(([0], route[split_pos + 1:]))\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # 2-opt intra-route improvement with random segment selection\n            i, j = sorted(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n            new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n            else:\n                new_solution.append(route.copy())\n\n    # Post-processing: attempt to merge small routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) + len(new_solution[j]) - 2 <= 10:  # Small routes\n                merged = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n                if sum(demand[merged[1:-1]]) <= capacity:\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.62859205168418,
            1.860775202512741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] if np.random.rand() < 0.5 else x[1][0])[0].copy()\n\n    # Hybrid local search: combine route merging and split with 2-opt intra-route improvement\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 4:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly choose between merging or splitting\n        if np.random.rand() < 0.5:\n            # Route splitting: try to split a long route into two balanced routes\n            split_pos = len(route) // 2\n            route1 = np.concatenate((route[:split_pos + 1], [0]))\n            route2 = np.concatenate(([0], route[split_pos + 1:]))\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.extend([route1, route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # 2-opt intra-route improvement with random segment selection\n            i, j = sorted(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n            new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n            else:\n                new_solution.append(route.copy())\n\n    # Post-processing: attempt to merge small routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) + len(new_solution[j]) - 2 <= 10:  # Small routes\n                merged = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n                if sum(demand[merged[1:-1]]) <= capacity:\n                    new_solution[i] = merged\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search operator combines route merging, demand-aware node swaps, and makespan-balancing route splits to generate high-quality neighbors by intelligently addressing both total distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator steps:\n    # 1. Route merging: Merge two routes if their combined demand is <= capacity\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them via nearest nodes\n                last_i = route_i[-2]\n                first_j = route_j[1]\n                new_route = np.concatenate([route_i[:-1], route_j[1:]])\n                # Check if merging reduces total distance\n                if distance_matrix[last_i][first_j] < distance_matrix[last_i][0] + distance_matrix[0][first_j]:\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(new_route)\n\n    # 2. Demand-aware node swap: Swap nodes between routes if demands are compatible\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select a node from each route\n                node_i = random.randint(1, len(route_i) - 2)\n                node_j = random.randint(1, len(route_j) - 2)\n                # Check demand compatibility\n                demand_i = demand[route_i[node_i]]\n                demand_j = demand[route_j[node_j]]\n                if (np.sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                    np.sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity):\n                    # Perform swap\n                    new_route_i = route_i.copy()\n                    new_route_j = route_j.copy()\n                    new_route_i[node_i], new_route_j[node_j] = new_route_j[node_j], new_route_i[node_i]\n                    # Check if swap reduces total distance\n                    if (distance_matrix[route_i[node_i-1]][new_route_i[node_i]] +\n                        distance_matrix[new_route_i[node_i]][route_i[node_i+1]] +\n                        distance_matrix[route_j[node_j-1]][new_route_j[node_j]] +\n                        distance_matrix[new_route_j[node_j]][route_j[node_j+1]]) < (\n                        distance_matrix[route_i[node_i-1]][route_i[node_i]] +\n                        distance_matrix[route_i[node_i]][route_i[node_i+1]] +\n                        distance_matrix[route_j[node_j-1]][route_j[node_j]] +\n                        distance_matrix[route_j[node_j]][route_j[node_j+1]]):\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n\n    # 3. Makespan-balancing route split: Split a long route into two if it significantly reduces makespan\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough nodes\n            # Find the point where splitting would balance makespan\n            total_demand = np.sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            split_point = -1\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n            if split_point > 0:\n                # Create two new routes\n                route1 = np.concatenate([route[:split_point+1], [0]])\n                route2 = np.concatenate([[0], route[split_point+1:]])\n                # Check if split reduces makespan\n                if max(distance_matrix[route1[:-1], route1[1:]].sum(),\n                       distance_matrix[route2[:-1], route2[1:]].sum()) < (\n                       distance_matrix[route[:-1], route[1:]].sum()):\n                    # Replace original route with the two new routes\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                    new_solution.extend([route1, route2])\n\n    # Ensure feasibility by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5691661914852788,
            3.4971512854099274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator steps:\n    # 1. Route merging: Merge two routes if their combined demand is <= capacity\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them via nearest nodes\n                last_i = route_i[-2]\n                first_j = route_j[1]\n                new_route = np.concatenate([route_i[:-1], route_j[1:]])\n                # Check if merging reduces total distance\n                if distance_matrix[last_i][first_j] < distance_matrix[last_i][0] + distance_matrix[0][first_j]:\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(new_route)\n\n    # 2. Demand-aware node swap: Swap nodes between routes if demands are compatible\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select a node from each route\n                node_i = random.randint(1, len(route_i) - 2)\n                node_j = random.randint(1, len(route_j) - 2)\n                # Check demand compatibility\n                demand_i = demand[route_i[node_i]]\n                demand_j = demand[route_j[node_j]]\n                if (np.sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                    np.sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity):\n                    # Perform swap\n                    new_route_i = route_i.copy()\n                    new_route_j = route_j.copy()\n                    new_route_i[node_i], new_route_j[node_j] = new_route_j[node_j], new_route_i[node_i]\n                    # Check if swap reduces total distance\n                    if (distance_matrix[route_i[node_i-1]][new_route_i[node_i]] +\n                        distance_matrix[new_route_i[node_i]][route_i[node_i+1]] +\n                        distance_matrix[route_j[node_j-1]][new_route_j[node_j]] +\n                        distance_matrix[new_route_j[node_j]][route_j[node_j+1]]) < (\n                        distance_matrix[route_i[node_i-1]][route_i[node_i]] +\n                        distance_matrix[route_i[node_i]][route_i[node_i+1]] +\n                        distance_matrix[route_j[node_j-1]][route_j[node_j]] +\n                        distance_matrix[route_j[node_j]][route_j[node_j+1]]):\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n\n    # 3. Makespan-balancing route split: Split a long route into two if it significantly reduces makespan\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough nodes\n            # Find the point where splitting would balance makespan\n            total_demand = np.sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            split_point = -1\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand >= half_demand:\n                    split_point = i\n                    break\n            if split_point > 0:\n                # Create two new routes\n                route1 = np.concatenate([route[:split_point+1], [0]])\n                route2 = np.concatenate([[0], route[split_point+1:]])\n                # Check if split reduces makespan\n                if max(distance_matrix[route1[:-1], route1[1:]].sum(),\n                       distance_matrix[route2[:-1], route2[1:]].sum()) < (\n                       distance_matrix[route[:-1], route[1:]].sum()):\n                    # Replace original route with the two new routes\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                    new_solution.extend([route1, route2])\n\n    # Ensure feasibility by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with lower total distance and makespan, then applies a hybrid local search combining route merging, segment relocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    num_routes = len(new_solution)\n\n    # Step 1: Route Merging (if two routes can be merged without exceeding capacity)\n    if num_routes > 1:\n        for i in range(num_routes):\n            for j in range(i + 1, num_routes):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route_j into route_i\n                    merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n                    new_solution[i] = merged_route\n                    # Remove route_j\n                    new_solution = np.delete(new_solution, j, axis=0)\n                    num_routes -= 1\n                    break\n\n    # Step 2: Segment Relocation (move a segment from one route to another)\n    for _ in range(2):  # Perform twice for more exploration\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no relocatable segments\n            continue\n\n        # Select a segment to move\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx + 1]\n        segment_demand = sum(demand[segment])\n\n        # Find a target route that can accommodate the segment\n        for target_idx in range(len(new_solution)):\n            if target_idx == route_idx:\n                continue\n            target_route = new_solution[target_idx]\n            if sum(demand[target_route[1:-1]]) + segment_demand <= capacity:\n                # Insert segment into target route\n                new_target_route = np.concatenate((target_route[:-1], segment, target_route[-1:]))\n                new_solution[target_idx] = new_target_route\n                # Remove segment from original route\n                new_route = np.concatenate((route[:start_idx], route[end_idx + 1:]))\n                new_solution[route_idx] = new_route\n                break\n\n    # Step 3: Capacity-Aware Swap (swap customers between routes if it improves feasibility)\n    for _ in range(3):  # Perform three times for more exploration\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from each route\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check if swapping improves feasibility\n        new_route1_demand = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n        new_route2_demand = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform swap\n            new_route1 = np.concatenate((route1[:cust1_idx], [cust2], route1[cust1_idx + 1:]))\n            new_route2 = np.concatenate((route2[:cust2_idx], [cust1], route2[cust2_idx + 1:]))\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.602558650913781,
            2.130929261445999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    num_routes = len(new_solution)\n\n    # Step 1: Route Merging (if two routes can be merged without exceeding capacity)\n    if num_routes > 1:\n        for i in range(num_routes):\n            for j in range(i + 1, num_routes):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route_j into route_i\n                    merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n                    new_solution[i] = merged_route\n                    # Remove route_j\n                    new_solution = np.delete(new_solution, j, axis=0)\n                    num_routes -= 1\n                    break\n\n    # Step 2: Segment Relocation (move a segment from one route to another)\n    for _ in range(2):  # Perform twice for more exploration\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route has no relocatable segments\n            continue\n\n        # Select a segment to move\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx + 1]\n        segment_demand = sum(demand[segment])\n\n        # Find a target route that can accommodate the segment\n        for target_idx in range(len(new_solution)):\n            if target_idx == route_idx:\n                continue\n            target_route = new_solution[target_idx]\n            if sum(demand[target_route[1:-1]]) + segment_demand <= capacity:\n                # Insert segment into target route\n                new_target_route = np.concatenate((target_route[:-1], segment, target_route[-1:]))\n                new_solution[target_idx] = new_target_route\n                # Remove segment from original route\n                new_route = np.concatenate((route[:start_idx], route[end_idx + 1:]))\n                new_solution[route_idx] = new_route\n                break\n\n    # Step 3: Capacity-Aware Swap (swap customers between routes if it improves feasibility)\n    for _ in range(3):  # Perform three times for more exploration\n        if len(new_solution) < 2:\n            break\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select a customer from each route\n        cust1_idx = random.randint(1, len(route1) - 2)\n        cust2_idx = random.randint(1, len(route2) - 2)\n        cust1 = route1[cust1_idx]\n        cust2 = route2[cust2_idx]\n\n        # Check if swapping improves feasibility\n        new_route1_demand = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n        new_route2_demand = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform swap\n            new_route1 = np.concatenate((route1[:cust1_idx], [cust2], route1[cust1_idx + 1:]))\n            new_route2 = np.concatenate((route2[:cust2_idx], [cust1], route2[cust2_idx + 1:]))\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{My algorithm selects a solution from the archive with the highest potential for improvement by considering both objectives, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-customer-depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: split route and reallocate customers\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity for each part\n        def is_feasible(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_feasible(part1) and is_feasible(part2):\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try to reallocate customers\n            customers = route[1:-1]\n            random.shuffle(customers)\n            temp_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    temp_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(temp_route) > 1:\n                temp_route.append(0)\n                new_solution.append(np.array(temp_route))\n\n    # Perform capacity-aware swaps between routes\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Try to swap a customer from route1 to route2\n            customer1 = random.choice(route1[1:-1])\n            customer2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints after swap\n            load1 = sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2]\n            load2 = sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1]\n\n            if load1 <= capacity and load2 <= capacity:\n                # Perform the swap\n                new_route1 = np.array([0] + [c if c != customer1 else customer2 for c in route1[1:-1]] + [0])\n                new_route2 = np.array([0] + [c if c != customer2 else customer1 for c in route2[1:-1]] + [0])\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8266916974191489,
            7.665743112564087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-customer-depot)\n            new_solution.append(route.copy())\n            continue\n\n        # Hybrid local search: split route and reallocate customers\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity for each part\n        def is_feasible(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_feasible(part1) and is_feasible(part2):\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try to reallocate customers\n            customers = route[1:-1]\n            random.shuffle(customers)\n            temp_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    temp_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(temp_route) > 1:\n                temp_route.append(0)\n                new_solution.append(np.array(temp_route))\n\n    # Perform capacity-aware swaps between routes\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Try to swap a customer from route1 to route2\n            customer1 = random.choice(route1[1:-1])\n            customer2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints after swap\n            load1 = sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2]\n            load2 = sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1]\n\n            if load1 <= capacity and load2 <= capacity:\n                # Perform the swap\n                new_route1 = np.array([0] + [c if c != customer1 else customer2 for c in route1[1:-1]] + [0])\n                new_route2 = np.array([0] + [c if c != customer2 else customer1 for c in route2[1:-1]] + [0])\n                new_solution[i] = new_route1\n                new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Identify the longest route (makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    if len(longest_route) > 4:  # Ensure route can be split\n        # Split the longest route at a random feasible point\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If split is infeasible, try reallocating a random customer from the longest route\n            candidate = random.choice(longest_route[1:-1])\n            for i in range(len(new_solution)):\n                if i != longest_route_idx:\n                    temp_route = new_solution[i].tolist()\n                    temp_route.insert(-1, candidate)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[i] = np.array(temp_route)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == candidate))\n                        break\n\n    # Ensure all routes are feasible (fallback to original if needed)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            return selected\n\n    return new_solution\n\n",
        "score": [
            -0.7020008688701731,
            0.23130923509597778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Identify the longest route (makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    if len(longest_route) > 4:  # Ensure route can be split\n        # Split the longest route at a random feasible point\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If split is infeasible, try reallocating a random customer from the longest route\n            candidate = random.choice(longest_route[1:-1])\n            for i in range(len(new_solution)):\n                if i != longest_route_idx:\n                    temp_route = new_solution[i].tolist()\n                    temp_route.insert(-1, candidate)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[i] = np.array(temp_route)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == candidate))\n                        break\n\n    # Ensure all routes are feasible (fallback to original if needed)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            return selected\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Identify the longest route (makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    if len(longest_route) > 4:  # Ensure route can be split\n        # Split the longest route at a random feasible point\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If split is infeasible, try reallocating a random customer from the longest route\n            candidate = random.choice(longest_route[1:-1])\n            for i in range(len(new_solution)):\n                if i != longest_route_idx:\n                    temp_route = new_solution[i].tolist()\n                    temp_route.insert(-1, candidate)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[i] = np.array(temp_route)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == candidate))\n                        break\n\n    # Ensure all routes are feasible (fallback to original if needed)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            return selected\n\n    return new_solution\n\n",
        "score": [
            -0.7020008688701731,
            0.23130923509597778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Identify the longest route (makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    if len(longest_route) > 4:  # Ensure route can be split\n        # Split the longest route at a random feasible point\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If split is infeasible, try reallocating a random customer from the longest route\n            candidate = random.choice(longest_route[1:-1])\n            for i in range(len(new_solution)):\n                if i != longest_route_idx:\n                    temp_route = new_solution[i].tolist()\n                    temp_route.insert(-1, candidate)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        new_solution[i] = np.array(temp_route)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == candidate))\n                        break\n\n    # Ensure all routes are feasible (fallback to original if needed)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            return selected\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The algorithm selects a promising solution from the archive by considering both objective values (total distance and makespan), then applies a hybrid local search operator that combines route splitting, customer reallocation, and distance-aware swaps to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if possible)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:  # Only consider non-trivial routes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos:]\n\n                # Check capacity constraints\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    solution[i] = new_route1\n                    solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try 3 times\n            if len(solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(solution)), 2)\n            route1 = solution[route1_idx]\n            route2 = solution[route2_idx]\n\n            if len(route1) > 2:  # Can remove customer\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best position in route2\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                                distance_matrix[customer][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform the move\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n\n                    # Update solution\n                    solution[route1_idx] = new_route1\n                    solution[route2_idx] = new_route2\n                    break\n\n        # Step 3: Distance-aware swaps (within routes)\n        for route in solution:\n            if len(route) > 3:  # Only consider routes with enough customers\n                for _ in range(2):  # Try 2 swaps per route\n                    i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                    customer_i, customer_j = route[i], route[j]\n\n                    # Calculate cost change\n                    old_cost = (distance_matrix[route[i-1]][customer_i] +\n                               distance_matrix[customer_i][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_j] +\n                               distance_matrix[customer_j][route[j+1]])\n\n                    new_cost = (distance_matrix[route[i-1]][customer_j] +\n                               distance_matrix[customer_j][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_i] +\n                               distance_matrix[customer_i][route[j+1]])\n\n                    if new_cost < old_cost:\n                        # Perform the swap\n                        route[i], route[j] = route[j], route[i]\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.8576971509747996,
            1.4198346436023712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if possible)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:  # Only consider non-trivial routes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos:]\n\n                # Check capacity constraints\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    solution[i] = new_route1\n                    solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try 3 times\n            if len(solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(solution)), 2)\n            route1 = solution[route1_idx]\n            route2 = solution[route2_idx]\n\n            if len(route1) > 2:  # Can remove customer\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best position in route2\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                                distance_matrix[customer][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform the move\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n\n                    # Update solution\n                    solution[route1_idx] = new_route1\n                    solution[route2_idx] = new_route2\n                    break\n\n        # Step 3: Distance-aware swaps (within routes)\n        for route in solution:\n            if len(route) > 3:  # Only consider routes with enough customers\n                for _ in range(2):  # Try 2 swaps per route\n                    i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                    customer_i, customer_j = route[i], route[j]\n\n                    # Calculate cost change\n                    old_cost = (distance_matrix[route[i-1]][customer_i] +\n                               distance_matrix[customer_i][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_j] +\n                               distance_matrix[customer_j][route[j+1]])\n\n                    new_cost = (distance_matrix[route[i-1]][customer_j] +\n                               distance_matrix[customer_j][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_i] +\n                               distance_matrix[customer_i][route[j+1]])\n\n                    if new_cost < old_cost:\n                        # Perform the swap\n                        route[i], route[j] = route[j], route[i]\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The algorithm selects a promising solution from the archive by considering both objective values (total distance and makespan), then applies a hybrid local search operator that combines route splitting, customer reallocation, and distance-aware swaps to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if possible)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:  # Only consider non-trivial routes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos:]\n\n                # Check capacity constraints\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    solution[i] = new_route1\n                    solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try 3 times\n            if len(solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(solution)), 2)\n            route1 = solution[route1_idx]\n            route2 = solution[route2_idx]\n\n            if len(route1) > 2:  # Can remove customer\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best position in route2\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                                distance_matrix[customer][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform the move\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n\n                    # Update solution\n                    solution[route1_idx] = new_route1\n                    solution[route2_idx] = new_route2\n                    break\n\n        # Step 3: Distance-aware swaps (within routes)\n        for route in solution:\n            if len(route) > 3:  # Only consider routes with enough customers\n                for _ in range(2):  # Try 2 swaps per route\n                    i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                    customer_i, customer_j = route[i], route[j]\n\n                    # Calculate cost change\n                    old_cost = (distance_matrix[route[i-1]][customer_i] +\n                               distance_matrix[customer_i][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_j] +\n                               distance_matrix[customer_j][route[j+1]])\n\n                    new_cost = (distance_matrix[route[i-1]][customer_j] +\n                               distance_matrix[customer_j][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_i] +\n                               distance_matrix[customer_i][route[j+1]])\n\n                    if new_cost < old_cost:\n                        # Perform the swap\n                        route[i], route[j] = route[j], route[i]\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            -0.8576971509747996,
            1.4198346436023712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if possible)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:  # Only consider non-trivial routes\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = route[:split_pos + 1]\n                new_route2 = [0] + route[split_pos:]\n\n                # Check capacity constraints\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    solution[i] = new_route1\n                    solution.insert(i + 1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try 3 times\n            if len(solution) < 2:\n                break\n            route1_idx, route2_idx = random.sample(range(len(solution)), 2)\n            route1 = solution[route1_idx]\n            route2 = solution[route2_idx]\n\n            if len(route1) > 2:  # Can remove customer\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best position in route2\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    if sum(demand[new_route2[1:-1]]) <= capacity:\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                                distance_matrix[customer][route2[pos]] -\n                                distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform the move\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n\n                    # Update solution\n                    solution[route1_idx] = new_route1\n                    solution[route2_idx] = new_route2\n                    break\n\n        # Step 3: Distance-aware swaps (within routes)\n        for route in solution:\n            if len(route) > 3:  # Only consider routes with enough customers\n                for _ in range(2):  # Try 2 swaps per route\n                    i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                    customer_i, customer_j = route[i], route[j]\n\n                    # Calculate cost change\n                    old_cost = (distance_matrix[route[i-1]][customer_i] +\n                               distance_matrix[customer_i][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_j] +\n                               distance_matrix[customer_j][route[j+1]])\n\n                    new_cost = (distance_matrix[route[i-1]][customer_j] +\n                               distance_matrix[customer_j][route[i+1]] +\n                               distance_matrix[route[j-1]][customer_i] +\n                               distance_matrix[customer_i][route[j+1]])\n\n                    if new_cost < old_cost:\n                        # Perform the swap\n                        route[i], route[j] = route[j], route[i]\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A hybrid local search operator that combines route segment relocation with adaptive capacity-aware merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then pick a diverse one\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        candidate_indices = [i for i in range(len(sorted_archive)) if i % 2 == 0 or i == len(sorted_archive)-1]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + adaptive merging\n    if len(new_solution) > 1:\n        # Step 1: Relocate a random segment from one route to another\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Ensure we can extract a segment\n            start_idx = random.randint(1, len(route1)-3)\n            end_idx = random.randint(start_idx+1, len(route1)-2)\n            segment = route1[start_idx:end_idx+1]\n\n            # Check capacity feasibility for target route\n            route2_idx = random.randint(0, len(new_solution)-1)\n            while route2_idx == route1_idx:\n                route2_idx = random.randint(0, len(new_solution)-1)\n            route2 = new_solution[route2_idx]\n\n            segment_demand = sum(demand[node] for node in segment)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Step 2: Adaptive merging (if routes can be merged without exceeding capacity)\n                if len(new_solution) > 1:\n                    for i in range(len(new_solution)):\n                        for j in range(i+1, len(new_solution)):\n                            route_i = new_solution[i]\n                            route_j = new_solution[j]\n                            if sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j) <= capacity:\n                                # Merge routes i and j\n                                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                                new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n                                new_solution.append(merged_route)\n                                break\n                        if len(new_solution) < len(base_solution):\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.5965827119226642,
            1.3791759312152863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then pick a diverse one\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        candidate_indices = [i for i in range(len(sorted_archive)) if i % 2 == 0 or i == len(sorted_archive)-1]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + adaptive merging\n    if len(new_solution) > 1:\n        # Step 1: Relocate a random segment from one route to another\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Ensure we can extract a segment\n            start_idx = random.randint(1, len(route1)-3)\n            end_idx = random.randint(start_idx+1, len(route1)-2)\n            segment = route1[start_idx:end_idx+1]\n\n            # Check capacity feasibility for target route\n            route2_idx = random.randint(0, len(new_solution)-1)\n            while route2_idx == route1_idx:\n                route2_idx = random.randint(0, len(new_solution)-1)\n            route2 = new_solution[route2_idx]\n\n            segment_demand = sum(demand[node] for node in segment)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n                # Update routes\n                new_route1 = np.concatenate([route1[:start_idx], route1[end_idx+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Step 2: Adaptive merging (if routes can be merged without exceeding capacity)\n                if len(new_solution) > 1:\n                    for i in range(len(new_solution)):\n                        for j in range(i+1, len(new_solution)):\n                            route_i = new_solution[i]\n                            route_j = new_solution[j]\n                            if sum(demand[node] for node in route_i) + sum(demand[node] for node in route_j) <= capacity:\n                                # Merge routes i and j\n                                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                                new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n                                new_solution.append(merged_route)\n                                break\n                        if len(new_solution) < len(base_solution):\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining route merging, customer reallocation, and capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])  # Merge excluding depot\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Step 2: Customer reallocation (move a customer to a different route if beneficial)\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure there's a customer to move\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == source_route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n                # Try inserting at different positions in the target route\n                for insert_pos in range(1, len(target_route)):\n                    new_target_route = np.insert(target_route, insert_pos, customer)\n                    if np.sum(demand[new_target_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[source_route_idx] = np.delete(source_route, customer_pos)\n                        new_solution[target_route_idx] = new_target_route\n                        # Early exit if successful\n                        break\n\n    # Step 3: Capacity-aware swap (swap two non-depot nodes between routes if beneficial)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers (excluding depots)\n                cust1_pos = random.randint(1, len(route1)-2)\n                cust2_pos = random.randint(1, len(route2)-2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route1[cust1_pos] = cust2\n                new_route2 = route2.copy()\n                new_route2[cust2_pos] = cust1\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure no empty routes (merge with nearest route if possible)\n    for i in range(len(new_solution)-1, -1, -1):\n        if len(new_solution[i]) <= 2:\n            if i > 0:\n                # Merge with previous route\n                new_solution[i-1] = np.concatenate([new_solution[i-1][:-1], new_solution[i][1:]])\n            else:\n                # Merge with next route\n                new_solution[i+1] = np.concatenate([new_solution[i][:-1], new_solution[i+1][1:]])\n            del new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5261060527839758,
            5.202271670103073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging, customer reallocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])  # Merge excluding depot\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Step 2: Customer reallocation (move a customer to a different route if beneficial)\n    if len(new_solution) > 1:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure there's a customer to move\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == source_route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n                # Try inserting at different positions in the target route\n                for insert_pos in range(1, len(target_route)):\n                    new_target_route = np.insert(target_route, insert_pos, customer)\n                    if np.sum(demand[new_target_route[1:-1]]) <= capacity:\n                        # Update routes\n                        new_solution[source_route_idx] = np.delete(source_route, customer_pos)\n                        new_solution[target_route_idx] = new_target_route\n                        # Early exit if successful\n                        break\n\n    # Step 3: Capacity-aware swap (swap two non-depot nodes between routes if beneficial)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers (excluding depots)\n                cust1_pos = random.randint(1, len(route1)-2)\n                cust2_pos = random.randint(1, len(route2)-2)\n                cust1 = route1[cust1_pos]\n                cust2 = route2[cust2_pos]\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route1[cust1_pos] = cust2\n                new_route2 = route2.copy()\n                new_route2[cust2_pos] = cust1\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure no empty routes (merge with nearest route if possible)\n    for i in range(len(new_solution)-1, -1, -1):\n        if len(new_solution[i]) <= 2:\n            if i > 0:\n                # Merge with previous route\n                new_solution[i-1] = np.concatenate([new_solution[i-1][:-1], new_solution[i][1:]])\n            else:\n                # Merge with next route\n                new_solution[i+1] = np.concatenate([new_solution[i][:-1], new_solution[i+1][1:]])\n            del new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If route has more than 3 nodes, attempt to split it into two routes\n    if len(route) > 3:\n        split_pos = np.random.randint(2, len(route) - 1)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            selected_solution[route_idx] = new_route1\n            selected_solution.append(new_route2)\n            return selected_solution\n\n    # Otherwise, try to move a customer to another route\n    if len(selected_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        # Select a customer to move\n        if len(route) > 2:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            # Check if moving this customer to another route is feasible\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate distance increase\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the move\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                selected_solution[other_route_idx] = new_route\n                selected_solution[route_idx] = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                return selected_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n",
        "score": [
            -0.752934879412302,
            0.6422898769378662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If route has more than 3 nodes, attempt to split it into two routes\n    if len(route) > 3:\n        split_pos = np.random.randint(2, len(route) - 1)\n        new_route1 = np.concatenate([route[:split_pos], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[new_route1[1:-1]])\n        demand2 = np.sum(demand[new_route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            selected_solution[route_idx] = new_route1\n            selected_solution.append(new_route2)\n            return selected_solution\n\n    # Otherwise, try to move a customer to another route\n    if len(selected_solution) > 1:\n        other_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != route_idx])\n        other_route = selected_solution[other_route_idx].copy()\n\n        # Select a customer to move\n        if len(route) > 2:\n            customer_pos = np.random.randint(1, len(route) - 1)\n            customer = route[customer_pos]\n\n            # Check if moving this customer to another route is feasible\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate distance increase\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Perform the move\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                selected_solution[other_route_idx] = new_route\n                selected_solution[route_idx] = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n                return selected_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 3-opt moves to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # More weight on total distance\n    scores = np.array([np.dot(weights, obj) for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Route splitting: Split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure it's worth splitting\n            split_pos = len(long_route) // 2\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            new_solution[long_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Customer reallocation: Move a customer between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure it's worth moving a customer\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n            if demand[customer] <= capacity:\n                # Find target route with enough capacity\n                target_routes = [i for i, route in enumerate(new_solution)\n                               if i != source_route_idx and sum(demand[route[1:-1]]) + demand[customer] <= capacity]\n                if target_routes:\n                    target_route_idx = random.choice(target_routes)\n                    target_route = new_solution[target_route_idx]\n                    # Insert customer into target route (nearest neighbor)\n                    insert_pos = 1\n                    min_dist = float('inf')\n                    for i in range(1, len(target_route)):\n                        dist = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            insert_pos = i\n                    new_route = np.insert(target_route, insert_pos, customer)\n                    new_solution[target_route_idx] = new_route\n                    # Remove from source route\n                    new_solution[source_route_idx] = np.delete(source_route, customer_pos)\n\n    # Adaptive 3-opt: Apply 3-opt on a random route\n    if random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 5:  # Ensure it's worth applying 3-opt\n            # Select three distinct positions\n            pos = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all possible reconnections\n            candidates = []\n            for i in range(3):\n                for j in range(i+1, 3):\n                    # Create candidate by reversing segment between i and j\n                    candidate = np.concatenate([\n                        route[:pos[i]],\n                        route[pos[i]:pos[j]+1][::-1],\n                        route[pos[j]+1:]\n                    ])\n                    # Check capacity constraint\n                    if sum(demand[candidate[1:-1]]) <= capacity:\n                        candidates.append(candidate)\n            if candidates:\n                # Select best candidate based on distance reduction\n                original_dist = sum(distance_matrix[route[:-1], route[1:]])\n                best_candidate = None\n                best_dist = original_dist\n                for candidate in candidates:\n                    candidate_dist = sum(distance_matrix[candidate[:-1], candidate[1:]])\n                    if candidate_dist < best_dist:\n                        best_dist = candidate_dist\n                        best_candidate = candidate\n                if best_candidate is not None:\n                    new_solution[route_idx] = best_candidate\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5026698481598486,
            1.5773392021656036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # More weight on total distance\n    scores = np.array([np.dot(weights, obj) for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Route splitting: Split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure it's worth splitting\n            split_pos = len(long_route) // 2\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            new_solution[long_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Customer reallocation: Move a customer between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure it's worth moving a customer\n            customer_pos = random.randint(1, len(source_route)-2)\n            customer = source_route[customer_pos]\n            if demand[customer] <= capacity:\n                # Find target route with enough capacity\n                target_routes = [i for i, route in enumerate(new_solution)\n                               if i != source_route_idx and sum(demand[route[1:-1]]) + demand[customer] <= capacity]\n                if target_routes:\n                    target_route_idx = random.choice(target_routes)\n                    target_route = new_solution[target_route_idx]\n                    # Insert customer into target route (nearest neighbor)\n                    insert_pos = 1\n                    min_dist = float('inf')\n                    for i in range(1, len(target_route)):\n                        dist = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            insert_pos = i\n                    new_route = np.insert(target_route, insert_pos, customer)\n                    new_solution[target_route_idx] = new_route\n                    # Remove from source route\n                    new_solution[source_route_idx] = np.delete(source_route, customer_pos)\n\n    # Adaptive 3-opt: Apply 3-opt on a random route\n    if random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 5:  # Ensure it's worth applying 3-opt\n            # Select three distinct positions\n            pos = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all possible reconnections\n            candidates = []\n            for i in range(3):\n                for j in range(i+1, 3):\n                    # Create candidate by reversing segment between i and j\n                    candidate = np.concatenate([\n                        route[:pos[i]],\n                        route[pos[i]:pos[j]+1][::-1],\n                        route[pos[j]+1:]\n                    ])\n                    # Check capacity constraint\n                    if sum(demand[candidate[1:-1]]) <= capacity:\n                        candidates.append(candidate)\n            if candidates:\n                # Select best candidate based on distance reduction\n                original_dist = sum(distance_matrix[route[:-1], route[1:]])\n                best_candidate = None\n                best_dist = original_dist\n                for candidate in candidates:\n                    candidate_dist = sum(distance_matrix[candidate[:-1], candidate[1:]])\n                    if candidate_dist < best_dist:\n                        best_dist = candidate_dist\n                        best_candidate = candidate\n                if best_candidate is not None:\n                    new_solution[route_idx] = best_candidate\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting one into the other\n            merged_route = [0]\n            # Alternate between customers from route_i and route_j\n            len_i, len_j = len(route_i) - 2, len(route_j) - 2\n            for k in range(max(len_i, len_j)):\n                if k < len_i:\n                    merged_route.append(route_i[k + 1])\n                if k < len_j:\n                    merged_route.append(route_j[k + 1])\n            merged_route.append(0)\n\n            # Replace the two routes with the merged one\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(np.array(merged_route))\n\n    # Customer reallocation: Move a random customer from a long route to a short route\n    if len(new_solution) > 1:\n        # Sort routes by length (ascending)\n        sorted_routes = sorted(new_solution, key=lambda r: len(r))\n        shortest_route = sorted_routes[0]\n        longest_route = sorted_routes[-1]\n\n        if len(longest_route) > 3:  # Ensure longest route has at least one customer\n            # Find a random customer in the longest route\n            customer_idx = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[customer_idx]\n\n            # Check if moving the customer to the shortest route is feasible\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into the shortest route (random position)\n                insert_pos = np.random.randint(1, len(shortest_route))\n                updated_shortest = np.insert(shortest_route, insert_pos, customer)\n\n                # Remove the customer from the longest route\n                updated_longest = np.delete(longest_route, customer_idx)\n\n                # Update the solution\n                for i, route in enumerate(new_solution):\n                    if np.array_equal(route, shortest_route):\n                        new_solution[i] = updated_shortest\n                    elif np.array_equal(route, longest_route):\n                        new_solution[i] = updated_longest\n\n    return new_solution\n\n",
        "score": [
            -0.5931663539984254,
            7.178441286087036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting one into the other\n            merged_route = [0]\n            # Alternate between customers from route_i and route_j\n            len_i, len_j = len(route_i) - 2, len(route_j) - 2\n            for k in range(max(len_i, len_j)):\n                if k < len_i:\n                    merged_route.append(route_i[k + 1])\n                if k < len_j:\n                    merged_route.append(route_j[k + 1])\n            merged_route.append(0)\n\n            # Replace the two routes with the merged one\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(np.array(merged_route))\n\n    # Customer reallocation: Move a random customer from a long route to a short route\n    if len(new_solution) > 1:\n        # Sort routes by length (ascending)\n        sorted_routes = sorted(new_solution, key=lambda r: len(r))\n        shortest_route = sorted_routes[0]\n        longest_route = sorted_routes[-1]\n\n        if len(longest_route) > 3:  # Ensure longest route has at least one customer\n            # Find a random customer in the longest route\n            customer_idx = np.random.randint(1, len(longest_route) - 1)\n            customer = longest_route[customer_idx]\n\n            # Check if moving the customer to the shortest route is feasible\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into the shortest route (random position)\n                insert_pos = np.random.randint(1, len(shortest_route))\n                updated_shortest = np.insert(shortest_route, insert_pos, customer)\n\n                # Remove the customer from the longest route\n                updated_longest = np.delete(longest_route, customer_idx)\n\n                # Update the solution\n                for i, route in enumerate(new_solution):\n                    if np.array_equal(route, shortest_route):\n                        new_solution[i] = updated_shortest\n                    elif np.array_equal(route, longest_route):\n                        new_solution[i] = updated_longest\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Choose a route to modify with probability proportional to its demand or distance\n    route_weights = []\n    for route in selected_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        route_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n        route_weights.append(route_demand + route_distance)\n\n    if not route_weights:\n        return selected_solution\n\n    selected_route_idx = np.random.choice(len(selected_solution), p=np.array(route_weights)/sum(route_weights))\n    selected_route = selected_solution[selected_route_idx].copy()\n\n    # Attempt 2-opt* on the selected route\n    improved = False\n    for i in range(1, len(selected_route)-2):\n        for j in range(i+1, len(selected_route)-1):\n            # Create a candidate route by reversing the segment between i and j\n            candidate_route = np.concatenate([\n                selected_route[:i],\n                selected_route[i:j+1][::-1],\n                selected_route[j+1:]\n            ])\n\n            # Check capacity constraint\n            if sum(demand[node] for node in candidate_route[1:-1]) <= capacity:\n                # Check if the candidate route is shorter\n                candidate_distance = sum(distance_matrix[candidate_route[k]][candidate_route[k+1]] for k in range(len(candidate_route)-1))\n                original_distance = sum(distance_matrix[selected_route[k]][selected_route[k+1]] for k in range(len(selected_route)-1))\n\n                if candidate_distance < original_distance:\n                    selected_route = candidate_route\n                    improved = True\n                    break\n        if improved:\n            break\n\n    if improved:\n        selected_solution[selected_route_idx] = selected_route\n        return selected_solution\n\n    # If 2-opt* didn't improve, try route-splitting\n    if len(selected_route) > 3:  # Ensure the route has at least one customer\n        split_pos = np.random.randint(1, len(selected_route)-1)\n        first_part = np.concatenate([selected_route[:split_pos+1], [0]])\n        second_part = np.concatenate([[0], selected_route[split_pos+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n            sum(demand[node] for node in second_part[1:-1]) <= capacity):\n            selected_solution[selected_route_idx] = first_part\n            selected_solution.append(second_part)\n            return selected_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.3955612632706005,
            5.653851687908173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Choose a route to modify with probability proportional to its demand or distance\n    route_weights = []\n    for route in selected_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        route_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n        route_weights.append(route_demand + route_distance)\n\n    if not route_weights:\n        return selected_solution\n\n    selected_route_idx = np.random.choice(len(selected_solution), p=np.array(route_weights)/sum(route_weights))\n    selected_route = selected_solution[selected_route_idx].copy()\n\n    # Attempt 2-opt* on the selected route\n    improved = False\n    for i in range(1, len(selected_route)-2):\n        for j in range(i+1, len(selected_route)-1):\n            # Create a candidate route by reversing the segment between i and j\n            candidate_route = np.concatenate([\n                selected_route[:i],\n                selected_route[i:j+1][::-1],\n                selected_route[j+1:]\n            ])\n\n            # Check capacity constraint\n            if sum(demand[node] for node in candidate_route[1:-1]) <= capacity:\n                # Check if the candidate route is shorter\n                candidate_distance = sum(distance_matrix[candidate_route[k]][candidate_route[k+1]] for k in range(len(candidate_route)-1))\n                original_distance = sum(distance_matrix[selected_route[k]][selected_route[k+1]] for k in range(len(selected_route)-1))\n\n                if candidate_distance < original_distance:\n                    selected_route = candidate_route\n                    improved = True\n                    break\n        if improved:\n            break\n\n    if improved:\n        selected_solution[selected_route_idx] = selected_route\n        return selected_solution\n\n    # If 2-opt* didn't improve, try route-splitting\n    if len(selected_route) > 3:  # Ensure the route has at least one customer\n        split_pos = np.random.randint(1, len(selected_route)-1)\n        first_part = np.concatenate([selected_route[:split_pos+1], [0]])\n        second_part = np.concatenate([[0], selected_route[split_pos+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n            sum(demand[node] for node in second_part[1:-1]) <= capacity):\n            selected_solution[selected_route_idx] = first_part\n            selected_solution.append(second_part)\n            return selected_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This novel local search operator combines route segmentation and demand-aware reinsertion, where segments of long routes are reinserted into other routes or new routes while respecting capacity constraints, aiming to balance distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route (makespan route)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Split the longest route into two segments at a random point\n    split_point = np.random.randint(1, len(longest_route)-1)\n    segment1 = longest_route[:split_point+1]\n    segment2 = longest_route[split_point:]\n\n    # Calculate demands for the segments\n    demand_segment1 = sum(demand[node] for node in segment1[1:-1])  # exclude depot\n    demand_segment2 = sum(demand[node] for node in segment2[1:-1])  # exclude depot\n\n    # Try to reinsert segments into other routes or create new routes\n    segments = [segment1, segment2]\n    for segment in segments:\n        segment_demand = sum(demand[node] for node in segment[1:-1])\n        inserted = False\n\n        # Try inserting into existing routes\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand + segment_demand <= capacity:\n                # Find the best insertion point (minimizing added distance)\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], segment[1]] + distance_matrix[segment[-2], route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Insert the segment\n                new_route = np.concatenate((route[:best_pos], segment[1:-1], route[best_pos:]))\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        # If not inserted, create a new route\n        if not inserted:\n            new_solution.append(segment.copy())\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - served_nodes\n    if missing_nodes:\n        # Assign missing nodes to the route with the least added distance\n        for node in missing_nodes:\n            best_route_idx = 0\n            best_pos = 1\n            best_cost = float('inf')\n            for i, route in enumerate(new_solution):\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + demand[node] > capacity:\n                    continue\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], node] + distance_matrix[node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n            new_route = np.concatenate((new_solution[best_route_idx][:best_pos], [node], new_solution[best_route_idx][best_pos:]))\n            new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8290199226610078,
            1.140809714794159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route (makespan route)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Split the longest route into two segments at a random point\n    split_point = np.random.randint(1, len(longest_route)-1)\n    segment1 = longest_route[:split_point+1]\n    segment2 = longest_route[split_point:]\n\n    # Calculate demands for the segments\n    demand_segment1 = sum(demand[node] for node in segment1[1:-1])  # exclude depot\n    demand_segment2 = sum(demand[node] for node in segment2[1:-1])  # exclude depot\n\n    # Try to reinsert segments into other routes or create new routes\n    segments = [segment1, segment2]\n    for segment in segments:\n        segment_demand = sum(demand[node] for node in segment[1:-1])\n        inserted = False\n\n        # Try inserting into existing routes\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand + segment_demand <= capacity:\n                # Find the best insertion point (minimizing added distance)\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], segment[1]] + distance_matrix[segment[-2], route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                # Insert the segment\n                new_route = np.concatenate((route[:best_pos], segment[1:-1], route[best_pos:]))\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        # If not inserted, create a new route\n        if not inserted:\n            new_solution.append(segment.copy())\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - served_nodes\n    if missing_nodes:\n        # Assign missing nodes to the route with the least added distance\n        for node in missing_nodes:\n            best_route_idx = 0\n            best_pos = 1\n            best_cost = float('inf')\n            for i, route in enumerate(new_solution):\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + demand[node] > capacity:\n                    continue\n                for pos in range(1, len(route)):\n                    cost = distance_matrix[route[pos-1], node] + distance_matrix[node, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n            new_route = np.concatenate((new_solution[best_route_idx][:best_pos], [node], new_solution[best_route_idx][best_pos:]))\n            new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines route segmentation with demand-aware customer reinsertion to balance distance and makespan, and ensures feasibility by validating capacity constraints after each modification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Simple combined objective sorting\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive_sorted)//4)])[0]  # Select from top candidates\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segmentation + demand-aware customer reinsertion\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Ensure route has enough nodes to split\n            # Segment the route into two parts\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos]\n            part2 = route[split_pos:]\n\n            # Try to reinsert customers from part2 into other routes or new route\n            for customer in part2[1:-1]:  # Skip depot\n                # Find best insertion point in part1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Check capacity constraint\n                    if np.sum(demand[part1[1:i]]) + demand[customer] <= capacity:\n                        # Calculate insertion cost\n                        cost = (distance_matrix[part1[i-1], customer] +\n                               distance_matrix[customer, part1[i]] -\n                               distance_matrix[part1[i-1], part1[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                if best_cost < float('inf'):\n                    part1 = np.insert(part1, best_pos, customer)\n\n                # Try to insert into other routes\n                inserted = False\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        for i in range(1, len(other_route)):\n                            if np.sum(demand[other_route[1:i]]) + demand[customer] <= capacity:\n                                cost = (distance_matrix[other_route[i-1], customer] +\n                                        distance_matrix[customer, other_route[i]] -\n                                        distance_matrix[other_route[i-1], other_route[i]])\n                                if cost < best_cost:\n                                    # Insert into other route\n                                    new_solution[other_route_idx] = np.insert(other_route, i, customer)\n                                    inserted = True\n                                    break\n                        if inserted:\n                            break\n\n                if not inserted and np.sum(demand[part1[1:-1]]) + demand[customer] <= capacity:\n                    part1 = np.append(part1[:-1], [customer, 0])\n\n            # Update the solution\n            new_solution[route_idx] = part1\n            if len(part2) > 2:  # Only add if there are customers left\n                new_solution.append(np.array([0] + list(part2[1:-1]) + [0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6788128728540548,
            3.1252933740615845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Simple combined objective sorting\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive_sorted)//4)])[0]  # Select from top candidates\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segmentation + demand-aware customer reinsertion\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Ensure route has enough nodes to split\n            # Segment the route into two parts\n            split_pos = random.randint(2, len(route) - 3)\n            part1 = route[:split_pos]\n            part2 = route[split_pos:]\n\n            # Try to reinsert customers from part2 into other routes or new route\n            for customer in part2[1:-1]:  # Skip depot\n                # Find best insertion point in part1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Check capacity constraint\n                    if np.sum(demand[part1[1:i]]) + demand[customer] <= capacity:\n                        # Calculate insertion cost\n                        cost = (distance_matrix[part1[i-1], customer] +\n                               distance_matrix[customer, part1[i]] -\n                               distance_matrix[part1[i-1], part1[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                if best_cost < float('inf'):\n                    part1 = np.insert(part1, best_pos, customer)\n\n                # Try to insert into other routes\n                inserted = False\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        for i in range(1, len(other_route)):\n                            if np.sum(demand[other_route[1:i]]) + demand[customer] <= capacity:\n                                cost = (distance_matrix[other_route[i-1], customer] +\n                                        distance_matrix[customer, other_route[i]] -\n                                        distance_matrix[other_route[i-1], other_route[i]])\n                                if cost < best_cost:\n                                    # Insert into other route\n                                    new_solution[other_route_idx] = np.insert(other_route, i, customer)\n                                    inserted = True\n                                    break\n                        if inserted:\n                            break\n\n                if not inserted and np.sum(demand[part1[1:-1]]) + demand[customer] <= capacity:\n                    part1 = np.append(part1[:-1], [customer, 0])\n\n            # Update the solution\n            new_solution[route_idx] = part1\n            if len(part2) > 2:  # Only add if there are customers left\n                new_solution.append(np.array([0] + list(part2[1:-1]) + [0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with capacity-aware route merging, followed by a makespan-balancing step to intelligently trade off distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment swap with capacity check\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid segments to swap (excluding depot)\n        valid_segments = []\n        for r in [route1, route2]:\n            if len(r) > 3:  # Need at least one customer between depots\n                valid_segments.append((r, np.random.randint(1, len(r)-1)))\n\n        if len(valid_segments) == 2:\n            (r1, pos1), (r2, pos2) = valid_segments\n\n            # Check capacity feasibility after swap\n            def check_capacity(route, new_segment):\n                current_demand = sum(demand[node] for node in route)\n                new_demand = current_demand - sum(demand[node] for node in route[pos1:]) + sum(demand[node] for node in new_segment)\n                return new_demand <= capacity\n\n            # Perform swap if feasible\n            if check_capacity(r1, r2[pos2:]) and check_capacity(r2, r1[pos1:]):\n                new_r1 = np.concatenate([r1[:pos1], r2[pos2:]])\n                new_r2 = np.concatenate([r2[:pos2], r1[pos1:]])\n                new_solution[route1_idx] = new_r1\n                new_solution[route2_idx] = new_r2\n\n    # Makespan balancing step: Move longest customers to other routes if possible\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to move the longest customer to another route\n        if len(longest_route) > 3:\n            # Find the customer with highest demand in the longest route\n            customer_nodes = longest_route[1:-1]\n            if len(customer_nodes) > 0:\n                max_demand_customer = max(customer_nodes, key=lambda x: demand[x])\n\n                # Find a route that can accommodate this customer\n                for i in range(len(new_solution)):\n                    if i != longest_route_idx:\n                        candidate_route = new_solution[i]\n                        if sum(demand[node] for node in candidate_route) + demand[max_demand_customer] <= capacity:\n                            # Insert the customer into the candidate route\n                            insert_pos = np.random.randint(1, len(candidate_route))\n                            new_route = np.concatenate([\n                                candidate_route[:insert_pos],\n                                [max_demand_customer],\n                                candidate_route[insert_pos:]\n                            ])\n                            new_solution[i] = new_route\n\n                            # Remove from original route\n                            new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == max_demand_customer)[0][0])\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.44889079241667623,
            0.7915735244750977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment swap with capacity check\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid segments to swap (excluding depot)\n        valid_segments = []\n        for r in [route1, route2]:\n            if len(r) > 3:  # Need at least one customer between depots\n                valid_segments.append((r, np.random.randint(1, len(r)-1)))\n\n        if len(valid_segments) == 2:\n            (r1, pos1), (r2, pos2) = valid_segments\n\n            # Check capacity feasibility after swap\n            def check_capacity(route, new_segment):\n                current_demand = sum(demand[node] for node in route)\n                new_demand = current_demand - sum(demand[node] for node in route[pos1:]) + sum(demand[node] for node in new_segment)\n                return new_demand <= capacity\n\n            # Perform swap if feasible\n            if check_capacity(r1, r2[pos2:]) and check_capacity(r2, r1[pos1:]):\n                new_r1 = np.concatenate([r1[:pos1], r2[pos2:]])\n                new_r2 = np.concatenate([r2[:pos2], r1[pos1:]])\n                new_solution[route1_idx] = new_r1\n                new_solution[route2_idx] = new_r2\n\n    # Makespan balancing step: Move longest customers to other routes if possible\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to move the longest customer to another route\n        if len(longest_route) > 3:\n            # Find the customer with highest demand in the longest route\n            customer_nodes = longest_route[1:-1]\n            if len(customer_nodes) > 0:\n                max_demand_customer = max(customer_nodes, key=lambda x: demand[x])\n\n                # Find a route that can accommodate this customer\n                for i in range(len(new_solution)):\n                    if i != longest_route_idx:\n                        candidate_route = new_solution[i]\n                        if sum(demand[node] for node in candidate_route) + demand[max_demand_customer] <= capacity:\n                            # Insert the customer into the candidate route\n                            insert_pos = np.random.randint(1, len(candidate_route))\n                            new_route = np.concatenate([\n                                candidate_route[:insert_pos],\n                                [max_demand_customer],\n                                candidate_route[insert_pos:]\n                            ])\n                            new_solution[i] = new_route\n\n                            # Remove from original route\n                            new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == max_demand_customer)[0][0])\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The algorithm performs a hybrid local search by iteratively applying a combination of route fragmentation and customer reinsertion, guided by a dynamic trade-off between reducing total distance and balancing makespan, while ensuring feasibility through demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Split the route into two parts at a random point (excluding depot)\n        if len(selected_route) > 3:\n            split_pos = random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check if the split is feasible\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n    # Randomly select a customer from a non-depot route to reinsert\n    non_depot_routes = [i for i, route in enumerate(new_solution) if len(route) > 2]\n    if non_depot_routes:\n        route_idx = random.choice(non_depot_routes)\n        selected_route = new_solution[route_idx]\n\n        # Remove a random customer (excluding depot)\n        customer_idx = random.randint(1, len(selected_route) - 2)\n        customer = selected_route[customer_idx]\n        selected_route = np.delete(selected_route, customer_idx)\n\n        # Find the best insertion point in the same route\n        best_pos = 1\n        best_cost = float('inf')\n        for i in range(1, len(selected_route)):\n            # Try inserting after position i\n            new_route = np.insert(selected_route, i, customer)\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                cost = distance_matrix[new_route[i-1], customer] + distance_matrix[customer, new_route[i+1]] - distance_matrix[new_route[i-1], new_route[i+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        # Insert the customer at the best position\n        new_route = np.insert(selected_route, best_pos, customer)\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7504123414519155,
            0.6906291246414185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Split the route into two parts at a random point (excluding depot)\n        if len(selected_route) > 3:\n            split_pos = random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos:]\n\n            # Check if the split is feasible\n            if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n                # Replace the original route with the two new routes\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx + 1, part2)\n\n    # Randomly select a customer from a non-depot route to reinsert\n    non_depot_routes = [i for i, route in enumerate(new_solution) if len(route) > 2]\n    if non_depot_routes:\n        route_idx = random.choice(non_depot_routes)\n        selected_route = new_solution[route_idx]\n\n        # Remove a random customer (excluding depot)\n        customer_idx = random.randint(1, len(selected_route) - 2)\n        customer = selected_route[customer_idx]\n        selected_route = np.delete(selected_route, customer_idx)\n\n        # Find the best insertion point in the same route\n        best_pos = 1\n        best_cost = float('inf')\n        for i in range(1, len(selected_route)):\n            # Try inserting after position i\n            new_route = np.insert(selected_route, i, customer)\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                cost = distance_matrix[new_route[i-1], customer] + distance_matrix[customer, new_route[i+1]] - distance_matrix[new_route[i-1], new_route[i+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        # Insert the customer at the best position\n        new_route = np.insert(selected_route, best_pos, customer)\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between total distance and makespan\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-8))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(3):  # Perform multiple iterations for improvement\n        # Step 1: Split a long route into two by selecting a split point that balances load and distance\n        if len(new_solution) > 1:\n            long_route_idx = np.argmax([len(route) for route in new_solution])\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 4:  # Ensure route is long enough to split\n                split_pos = len(long_route) // 2\n                # Ensure split point doesn't violate capacity\n                cumulative_load = np.cumsum([demand[node] for node in long_route[1:split_pos]])\n                if np.max(cumulative_load) <= capacity:\n                    route1 = np.concatenate((long_route[:split_pos], [0]))\n                    route2 = np.concatenate(([0], long_route[split_pos:-1], [0]))\n                    new_solution[long_route_idx] = route1\n                    new_solution.append(route2)\n\n        # Step 2: Reinsert a customer from a route to another to potentially reduce total distance\n        if len(new_solution) > 1:\n            # Select a random route and customer to move\n            from_route_idx = np.random.randint(len(new_solution))\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:  # Ensure route has customers to move\n                customer_pos = np.random.randint(1, len(from_route)-1)\n                customer = from_route[customer_pos]\n\n                # Try to insert into another route\n                to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n                to_route = new_solution[to_route_idx]\n\n                # Find best insertion position in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    # Calculate insertion cost\n                    prev_node = to_route[pos-1]\n                    next_node = to_route[pos]\n                    cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    # Check capacity constraint\n                    route_load = sum(demand[node] for node in to_route[1:-1]) - demand[from_route[customer_pos]] + demand[customer]\n                    if cost < best_cost and route_load <= capacity:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform insertion\n                    new_route = np.concatenate((to_route[:best_pos], [customer], to_route[best_pos:]))\n                    new_solution[to_route_idx] = new_route\n                    # Remove customer from original route\n                    new_solution[from_route_idx] = np.concatenate((from_route[:customer_pos], from_route[customer_pos+1:]))\n\n        # Step 3: Merge two short routes if their combined load is within capacity\n        if len(new_solution) > 2:\n            # Select two shortest routes\n            route_lengths = [len(route) for route in new_solution]\n            short_route_indices = np.argsort(route_lengths)[:2]\n            route1_idx, route2_idx = short_route_indices\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if combined_load <= capacity:\n                # Merge routes\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.46704970976780796,
            2.155153512954712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between total distance and makespan\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-8))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(3):  # Perform multiple iterations for improvement\n        # Step 1: Split a long route into two by selecting a split point that balances load and distance\n        if len(new_solution) > 1:\n            long_route_idx = np.argmax([len(route) for route in new_solution])\n            long_route = new_solution[long_route_idx]\n            if len(long_route) > 4:  # Ensure route is long enough to split\n                split_pos = len(long_route) // 2\n                # Ensure split point doesn't violate capacity\n                cumulative_load = np.cumsum([demand[node] for node in long_route[1:split_pos]])\n                if np.max(cumulative_load) <= capacity:\n                    route1 = np.concatenate((long_route[:split_pos], [0]))\n                    route2 = np.concatenate(([0], long_route[split_pos:-1], [0]))\n                    new_solution[long_route_idx] = route1\n                    new_solution.append(route2)\n\n        # Step 2: Reinsert a customer from a route to another to potentially reduce total distance\n        if len(new_solution) > 1:\n            # Select a random route and customer to move\n            from_route_idx = np.random.randint(len(new_solution))\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:  # Ensure route has customers to move\n                customer_pos = np.random.randint(1, len(from_route)-1)\n                customer = from_route[customer_pos]\n\n                # Try to insert into another route\n                to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n                to_route = new_solution[to_route_idx]\n\n                # Find best insertion position in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    # Calculate insertion cost\n                    prev_node = to_route[pos-1]\n                    next_node = to_route[pos]\n                    cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    # Check capacity constraint\n                    route_load = sum(demand[node] for node in to_route[1:-1]) - demand[from_route[customer_pos]] + demand[customer]\n                    if cost < best_cost and route_load <= capacity:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < float('inf'):\n                    # Perform insertion\n                    new_route = np.concatenate((to_route[:best_pos], [customer], to_route[best_pos:]))\n                    new_solution[to_route_idx] = new_route\n                    # Remove customer from original route\n                    new_solution[from_route_idx] = np.concatenate((from_route[:customer_pos], from_route[customer_pos+1:]))\n\n        # Step 3: Merge two short routes if their combined load is within capacity\n        if len(new_solution) > 2:\n            # Select two shortest routes\n            route_lengths = [len(route) for route in new_solution]\n            short_route_indices = np.argsort(route_lengths)[:2]\n            route1_idx, route2_idx = short_route_indices\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if combined_load <= capacity:\n                # Merge routes\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes if they have low demand and reallocate customers to balance makespan\n    if len(base_solution) > 1:\n        # Select two routes with the highest makespan\n        route1_idx, route1 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n        route2_idx, route2 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n\n        # Merge routes if their combined demand is within capacity\n        if route1_idx != route2_idx and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # Reallocate a customer from the longest route to the shortest route if possible\n            longest_route = base_solution[route1_idx]\n            shortest_route = min(base_solution, key=lambda r: distance_matrix[r[:-1], r[1:]].sum())\n\n            for customer in longest_route[1:-1]:\n                if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route (greedy insertion)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[i-1], customer] +\n                                    distance_matrix[customer, shortest_route[i]] -\n                                    distance_matrix[shortest_route[i-1], shortest_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    new_shortest = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n                    new_longest = np.array([c for c in longest_route if c != customer])\n                    if len(new_longest) > 2:  # Ensure route remains valid\n                        new_solution = [r for r in base_solution if r is not longest_route]\n                        new_solution.append(new_shortest)\n                        new_solution.append(new_longest)\n                    else:\n                        new_solution = base_solution.copy()\n                    break\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8586032881413117,
            0.9357344806194305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes if they have low demand and reallocate customers to balance makespan\n    if len(base_solution) > 1:\n        # Select two routes with the highest makespan\n        route1_idx, route1 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n        route2_idx, route2 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n\n        # Merge routes if their combined demand is within capacity\n        if route1_idx != route2_idx and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # Reallocate a customer from the longest route to the shortest route if possible\n            longest_route = base_solution[route1_idx]\n            shortest_route = min(base_solution, key=lambda r: distance_matrix[r[:-1], r[1:]].sum())\n\n            for customer in longest_route[1:-1]:\n                if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route (greedy insertion)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[i-1], customer] +\n                                    distance_matrix[customer, shortest_route[i]] -\n                                    distance_matrix[shortest_route[i-1], shortest_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    new_shortest = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n                    new_longest = np.array([c for c in longest_route if c != customer])\n                    if len(new_longest) > 2:  # Ensure route remains valid\n                        new_solution = [r for r in base_solution if r is not longest_route]\n                        new_solution.append(new_shortest)\n                        new_solution.append(new_longest)\n                    else:\n                        new_solution = base_solution.copy()\n                    break\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes if they have low demand and reallocate customers to balance makespan\n    if len(base_solution) > 1:\n        # Select two routes with the highest makespan\n        route1_idx, route1 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n        route2_idx, route2 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n\n        # Merge routes if their combined demand is within capacity\n        if route1_idx != route2_idx and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # Reallocate a customer from the longest route to the shortest route if possible\n            longest_route = base_solution[route1_idx]\n            shortest_route = min(base_solution, key=lambda r: distance_matrix[r[:-1], r[1:]].sum())\n\n            for customer in longest_route[1:-1]:\n                if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route (greedy insertion)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[i-1], customer] +\n                                    distance_matrix[customer, shortest_route[i]] -\n                                    distance_matrix[shortest_route[i-1], shortest_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    new_shortest = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n                    new_longest = np.array([c for c in longest_route if c != customer])\n                    if len(new_longest) > 2:  # Ensure route remains valid\n                        new_solution = [r for r in base_solution if r is not longest_route]\n                        new_solution.append(new_shortest)\n                        new_solution.append(new_longest)\n                    else:\n                        new_solution = base_solution.copy()\n                    break\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8586032881413117,
            0.9357344806194305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes if they have low demand and reallocate customers to balance makespan\n    if len(base_solution) > 1:\n        # Select two routes with the highest makespan\n        route1_idx, route1 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n        route2_idx, route2 = max(enumerate(base_solution), key=lambda x: distance_matrix[x[1][:-1], x[1][1:]].sum())\n\n        # Merge routes if their combined demand is within capacity\n        if route1_idx != route2_idx and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for i, r in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n        else:\n            # Reallocate a customer from the longest route to the shortest route if possible\n            longest_route = base_solution[route1_idx]\n            shortest_route = min(base_solution, key=lambda r: distance_matrix[r[:-1], r[1:]].sum())\n\n            for customer in longest_route[1:-1]:\n                if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into shortest route (greedy insertion)\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for i in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[i-1], customer] +\n                                    distance_matrix[customer, shortest_route[i]] -\n                                    distance_matrix[shortest_route[i-1], shortest_route[i]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n                    new_shortest = np.concatenate([shortest_route[:best_pos], [customer], shortest_route[best_pos:]])\n                    new_longest = np.array([c for c in longest_route if c != customer])\n                    if len(new_longest) > 2:  # Ensure route remains valid\n                        new_solution = [r for r in base_solution if r is not longest_route]\n                        new_solution.append(new_shortest)\n                        new_solution.append(new_longest)\n                    else:\n                        new_solution = base_solution.copy()\n                    break\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, node relocation, and capacity-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, node relocation, and edge swaps\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n        split_pos = random.randint(1, len(longest_route) - 2)\n        new_route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([new_route1, new_route2])\n\n    # Node relocation: move a node from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        to_route_idx = random.randint(0, len(new_solution) - 1)\n        if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 2:\n            from_route = new_solution[from_route_idx]\n            node_pos = random.randint(1, len(from_route) - 2)\n            node = from_route[node_pos]\n\n            # Check if moving the node to another route is feasible\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[node] <= capacity:\n                # Remove node from original route\n                new_from_route = np.concatenate([from_route[:node_pos], from_route[node_pos + 1:]])\n                new_solution[from_route_idx] = new_from_route\n\n                # Insert node into new route (random position)\n                insert_pos = random.randint(1, len(to_route) - 1)\n                new_to_route = np.concatenate([to_route[:insert_pos], [node], to_route[insert_pos:]])\n                new_solution[to_route_idx] = new_to_route\n\n    # Capacity-aware edge swap: swap edges between two routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random edges from each route\n            edge1_pos = random.randint(1, len(route1) - 2)\n            edge2_pos = random.randint(1, len(route2) - 2)\n\n            # Extract the edges\n            edge1 = (route1[edge1_pos], route1[edge1_pos + 1])\n            edge2 = (route2[edge2_pos], route2[edge2_pos + 1])\n\n            # Create new routes by swapping edges\n            new_route1 = np.concatenate([\n                route1[:edge1_pos],\n                [edge2[0], edge2[1]],\n                route1[edge1_pos + 2:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:edge2_pos],\n                [edge1[0], edge1[1]],\n                route2[edge2_pos + 2:]\n            ])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.3792898125604839,
            0.9504245221614838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, node relocation, and edge swaps\n    if len(new_solution) > 1:\n        # Route splitting: split a long route into two\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n        split_pos = random.randint(1, len(longest_route) - 2)\n        new_route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([new_route1, new_route2])\n\n    # Node relocation: move a node from one route to another\n    if len(new_solution) > 1:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        to_route_idx = random.randint(0, len(new_solution) - 1)\n        if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 2:\n            from_route = new_solution[from_route_idx]\n            node_pos = random.randint(1, len(from_route) - 2)\n            node = from_route[node_pos]\n\n            # Check if moving the node to another route is feasible\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[node] <= capacity:\n                # Remove node from original route\n                new_from_route = np.concatenate([from_route[:node_pos], from_route[node_pos + 1:]])\n                new_solution[from_route_idx] = new_from_route\n\n                # Insert node into new route (random position)\n                insert_pos = random.randint(1, len(to_route) - 1)\n                new_to_route = np.concatenate([to_route[:insert_pos], [node], to_route[insert_pos:]])\n                new_solution[to_route_idx] = new_to_route\n\n    # Capacity-aware edge swap: swap edges between two routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random edges from each route\n            edge1_pos = random.randint(1, len(route1) - 2)\n            edge2_pos = random.randint(1, len(route2) - 2)\n\n            # Extract the edges\n            edge1 = (route1[edge1_pos], route1[edge1_pos + 1])\n            edge2 = (route2[edge2_pos], route2[edge2_pos + 1])\n\n            # Create new routes by swapping edges\n            new_route1 = np.concatenate([\n                route1[:edge1_pos],\n                [edge2[0], edge2[1]],\n                route1[edge1_pos + 2:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:edge2_pos],\n                [edge1[0], edge1[1]],\n                route2[edge2_pos + 2:]\n            ])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.append(merged_route)\n\n            # Reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only consider routes with more than one customer\n                    # Randomly select a customer to move\n                    customer_idx = np.random.randint(1, len(route)-1)\n                    customer = route[customer_idx]\n\n                    # Find the best route to insert the customer (minimizing makespan increase)\n                    best_route = None\n                    min_increase = float('inf')\n                    for candidate_route in new_solution:\n                        if len(candidate_route) > 2 and sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                            # Evaluate all possible insertion positions\n                            for pos in range(1, len(candidate_route)):\n                                new_route = np.insert(candidate_route, pos, customer)\n                                new_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                increase = new_length - sum(distance_matrix[candidate_route[:-1], candidate_route[1:]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_route = candidate_route\n\n                    # Perform the move if beneficial\n                    if best_route is not None and min_increase < 0:\n                        # Remove customer from original route\n                        route = np.delete(route, customer_idx)\n                        # Insert into best route\n                        for pos in range(1, len(best_route)):\n                            new_route = np.insert(best_route, pos, customer)\n                            if sum(distance_matrix[new_route[:-1], new_route[1:]]) <= sum(distance_matrix[best_route[:-1], best_route[1:]]):\n                                best_route = new_route\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.8575538133283032,
            2.05599582195282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Select solution with highest makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.append(merged_route)\n\n            # Reallocate customers to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # Only consider routes with more than one customer\n                    # Randomly select a customer to move\n                    customer_idx = np.random.randint(1, len(route)-1)\n                    customer = route[customer_idx]\n\n                    # Find the best route to insert the customer (minimizing makespan increase)\n                    best_route = None\n                    min_increase = float('inf')\n                    for candidate_route in new_solution:\n                        if len(candidate_route) > 2 and sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                            # Evaluate all possible insertion positions\n                            for pos in range(1, len(candidate_route)):\n                                new_route = np.insert(candidate_route, pos, customer)\n                                new_length = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                increase = new_length - sum(distance_matrix[candidate_route[:-1], candidate_route[1:]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_route = candidate_route\n\n                    # Perform the move if beneficial\n                    if best_route is not None and min_increase < 0:\n                        # Remove customer from original route\n                        route = np.delete(route, customer_idx)\n                        # Insert into best route\n                        for pos in range(1, len(best_route)):\n                            new_route = np.insert(best_route, pos, customer)\n                            if sum(distance_matrix[new_route[:-1], new_route[1:]]) <= sum(distance_matrix[best_route[:-1], best_route[1:]]):\n                                best_route = new_route\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: route merging and route splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            # Split the route into two parts\n            split_point = len(route) // 2\n            route1 = np.concatenate([route[:split_point], [0]])\n            route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity feasibility for both new routes\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.append(route1)\n                new_solution.append(route2)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Try merging two short routes if possible\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            if len(route1) > 3 and len(route2) > 3:  # Ensure routes have customers to merge\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(i + 1)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.652990273762672,
            3.231517344713211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: route merging and route splitting\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            # Split the route into two parts\n            split_point = len(route) // 2\n            route1 = np.concatenate([route[:split_point], [0]])\n            route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity feasibility for both new routes\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.append(route1)\n                new_solution.append(route2)\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Try merging two short routes if possible\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            if len(route1) > 3 and len(route2) > 3:  # Ensure routes have customers to merge\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(i + 1)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route Splitting: Split long routes to reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_route_demand = sum(demand[route[1:-1]])\n            if total_route_demand > capacity * 0.7:  # If route is heavily loaded\n                split_point = len(route) // 2\n                new_route1 = np.concatenate(([0], route[1:split_point+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_point+1:-1], [0]))\n\n                # Check feasibility\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n    # 2. Customer Reallocation: Move customers between routes to balance loads\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find the most loaded route\n        loaded_routes = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        loaded_routes.sort(key=lambda x: -x[1])\n\n        if not loaded_routes:\n            break\n\n        most_loaded_idx = loaded_routes[0][0]\n        most_loaded_route = new_solution[most_loaded_idx]\n\n        # Find the least loaded route\n        least_loaded_idx = loaded_routes[-1][0]\n        least_loaded_route = new_solution[least_loaded_idx]\n\n        # Try to move a customer from the most loaded to the least loaded route\n        for customer in most_loaded_route[1:-1]:\n            # Check if moving this customer would keep both routes feasible\n            if (sum(demand[least_loaded_route[1:-1]]) + demand[customer] <= capacity and\n                sum(demand[most_loaded_route[1:-1]]) - demand[customer] >= 0):\n\n                # Find the best insertion point in the least loaded route\n                best_insert_pos = 1\n                min_increase = float('inf')\n\n                for i in range(1, len(least_loaded_route)):\n                    # Calculate distance increase\n                    prev_node = least_loaded_route[i-1]\n                    next_node = least_loaded_route[i]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_insert_pos = i\n\n                # Perform the move\n                least_loaded_route = np.insert(least_loaded_route, best_insert_pos, customer)\n                most_loaded_route = np.delete(most_loaded_route, np.where(most_loaded_route == customer)[0][0])\n\n                # Update the routes\n                new_solution[least_loaded_idx] = least_loaded_route\n                new_solution[most_loaded_idx] = most_loaded_route\n                break\n\n    # 3. Adaptive 2-opt: Perform 2-opt on routes with high potential for improvement\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            # Calculate the route's distance\n            current_distance = sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1))\n\n            # Try all possible 2-opt swaps\n            improved = True\n            while improved:\n                improved = False\n                for j in range(1, len(route)-2):\n                    for k in range(j+1, len(route)-1):\n                        # Create the new route\n                        new_route = route.copy()\n                        new_route[j:k+1] = route[j:k+1][::-1]\n\n                        # Calculate new distance\n                        new_distance = sum(distance_matrix[new_route[l]][new_route[l+1]] for l in range(len(new_route)-1))\n\n                        # If improvement is found, accept it\n                        if new_distance < current_distance:\n                            route = new_route\n                            current_distance = new_distance\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n                # Update the route if improved\n                if improved:\n                    new_solution[i] = route\n\n    return new_solution\n\n",
        "score": [
            -0.3863625327782555,
            8.843055188655853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # 1. Route Splitting: Split long routes to reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_route_demand = sum(demand[route[1:-1]])\n            if total_route_demand > capacity * 0.7:  # If route is heavily loaded\n                split_point = len(route) // 2\n                new_route1 = np.concatenate(([0], route[1:split_point+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_point+1:-1], [0]))\n\n                # Check feasibility\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n\n    # 2. Customer Reallocation: Move customers between routes to balance loads\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find the most loaded route\n        loaded_routes = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        loaded_routes.sort(key=lambda x: -x[1])\n\n        if not loaded_routes:\n            break\n\n        most_loaded_idx = loaded_routes[0][0]\n        most_loaded_route = new_solution[most_loaded_idx]\n\n        # Find the least loaded route\n        least_loaded_idx = loaded_routes[-1][0]\n        least_loaded_route = new_solution[least_loaded_idx]\n\n        # Try to move a customer from the most loaded to the least loaded route\n        for customer in most_loaded_route[1:-1]:\n            # Check if moving this customer would keep both routes feasible\n            if (sum(demand[least_loaded_route[1:-1]]) + demand[customer] <= capacity and\n                sum(demand[most_loaded_route[1:-1]]) - demand[customer] >= 0):\n\n                # Find the best insertion point in the least loaded route\n                best_insert_pos = 1\n                min_increase = float('inf')\n\n                for i in range(1, len(least_loaded_route)):\n                    # Calculate distance increase\n                    prev_node = least_loaded_route[i-1]\n                    next_node = least_loaded_route[i]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_insert_pos = i\n\n                # Perform the move\n                least_loaded_route = np.insert(least_loaded_route, best_insert_pos, customer)\n                most_loaded_route = np.delete(most_loaded_route, np.where(most_loaded_route == customer)[0][0])\n\n                # Update the routes\n                new_solution[least_loaded_idx] = least_loaded_route\n                new_solution[most_loaded_idx] = most_loaded_route\n                break\n\n    # 3. Adaptive 2-opt: Perform 2-opt on routes with high potential for improvement\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            # Calculate the route's distance\n            current_distance = sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1))\n\n            # Try all possible 2-opt swaps\n            improved = True\n            while improved:\n                improved = False\n                for j in range(1, len(route)-2):\n                    for k in range(j+1, len(route)-1):\n                        # Create the new route\n                        new_route = route.copy()\n                        new_route[j:k+1] = route[j:k+1][::-1]\n\n                        # Calculate new distance\n                        new_distance = sum(distance_matrix[new_route[l]][new_route[l+1]] for l in range(len(new_route)-1))\n\n                        # If improvement is found, accept it\n                        if new_distance < current_distance:\n                            route = new_route\n                            current_distance = new_distance\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n                # Update the route if improved\n                if improved:\n                    new_solution[i] = route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high makespan)\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search operator: Route splitting and demand-based reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Reinsert nodes from overloaded routes into other feasible routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        if np.sum(demand[current_route[1:-1]]) > capacity:\n            # Find nodes to reinsert\n            excess_nodes = []\n            current_demand = 0\n            for node in current_route[1:-1]:\n                if current_demand + demand[node] > capacity:\n                    excess_nodes.append(node)\n                else:\n                    current_demand += demand[node]\n\n            # Try to reinsert excess nodes into other routes\n            for node in excess_nodes:\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    candidate_route = new_solution[j]\n                    # Check if adding the node keeps the route feasible\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[node] <= capacity:\n                        # Find the best insertion position (minimizing additional distance)\n                        min_additional_dist = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(candidate_route)):\n                            dist = (distance_matrix[candidate_route[pos-1], node] +\n                                    distance_matrix[node, candidate_route[pos]] -\n                                    distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                            if dist < min_additional_dist:\n                                min_additional_dist = dist\n                                best_pos = pos\n                        if best_pos != -1:\n                            # Insert the node\n                            candidate_route = np.insert(candidate_route, best_pos, node)\n                            new_solution[j] = candidate_route\n                            # Remove from current route\n                            current_route = np.delete(current_route, np.where(current_route == node)[0][0])\n                            new_solution[i] = current_route\n                            break\n\n    # Perform distance-aware swaps between routes to reduce total distance\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find feasible swaps between routes\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check capacity constraints after swap\n                if (np.sum(demand[np.concatenate([route1[1:k], route2[l:l+1], route1[k+1:-1]])]) <= capacity and\n                    np.sum(demand[np.concatenate([route2[1:l], route1[k:k+1], route2[l+1:-1]])]) <= capacity):\n                    # Calculate distance change\n                    old_dist = (distance_matrix[route1[k-1], route1[k]] +\n                                distance_matrix[route1[k], route1[k+1]] +\n                                distance_matrix[route2[l-1], route2[l]] +\n                                distance_matrix[route2[l], route2[l+1]])\n                    new_dist = (distance_matrix[route1[k-1], route2[l]] +\n                                distance_matrix[route2[l], route1[k+1]] +\n                                distance_matrix[route2[l-1], route1[k]] +\n                                distance_matrix[route1[k], route2[l+1]])\n                    if new_dist < old_dist:\n                        # Perform the swap\n                        route1[k], route2[l] = route2[l], route1[k]\n                        new_solution[i] = route1\n                        new_solution[j] = route2\n                        break\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7707531800816831,
            3.7732041478157043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high makespan)\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search operator: Route splitting and demand-based reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Reinsert nodes from overloaded routes into other feasible routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        if np.sum(demand[current_route[1:-1]]) > capacity:\n            # Find nodes to reinsert\n            excess_nodes = []\n            current_demand = 0\n            for node in current_route[1:-1]:\n                if current_demand + demand[node] > capacity:\n                    excess_nodes.append(node)\n                else:\n                    current_demand += demand[node]\n\n            # Try to reinsert excess nodes into other routes\n            for node in excess_nodes:\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    candidate_route = new_solution[j]\n                    # Check if adding the node keeps the route feasible\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[node] <= capacity:\n                        # Find the best insertion position (minimizing additional distance)\n                        min_additional_dist = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(candidate_route)):\n                            dist = (distance_matrix[candidate_route[pos-1], node] +\n                                    distance_matrix[node, candidate_route[pos]] -\n                                    distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                            if dist < min_additional_dist:\n                                min_additional_dist = dist\n                                best_pos = pos\n                        if best_pos != -1:\n                            # Insert the node\n                            candidate_route = np.insert(candidate_route, best_pos, node)\n                            new_solution[j] = candidate_route\n                            # Remove from current route\n                            current_route = np.delete(current_route, np.where(current_route == node)[0][0])\n                            new_solution[i] = current_route\n                            break\n\n    # Perform distance-aware swaps between routes to reduce total distance\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find feasible swaps between routes\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check capacity constraints after swap\n                if (np.sum(demand[np.concatenate([route1[1:k], route2[l:l+1], route1[k+1:-1]])]) <= capacity and\n                    np.sum(demand[np.concatenate([route2[1:l], route1[k:k+1], route2[l+1:-1]])]) <= capacity):\n                    # Calculate distance change\n                    old_dist = (distance_matrix[route1[k-1], route1[k]] +\n                                distance_matrix[route1[k], route1[k+1]] +\n                                distance_matrix[route2[l-1], route2[l]] +\n                                distance_matrix[route2[l], route2[l+1]])\n                    new_dist = (distance_matrix[route1[k-1], route2[l]] +\n                                distance_matrix[route2[l], route1[k+1]] +\n                                distance_matrix[route2[l-1], route1[k]] +\n                                distance_matrix[route1[k], route2[l+1]])\n                    if new_dist < old_dist:\n                        # Perform the swap\n                        route1[k], route2[l] = route2[l], route1[k]\n                        new_solution[i] = route1\n                        new_solution[j] = route2\n                        break\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and intra-route relocation\n    n_routes = len(new_solution)\n    if n_routes > 1:\n        # Try merging two routes if their total demand fits within capacity\n        for i in range(n_routes):\n            for j in range(i + 1, n_routes):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    # Check feasibility and improve with 2-opt on the merged route\n                    if len(merged_route) > 3:\n                        # Apply 2-opt to the merged route\n                        improved_route = merged_route.copy()\n                        for k in range(1, len(improved_route) - 2):\n                            for l in range(k + 1, len(improved_route) - 1):\n                                if (distance_matrix[improved_route[k-1]][improved_route[l]] +\n                                    distance_matrix[improved_route[k]][improved_route[l+1]]) < (\n                                    distance_matrix[improved_route[k-1]][improved_route[k]] +\n                                    distance_matrix[improved_route[l]][improved_route[l+1]]):\n                                    improved_route[k:l+1] = improved_route[k:l+1][::-1]\n                        new_solution[i] = improved_route\n                    break\n    else:\n        # Apply intra-route relocation with demand feasibility check\n        route = new_solution[0]\n        for i in range(1, len(route) - 1):\n            for j in range(1, len(route)):\n                if i != j and j != i + 1:\n                    # Check if relocation is feasible\n                    if i < j:\n                        segment = route[i:j]\n                        without_segment = np.concatenate([route[:i], route[j:]])\n                    else:\n                        segment = route[j:i]\n                        without_segment = np.concatenate([route[:j], route[i:]])\n                    # Check demand feasibility for the segment\n                    segment_demand = np.sum(demand[segment])\n                    # Find insertion points in other routes\n                    for k in range(len(new_solution)):\n                        if k == 0:\n                            continue  # Skip the current route\n                        insertion_route = new_solution[k]\n                        for l in range(1, len(insertion_route)):\n                            # Check if insertion is feasible\n                            if np.sum(demand[insertion_route[1:-1]]) + segment_demand <= capacity:\n                                new_insertion_route = np.concatenate([insertion_route[:l], segment, insertion_route[l:]])\n                                new_solution[k] = new_insertion_route\n                                new_solution[0] = without_segment\n                                # Apply 2-opt to the modified routes\n                                for r in range(len(new_solution)):\n                                    if len(new_solution[r]) > 3:\n                                        improved_route = new_solution[r].copy()\n                                        for m in range(1, len(improved_route) - 2):\n                                            for n in range(m + 1, len(improved_route) - 1):\n                                                if (distance_matrix[improved_route[m-1]][improved_route[n]] +\n                                                    distance_matrix[improved_route[m]][improved_route[n+1]]) < (\n                                                    distance_matrix[improved_route[m-1]][improved_route[m]] +\n                                                    distance_matrix[improved_route[n]][improved_route[n+1]]):\n                                                    improved_route[m:n+1] = improved_route[m:n+1][::-1]\n                                        new_solution[r] = improved_route\n                                break\n\n    # Ensure all routes are feasible and return the new solution\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7257677264864434,
            3.8779047429561615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and intra-route relocation\n    n_routes = len(new_solution)\n    if n_routes > 1:\n        # Try merging two routes if their total demand fits within capacity\n        for i in range(n_routes):\n            for j in range(i + 1, n_routes):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    # Check feasibility and improve with 2-opt on the merged route\n                    if len(merged_route) > 3:\n                        # Apply 2-opt to the merged route\n                        improved_route = merged_route.copy()\n                        for k in range(1, len(improved_route) - 2):\n                            for l in range(k + 1, len(improved_route) - 1):\n                                if (distance_matrix[improved_route[k-1]][improved_route[l]] +\n                                    distance_matrix[improved_route[k]][improved_route[l+1]]) < (\n                                    distance_matrix[improved_route[k-1]][improved_route[k]] +\n                                    distance_matrix[improved_route[l]][improved_route[l+1]]):\n                                    improved_route[k:l+1] = improved_route[k:l+1][::-1]\n                        new_solution[i] = improved_route\n                    break\n    else:\n        # Apply intra-route relocation with demand feasibility check\n        route = new_solution[0]\n        for i in range(1, len(route) - 1):\n            for j in range(1, len(route)):\n                if i != j and j != i + 1:\n                    # Check if relocation is feasible\n                    if i < j:\n                        segment = route[i:j]\n                        without_segment = np.concatenate([route[:i], route[j:]])\n                    else:\n                        segment = route[j:i]\n                        without_segment = np.concatenate([route[:j], route[i:]])\n                    # Check demand feasibility for the segment\n                    segment_demand = np.sum(demand[segment])\n                    # Find insertion points in other routes\n                    for k in range(len(new_solution)):\n                        if k == 0:\n                            continue  # Skip the current route\n                        insertion_route = new_solution[k]\n                        for l in range(1, len(insertion_route)):\n                            # Check if insertion is feasible\n                            if np.sum(demand[insertion_route[1:-1]]) + segment_demand <= capacity:\n                                new_insertion_route = np.concatenate([insertion_route[:l], segment, insertion_route[l:]])\n                                new_solution[k] = new_insertion_route\n                                new_solution[0] = without_segment\n                                # Apply 2-opt to the modified routes\n                                for r in range(len(new_solution)):\n                                    if len(new_solution[r]) > 3:\n                                        improved_route = new_solution[r].copy()\n                                        for m in range(1, len(improved_route) - 2):\n                                            for n in range(m + 1, len(improved_route) - 1):\n                                                if (distance_matrix[improved_route[m-1]][improved_route[n]] +\n                                                    distance_matrix[improved_route[m]][improved_route[n+1]]) < (\n                                                    distance_matrix[improved_route[m-1]][improved_route[m]] +\n                                                    distance_matrix[improved_route[n]][improved_route[n+1]]):\n                                                    improved_route[m:n+1] = improved_route[m:n+1][::-1]\n                                        new_solution[r] = improved_route\n                                break\n\n    # Ensure all routes are feasible and return the new solution\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        customers = route[1:-1]  # Exclude depot\n\n        if len(customers) > 1:\n            # Randomly split the route into two parts and reinsert\n            split_point = np.random.randint(1, len(customers))\n            part1 = customers[:split_point]\n            part2 = customers[split_point:]\n\n            # Create a new route by swapping parts and reinserting\n            new_route = np.concatenate([[0], part2, part1, [0]])\n            new_solution[route_idx] = new_route\n\n            # Check feasibility and repair if needed\n            if np.sum(demand[new_route[1:-1]]) > capacity:\n                # If capacity is exceeded, try to rebalance by moving customers to other routes\n                for customer in new_route[1:-1]:\n                    for i in range(len(new_solution)):\n                        if i != route_idx:\n                            temp_route = np.concatenate([new_solution[i][:-1], [customer], [0]])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[route_idx] = np.concatenate([[0], np.setdiff1d(new_route[1:-1], [customer]), [0]])\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.7859882176195037,
            0.4327089786529541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        customers = route[1:-1]  # Exclude depot\n\n        if len(customers) > 1:\n            # Randomly split the route into two parts and reinsert\n            split_point = np.random.randint(1, len(customers))\n            part1 = customers[:split_point]\n            part2 = customers[split_point:]\n\n            # Create a new route by swapping parts and reinserting\n            new_route = np.concatenate([[0], part2, part1, [0]])\n            new_solution[route_idx] = new_route\n\n            # Check feasibility and repair if needed\n            if np.sum(demand[new_route[1:-1]]) > capacity:\n                # If capacity is exceeded, try to rebalance by moving customers to other routes\n                for customer in new_route[1:-1]:\n                    for i in range(len(new_solution)):\n                        if i != route_idx:\n                            temp_route = np.concatenate([new_solution[i][:-1], [customer], [0]])\n                            if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                new_solution[i] = temp_route\n                                new_solution[route_idx] = np.concatenate([[0], np.setdiff1d(new_route[1:-1], [customer]), [0]])\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # If route has only depot and one customer, skip\n    if len(route) <= 3:\n        return new_solution\n\n    # Split the route into two parts at a random point\n    split_pos = np.random.randint(1, len(route) - 2)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n\n    # Reverse part2 to create a new route segment\n    reversed_part2 = part2[::-1]\n\n    # Check capacity constraint for the new route\n    total_demand = sum(demand[node] for node in reversed_part2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Create a new route by combining part1 and reversed_part2\n    new_route = np.concatenate([part1, reversed_part2[1:]])\n\n    # Update the solution with the new route\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7134432291555375,
            0.1814487874507904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # If route has only depot and one customer, skip\n    if len(route) <= 3:\n        return new_solution\n\n    # Split the route into two parts at a random point\n    split_pos = np.random.randint(1, len(route) - 2)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n\n    # Reverse part2 to create a new route segment\n    reversed_part2 = part2[::-1]\n\n    # Check capacity constraint for the new route\n    total_demand = sum(demand[node] for node in reversed_part2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Create a new route by combining part1 and reversed_part2\n    new_route = np.concatenate([part1, reversed_part2[1:]])\n\n    # Update the solution with the new route\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # If route has only depot and one customer, skip\n    if len(route) <= 3:\n        return new_solution\n\n    # Split the route into two parts at a random point\n    split_pos = np.random.randint(1, len(route) - 2)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n\n    # Reverse part2 to create a new route segment\n    reversed_part2 = part2[::-1]\n\n    # Check capacity constraint for the new route\n    total_demand = sum(demand[node] for node in reversed_part2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Create a new route by combining part1 and reversed_part2\n    new_route = np.concatenate([part1, reversed_part2[1:]])\n\n    # Update the solution with the new route\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7134432291555375,
            0.1814487874507904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx].copy()\n\n    # If route has only depot and one customer, skip\n    if len(route) <= 3:\n        return new_solution\n\n    # Split the route into two parts at a random point\n    split_pos = np.random.randint(1, len(route) - 2)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n\n    # Reverse part2 to create a new route segment\n    reversed_part2 = part2[::-1]\n\n    # Check capacity constraint for the new route\n    total_demand = sum(demand[node] for node in reversed_part2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Create a new route by combining part1 and reversed_part2\n    new_route = np.concatenate([part1, reversed_part2[1:]])\n\n    # Update the solution with the new route\n    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Randomly select a segment to reallocate\n    if len(selected_route) > 3:  # Ensure there are customers to move\n        start_idx = np.random.randint(1, len(selected_route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(selected_route) - 1)\n        segment = selected_route[start_idx:end_idx]\n\n        # Calculate the demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find the best route to reallocate the segment\n        best_route_idx = -1\n        best_improvement = 0\n        for i, route in enumerate(base_solution):\n            if i == route_idx:\n                continue\n            # Check if the route can accommodate the segment\n            if np.sum(demand[route]) + segment_demand <= capacity:\n                # Calculate the improvement in total distance\n                # Remove segment from original route\n                original_distance = distance_matrix[selected_route[start_idx - 1], selected_route[start_idx]] + \\\n                                   distance_matrix[selected_route[end_idx], selected_route[end_idx + 1]] - \\\n                                   distance_matrix[selected_route[start_idx - 1], selected_route[end_idx + 1]]\n                # Add segment to new route\n                new_distance = distance_matrix[route[-2], segment[0]] + \\\n                               distance_matrix[segment[-1], route[-1]] - \\\n                               distance_matrix[route[-2], route[-1]]\n                improvement = original_distance - new_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route_idx = i\n\n        # If a better route is found, reallocate the segment\n        if best_route_idx != -1:\n            # Remove the segment from the original route\n            new_selected_route = np.concatenate([selected_route[:start_idx], selected_route[end_idx + 1:]])\n            base_solution[route_idx] = new_selected_route\n            # Add the segment to the best route\n            best_route = base_solution[best_route_idx]\n            new_best_route = np.concatenate([best_route[:-1], segment, [best_route[-1]]])\n            base_solution[best_route_idx] = new_best_route\n\n    # Randomly decide to merge two routes if they fit capacity constraints\n    if len(base_solution) > 1 and np.random.rand() < 0.3:\n        route1_idx = np.random.randint(len(base_solution))\n        route2_idx = np.random.choice([i for i in range(len(base_solution)) if i != route1_idx])\n        route1 = base_solution[route1_idx]\n        route2 = base_solution[route2_idx]\n        if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n            # Merge route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for i, route in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    # Randomly decide to split a long route if it can be divided into two feasible routes\n    if len(base_solution) < len(demand) and np.random.rand() < 0.3:\n        long_route_idx = np.argmax([len(route) for route in base_solution])\n        long_route = base_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure it can be split\n            split_pos = np.random.randint(2, len(long_route) - 2)\n            part1 = long_route[:split_pos + 1]\n            part2 = np.concatenate([[0], long_route[split_pos + 1:]])\n            if np.sum(demand[part1]) <= capacity and np.sum(demand[part2]) <= capacity:\n                new_solution = [route for i, route in enumerate(base_solution) if i != long_route_idx]\n                new_solution.extend([part1, part2])\n                base_solution = new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.49058261841138273,
            2.414911538362503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Randomly select a segment to reallocate\n    if len(selected_route) > 3:  # Ensure there are customers to move\n        start_idx = np.random.randint(1, len(selected_route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(selected_route) - 1)\n        segment = selected_route[start_idx:end_idx]\n\n        # Calculate the demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Find the best route to reallocate the segment\n        best_route_idx = -1\n        best_improvement = 0\n        for i, route in enumerate(base_solution):\n            if i == route_idx:\n                continue\n            # Check if the route can accommodate the segment\n            if np.sum(demand[route]) + segment_demand <= capacity:\n                # Calculate the improvement in total distance\n                # Remove segment from original route\n                original_distance = distance_matrix[selected_route[start_idx - 1], selected_route[start_idx]] + \\\n                                   distance_matrix[selected_route[end_idx], selected_route[end_idx + 1]] - \\\n                                   distance_matrix[selected_route[start_idx - 1], selected_route[end_idx + 1]]\n                # Add segment to new route\n                new_distance = distance_matrix[route[-2], segment[0]] + \\\n                               distance_matrix[segment[-1], route[-1]] - \\\n                               distance_matrix[route[-2], route[-1]]\n                improvement = original_distance - new_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route_idx = i\n\n        # If a better route is found, reallocate the segment\n        if best_route_idx != -1:\n            # Remove the segment from the original route\n            new_selected_route = np.concatenate([selected_route[:start_idx], selected_route[end_idx + 1:]])\n            base_solution[route_idx] = new_selected_route\n            # Add the segment to the best route\n            best_route = base_solution[best_route_idx]\n            new_best_route = np.concatenate([best_route[:-1], segment, [best_route[-1]]])\n            base_solution[best_route_idx] = new_best_route\n\n    # Randomly decide to merge two routes if they fit capacity constraints\n    if len(base_solution) > 1 and np.random.rand() < 0.3:\n        route1_idx = np.random.randint(len(base_solution))\n        route2_idx = np.random.choice([i for i in range(len(base_solution)) if i != route1_idx])\n        route1 = base_solution[route1_idx]\n        route2 = base_solution[route2_idx]\n        if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n            # Merge route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [route for i, route in enumerate(base_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(merged_route)\n            base_solution = new_solution\n\n    # Randomly decide to split a long route if it can be divided into two feasible routes\n    if len(base_solution) < len(demand) and np.random.rand() < 0.3:\n        long_route_idx = np.argmax([len(route) for route in base_solution])\n        long_route = base_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure it can be split\n            split_pos = np.random.randint(2, len(long_route) - 2)\n            part1 = long_route[:split_pos + 1]\n            part2 = np.concatenate([[0], long_route[split_pos + 1:]])\n            if np.sum(demand[part1]) <= capacity and np.sum(demand[part2]) <= capacity:\n                new_solution = [route for i, route in enumerate(base_solution) if i != long_route_idx]\n                new_solution.extend([part1, part2])\n                base_solution = new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point]\n    part2 = longest_route[split_point:]\n\n    # Ensure both parts are feasible (capacity not exceeded)\n    demand_part1 = demand[part1[1:-1]].sum()\n    demand_part2 = demand[part2[1:-1]].sum()\n\n    if demand_part1 <= capacity and demand_part2 <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.insert(longest_route_idx + 1, part2)\n    else:\n        # If splitting is infeasible, try moving a random customer from the longest route to another route\n        if len(selected_solution) > 1:\n            target_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != longest_route_idx])\n            target_route = selected_solution[target_route_idx].copy()\n            customer_to_move = np.random.choice(longest_route[1:-1])\n\n            # Check if moving the customer is feasible for the target route\n            if demand[customer_to_move] + demand[target_route[1:-1]].sum() <= capacity:\n                # Update the routes\n                part1 = np.delete(longest_route, np.where(longest_route == customer_to_move))\n                part2 = np.insert(target_route, -1, customer_to_move)\n                new_solution[longest_route_idx] = part1\n                new_solution[target_route_idx] = part2\n\n    return new_solution\n\n",
        "score": [
            -0.7770830245903011,
            0.40452495217323303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify the longest route in the selected solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point]\n    part2 = longest_route[split_point:]\n\n    # Ensure both parts are feasible (capacity not exceeded)\n    demand_part1 = demand[part1[1:-1]].sum()\n    demand_part2 = demand[part2[1:-1]].sum()\n\n    if demand_part1 <= capacity and demand_part2 <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.insert(longest_route_idx + 1, part2)\n    else:\n        # If splitting is infeasible, try moving a random customer from the longest route to another route\n        if len(selected_solution) > 1:\n            target_route_idx = np.random.choice([i for i in range(len(selected_solution)) if i != longest_route_idx])\n            target_route = selected_solution[target_route_idx].copy()\n            customer_to_move = np.random.choice(longest_route[1:-1])\n\n            # Check if moving the customer is feasible for the target route\n            if demand[customer_to_move] + demand[target_route[1:-1]].sum() <= capacity:\n                # Update the routes\n                part1 = np.delete(longest_route, np.where(longest_route == customer_to_move))\n                part2 = np.insert(target_route, -1, customer_to_move)\n                new_solution[longest_route_idx] = part1\n                new_solution[target_route_idx] = part2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and intra-route relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Perform intra-route relocation on each part\n            for part in [part1, part2]:\n                if len(part) > 3:\n                    # Randomly select two nodes to swap\n                    i, j = np.random.choice(range(1, len(part) - 1), 2, replace=False)\n                    part[i], part[j] = part[j], part[i]\n\n                    # Ensure capacity constraint is still satisfied\n                    if np.sum(demand[part[1:-1]]) > capacity:\n                        # Undo swap if capacity is violated\n                        part[i], part[j] = part[j], part[i]\n\n            # Add both parts to the new solution\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, keep original route and perform relocation\n            modified_route = route.copy()\n            i, j = np.random.choice(range(1, len(modified_route) - 1), 2, replace=False)\n            modified_route[i], modified_route[j] = modified_route[j], modified_route[i]\n\n            # Ensure capacity constraint\n            if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                new_solution.append(modified_route)\n            else:\n                new_solution.append(route.copy())\n\n    # Convert list of routes back to original format\n    final_solution = [np.array(route) for route in new_solution]\n    return final_solution\n\n",
        "score": [
            -0.8001414694298762,
            2.6719457805156708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and intra-route relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        demand1 = np.sum(demand[part1[1:-1]])\n        demand2 = np.sum(demand[part2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Perform intra-route relocation on each part\n            for part in [part1, part2]:\n                if len(part) > 3:\n                    # Randomly select two nodes to swap\n                    i, j = np.random.choice(range(1, len(part) - 1), 2, replace=False)\n                    part[i], part[j] = part[j], part[i]\n\n                    # Ensure capacity constraint is still satisfied\n                    if np.sum(demand[part[1:-1]]) > capacity:\n                        # Undo swap if capacity is violated\n                        part[i], part[j] = part[j], part[i]\n\n            # Add both parts to the new solution\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, keep original route and perform relocation\n            modified_route = route.copy()\n            i, j = np.random.choice(range(1, len(modified_route) - 1), 2, replace=False)\n            modified_route[i], modified_route[j] = modified_route[j], modified_route[i]\n\n            # Ensure capacity constraint\n            if np.sum(demand[modified_route[1:-1]]) <= capacity:\n                new_solution.append(modified_route)\n            else:\n                new_solution.append(route.copy())\n\n    # Convert list of routes back to original format\n    final_solution = [np.array(route) for route in new_solution]\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search operator that combines route swapping, 3-opt, and demand-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def weighted_objective(obj):\n        return obj[0] * 0.6 + obj[1] * 0.4  # Prioritize total distance slightly more\n\n    sorted_archive = sorted(archive, key=lambda x: weighted_objective(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(3, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route swapping between two randomly selected routes\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i][1:-1]  # Exclude depot\n            route_j = new_solution[j][1:-1]\n\n            # Check feasibility after swapping\n            if (sum(demand[route_i]) <= capacity and sum(demand[route_j]) <= capacity):\n                new_solution[i] = np.concatenate([[0], route_j, [0]])\n                new_solution[j] = np.concatenate([[0], route_i, [0]])\n\n        # Step 2: 3-opt on a randomly selected route\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx][1:-1]  # Exclude depot\n\n            if len(route) >= 3:\n                # Select three random edges to reverse\n                a, b, c = sorted(random.sample(range(len(route)), 3))\n                new_route = np.concatenate([\n                    route[:a],\n                    route[a:b][::-1],\n                    route[b:c],\n                    route[c:][::-1]\n                ])\n\n                # Check feasibility\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = np.concatenate([[0], new_route, [0]])\n\n        # Step 3: Demand-aware insertion (move a customer from one route to another)\n        if len(new_solution) >= 2:\n            src_route_idx, dest_route_idx = random.sample(range(len(new_solution)), 2)\n            src_route = new_solution[src_route_idx][1:-1]\n            dest_route = new_solution[dest_route_idx][1:-1]\n\n            if len(src_route) > 0:\n                customer = random.choice(src_route)\n                # Find best insertion position in destination route\n                best_pos = 0\n                min_increase = float('inf')\n\n                for i in range(len(dest_route) + 1):\n                    if i == 0:\n                        new_seq = np.concatenate([[customer], dest_route])\n                    elif i == len(dest_route):\n                        new_seq = np.concatenate([dest_route, [customer]])\n                    else:\n                        new_seq = np.concatenate([dest_route[:i], [customer], dest_route[i:]])\n\n                    # Check feasibility\n                    if sum(demand[new_seq]) <= capacity:\n                        # Calculate increase in distance\n                        if i == 0:\n                            increase = distance_matrix[0][customer] + distance_matrix[customer][dest_route[0]] - distance_matrix[0][dest_route[0]]\n                        elif i == len(dest_route):\n                            increase = distance_matrix[dest_route[-1]][customer] + distance_matrix[customer][0] - distance_matrix[dest_route[-1]][0]\n                        else:\n                            increase = distance_matrix[dest_route[i-1]][customer] + distance_matrix[customer][dest_route[i]] - distance_matrix[dest_route[i-1]][dest_route[i]]\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n\n                # Apply insertion if feasible\n                if min_increase != float('inf'):\n                    if best_pos == 0:\n                        new_dest = np.concatenate([[customer], dest_route])\n                    elif best_pos == len(dest_route):\n                        new_dest = np.concatenate([dest_route, [customer]])\n                    else:\n                        new_dest = np.concatenate([dest_route[:best_pos], [customer], dest_route[best_pos:]])\n\n                    new_solution[dest_route_idx] = np.concatenate([[0], new_dest, [0]])\n                    new_solution[src_route_idx] = np.concatenate([[0], np.setdiff1d(src_route, [customer]), [0]])\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure solution validity\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Invalid solution generated - capacity exceeded\")\n\n    return new_solution\n\n",
        "score": [
            -0.3069568621361632,
            1.258326143026352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def weighted_objective(obj):\n        return obj[0] * 0.6 + obj[1] * 0.4  # Prioritize total distance slightly more\n\n    sorted_archive = sorted(archive, key=lambda x: weighted_objective(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(3, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route swapping between two randomly selected routes\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i][1:-1]  # Exclude depot\n            route_j = new_solution[j][1:-1]\n\n            # Check feasibility after swapping\n            if (sum(demand[route_i]) <= capacity and sum(demand[route_j]) <= capacity):\n                new_solution[i] = np.concatenate([[0], route_j, [0]])\n                new_solution[j] = np.concatenate([[0], route_i, [0]])\n\n        # Step 2: 3-opt on a randomly selected route\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx][1:-1]  # Exclude depot\n\n            if len(route) >= 3:\n                # Select three random edges to reverse\n                a, b, c = sorted(random.sample(range(len(route)), 3))\n                new_route = np.concatenate([\n                    route[:a],\n                    route[a:b][::-1],\n                    route[b:c],\n                    route[c:][::-1]\n                ])\n\n                # Check feasibility\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = np.concatenate([[0], new_route, [0]])\n\n        # Step 3: Demand-aware insertion (move a customer from one route to another)\n        if len(new_solution) >= 2:\n            src_route_idx, dest_route_idx = random.sample(range(len(new_solution)), 2)\n            src_route = new_solution[src_route_idx][1:-1]\n            dest_route = new_solution[dest_route_idx][1:-1]\n\n            if len(src_route) > 0:\n                customer = random.choice(src_route)\n                # Find best insertion position in destination route\n                best_pos = 0\n                min_increase = float('inf')\n\n                for i in range(len(dest_route) + 1):\n                    if i == 0:\n                        new_seq = np.concatenate([[customer], dest_route])\n                    elif i == len(dest_route):\n                        new_seq = np.concatenate([dest_route, [customer]])\n                    else:\n                        new_seq = np.concatenate([dest_route[:i], [customer], dest_route[i:]])\n\n                    # Check feasibility\n                    if sum(demand[new_seq]) <= capacity:\n                        # Calculate increase in distance\n                        if i == 0:\n                            increase = distance_matrix[0][customer] + distance_matrix[customer][dest_route[0]] - distance_matrix[0][dest_route[0]]\n                        elif i == len(dest_route):\n                            increase = distance_matrix[dest_route[-1]][customer] + distance_matrix[customer][0] - distance_matrix[dest_route[-1]][0]\n                        else:\n                            increase = distance_matrix[dest_route[i-1]][customer] + distance_matrix[customer][dest_route[i]] - distance_matrix[dest_route[i-1]][dest_route[i]]\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = i\n\n                # Apply insertion if feasible\n                if min_increase != float('inf'):\n                    if best_pos == 0:\n                        new_dest = np.concatenate([[customer], dest_route])\n                    elif best_pos == len(dest_route):\n                        new_dest = np.concatenate([dest_route, [customer]])\n                    else:\n                        new_dest = np.concatenate([dest_route[:best_pos], [customer], dest_route[best_pos:]])\n\n                    new_solution[dest_route_idx] = np.concatenate([[0], new_dest, [0]])\n                    new_solution[src_route_idx] = np.concatenate([[0], np.setdiff1d(src_route, [customer]), [0]])\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure solution validity\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Invalid solution generated - capacity exceeded\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (e.g., high makespan or large total distance)\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reassignment\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random point and attempt to reassign segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Check capacity constraints for both segments\n        def is_valid(seg):\n            return sum(demand[seg[1:-1]]) <= capacity\n\n        if is_valid(segment1) and is_valid(segment2):\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If invalid, try to reassign nodes to other routes or swap segments\n            for i in range(1, len(route) - 1):\n                node = route[i]\n                # Find a route where adding this node doesn't exceed capacity\n                for other_route in new_solution:\n                    if sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                        # Insert node into the middle of the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.insert(other_route, insert_pos, node)\n                        other_route[:] = new_route\n                        break\n                else:\n                    # If no valid route found, keep the original route\n                    new_solution.append(route.copy())\n                    break\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route = np.insert(route, 0, 0)\n            route = np.append(route, 0)\n\n    return new_solution\n\n",
        "score": [
            -0.710938573075308,
            1.9495773315429688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (e.g., high makespan or large total distance)\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reassignment\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random point and attempt to reassign segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Check capacity constraints for both segments\n        def is_valid(seg):\n            return sum(demand[seg[1:-1]]) <= capacity\n\n        if is_valid(segment1) and is_valid(segment2):\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If invalid, try to reassign nodes to other routes or swap segments\n            for i in range(1, len(route) - 1):\n                node = route[i]\n                # Find a route where adding this node doesn't exceed capacity\n                for other_route in new_solution:\n                    if sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                        # Insert node into the middle of the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.insert(other_route, insert_pos, node)\n                        other_route[:] = new_route\n                        break\n                else:\n                    # If no valid route found, keep the original route\n                    new_solution.append(route.copy())\n                    break\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route = np.insert(route, 0, 0)\n            route = np.append(route, 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Route splitting and merging with demand-aware swaps\n    new_solution = []\n    for route in selected_solution:\n        # Split long routes into smaller segments\n        if len(route) > 4:  # Avoid trivial routes\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.append(route[:split_pos + 1], 0)\n            new_route2 = np.insert(route[split_pos + 1:], 0, 0)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Merge short routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i].copy()\n        j = i + 1\n        while j < len(new_solution):\n            next_route = new_solution[j]\n            # Try to merge current_route and next_route\n            merged = np.concatenate([current_route[:-1], next_route[1:]])\n            if np.sum(demand[merged[1:-1]]) <= capacity:\n                current_route = merged\n                j += 1\n            else:\n                break\n        merged_solution.append(current_route)\n        i = j\n\n    # Demand-aware node swaps between routes\n    for k in range(min(5, len(merged_solution))):  # Limit iterations\n        route_a, route_b = np.random.choice(len(merged_solution), 2, replace=False)\n        a_customers = merged_solution[route_a][1:-1]\n        b_customers = merged_solution[route_b][1:-1]\n\n        if len(a_customers) > 1 and len(b_customers) > 1:\n            # Select nodes with similar demands\n            a_node = np.random.choice(a_customers)\n            similar_demands = np.abs(demand[b_customers] - demand[a_node]) < (capacity * 0.2)\n            if np.any(similar_demands):\n                b_node = np.random.choice(b_customers[similar_demands])\n\n                # Try to swap\n                new_route_a = merged_solution[route_a].copy()\n                new_route_b = merged_solution[route_b].copy()\n\n                # Find positions and swap\n                pos_a = np.where(new_route_a == a_node)[0][0]\n                pos_b = np.where(new_route_b == b_node)[0][0]\n\n                new_route_a[pos_a], new_route_b[pos_b] = new_route_b[pos_b], new_route_a[pos_a]\n\n                # Check capacity\n                if (np.sum(demand[new_route_a[1:-1]]) <= capacity and\n                    np.sum(demand[new_route_b[1:-1]]) <= capacity):\n                    merged_solution[route_a] = new_route_a\n                    merged_solution[route_b] = new_route_b\n\n    return merged_solution\n\n",
        "score": [
            -0.5797724264670205,
            4.021961897611618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Route splitting and merging with demand-aware swaps\n    new_solution = []\n    for route in selected_solution:\n        # Split long routes into smaller segments\n        if len(route) > 4:  # Avoid trivial routes\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.append(route[:split_pos + 1], 0)\n            new_route2 = np.insert(route[split_pos + 1:], 0, 0)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Merge short routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i].copy()\n        j = i + 1\n        while j < len(new_solution):\n            next_route = new_solution[j]\n            # Try to merge current_route and next_route\n            merged = np.concatenate([current_route[:-1], next_route[1:]])\n            if np.sum(demand[merged[1:-1]]) <= capacity:\n                current_route = merged\n                j += 1\n            else:\n                break\n        merged_solution.append(current_route)\n        i = j\n\n    # Demand-aware node swaps between routes\n    for k in range(min(5, len(merged_solution))):  # Limit iterations\n        route_a, route_b = np.random.choice(len(merged_solution), 2, replace=False)\n        a_customers = merged_solution[route_a][1:-1]\n        b_customers = merged_solution[route_b][1:-1]\n\n        if len(a_customers) > 1 and len(b_customers) > 1:\n            # Select nodes with similar demands\n            a_node = np.random.choice(a_customers)\n            similar_demands = np.abs(demand[b_customers] - demand[a_node]) < (capacity * 0.2)\n            if np.any(similar_demands):\n                b_node = np.random.choice(b_customers[similar_demands])\n\n                # Try to swap\n                new_route_a = merged_solution[route_a].copy()\n                new_route_b = merged_solution[route_b].copy()\n\n                # Find positions and swap\n                pos_a = np.where(new_route_a == a_node)[0][0]\n                pos_b = np.where(new_route_b == b_node)[0][0]\n\n                new_route_a[pos_a], new_route_b[pos_b] = new_route_b[pos_b], new_route_a[pos_a]\n\n                # Check capacity\n                if (np.sum(demand[new_route_a[1:-1]]) <= capacity and\n                    np.sum(demand[new_route_b[1:-1]]) <= capacity):\n                    merged_solution[route_a] = new_route_a\n                    merged_solution[route_b] = new_route_b\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive, then applies a hybrid local search combining route segment inversion, customer reinsertion with demand-aware optimization, and route merging/splitting to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Simple crowding distance approximation (for demonstration)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    for _ in range(3):  # Number of iterations\n        # Step 1: Route segment inversion with demand check\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Enough nodes to invert\n                i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                inverted_segment = route[i:j+1][::-1]\n                if sum(demand[inverted_segment]) <= capacity:\n                    new_route = np.concatenate([route[:i], inverted_segment, route[j+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Step 2: Customer reinsertion with demand-aware optimization\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Can remove a customer\n            pos = np.random.randint(1, len(route)-1)\n            customer = route[pos]\n            current_load = sum(demand[route])\n            # Remove customer\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best reinsertion position in same route\n            best_pos = 1\n            best_cost = np.inf\n            for pos in range(1, len(new_route)):\n                # Check demand constraint\n                if sum(demand[np.concatenate([new_route[:pos], [customer], new_route[pos:]])]) <= capacity:\n                    # Evaluate distance impact\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                            distance_matrix[customer, new_route[pos]] -\n                            distance_matrix[new_route[pos-1], new_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            # Reinsert\n            new_solution[route_idx] = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n\n        # Step 3: Route merging/splitting to balance makespan\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            # Try merging two routes\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            if sum(demand[route1]) + sum(demand[route2]) <= capacity:\n                # Find best merge point (minimize distance increase)\n                best_cost = np.inf\n                best_merge = None\n                for i in range(1, len(route1)):\n                    for j in range(1, len(route2)):\n                        # Merge route2 after i in route1\n                        merged_route = np.concatenate([route1[:i], route2[1:], route1[i:]])\n                        cost = (distance_matrix[route1[i-1], route2[1]] +\n                                distance_matrix[route2[-2], route1[i]] -\n                                distance_matrix[route1[i-1], route1[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = merged_route\n                if best_merge is not None:\n                    new_solution[route1_idx] = best_merge\n                    del new_solution[route2_idx]\n\n            # Try splitting a route (only if it's too long)\n            elif len(new_solution) < len(demand) and np.random.rand() < 0.2:\n                route_idx = np.random.randint(0, len(new_solution))\n                route = new_solution[route_idx]\n                if len(route) > 5:  # Arbitrary threshold for \"too long\"\n                    # Find best split point\n                    best_cost = np.inf\n                    best_split = None\n                    for pos in range(2, len(route)-2):\n                        # Split after pos\n                        route1 = np.concatenate([route[:pos+1], [0]])\n                        route2 = np.concatenate([[0], route[pos+1:]])\n                        cost = (distance_matrix[route[pos], 0] +\n                                distance_matrix[0, route[pos+1]] -\n                                distance_matrix[route[pos], route[pos+1]])\n                        if sum(demand[route1]) <= capacity and sum(demand[route2]) <= capacity:\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_split = (route1, route2)\n                    if best_split is not None:\n                        new_solution[route_idx] = best_split[0]\n                        new_solution.insert(route_idx+1, best_split[1])\n\n    return new_solution\n\n",
        "score": [
            -0.6411195680042878,
            1.7234926223754883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Simple crowding distance approximation (for demonstration)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    for _ in range(3):  # Number of iterations\n        # Step 1: Route segment inversion with demand check\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Enough nodes to invert\n                i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                inverted_segment = route[i:j+1][::-1]\n                if sum(demand[inverted_segment]) <= capacity:\n                    new_route = np.concatenate([route[:i], inverted_segment, route[j+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Step 2: Customer reinsertion with demand-aware optimization\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Can remove a customer\n            pos = np.random.randint(1, len(route)-1)\n            customer = route[pos]\n            current_load = sum(demand[route])\n            # Remove customer\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best reinsertion position in same route\n            best_pos = 1\n            best_cost = np.inf\n            for pos in range(1, len(new_route)):\n                # Check demand constraint\n                if sum(demand[np.concatenate([new_route[:pos], [customer], new_route[pos:]])]) <= capacity:\n                    # Evaluate distance impact\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                            distance_matrix[customer, new_route[pos]] -\n                            distance_matrix[new_route[pos-1], new_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            # Reinsert\n            new_solution[route_idx] = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n\n        # Step 3: Route merging/splitting to balance makespan\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            # Try merging two routes\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            if sum(demand[route1]) + sum(demand[route2]) <= capacity:\n                # Find best merge point (minimize distance increase)\n                best_cost = np.inf\n                best_merge = None\n                for i in range(1, len(route1)):\n                    for j in range(1, len(route2)):\n                        # Merge route2 after i in route1\n                        merged_route = np.concatenate([route1[:i], route2[1:], route1[i:]])\n                        cost = (distance_matrix[route1[i-1], route2[1]] +\n                                distance_matrix[route2[-2], route1[i]] -\n                                distance_matrix[route1[i-1], route1[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = merged_route\n                if best_merge is not None:\n                    new_solution[route1_idx] = best_merge\n                    del new_solution[route2_idx]\n\n            # Try splitting a route (only if it's too long)\n            elif len(new_solution) < len(demand) and np.random.rand() < 0.2:\n                route_idx = np.random.randint(0, len(new_solution))\n                route = new_solution[route_idx]\n                if len(route) > 5:  # Arbitrary threshold for \"too long\"\n                    # Find best split point\n                    best_cost = np.inf\n                    best_split = None\n                    for pos in range(2, len(route)-2):\n                        # Split after pos\n                        route1 = np.concatenate([route[:pos+1], [0]])\n                        route2 = np.concatenate([[0], route[pos+1:]])\n                        cost = (distance_matrix[route[pos], 0] +\n                                distance_matrix[0, route[pos+1]] -\n                                distance_matrix[route[pos], route[pos+1]])\n                        if sum(demand[route1]) <= capacity and sum(demand[route2]) <= capacity:\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_split = (route1, route2)\n                    if best_split is not None:\n                        new_solution[route_idx] = best_split[0]\n                        new_solution.insert(route_idx+1, best_split[1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search operator that combines route segmentation, demand-aware customer reinsertion, and adaptive route merging to balance distance minimization and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(s[1][1] - s[1][0]) for s in archive])  # Prefer solutions with high makespan/distance ratio\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segmentation + demand-aware reinsertion\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Segment the route into two parts at a random point\n        split_pos = random.randint(1, len(route)-2)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        # Calculate demands for segments\n        demand1 = sum(demand[node] for node in segment1[1:-1])\n        demand2 = sum(demand[node] for node in segment2[1:-1])\n\n        # Try to reinsert customers from the longer segment into the shorter one if feasible\n        if demand1 < demand2 and demand2 > capacity * 0.3:  # If second segment has high demand\n            for i in range(len(segment2)-2, 0, -1):  # Iterate backwards to preserve order\n                node = segment2[i]\n                if demand[node] <= capacity - demand1:\n                    # Find best insertion position in segment1\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for j in range(1, len(segment1)):\n                        cost = distance_matrix[segment1[j-1]][node] + distance_matrix[node][segment1[j]] - distance_matrix[segment1[j-1]][segment1[j]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = j\n\n                    # Insert if it improves the route\n                    if best_cost < 0:\n                        segment1.insert(best_pos, node)\n                        segment2.pop(i)\n                        demand1 += demand[node]\n                        demand2 -= demand[node]\n\n        # Merge segments back\n        new_solution[route_idx] = np.concatenate([segment1, segment2[1:]])\n\n        # Adaptive route merging: Try to merge with another route if beneficial\n        if len(new_solution) > 1 and random.random() < 0.5:\n            other_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_idx]\n\n            # Check if merging would be feasible\n            total_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in other_route[1:-1])\n            if total_demand <= capacity:\n                # Calculate merging cost\n                cost_before = distance_matrix[route[-2]][0] + distance_matrix[other_route[0]][other_route[1]]\n                cost_after = distance_matrix[route[-2]][other_route[1]] + distance_matrix[other_route[-2]][0]\n\n                if cost_after < cost_before:\n                    # Merge routes\n                    merged_route = np.concatenate([route[:-1], other_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    new_solution.pop(other_idx)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7039972082800341,
            0.8165992200374603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(s[1][1] - s[1][0]) for s in archive])  # Prefer solutions with high makespan/distance ratio\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route segmentation + demand-aware reinsertion\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too small\n            continue\n\n        # Segment the route into two parts at a random point\n        split_pos = random.randint(1, len(route)-2)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        # Calculate demands for segments\n        demand1 = sum(demand[node] for node in segment1[1:-1])\n        demand2 = sum(demand[node] for node in segment2[1:-1])\n\n        # Try to reinsert customers from the longer segment into the shorter one if feasible\n        if demand1 < demand2 and demand2 > capacity * 0.3:  # If second segment has high demand\n            for i in range(len(segment2)-2, 0, -1):  # Iterate backwards to preserve order\n                node = segment2[i]\n                if demand[node] <= capacity - demand1:\n                    # Find best insertion position in segment1\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for j in range(1, len(segment1)):\n                        cost = distance_matrix[segment1[j-1]][node] + distance_matrix[node][segment1[j]] - distance_matrix[segment1[j-1]][segment1[j]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = j\n\n                    # Insert if it improves the route\n                    if best_cost < 0:\n                        segment1.insert(best_pos, node)\n                        segment2.pop(i)\n                        demand1 += demand[node]\n                        demand2 -= demand[node]\n\n        # Merge segments back\n        new_solution[route_idx] = np.concatenate([segment1, segment2[1:]])\n\n        # Adaptive route merging: Try to merge with another route if beneficial\n        if len(new_solution) > 1 and random.random() < 0.5:\n            other_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_idx]\n\n            # Check if merging would be feasible\n            total_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in other_route[1:-1])\n            if total_demand <= capacity:\n                # Calculate merging cost\n                cost_before = distance_matrix[route[-2]][0] + distance_matrix[other_route[0]][other_route[1]]\n                cost_after = distance_matrix[route[-2]][other_route[1]] + distance_matrix[other_route[-2]][0]\n\n                if cost_after < cost_before:\n                    # Merge routes\n                    merged_route = np.concatenate([route[:-1], other_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    new_solution.pop(other_idx)\n\n    # Ensure solution is feasible (should be, but verify)\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 1: Attempt to merge adjacent routes if they fit capacity constraints\n    for i in range(len(selected_solution)):\n        if i != longest_route_idx:\n            candidate_route = selected_solution[i]\n            merged_route = np.concatenate([longest_route[:-1], candidate_route[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                selected_solution[longest_route_idx] = np.array([0] + list(merged_route[1:-1]) + [0])\n                selected_solution.pop(i)\n                return selected_solution\n\n    # Step 2: Reallocate customers from the longest route to other routes if possible\n    for customer in longest_route[1:-1]:\n        for i in range(len(selected_solution)):\n            if i != longest_route_idx:\n                candidate_route = selected_solution[i]\n                new_route = np.concatenate([candidate_route[:-1], [customer], [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    selected_solution[i] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    selected_solution[longest_route_idx] = longest_route\n                    return selected_solution\n\n    # Step 3: Split the longest route into two parts and reinsert customers\n    if len(longest_route) > 3:\n        split_point = len(longest_route) // 2\n        first_part = longest_route[:split_point + 1]\n        second_part = np.concatenate([[0], longest_route[split_point:]])\n\n        # Try to reinsert the second part into another route\n        for i in range(len(selected_solution)):\n            if i != longest_route_idx:\n                candidate_route = selected_solution[i]\n                merged_route = np.concatenate([candidate_route[:-1], second_part[1:-1], [0]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    selected_solution[longest_route_idx] = first_part\n                    selected_solution[i] = merged_route\n                    return selected_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.7361532614187544,
            3.4597844183444977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 1: Attempt to merge adjacent routes if they fit capacity constraints\n    for i in range(len(selected_solution)):\n        if i != longest_route_idx:\n            candidate_route = selected_solution[i]\n            merged_route = np.concatenate([longest_route[:-1], candidate_route[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                selected_solution[longest_route_idx] = np.array([0] + list(merged_route[1:-1]) + [0])\n                selected_solution.pop(i)\n                return selected_solution\n\n    # Step 2: Reallocate customers from the longest route to other routes if possible\n    for customer in longest_route[1:-1]:\n        for i in range(len(selected_solution)):\n            if i != longest_route_idx:\n                candidate_route = selected_solution[i]\n                new_route = np.concatenate([candidate_route[:-1], [customer], [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    selected_solution[i] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    selected_solution[longest_route_idx] = longest_route\n                    return selected_solution\n\n    # Step 3: Split the longest route into two parts and reinsert customers\n    if len(longest_route) > 3:\n        split_point = len(longest_route) // 2\n        first_part = longest_route[:split_point + 1]\n        second_part = np.concatenate([[0], longest_route[split_point:]])\n\n        # Try to reinsert the second part into another route\n        for i in range(len(selected_solution)):\n            if i != longest_route_idx:\n                candidate_route = selected_solution[i]\n                merged_route = np.concatenate([candidate_route[:-1], second_part[1:-1], [0]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    selected_solution[longest_route_idx] = first_part\n                    selected_solution[i] = merged_route\n                    return selected_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by combining a biased random selection based on objective values with a novel local search operator that intelligently rebalances routes by merging and splitting segments while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = []\n    for sol, (total_dist, makespan) in archive:\n        # Normalize and combine objectives to score potential\n        normalized_dist = total_dist / (max(obj[0] for obj in [s[1] for s in archive]) + 1e-6)\n        normalized_makespan = makespan / (max(obj[1] for obj in [s[1] for s in archive]) + 1e-6)\n        score = 0.6 * normalized_makespan + 0.4 * normalized_dist  # Bias toward makespan\n        weighted_scores.append(score)\n\n    # Select top 3 solutions and pick one randomly\n    top_indices = np.argsort(weighted_scores)[-3:]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Route segment rebalancing with capacity-aware merging/splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a split point (not at depot)\n        split_idx = random.randint(1, len(route) - 2)\n\n        # Create two segments: first_part (0 -> split), second_part (split -> 0)\n        first_part = route[:split_idx + 1]\n        second_part = route[split_idx:]\n\n        # Calculate demands for segments\n        demand_first = np.sum(demand[first_part[1:-1]])\n        demand_second = np.sum(demand[second_part[1:-1]])\n\n        # Attempt to merge with another route if possible\n        if demand_first <= capacity and demand_second <= capacity:\n            # Find another route to merge with\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_demand = np.sum(demand[other_route[1:-1]])\n\n                # Try merging first_part with other_route\n                if other_demand + demand_first <= capacity:\n                    # Insert first_part into other_route\n                    # Find best insertion point in other_route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate distance increase\n                        dist_before = distance_matrix[other_route[pos-1], other_route[pos]]\n                        dist_after = distance_matrix[other_route[pos-1], first_part[1]] + \\\n                                   distance_matrix[first_part[-2], other_route[pos]]\n                        increase = dist_after - dist_before\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the merge\n                    merged_route = np.concatenate([\n                        other_route[:best_pos],\n                        first_part[1:-1],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[j] = merged_route\n                    new_solution[i] = second_part\n                    break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7660167668371768,
            2.6162367463111877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weighted_scores = []\n    for sol, (total_dist, makespan) in archive:\n        # Normalize and combine objectives to score potential\n        normalized_dist = total_dist / (max(obj[0] for obj in [s[1] for s in archive]) + 1e-6)\n        normalized_makespan = makespan / (max(obj[1] for obj in [s[1] for s in archive]) + 1e-6)\n        score = 0.6 * normalized_makespan + 0.4 * normalized_dist  # Bias toward makespan\n        weighted_scores.append(score)\n\n    # Select top 3 solutions and pick one randomly\n    top_indices = np.argsort(weighted_scores)[-3:]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply novel local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: Route segment rebalancing with capacity-aware merging/splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a split point (not at depot)\n        split_idx = random.randint(1, len(route) - 2)\n\n        # Create two segments: first_part (0 -> split), second_part (split -> 0)\n        first_part = route[:split_idx + 1]\n        second_part = route[split_idx:]\n\n        # Calculate demands for segments\n        demand_first = np.sum(demand[first_part[1:-1]])\n        demand_second = np.sum(demand[second_part[1:-1]])\n\n        # Attempt to merge with another route if possible\n        if demand_first <= capacity and demand_second <= capacity:\n            # Find another route to merge with\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_demand = np.sum(demand[other_route[1:-1]])\n\n                # Try merging first_part with other_route\n                if other_demand + demand_first <= capacity:\n                    # Insert first_part into other_route\n                    # Find best insertion point in other_route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate distance increase\n                        dist_before = distance_matrix[other_route[pos-1], other_route[pos]]\n                        dist_after = distance_matrix[other_route[pos-1], first_part[1]] + \\\n                                   distance_matrix[first_part[-2], other_route[pos]]\n                        increase = dist_after - dist_before\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the merge\n                    merged_route = np.concatenate([\n                        other_route[:best_pos],\n                        first_part[1:-1],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[j] = merged_route\n                    new_solution[i] = second_part\n                    break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging and customer reinsertion with feasibility checks to generate a neighbor solution while maintaining vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the merged routes and add the new merged route\n        new_solution = [r for i, r in enumerate(new_solution) if i not in route_indices]\n        new_solution.append(merged_route)\n\n        # Check capacity feasibility of the merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand > capacity:\n            # If infeasible, split the merged route back into two\n            split_point = len(route1) - 1  # Split at the end of the first route\n            new_solution = [route1, route2]\n        else:\n            # If feasible, perform reinsertion to optimize the merged route\n            for i in range(1, len(merged_route) - 1):\n                customer = merged_route[i]\n                # Remove customer from the route\n                temp_route = np.concatenate([merged_route[:i], merged_route[i+1:]])\n                # Try inserting the customer in a different position\n                for j in range(1, len(temp_route)):\n                    # Check capacity constraint before insertion\n                    if np.sum(demand[np.concatenate([temp_route[:j], [customer], temp_route[j:]])[1:-1]]) <= capacity:\n                        # Insert customer at position j\n                        merged_route = np.concatenate([temp_route[:j], [customer], temp_route[j:]])\n                        break\n            # Update the merged route in the solution\n            new_solution[-1] = merged_route\n\n    # Ensure the solution remains feasible by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If any route exceeds capacity, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8103414138036463,
            0.17304310202598572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the merged routes and add the new merged route\n        new_solution = [r for i, r in enumerate(new_solution) if i not in route_indices]\n        new_solution.append(merged_route)\n\n        # Check capacity feasibility of the merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand > capacity:\n            # If infeasible, split the merged route back into two\n            split_point = len(route1) - 1  # Split at the end of the first route\n            new_solution = [route1, route2]\n        else:\n            # If feasible, perform reinsertion to optimize the merged route\n            for i in range(1, len(merged_route) - 1):\n                customer = merged_route[i]\n                # Remove customer from the route\n                temp_route = np.concatenate([merged_route[:i], merged_route[i+1:]])\n                # Try inserting the customer in a different position\n                for j in range(1, len(temp_route)):\n                    # Check capacity constraint before insertion\n                    if np.sum(demand[np.concatenate([temp_route[:j], [customer], temp_route[j:]])[1:-1]]) <= capacity:\n                        # Insert customer at position j\n                        merged_route = np.concatenate([temp_route[:j], [customer], temp_route[j:]])\n                        break\n            # Update the merged route in the solution\n            new_solution[-1] = merged_route\n\n    # Ensure the solution remains feasible by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If any route exceeds capacity, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging and customer reinsertion with feasibility checks to generate a neighbor solution while maintaining vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the merged routes and add the new merged route\n        new_solution = [r for i, r in enumerate(new_solution) if i not in route_indices]\n        new_solution.append(merged_route)\n\n        # Check capacity feasibility of the merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand > capacity:\n            # If infeasible, split the merged route back into two\n            split_point = len(route1) - 1  # Split at the end of the first route\n            new_solution = [route1, route2]\n        else:\n            # If feasible, perform reinsertion to optimize the merged route\n            for i in range(1, len(merged_route) - 1):\n                customer = merged_route[i]\n                # Remove customer from the route\n                temp_route = np.concatenate([merged_route[:i], merged_route[i+1:]])\n                # Try inserting the customer in a different position\n                for j in range(1, len(temp_route)):\n                    # Check capacity constraint before insertion\n                    if np.sum(demand[np.concatenate([temp_route[:j], [customer], temp_route[j:]])[1:-1]]) <= capacity:\n                        # Insert customer at position j\n                        merged_route = np.concatenate([temp_route[:j], [customer], temp_route[j:]])\n                        break\n            # Update the merged route in the solution\n            new_solution[-1] = merged_route\n\n    # Ensure the solution remains feasible by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If any route exceeds capacity, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8103414138036463,
            0.17304310202598572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the merged routes and add the new merged route\n        new_solution = [r for i, r in enumerate(new_solution) if i not in route_indices]\n        new_solution.append(merged_route)\n\n        # Check capacity feasibility of the merged route\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand > capacity:\n            # If infeasible, split the merged route back into two\n            split_point = len(route1) - 1  # Split at the end of the first route\n            new_solution = [route1, route2]\n        else:\n            # If feasible, perform reinsertion to optimize the merged route\n            for i in range(1, len(merged_route) - 1):\n                customer = merged_route[i]\n                # Remove customer from the route\n                temp_route = np.concatenate([merged_route[:i], merged_route[i+1:]])\n                # Try inserting the customer in a different position\n                for j in range(1, len(temp_route)):\n                    # Check capacity constraint before insertion\n                    if np.sum(demand[np.concatenate([temp_route[:j], [customer], temp_route[j:]])[1:-1]]) <= capacity:\n                        # Insert customer at position j\n                        merged_route = np.concatenate([temp_route[:j], [customer], temp_route[j:]])\n                        break\n            # Update the merged route in the solution\n            new_solution[-1] = merged_route\n\n    # Ensure the solution remains feasible by checking all routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If any route exceeds capacity, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm selects a solution from the archive with the highest sum of normalized objective values, applies a hybrid local search combining route merging, partial route reversal, and demand-balanced reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: merge routes, reverse partial routes, and reinsert nodes\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reverse\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        reversed_segment = route[start:end][::-1]\n        new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n        # Randomly reinsert a node from another route\n        if len(base_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx and len(base_solution[i]) > 3])\n            other_route = base_solution[other_route_idx].copy()\n            node_pos = random.randint(1, len(other_route)-2)\n            node = other_route[node_pos]\n\n            # Find best insertion position in current route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, node)\n                cost = distance_matrix[temp_route[pos-1]][temp_route[pos]] + distance_matrix[temp_route[pos]][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if np.sum(demand[temp_route[1:-1]]) <= capacity and cost < best_cost:\n                    best_pos = pos\n                    best_cost = cost\n\n            if best_cost < float('inf'):\n                route = np.insert(route, best_pos, node)\n\n        new_solution.append(route)\n\n    # Try merging two routes if they fit capacity\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j and np.sum(demand[new_solution[i][1:-1]]) + np.sum(demand[new_solution[j][1:-1]]) <= capacity:\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7958625174312841,
            11.054713070392609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: merge routes, reverse partial routes, and reinsert nodes\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reverse\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        reversed_segment = route[start:end][::-1]\n        new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            route = new_route\n\n        # Randomly reinsert a node from another route\n        if len(base_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(base_solution)) if i != selected_idx and len(base_solution[i]) > 3])\n            other_route = base_solution[other_route_idx].copy()\n            node_pos = random.randint(1, len(other_route)-2)\n            node = other_route[node_pos]\n\n            # Find best insertion position in current route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, node)\n                cost = distance_matrix[temp_route[pos-1]][temp_route[pos]] + distance_matrix[temp_route[pos]][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if np.sum(demand[temp_route[1:-1]]) <= capacity and cost < best_cost:\n                    best_pos = pos\n                    best_cost = cost\n\n            if best_cost < float('inf'):\n                route = np.insert(route, best_pos, node)\n\n        new_solution.append(route)\n\n    # Try merging two routes if they fit capacity\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j and np.sum(demand[new_solution[i][1:-1]]) + np.sum(demand[new_solution[j][1:-1]]) <= capacity:\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with lower makespan or total distance, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware placement, and a probabilistic two-opt variant to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    for i in range(len(archive)):\n        if archive[i][1][0] < archive[selected_idx][1][0] or archive[i][1][1] < archive[selected_idx][1][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route merging + demand-aware reinsertion + probabilistic two-opt\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Route merging: combine two routes if demand allows\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them at the closest points\n            min_dist = float('inf')\n            best_merge = None\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    dist = distance_matrix[route1[i]][route2[j]]\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_merge = (i, j)\n            if best_merge:\n                i, j = best_merge\n                merged_route = np.concatenate([route1[:i+1], route2[j:-1], route1[i+1:]])\n                new_solution = [r for idx, r in enumerate(new_solution) if idx not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware reinsertion: move customers between routes if feasible\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n            # Try to insert into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in other route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Perform insertion\n                    new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    break\n\n    # Probabilistic two-opt variant: with demand-awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes to apply two-opt\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n            # Check if reversing segment i+1 to j improves distance and maintains capacity\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            if np.sum(demand[segment[1:-1]]) <= capacity:  # Ensure reversed segment doesn't exceed capacity\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                # Calculate distance change\n                old_dist = (distance_matrix[route[i-1]][route[i]] +\n                            distance_matrix[route[j]][route[j+1]])\n                new_dist = (distance_matrix[route[i-1]][reversed_segment[0]] +\n                            distance_matrix[reversed_segment[-1]][route[j+1]])\n                if new_dist < old_dist and random.random() < 0.5:  # Accept with probability if better\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.3803079977379565,
            1.165148138999939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    for i in range(len(archive)):\n        if archive[i][1][0] < archive[selected_idx][1][0] or archive[i][1][1] < archive[selected_idx][1][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route merging + demand-aware reinsertion + probabilistic two-opt\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Route merging: combine two routes if demand allows\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them at the closest points\n            min_dist = float('inf')\n            best_merge = None\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    dist = distance_matrix[route1[i]][route2[j]]\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_merge = (i, j)\n            if best_merge:\n                i, j = best_merge\n                merged_route = np.concatenate([route1[:i+1], route2[j:-1], route1[i+1:]])\n                new_solution = [r for idx, r in enumerate(new_solution) if idx not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware reinsertion: move customers between routes if feasible\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has customers to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n            # Try to insert into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion point in other route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Perform insertion\n                    new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    break\n\n    # Probabilistic two-opt variant: with demand-awareness\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes to apply two-opt\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n            # Check if reversing segment i+1 to j improves distance and maintains capacity\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            if np.sum(demand[segment[1:-1]]) <= capacity:  # Ensure reversed segment doesn't exceed capacity\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                # Calculate distance change\n                old_dist = (distance_matrix[route[i-1]][route[i]] +\n                            distance_matrix[route[j]][route[j+1]])\n                new_dist = (distance_matrix[route[i-1]][reversed_segment[0]] +\n                            distance_matrix[reversed_segment[-1]][route[j+1]])\n                if new_dist < old_dist and random.random() < 0.5:  # Accept with probability if better\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator combining route splitting, merging, and cross-exchange moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.7, 0.3])\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: route splitting, merging, and cross-exchange\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Route splitting: split into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n        part2[0] = 0  # Ensure starts with depot\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Route merging: merge feasible routes\n    merged = []\n    i = 0\n    while i < len(new_solution):\n        if i + 1 < len(new_solution):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Check capacity\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                merged.append(merged_route.copy())\n                i += 2\n                continue\n\n        merged.append(new_solution[i].copy())\n        i += 1\n\n    # Cross-exchange: swap segments between routes\n    if len(merged) >= 2:\n        i, j = np.random.choice(len(merged), 2, replace=False)\n        route1 = merged[i]\n        route2 = merged[j]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments from each route (excluding depot)\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg1_end = np.random.randint(seg1_start + 1, len(route1))\n            seg2_start = np.random.randint(1, len(route2) - 1)\n            seg2_end = np.random.randint(seg2_start + 1, len(route2))\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Create new routes\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Check capacity\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                merged[i] = new_route1.copy()\n                merged[j] = new_route2.copy()\n\n    return np.array(merged, dtype=object)\n\n",
        "score": [
            -0.786788615335152,
            1.2360447645187378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.7, 0.3])\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: route splitting, merging, and cross-exchange\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Route splitting: split into two parts\n        split_pos = len(route) // 2\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n        part2[0] = 0  # Ensure starts with depot\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Route merging: merge feasible routes\n    merged = []\n    i = 0\n    while i < len(new_solution):\n        if i + 1 < len(new_solution):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Check capacity\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                merged.append(merged_route.copy())\n                i += 2\n                continue\n\n        merged.append(new_solution[i].copy())\n        i += 1\n\n    # Cross-exchange: swap segments between routes\n    if len(merged) >= 2:\n        i, j = np.random.choice(len(merged), 2, replace=False)\n        route1 = merged[i]\n        route2 = merged[j]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random segments from each route (excluding depot)\n            seg1_start = np.random.randint(1, len(route1) - 1)\n            seg1_end = np.random.randint(seg1_start + 1, len(route1))\n            seg2_start = np.random.randint(1, len(route2) - 1)\n            seg2_end = np.random.randint(seg2_start + 1, len(route2))\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Create new routes\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Check capacity\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                merged[i] = new_route1.copy()\n                merged[j] = new_route2.copy()\n\n    return np.array(merged, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel \"cluster-and-rebalance\" local search approach that intelligently selects a solution from the archive, clusters customers into high-demand regions, and rebalances routes by redistributing customers between vehicles to reduce total distance and makespan while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()  # Prioritize solutions with balanced objectives\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Cluster customers into high-demand regions\n    demand_threshold = np.percentile(demand[1:], 75)  # Consider top 25% high-demand customers\n    high_demand_nodes = np.where(demand[1:] >= demand_threshold)[0] + 1  # +1 to account for depot\n\n    # Identify routes that serve high-demand customers\n    high_demand_routes = []\n    for i, route in enumerate(new_solution):\n        if any(node in route for node in high_demand_nodes):\n            high_demand_routes.append(i)\n\n    # Rebalance routes by redistributing high-demand customers\n    for route_idx in high_demand_routes:\n        route = new_solution[route_idx]\n        # Find customers in this route that can be moved to other routes\n        for node in route[1:-1]:  # Skip depot\n            if node in high_demand_nodes:\n                # Try to move this node to another route\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n                    # Check capacity constraint\n                    if sum(demand[other_route]) + demand[node] <= capacity:\n                        # Find best insertion position in other route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            # Calculate insertion cost\n                            prev_node = other_route[pos-1]\n                            next_node = other_route[pos]\n                            cost = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        # Insert node into other route\n                        new_route = np.insert(other_route, best_pos, node)\n                        # Remove from original route\n                        new_solution[route_idx] = np.delete(route, np.where(route == node))\n                        new_solution[other_route_idx] = new_route\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7718712425815956,
            9.779393285512924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()  # Prioritize solutions with balanced objectives\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Cluster customers into high-demand regions\n    demand_threshold = np.percentile(demand[1:], 75)  # Consider top 25% high-demand customers\n    high_demand_nodes = np.where(demand[1:] >= demand_threshold)[0] + 1  # +1 to account for depot\n\n    # Identify routes that serve high-demand customers\n    high_demand_routes = []\n    for i, route in enumerate(new_solution):\n        if any(node in route for node in high_demand_nodes):\n            high_demand_routes.append(i)\n\n    # Rebalance routes by redistributing high-demand customers\n    for route_idx in high_demand_routes:\n        route = new_solution[route_idx]\n        # Find customers in this route that can be moved to other routes\n        for node in route[1:-1]:  # Skip depot\n            if node in high_demand_nodes:\n                # Try to move this node to another route\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n                    # Check capacity constraint\n                    if sum(demand[other_route]) + demand[node] <= capacity:\n                        # Find best insertion position in other route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(other_route)):\n                            # Calculate insertion cost\n                            prev_node = other_route[pos-1]\n                            next_node = other_route[pos]\n                            cost = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        # Insert node into other route\n                        new_route = np.insert(other_route, best_pos, node)\n                        # Remove from original route\n                        new_solution[route_idx] = np.delete(route, np.where(route == node))\n                        new_solution[other_route_idx] = new_route\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel local search operator combines route merging, segment swapping, and capacity-aware insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by distance\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose one of the three operators\n    operator = random.choice(['merge', 'swap', 'insert'])\n\n    if operator == 'merge':\n        # Merge two routes if they can be combined without exceeding capacity\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them at the depot\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    elif operator == 'swap':\n        # Swap segments between two routes if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find feasible segments to swap\n            for _ in range(10):  # Try up to 10 times\n                # Randomly select segments from both routes\n                seg1_start = random.randint(1, len(route1)-2)\n                seg1_end = random.randint(seg1_start, len(route1)-2)\n                seg2_start = random.randint(1, len(route2)-2)\n                seg2_end = random.randint(seg2_start, len(route2)-2)\n\n                # Check capacity constraints\n                demand1 = sum(demand[route1[seg1_start:seg1_end+1]])\n                demand2 = sum(demand[route2[seg2_start:seg2_end+1]])\n                new_demand1 = sum(demand[route1[1:-1]]) - demand1 + demand2\n                new_demand2 = sum(demand[route2[1:-1]]) - demand2 + demand1\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform the swap\n                    new_route1 = np.concatenate((route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]))\n                    new_route2 = np.concatenate((route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]))\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n\n    elif operator == 'insert':\n        # Insert a customer from one route to another if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Select a customer from route1 (not depot)\n            if len(route1) > 2:\n                customer_idx = random.randint(1, len(route1)-2)\n                customer = route1[customer_idx]\n                customer_demand = demand[customer]\n\n                # Try to insert into route2\n                for pos in range(1, len(route2)):\n                    # Check capacity constraint\n                    if sum(demand[route2[1:pos]]) + customer_demand <= capacity:\n                        new_route2 = np.insert(route2, pos, customer)\n                        new_route1 = np.delete(route1, customer_idx)\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5361230116164095,
            0.7759113907814026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by distance\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose one of the three operators\n    operator = random.choice(['merge', 'swap', 'insert'])\n\n    if operator == 'merge':\n        # Merge two routes if they can be combined without exceeding capacity\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them at the depot\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    elif operator == 'swap':\n        # Swap segments between two routes if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find feasible segments to swap\n            for _ in range(10):  # Try up to 10 times\n                # Randomly select segments from both routes\n                seg1_start = random.randint(1, len(route1)-2)\n                seg1_end = random.randint(seg1_start, len(route1)-2)\n                seg2_start = random.randint(1, len(route2)-2)\n                seg2_end = random.randint(seg2_start, len(route2)-2)\n\n                # Check capacity constraints\n                demand1 = sum(demand[route1[seg1_start:seg1_end+1]])\n                demand2 = sum(demand[route2[seg2_start:seg2_end+1]])\n                new_demand1 = sum(demand[route1[1:-1]]) - demand1 + demand2\n                new_demand2 = sum(demand[route2[1:-1]]) - demand2 + demand1\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform the swap\n                    new_route1 = np.concatenate((route1[:seg1_start], route2[seg2_start:seg2_end+1], route1[seg1_end+1:]))\n                    new_route2 = np.concatenate((route2[:seg2_start], route1[seg1_start:seg1_end+1], route2[seg2_end+1:]))\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n\n    elif operator == 'insert':\n        # Insert a customer from one route to another if feasible\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Select a customer from route1 (not depot)\n            if len(route1) > 2:\n                customer_idx = random.randint(1, len(route1)-2)\n                customer = route1[customer_idx]\n                customer_demand = demand[customer]\n\n                # Try to insert into route2\n                for pos in range(1, len(route2)):\n                    # Check capacity constraint\n                    if sum(demand[route2[1:pos]]) + customer_demand <= capacity:\n                        new_route2 = np.insert(route2, pos, customer)\n                        new_route1 = np.delete(route1, customer_idx)\n                        new_solution[i] = new_route1\n                        new_solution[j] = new_route2\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The algorithm randomly selects a solution from the archive, then applies a hybrid local search combining route segment swapping and demand-balanced route merging to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)\n    base_solution = selected_solution[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine segment swap and demand-balanced merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try segment swap\n        if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n            # Select a segment from route i\n            start_i = random.randint(1, len(new_solution[i]) - 2)\n            end_i = random.randint(start_i, len(new_solution[i]) - 2)\n            segment_i = new_solution[i][start_i:end_i + 1]\n\n            # Check if swapping with route j is feasible\n            total_demand_i = np.sum(demand[new_solution[i]])\n            segment_demand = np.sum(demand[segment_i])\n            if total_demand_i - segment_demand + segment_demand <= capacity:\n                # Insert segment into route j\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_route_j = np.concatenate([new_solution[j][:insert_pos], segment_i, new_solution[j][insert_pos:]])\n\n                # Remove segment from route i\n                new_route_i = np.concatenate([new_solution[i][:start_i], new_solution[i][end_i + 1:]])\n\n                # Update routes if feasible\n                if np.sum(demand[new_route_i]) <= capacity and np.sum(demand[new_route_j]) <= capacity:\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n        # Try demand-balanced merging\n        if len(new_solution) > 1:\n            # Find the two most imbalanced routes (largest and smallest)\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            max_route_idx = np.argmax(route_lengths)\n            min_route_idx = np.argmin(route_lengths)\n\n            if max_route_idx != min_route_idx:\n                max_route = new_solution[max_route_idx]\n                min_route = new_solution[min_route_idx]\n\n                # Try to merge min_route into max_route\n                if np.sum(demand[max_route]) + np.sum(demand[min_route]) <= capacity:\n                    # Insert min_route into max_route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(max_route)):\n                        # Insert min_route (without depots) into max_route at position pos\n                        candidate = np.concatenate([max_route[:pos], min_route[1:-1], max_route[pos:]])\n                        cost = np.sum(distance_matrix[candidate[:-1], candidate[1:]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform the merge\n                    merged_route = np.concatenate([max_route[:best_pos], min_route[1:-1], max_route[best_pos:]])\n                    new_solution[max_route_idx] = merged_route\n                    new_solution.pop(min_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.6172035975423925,
            1.074228972196579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)\n    base_solution = selected_solution[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine segment swap and demand-balanced merging\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n\n        # Try segment swap\n        if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n            # Select a segment from route i\n            start_i = random.randint(1, len(new_solution[i]) - 2)\n            end_i = random.randint(start_i, len(new_solution[i]) - 2)\n            segment_i = new_solution[i][start_i:end_i + 1]\n\n            # Check if swapping with route j is feasible\n            total_demand_i = np.sum(demand[new_solution[i]])\n            segment_demand = np.sum(demand[segment_i])\n            if total_demand_i - segment_demand + segment_demand <= capacity:\n                # Insert segment into route j\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_route_j = np.concatenate([new_solution[j][:insert_pos], segment_i, new_solution[j][insert_pos:]])\n\n                # Remove segment from route i\n                new_route_i = np.concatenate([new_solution[i][:start_i], new_solution[i][end_i + 1:]])\n\n                # Update routes if feasible\n                if np.sum(demand[new_route_i]) <= capacity and np.sum(demand[new_route_j]) <= capacity:\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n        # Try demand-balanced merging\n        if len(new_solution) > 1:\n            # Find the two most imbalanced routes (largest and smallest)\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            max_route_idx = np.argmax(route_lengths)\n            min_route_idx = np.argmin(route_lengths)\n\n            if max_route_idx != min_route_idx:\n                max_route = new_solution[max_route_idx]\n                min_route = new_solution[min_route_idx]\n\n                # Try to merge min_route into max_route\n                if np.sum(demand[max_route]) + np.sum(demand[min_route]) <= capacity:\n                    # Insert min_route into max_route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(max_route)):\n                        # Insert min_route (without depots) into max_route at position pos\n                        candidate = np.concatenate([max_route[:pos], min_route[1:-1], max_route[pos:]])\n                        cost = np.sum(distance_matrix[candidate[:-1], candidate[1:]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform the merge\n                    merged_route = np.concatenate([max_route[:best_pos], min_route[1:-1], max_route[best_pos:]])\n                    new_solution[max_route_idx] = merged_route\n                    new_solution.pop(min_route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route at a random point and try to reallocate customers\n        split_point = np.random.randint(1, len(route) - 1)\n        part1, part2 = route[:split_point + 1], route[split_point:]\n\n        # Check capacity constraints for both parts\n        def is_valid(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(part1) and is_valid(part2):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                for j in range(len(new_solution)):\n                    if j != len(new_solution) - 1:  # Don't add to the same route\n                        temp_route = new_solution[j].copy()\n                        temp_route.insert(-1, customer)\n                        if sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[j] = temp_route\n                            break\n\n    # Apply a random customer swap between routes to improve distance\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers (excluding depots)\n            cust1 = np.random.randint(1, len(route1) - 1)\n            cust2 = np.random.randint(1, len(route2) - 1)\n\n            # Swap customers and check capacity\n            new_route1 = route1.copy()\n            new_route1[cust1] = route2[cust2]\n            new_route2 = route2.copy()\n            new_route2[cust2] = route1[cust1]\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7694973985493349,
            0.6220619380474091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route at a random point and try to reallocate customers\n        split_point = np.random.randint(1, len(route) - 1)\n        part1, part2 = route[:split_point + 1], route[split_point:]\n\n        # Check capacity constraints for both parts\n        def is_valid(r):\n            return sum(demand[r[1:-1]]) <= capacity\n\n        if is_valid(part1) and is_valid(part2):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                for j in range(len(new_solution)):\n                    if j != len(new_solution) - 1:  # Don't add to the same route\n                        temp_route = new_solution[j].copy()\n                        temp_route.insert(-1, customer)\n                        if sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[j] = temp_route\n                            break\n\n    # Apply a random customer swap between routes to improve distance\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers (excluding depots)\n            cust1 = np.random.randint(1, len(route1) - 1)\n            cust2 = np.random.randint(1, len(route2) - 1)\n\n            # Swap customers and check capacity\n            new_route1 = route1.copy()\n            new_route1[cust1] = route2[cust2]\n            new_route2 = route2.copy()\n            new_route2[cust2] = route1[cust1]\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The algorithm selects a diverse solution from the archive, applies a hybrid local search combining route-splitting, inter-route insertion, and capacity-aware 3-opt moves to balance distance and makespan, while ensuring feasibility through demand checks and dynamic route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution that is not the best in any objective to explore diverse regions\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        base_solution = random.choice(sorted_archive[1:])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Hybrid operator: Route-splitting + inter-route insertion + capacity-aware 3-opt\n    for _ in range(3):  # Repeat the hybrid operator a few times\n        # Route-splitting: Split a long route into two shorter ones\n        if len(new_solution) > 1:\n            # Select the longest route\n            longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n            longest_route = new_solution[longest_route_idx]\n\n            # Find the best split point (minimizing distance increase)\n            min_dist_increase = float('inf')\n            best_split_idx = -1\n            for i in range(1, len(longest_route)-1):\n                dist_increase = distance_matrix[longest_route[i], 0] + distance_matrix[0, longest_route[i+1]] - distance_matrix[longest_route[i-1], longest_route[i]]\n                if dist_increase < min_dist_increase and sum(demand[longest_route[:i+1]]) <= capacity and sum(demand[longest_route[i:]]) <= capacity:\n                    min_dist_increase = dist_increase\n                    best_split_idx = i\n\n            if best_split_idx != -1:\n                # Create two new routes\n                new_route1 = np.concatenate((longest_route[:best_split_idx+1], [0]))\n                new_route2 = np.concatenate(([0], longest_route[best_split_idx+1:]))\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Inter-route insertion: Move a customer from one route to another\n        if len(new_solution) > 1:\n            # Select two random routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select a random customer from route1 (not depot)\n            if len(route1) > 2:\n                customer_idx = random.choice(range(1, len(route1)-1))\n                customer = route1[customer_idx]\n\n                # Check if adding this customer to route2 is feasible\n                if sum(demand[route2]) + demand[customer] <= capacity:\n                    # Remove customer from route1\n                    new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n                    # Find the best insertion position in route2\n                    best_pos = 1\n                    min_dist_increase = float('inf')\n                    for i in range(1, len(route2)):\n                        dist_increase = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                        if dist_increase < min_dist_increase:\n                            min_dist_increase = dist_increase\n                            best_pos = i\n\n                    # Insert customer into route2\n                    new_route2 = np.concatenate((route2[:best_pos], [customer], route2[best_pos:]))\n\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Capacity-aware 3-opt: Apply 3-opt on a single route while respecting capacity\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Need at least 4 nodes to apply 3-opt\n                # Select three random edges to reverse\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n\n                # Create the new route by reversing the segment between i and k\n                new_route = np.concatenate((route[:i], route[j:k+1][::-1], route[k+1:]))\n\n                # Check capacity constraint\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate(([0], new_solution[i], [0]))\n\n    return new_solution\n\n",
        "score": [
            -0.8411807918384395,
            2.8154249489307404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution that is not the best in any objective to explore diverse regions\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        base_solution = random.choice(sorted_archive[1:])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid local search\n    # Hybrid operator: Route-splitting + inter-route insertion + capacity-aware 3-opt\n    for _ in range(3):  # Repeat the hybrid operator a few times\n        # Route-splitting: Split a long route into two shorter ones\n        if len(new_solution) > 1:\n            # Select the longest route\n            longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n            longest_route = new_solution[longest_route_idx]\n\n            # Find the best split point (minimizing distance increase)\n            min_dist_increase = float('inf')\n            best_split_idx = -1\n            for i in range(1, len(longest_route)-1):\n                dist_increase = distance_matrix[longest_route[i], 0] + distance_matrix[0, longest_route[i+1]] - distance_matrix[longest_route[i-1], longest_route[i]]\n                if dist_increase < min_dist_increase and sum(demand[longest_route[:i+1]]) <= capacity and sum(demand[longest_route[i:]]) <= capacity:\n                    min_dist_increase = dist_increase\n                    best_split_idx = i\n\n            if best_split_idx != -1:\n                # Create two new routes\n                new_route1 = np.concatenate((longest_route[:best_split_idx+1], [0]))\n                new_route2 = np.concatenate(([0], longest_route[best_split_idx+1:]))\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Inter-route insertion: Move a customer from one route to another\n        if len(new_solution) > 1:\n            # Select two random routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select a random customer from route1 (not depot)\n            if len(route1) > 2:\n                customer_idx = random.choice(range(1, len(route1)-1))\n                customer = route1[customer_idx]\n\n                # Check if adding this customer to route2 is feasible\n                if sum(demand[route2]) + demand[customer] <= capacity:\n                    # Remove customer from route1\n                    new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n                    # Find the best insertion position in route2\n                    best_pos = 1\n                    min_dist_increase = float('inf')\n                    for i in range(1, len(route2)):\n                        dist_increase = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                        if dist_increase < min_dist_increase:\n                            min_dist_increase = dist_increase\n                            best_pos = i\n\n                    # Insert customer into route2\n                    new_route2 = np.concatenate((route2[:best_pos], [customer], route2[best_pos:]))\n\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Capacity-aware 3-opt: Apply 3-opt on a single route while respecting capacity\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Need at least 4 nodes to apply 3-opt\n                # Select three random edges to reverse\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n\n                # Create the new route by reversing the segment between i and k\n                new_route = np.concatenate((route[:i], route[j:k+1][::-1], route[k+1:]))\n\n                # Check capacity constraint\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate(([0], new_solution[i], [0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The new algorithm selects a solution from the archive with high makespan variance and applies a hybrid local search combining route swaps and demand-balanced insertions to reduce the makespan while improving total distance, ensuring feasibility and diversity in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swap and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Perform the insertion\n                route1 = np.delete(route1, i)\n                route2 = np.insert(route2, best_pos, customer)\n                break\n\n        # Update the solution\n        new_solution[route_indices[0]] = route1\n        new_solution[route_indices[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.8789325783314973,
            1.9331320226192474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swap and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Perform the insertion\n                route1 = np.delete(route1, i)\n                route2 = np.insert(route2, best_pos, customer)\n                break\n\n        # Update the solution\n        new_solution[route_indices[0]] = route1\n        new_solution[route_indices[1]] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The new algorithm selects a solution from the archive with high makespan variance and applies a hybrid local search combining route swaps and demand-balanced insertions to reduce the makespan while improving total distance, ensuring feasibility and diversity in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swap and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Perform the insertion\n                route1 = np.delete(route1, i)\n                route2 = np.insert(route2, best_pos, customer)\n                break\n\n        # Update the solution\n        new_solution[route_indices[0]] = route1\n        new_solution[route_indices[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.8789325783314973,
            1.9331320226192474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route swap and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find a customer in route1 to move to route2\n        for i in range(1, len(route1) - 1):\n            customer = route1[i]\n            # Check if moving this customer to route2 is feasible\n            if np.sum(demand[route2]) + demand[customer] <= capacity:\n                # Insert customer into route2 at the best position\n                best_pos = 1\n                min_increase = float('inf')\n                for j in range(1, len(route2)):\n                    # Calculate distance increase\n                    increase = (distance_matrix[route2[j-1], customer] +\n                               distance_matrix[customer, route2[j]] -\n                               distance_matrix[route2[j-1], route2[j]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = j\n                # Perform the insertion\n                route1 = np.delete(route1, i)\n                route2 = np.insert(route2, best_pos, customer)\n                break\n\n        # Update the solution\n        new_solution[route_indices[0]] = route1\n        new_solution[route_indices[1]] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Make a deep copy to avoid modifying the original solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search: Route Swap + Route Relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Swap the routes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check capacity constraints for the swapped routes\n        if (np.sum(demand[new_solution[i][1:-1]]) > capacity) or (np.sum(demand[new_solution[j][1:-1]]) > capacity):\n            # If invalid, revert the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a customer from one route and relocate to another\n        route_from = np.random.choice(len(new_solution))\n        if len(new_solution[route_from]) > 3:  # Ensure there's a customer to relocate\n            # Select a random customer (excluding depot)\n            customer_pos = np.random.randint(1, len(new_solution[route_from]) - 1)\n            customer = new_solution[route_from][customer_pos]\n\n            # Remove the customer from the original route\n            new_solution[route_from] = np.delete(new_solution[route_from], customer_pos)\n\n            # Find the best insertion position in another route\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for route_to in range(len(new_solution)):\n                if route_to == route_from:\n                    continue\n                for pos in range(1, len(new_solution[route_to])):\n                    # Insert the customer and check capacity\n                    temp_route = np.insert(new_solution[route_to], pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the insertion\n                        cost = (distance_matrix[temp_route[pos-1], customer] +\n                                distance_matrix[customer, temp_route[pos+1]] -\n                                distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = route_to\n                            best_pos = pos\n\n            # Perform the relocation if feasible\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.48246850837920097,
            8.247284352779388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n\n    # Make a deep copy to avoid modifying the original solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search: Route Swap + Route Relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Swap the routes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check capacity constraints for the swapped routes\n        if (np.sum(demand[new_solution[i][1:-1]]) > capacity) or (np.sum(demand[new_solution[j][1:-1]]) > capacity):\n            # If invalid, revert the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a customer from one route and relocate to another\n        route_from = np.random.choice(len(new_solution))\n        if len(new_solution[route_from]) > 3:  # Ensure there's a customer to relocate\n            # Select a random customer (excluding depot)\n            customer_pos = np.random.randint(1, len(new_solution[route_from]) - 1)\n            customer = new_solution[route_from][customer_pos]\n\n            # Remove the customer from the original route\n            new_solution[route_from] = np.delete(new_solution[route_from], customer_pos)\n\n            # Find the best insertion position in another route\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for route_to in range(len(new_solution)):\n                if route_to == route_from:\n                    continue\n                for pos in range(1, len(new_solution[route_to])):\n                    # Insert the customer and check capacity\n                    temp_route = np.insert(new_solution[route_to], pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate the cost of the insertion\n                        cost = (distance_matrix[temp_route[pos-1], customer] +\n                                distance_matrix[customer, temp_route[pos+1]] -\n                                distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = route_to\n                            best_pos = pos\n\n            # Perform the relocation if feasible\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with longer makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert nodes to balance makespan\n    if len(new_solution) > 1:\n        # Select two routes with the largest and smallest makespan\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        largest_route_idx = np.argmax(route_lengths)\n        smallest_route_idx = np.argmin(route_lengths)\n\n        # Merge the largest and smallest routes\n        merged_route = np.concatenate([new_solution[largest_route_idx][:-1], new_solution[smallest_route_idx][1:]])\n\n        # Check capacity constraint for the merged route\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Reinsert nodes from the merged route to balance the makespan\n            for node in merged_route[1:-1]:\n                # Find the best position to reinsert the node in any route\n                best_route_idx = -1\n                best_pos = -1\n                best_increase = float('inf')\n\n                for route_idx in range(len(new_solution)):\n                    for pos in range(1, len(new_solution[route_idx])):\n                        # Insert node at position pos in route_idx\n                        temp_route = np.insert(new_solution[route_idx], pos, node)\n                        temp_demand = sum(demand[n] for n in temp_route if n != 0)\n                        if temp_demand > capacity:\n                            continue  # Skip if capacity is exceeded\n\n                        # Calculate the new route length\n                        new_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                        increase = new_length - sum(distance_matrix[new_solution[route_idx][i], new_solution[route_idx][i+1]] for i in range(len(new_solution[route_idx])-1))\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route_idx = route_idx\n                            best_pos = pos\n\n                # Perform the best insertion\n                if best_route_idx != -1:\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n                    # Remove the node from the merged route\n                    merged_route = np.delete(merged_route, np.where(merged_route == node)[0][0])\n\n            # Replace the original routes with the new routes\n            new_solution.pop(largest_route_idx)\n            new_solution.pop(smallest_route_idx - (1 if smallest_route_idx > largest_route_idx else 0))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7346683894398738,
            2.235468775033951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with longer makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge two routes and reinsert nodes to balance makespan\n    if len(new_solution) > 1:\n        # Select two routes with the largest and smallest makespan\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        largest_route_idx = np.argmax(route_lengths)\n        smallest_route_idx = np.argmin(route_lengths)\n\n        # Merge the largest and smallest routes\n        merged_route = np.concatenate([new_solution[largest_route_idx][:-1], new_solution[smallest_route_idx][1:]])\n\n        # Check capacity constraint for the merged route\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Reinsert nodes from the merged route to balance the makespan\n            for node in merged_route[1:-1]:\n                # Find the best position to reinsert the node in any route\n                best_route_idx = -1\n                best_pos = -1\n                best_increase = float('inf')\n\n                for route_idx in range(len(new_solution)):\n                    for pos in range(1, len(new_solution[route_idx])):\n                        # Insert node at position pos in route_idx\n                        temp_route = np.insert(new_solution[route_idx], pos, node)\n                        temp_demand = sum(demand[n] for n in temp_route if n != 0)\n                        if temp_demand > capacity:\n                            continue  # Skip if capacity is exceeded\n\n                        # Calculate the new route length\n                        new_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                        increase = new_length - sum(distance_matrix[new_solution[route_idx][i], new_solution[route_idx][i+1]] for i in range(len(new_solution[route_idx])-1))\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route_idx = route_idx\n                            best_pos = pos\n\n                # Perform the best insertion\n                if best_route_idx != -1:\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n                    # Remove the node from the merged route\n                    merged_route = np.delete(merged_route, np.where(merged_route == node)[0][0])\n\n            # Replace the original routes with the new routes\n            new_solution.pop(largest_route_idx)\n            new_solution.pop(smallest_route_idx - (1 if smallest_route_idx > largest_route_idx else 0))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) in the selected solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply a hybrid local search: split the longest route into two parts and reinsert them\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Step 4: Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if not is_feasible(part1) or not is_feasible(part2):\n        # If splitting is infeasible, try a different approach: move a random segment to another route\n        if len(selected_solution) > 1:\n            other_route_idx = (longest_route_idx + 1) % len(selected_solution)\n            other_route = selected_solution[other_route_idx].copy()\n\n            # Select a random segment from the longest route\n            start = np.random.randint(1, len(longest_route) - 2)\n            end = np.random.randint(start + 1, len(longest_route) - 1)\n            segment = longest_route[start:end + 1]\n\n            # Check if adding the segment to the other route is feasible\n            if sum(demand[segment[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Remove the segment from the longest route\n                new_longest_route = np.concatenate([longest_route[:start], longest_route[end + 1:]])\n                # Add the segment to the other route (insert at a random position)\n                insert_pos = np.random.randint(1, len(other_route))\n                new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n\n                # Update the solution\n                selected_solution[longest_route_idx] = new_longest_route\n                selected_solution[other_route_idx] = new_other_route\n\n    else:\n        # If splitting is feasible, update the solution\n        selected_solution[longest_route_idx] = part1\n        selected_solution.append(part2)\n\n    return selected_solution\n\n",
        "score": [
            -0.7485970118805203,
            0.32851606607437134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) in the selected solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Apply a hybrid local search: split the longest route into two parts and reinsert them\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Step 4: Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if not is_feasible(part1) or not is_feasible(part2):\n        # If splitting is infeasible, try a different approach: move a random segment to another route\n        if len(selected_solution) > 1:\n            other_route_idx = (longest_route_idx + 1) % len(selected_solution)\n            other_route = selected_solution[other_route_idx].copy()\n\n            # Select a random segment from the longest route\n            start = np.random.randint(1, len(longest_route) - 2)\n            end = np.random.randint(start + 1, len(longest_route) - 1)\n            segment = longest_route[start:end + 1]\n\n            # Check if adding the segment to the other route is feasible\n            if sum(demand[segment[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Remove the segment from the longest route\n                new_longest_route = np.concatenate([longest_route[:start], longest_route[end + 1:]])\n                # Add the segment to the other route (insert at a random position)\n                insert_pos = np.random.randint(1, len(other_route))\n                new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n\n                # Update the solution\n                selected_solution[longest_route_idx] = new_longest_route\n                selected_solution[other_route_idx] = new_other_route\n\n    else:\n        # If splitting is feasible, update the solution\n        selected_solution[longest_route_idx] = part1\n        selected_solution.append(part2)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel \"cluster-and-rebalance\" local search operator that intelligently reassigns customer clusters between routes while dynamically adjusting to capacity constraints and balancing distance and makespan objectives by iteratively merging, splitting, and reallocating routes based on spatial proximity and demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify clusters of customers by spatial proximity\n    clusters = []\n    for route in new_solution:\n        if len(route) > 2:  # Skip empty or trivial routes\n            cluster = route[1:-1]  # Exclude depot\n            clusters.append(cluster)\n\n    # Rebalance clusters by merging and splitting\n    if len(clusters) > 1:\n        # Select two clusters to merge\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        cluster_i, cluster_j = clusters[i], clusters[j]\n\n        # Check if merging these clusters is feasible\n        total_demand = sum(demand[cluster_i]) + sum(demand[cluster_j])\n        if total_demand <= capacity:\n            # Merge the clusters\n            merged_route = np.concatenate(([0], cluster_i, cluster_j, [0]))\n            new_route = merged_route\n\n            # Update the solution\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(new_route)\n\n            # Optimize the new route with a simple 2-opt\n            optimized_route = _optimize_route(new_route, distance_matrix)\n            new_solution[-1] = optimized_route\n\n    # If no merge was performed, try splitting a long route\n    if len(clusters) < 2 and len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure it can be split\n            # Split the route at a random feasible point\n            split_pos = np.random.randint(2, len(longest_route) - 2)\n            part1 = longest_route[:split_pos + 1]\n            part2 = np.concatenate(([0], longest_route[split_pos:-1], [0]))\n\n            # Check capacity constraints\n            if (sum(demand[part1]) <= capacity) and (sum(demand[part2]) <= capacity):\n                new_solution[longest_route_idx] = part1\n                new_solution.append(part2)\n\n                # Optimize both parts\n                new_solution[longest_route_idx] = _optimize_route(part1, distance_matrix)\n                new_solution[-1] = _optimize_route(part2, distance_matrix)\n\n    return new_solution\n\n",
        "score": [
            -0.7653792225953279,
            7.954973936080933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify clusters of customers by spatial proximity\n    clusters = []\n    for route in new_solution:\n        if len(route) > 2:  # Skip empty or trivial routes\n            cluster = route[1:-1]  # Exclude depot\n            clusters.append(cluster)\n\n    # Rebalance clusters by merging and splitting\n    if len(clusters) > 1:\n        # Select two clusters to merge\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        cluster_i, cluster_j = clusters[i], clusters[j]\n\n        # Check if merging these clusters is feasible\n        total_demand = sum(demand[cluster_i]) + sum(demand[cluster_j])\n        if total_demand <= capacity:\n            # Merge the clusters\n            merged_route = np.concatenate(([0], cluster_i, cluster_j, [0]))\n            new_route = merged_route\n\n            # Update the solution\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(new_route)\n\n            # Optimize the new route with a simple 2-opt\n            optimized_route = _optimize_route(new_route, distance_matrix)\n            new_solution[-1] = optimized_route\n\n    # If no merge was performed, try splitting a long route\n    if len(clusters) < 2 and len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure it can be split\n            # Split the route at a random feasible point\n            split_pos = np.random.randint(2, len(longest_route) - 2)\n            part1 = longest_route[:split_pos + 1]\n            part2 = np.concatenate(([0], longest_route[split_pos:-1], [0]))\n\n            # Check capacity constraints\n            if (sum(demand[part1]) <= capacity) and (sum(demand[part2]) <= capacity):\n                new_solution[longest_route_idx] = part1\n                new_solution.append(part2)\n\n                # Optimize both parts\n                new_solution[longest_route_idx] = _optimize_route(part1, distance_matrix)\n                new_solution[-1] = _optimize_route(part2, distance_matrix)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search operator that combines route splitting, customer reallocation, and segment swapping to generate a neighbor solution while ensuring feasibility and exploring trade-offs between distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting and merging\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route1) - 2)\n            new_route = np.concatenate([route1[:split_pos + 1], [0]])\n            route1 = np.concatenate([[0], route1[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route[1:-1]]) <= capacity and\n                np.sum(demand[route1[1:-1]]) <= capacity):\n                new_solution[route1_idx] = route1\n                new_solution.append(new_route)\n    else:\n        # Customer reallocation and segment swapping\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select segments from both routes\n                    seg1_start = random.randint(1, len(route1) - 2)\n                    seg1_end = random.randint(seg1_start, len(route1) - 2)\n                    seg2_start = random.randint(1, len(route2) - 2)\n                    seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                    # Swap segments\n                    new_route1 = np.concatenate([\n                        route1[:seg1_start],\n                        route2[seg2_start:seg2_end + 1],\n                        route1[seg1_end + 1:]\n                    ])\n                    new_route2 = np.concatenate([\n                        route2[:seg2_start],\n                        route1[seg1_start:seg1_end + 1],\n                        route2[seg2_end + 1:]\n                    ])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5914059815449814,
            0.40719643235206604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting and merging\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route1) - 2)\n            new_route = np.concatenate([route1[:split_pos + 1], [0]])\n            route1 = np.concatenate([[0], route1[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route[1:-1]]) <= capacity and\n                np.sum(demand[route1[1:-1]]) <= capacity):\n                new_solution[route1_idx] = route1\n                new_solution.append(new_route)\n    else:\n        # Customer reallocation and segment swapping\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select segments from both routes\n                    seg1_start = random.randint(1, len(route1) - 2)\n                    seg1_end = random.randint(seg1_start, len(route1) - 2)\n                    seg2_start = random.randint(1, len(route2) - 2)\n                    seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                    # Swap segments\n                    new_route1 = np.concatenate([\n                        route1[:seg1_start],\n                        route2[seg2_start:seg2_end + 1],\n                        route1[seg1_end + 1:]\n                    ])\n                    new_route2 = np.concatenate([\n                        route2[:seg2_start],\n                        route1[seg1_start:seg1_end + 1],\n                        route2[seg2_end + 1:]\n                    ])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{A novel hybrid local search operator combines route segment swapping with demand-aware path relinking, dynamically balancing distance and makespan objectives by probabilistically selecting between transformations based on route imbalance and demand distribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 5))\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment swap + demand-aware path relinking\n    new_solution = base_solution.copy()\n\n    # Randomly select two routes for segment swap\n    if len(new_solution) > 1:\n        route1, route2 = np.random.choice(len(new_solution), 2, replace=False)\n        r1 = new_solution[route1]\n        r2 = new_solution[route2]\n\n        # Find feasible segments to swap\n        def find_feasible_segment(route, max_len=5):\n            segments = []\n            for i in range(1, len(route)-1):\n                for j in range(i+1, min(i+max_len, len(route)-1)):\n                    seg_demand = sum(demand[route[i:j+1]])\n                    if seg_demand <= capacity:\n                        segments.append((i, j))\n            return segments if segments else [(1, len(route)-2)]\n\n        seg1 = random.choice(find_feasible_segment(r1))\n        seg2 = random.choice(find_feasible_segment(r2))\n\n        # Perform segment swap\n        new_r1 = np.concatenate([r1[:seg1[0]], r2[seg2[0]:seg2[1]+1], r1[seg1[1]+1:]])\n        new_r2 = np.concatenate([r2[:seg2[0]], r1[seg1[0]:seg1[1]+1], r2[seg2[1]+1:]])\n\n        # Check feasibility\n        if (sum(demand[new_r1[1:-1]]) <= capacity and\n            sum(demand[new_r2[1:-1]]) <= capacity):\n            new_solution[route1] = new_r1\n            new_solution[route2] = new_r2\n\n    # Demand-aware path relinking (probabilistic)\n    if random.random() < 0.3 and len(new_solution) > 0:\n        route = random.choice(new_solution)\n        if len(route) > 4:\n            # Identify high-demand nodes\n            customers = route[1:-1]\n            high_demand_nodes = [n for n in customers if demand[n] > capacity/3]\n\n            if high_demand_nodes:\n                # Relink around high-demand nodes\n                node = random.choice(high_demand_nodes)\n                idx = np.where(route == node)[0][0]\n\n                # Find insertion points that maintain feasibility\n                possible_inserts = []\n                for i in range(1, len(route)-1):\n                    if i != idx and i != idx-1:\n                        new_route = np.concatenate([route[:idx], route[idx+1:]])\n                        new_route = np.insert(new_route, i, node)\n                        if sum(demand[new_route[1:-1]]) <= capacity:\n                            possible_inserts.append((i, new_route))\n\n                if possible_inserts:\n                    new_route = random.choice(possible_inserts)[1]\n                    new_solution[np.where([np.array_equal(r, route) for r in new_solution])[0][0]] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6651580978163095,
            1.2920426428318024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 5))\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment swap + demand-aware path relinking\n    new_solution = base_solution.copy()\n\n    # Randomly select two routes for segment swap\n    if len(new_solution) > 1:\n        route1, route2 = np.random.choice(len(new_solution), 2, replace=False)\n        r1 = new_solution[route1]\n        r2 = new_solution[route2]\n\n        # Find feasible segments to swap\n        def find_feasible_segment(route, max_len=5):\n            segments = []\n            for i in range(1, len(route)-1):\n                for j in range(i+1, min(i+max_len, len(route)-1)):\n                    seg_demand = sum(demand[route[i:j+1]])\n                    if seg_demand <= capacity:\n                        segments.append((i, j))\n            return segments if segments else [(1, len(route)-2)]\n\n        seg1 = random.choice(find_feasible_segment(r1))\n        seg2 = random.choice(find_feasible_segment(r2))\n\n        # Perform segment swap\n        new_r1 = np.concatenate([r1[:seg1[0]], r2[seg2[0]:seg2[1]+1], r1[seg1[1]+1:]])\n        new_r2 = np.concatenate([r2[:seg2[0]], r1[seg1[0]:seg1[1]+1], r2[seg2[1]+1:]])\n\n        # Check feasibility\n        if (sum(demand[new_r1[1:-1]]) <= capacity and\n            sum(demand[new_r2[1:-1]]) <= capacity):\n            new_solution[route1] = new_r1\n            new_solution[route2] = new_r2\n\n    # Demand-aware path relinking (probabilistic)\n    if random.random() < 0.3 and len(new_solution) > 0:\n        route = random.choice(new_solution)\n        if len(route) > 4:\n            # Identify high-demand nodes\n            customers = route[1:-1]\n            high_demand_nodes = [n for n in customers if demand[n] > capacity/3]\n\n            if high_demand_nodes:\n                # Relink around high-demand nodes\n                node = random.choice(high_demand_nodes)\n                idx = np.where(route == node)[0][0]\n\n                # Find insertion points that maintain feasibility\n                possible_inserts = []\n                for i in range(1, len(route)-1):\n                    if i != idx and i != idx-1:\n                        new_route = np.concatenate([route[:idx], route[idx+1:]])\n                        new_route = np.insert(new_route, i, node)\n                        if sum(demand[new_route[1:-1]]) <= capacity:\n                            possible_inserts.append((i, new_route))\n\n                if possible_inserts:\n                    new_route = random.choice(possible_inserts)[1]\n                    new_solution[np.where([np.array_equal(r, route) for r in new_solution])[0][0]] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n\n    # Apply a hybrid local search: route merging followed by route splitting with demand feasibility check\n    new_solution = selected_solution.copy()\n\n    # Step 1: Merge two shortest routes if they can be merged without exceeding capacity\n    if len(new_solution) > 1:\n        # Sort routes by length\n        sorted_routes = sorted(new_solution, key=lambda x: len(x))\n        route1, route2 = sorted_routes[0], sorted_routes[1]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by connecting them\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + [r for r in new_solution if r is not route1 and r is not route2]\n\n    # Step 2: Split a long route into two if it can be split without exceeding capacity\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only split routes with more than 3 customers\n            # Try to find a split point where the demand after split is <= capacity\n            for j in range(2, len(route)-2):  # Avoid splitting at start/end\n                demand_part1 = sum(demand[route[1:j+1]])\n                demand_part2 = sum(demand[route[j+1:-1]])\n                if demand_part1 <= capacity and demand_part2 <= capacity:\n                    # Split the route\n                    part1 = np.concatenate([route[:j+1], [0]])\n                    part2 = np.concatenate([[0], route[j+1:]])\n                    new_solution = [r for r in new_solution if r is not route] + [part1, part2]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7965190730922479,
            3.102934390306473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n\n    # Apply a hybrid local search: route merging followed by route splitting with demand feasibility check\n    new_solution = selected_solution.copy()\n\n    # Step 1: Merge two shortest routes if they can be merged without exceeding capacity\n    if len(new_solution) > 1:\n        # Sort routes by length\n        sorted_routes = sorted(new_solution, key=lambda x: len(x))\n        route1, route2 = sorted_routes[0], sorted_routes[1]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by connecting them\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + [r for r in new_solution if r is not route1 and r is not route2]\n\n    # Step 2: Split a long route into two if it can be split without exceeding capacity\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only split routes with more than 3 customers\n            # Try to find a split point where the demand after split is <= capacity\n            for j in range(2, len(route)-2):  # Avoid splitting at start/end\n                demand_part1 = sum(demand[route[1:j+1]])\n                demand_part2 = sum(demand[route[j+1:-1]])\n                if demand_part1 <= capacity and demand_part2 <= capacity:\n                    # Split the route\n                    part1 = np.concatenate([route[:j+1], [0]])\n                    part2 = np.concatenate([[0], route[j+1:]])\n                    new_solution = [r for r in new_solution if r is not route] + [part1, part2]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The novel local search strategy combines route merging, segment reversal, and demand-based insertion to balance distance and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Try merging two short routes if they fit capacity constraints\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [len(route) - 1 for route in new_solution]  # exclude depot\n        shortest_indices = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])[:2]\n\n        route1, route2 = new_solution[shortest_indices[0]], new_solution[shortest_indices[1]]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            # Merge the two routes (remove depot from second route)\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[shortest_indices[0]] = merged_route\n            del new_solution[shortest_indices[1]]\n\n    # Step 2: Apply demand-based segment reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find the segment with most demand\n        demands = demand[route[1:-1]]\n        max_demand_idx = np.argmax(demands) + 1  # +1 to account for depot\n        segment_start = max(1, max_demand_idx - 2)\n        segment_end = min(len(route) - 2, max_demand_idx + 2)\n\n        # Reverse the segment\n        reversed_segment = route[segment_start:segment_end+1][::-1]\n        new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end+1:]])\n        new_solution[i] = new_route\n\n    # Step 3: Insert customers from long routes to short routes if feasible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        longest_route = new_solution[longest_idx]\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to move customers from longest to shortest route\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            # Check if adding this customer to shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into shortest route (greedy position)\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(shortest_route)):\n                    dist_increase = (distance_matrix[shortest_route[pos-1], customer] +\n                                    distance_matrix[customer, shortest_route[pos]] -\n                                    distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Insert and remove from longest route\n                shortest_route = np.insert(shortest_route, best_pos, customer)\n                longest_route = np.delete(longest_route, i)\n\n                # Update routes\n                new_solution[shortest_idx] = shortest_route\n                new_solution[longest_idx] = longest_route\n\n                # Break after first successful insertion\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7546086906723276,
            7.141607016324997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Try merging two short routes if they fit capacity constraints\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [len(route) - 1 for route in new_solution]  # exclude depot\n        shortest_indices = sorted(range(len(route_lengths)), key=lambda i: route_lengths[i])[:2]\n\n        route1, route2 = new_solution[shortest_indices[0]], new_solution[shortest_indices[1]]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            # Merge the two routes (remove depot from second route)\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[shortest_indices[0]] = merged_route\n            del new_solution[shortest_indices[1]]\n\n    # Step 2: Apply demand-based segment reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find the segment with most demand\n        demands = demand[route[1:-1]]\n        max_demand_idx = np.argmax(demands) + 1  # +1 to account for depot\n        segment_start = max(1, max_demand_idx - 2)\n        segment_end = min(len(route) - 2, max_demand_idx + 2)\n\n        # Reverse the segment\n        reversed_segment = route[segment_start:segment_end+1][::-1]\n        new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end+1:]])\n        new_solution[i] = new_route\n\n    # Step 3: Insert customers from long routes to short routes if feasible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        longest_route = new_solution[longest_idx]\n        shortest_route = new_solution[shortest_idx]\n\n        # Try to move customers from longest to shortest route\n        for i in range(1, len(longest_route)-1):\n            customer = longest_route[i]\n            # Check if adding this customer to shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into shortest route (greedy position)\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(shortest_route)):\n                    dist_increase = (distance_matrix[shortest_route[pos-1], customer] +\n                                    distance_matrix[customer, shortest_route[pos]] -\n                                    distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Insert and remove from longest route\n                shortest_route = np.insert(shortest_route, best_pos, customer)\n                longest_route = np.delete(longest_route, i)\n\n                # Update routes\n                new_solution[shortest_idx] = shortest_route\n                new_solution[longest_idx] = longest_route\n\n                # Break after first successful insertion\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random feasible split point\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    while sum(demand[longest_route[:split_idx]]) > capacity or sum(demand[longest_route[split_idx:]]) > capacity:\n        split_idx = np.random.randint(1, len(longest_route) - 1)\n\n    # Create two new routes\n    route1 = np.concatenate([[0], longest_route[:split_idx], [0]])\n    route2 = np.concatenate([[0], longest_route[split_idx:], [0]])\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = route1\n    new_solution.insert(longest_route_idx + 1, route2)\n\n    # Apply customer reinsertion to improve the new routes\n    for route in [route1, route2]:\n        if len(route) > 3:  # Only if the route has more than 2 customers\n            # Randomly select a customer to remove and reinsert\n            remove_idx = np.random.randint(1, len(route) - 1)\n            customer = route[remove_idx]\n\n            # Remove the customer\n            new_route = np.concatenate([route[:remove_idx], route[remove_idx + 1:]])\n\n            # Find the best position to reinsert the customer\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                # Insert customer at position pos\n                candidate_route = np.concatenate([new_route[:pos], [customer], new_route[pos:]])\n                # Check capacity constraint\n                if sum(demand[candidate_route]) <= capacity:\n                    # Calculate the cost of the new route\n                    cost = sum(distance_matrix[candidate_route[:-1], candidate_route[1:]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Reinsert at the best position\n            new_route = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n            # Update the route in the solution\n            if np.array_equal(route, route1):\n                route1 = new_route\n            else:\n                route2 = new_route\n\n    # Update the solution with the improved routes\n    new_solution[longest_route_idx] = route1\n    new_solution[longest_route_idx + 1] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.7823236816449881,
            1.2978991270065308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random feasible split point\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    while sum(demand[longest_route[:split_idx]]) > capacity or sum(demand[longest_route[split_idx:]]) > capacity:\n        split_idx = np.random.randint(1, len(longest_route) - 1)\n\n    # Create two new routes\n    route1 = np.concatenate([[0], longest_route[:split_idx], [0]])\n    route2 = np.concatenate([[0], longest_route[split_idx:], [0]])\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = route1\n    new_solution.insert(longest_route_idx + 1, route2)\n\n    # Apply customer reinsertion to improve the new routes\n    for route in [route1, route2]:\n        if len(route) > 3:  # Only if the route has more than 2 customers\n            # Randomly select a customer to remove and reinsert\n            remove_idx = np.random.randint(1, len(route) - 1)\n            customer = route[remove_idx]\n\n            # Remove the customer\n            new_route = np.concatenate([route[:remove_idx], route[remove_idx + 1:]])\n\n            # Find the best position to reinsert the customer\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                # Insert customer at position pos\n                candidate_route = np.concatenate([new_route[:pos], [customer], new_route[pos:]])\n                # Check capacity constraint\n                if sum(demand[candidate_route]) <= capacity:\n                    # Calculate the cost of the new route\n                    cost = sum(distance_matrix[candidate_route[:-1], candidate_route[1:]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Reinsert at the best position\n            new_route = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n            # Update the route in the solution\n            if np.array_equal(route, route1):\n                route1 = new_route\n            else:\n                route2 = new_route\n\n    # Update the solution with the improved routes\n    new_solution[longest_route_idx] = route1\n    new_solution[longest_route_idx + 1] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the shortest total distance, then applies a hybrid local search operator that combines a novel route-splitting heuristic with a demand-aware swap operator to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting + demand-aware swap\n    if len(new_solution) > 1:\n        # Route-splitting heuristic: split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure route is long enough to split\n            split_point = random.randint(1, len(longest_route)-2)\n            new_route1 = longest_route[:split_point+1]\n            new_route2 = [0] + longest_route[split_point+1:]\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution.pop(longest_route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Demand-aware swap operator: swap nodes between routes if it improves both objectives\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select nodes to swap (excluding depot)\n            node1_pos = random.randint(1, len(route1)-2)\n            node2_pos = random.randint(1, len(route2)-2)\n\n            node1 = route1[node1_pos]\n            node2 = route2[node2_pos]\n\n            # Create new routes after swap\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            new_route1[node1_pos] = node2\n            new_route2[node2_pos] = node1\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6829989977289174,
            0.6823334097862244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting + demand-aware swap\n    if len(new_solution) > 1:\n        # Route-splitting heuristic: split the longest route if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure route is long enough to split\n            split_point = random.randint(1, len(longest_route)-2)\n            new_route1 = longest_route[:split_point+1]\n            new_route2 = [0] + longest_route[split_point+1:]\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution.pop(longest_route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Demand-aware swap operator: swap nodes between routes if it improves both objectives\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select nodes to swap (excluding depot)\n            node1_pos = random.randint(1, len(route1)-2)\n            node2_pos = random.randint(1, len(route2)-2)\n\n            node1 = route1[node1_pos]\n            node2 = route2[node2_pos]\n\n            # Create new routes after swap\n            new_route1 = route1.copy()\n            new_route2 = route2.copy()\n\n            new_route1[node1_pos] = node2\n            new_route2[node2_pos] = node1\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive with a high total distance or high makespan, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and a novel \"route inversion\" operator to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    max_total_distance = max(total_distances)\n    max_makespan = max(makespans)\n\n    selected_idx = np.argmax([total_distances[i] / max_total_distance + makespans[i] / max_makespan for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Step 1: Route Splitting\n        split_pos = np.random.randint(1, len(route)-1)\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx+1, new_route2)\n            break\n\n    # Step 2: Customer Reinsertion with Capacity Check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select a customer to reinsert\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Remove customer from route\n        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n        new_solution[route_idx] = new_route\n\n        # Try to insert into other routes\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Try all possible insertion positions\n            for insert_pos in range(1, len(other_route)):\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n\n                # Check capacity feasibility\n                if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n                    break\n            else:\n                continue\n            break\n\n    # Step 3: Route Inversion (Novel Operator)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Invert a segment of the route\n        start_pos = np.random.randint(1, len(route)-2)\n        end_pos = np.random.randint(start_pos+1, len(route)-1)\n        inverted_segment = route[start_pos:end_pos][::-1]\n\n        new_route = np.concatenate([route[:start_pos], inverted_segment, route[end_pos:]])\n        new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5990944988328832,
            5.744303196668625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    max_total_distance = max(total_distances)\n    max_makespan = max(makespans)\n\n    selected_idx = np.argmax([total_distances[i] / max_total_distance + makespans[i] / max_makespan for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Step 1: Route Splitting\n        split_pos = np.random.randint(1, len(route)-1)\n        new_route1 = np.concatenate([route[:split_pos+1], [0]])\n        new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity feasibility\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_idx] = new_route1\n            new_solution.insert(route_idx+1, new_route2)\n            break\n\n    # Step 2: Customer Reinsertion with Capacity Check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Randomly select a customer to reinsert\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Remove customer from route\n        new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n        new_solution[route_idx] = new_route\n\n        # Try to insert into other routes\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Try all possible insertion positions\n            for insert_pos in range(1, len(other_route)):\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n\n                # Check capacity feasibility\n                if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n                    break\n            else:\n                continue\n            break\n\n    # Step 3: Route Inversion (Novel Operator)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Invert a segment of the route\n        start_pos = np.random.randint(1, len(route)-2)\n        end_pos = np.random.randint(start_pos+1, len(route)-1)\n        inverted_segment = route[start_pos:end_pos][::-1]\n\n        new_route = np.concatenate([route[:start_pos], inverted_segment, route[end_pos:]])\n        new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] / (obj[0] + 1e-6) for _, obj in archive])\n    selected_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: 1) Route combination + 2) Customer reinsertion\n    if len(new_solution) > 1:\n        # Combine two shortest routes if their combined load is within capacity\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_routes = sorted(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        for i in sorted_routes[:2]:\n            for j in sorted_routes[:2]:\n                if i != j and route_loads[i] + route_loads[j] <= capacity:\n                    # Combine routes i and j\n                    combined = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = combined\n                    del new_solution[j]\n                    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n                    break\n\n        # Reinsert customers from the longest route to balance makespan\n        if len(new_solution) > 1:\n            longest_route_idx = np.argmax([len(route) for route in new_solution])\n            longest_route = new_solution[longest_route_idx][1:-1]\n            route_load = route_loads[longest_route_idx]\n\n            for customer in longest_route:\n                # Try inserting customer into another route\n                for route_idx in range(len(new_solution)):\n                    if route_idx == longest_route_idx:\n                        continue\n                    temp_route = np.concatenate([new_solution[route_idx][:-1], [customer], [0]])\n                    temp_load = sum(demand[temp_route[1:-1]])\n                    if temp_load <= capacity:\n                        # Check if insertion improves makespan\n                        original_makespan = max(len(route) for route in new_solution)\n                        new_makespan = max(original_makespan, len(temp_route))\n                        if new_makespan < original_makespan:\n                            # Perform insertion\n                            new_solution[route_idx] = temp_route\n                            new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == customer))\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7109706221196554,
            3.35264790058136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] / (obj[0] + 1e-6) for _, obj in archive])\n    selected_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: 1) Route combination + 2) Customer reinsertion\n    if len(new_solution) > 1:\n        # Combine two shortest routes if their combined load is within capacity\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_routes = sorted(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        for i in sorted_routes[:2]:\n            for j in sorted_routes[:2]:\n                if i != j and route_loads[i] + route_loads[j] <= capacity:\n                    # Combine routes i and j\n                    combined = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = combined\n                    del new_solution[j]\n                    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n                    break\n\n        # Reinsert customers from the longest route to balance makespan\n        if len(new_solution) > 1:\n            longest_route_idx = np.argmax([len(route) for route in new_solution])\n            longest_route = new_solution[longest_route_idx][1:-1]\n            route_load = route_loads[longest_route_idx]\n\n            for customer in longest_route:\n                # Try inserting customer into another route\n                for route_idx in range(len(new_solution)):\n                    if route_idx == longest_route_idx:\n                        continue\n                    temp_route = np.concatenate([new_solution[route_idx][:-1], [customer], [0]])\n                    temp_load = sum(demand[temp_route[1:-1]])\n                    if temp_load <= capacity:\n                        # Check if insertion improves makespan\n                        original_makespan = max(len(route) for route in new_solution)\n                        new_makespan = max(original_makespan, len(temp_route))\n                        if new_makespan < original_makespan:\n                            # Perform insertion\n                            new_solution[route_idx] = temp_route\n                            new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], np.where(new_solution[longest_route_idx] == customer))\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes and attempt to merge them\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by connecting them via the closest customers\n            last_customer1 = route1[-2]\n            first_customer2 = route2[1]\n            if distance_matrix[last_customer1][first_customer2] < distance_matrix[last_customer1][0] + distance_matrix[0][first_customer2]:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n            else:\n                # If merging is not beneficial, try reallocating a customer\n                # Select a random customer from each route and swap them\n                if len(route1) > 2 and len(route2) > 2:\n                    customer1 = random.choice(route1[1:-1])\n                    customer2 = random.choice(route2[1:-1])\n                    # Check if swapping is feasible\n                    if (sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n                        # Perform the swap\n                        route1[route1 == customer1] = customer2\n                        route2[route2 == customer2] = customer1\n    else:\n        # If only one route, apply 2-opt* (extended 2-opt with demand checks)\n        route = new_solution[0]\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if reversing the segment is feasible\n                segment = route[i:j+1]\n                reversed_segment = segment[::-1]\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    new_solution[0] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7157331086251747,
            9.554388403892517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes and attempt to merge them\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by connecting them via the closest customers\n            last_customer1 = route1[-2]\n            first_customer2 = route2[1]\n            if distance_matrix[last_customer1][first_customer2] < distance_matrix[last_customer1][0] + distance_matrix[0][first_customer2]:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n            else:\n                # If merging is not beneficial, try reallocating a customer\n                # Select a random customer from each route and swap them\n                if len(route1) > 2 and len(route2) > 2:\n                    customer1 = random.choice(route1[1:-1])\n                    customer2 = random.choice(route2[1:-1])\n                    # Check if swapping is feasible\n                    if (sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n                        # Perform the swap\n                        route1[route1 == customer1] = customer2\n                        route2[route2 == customer2] = customer1\n    else:\n        # If only one route, apply 2-opt* (extended 2-opt with demand checks)\n        route = new_solution[0]\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Check if reversing the segment is feasible\n                segment = route[i:j+1]\n                reversed_segment = segment[::-1]\n                if sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    new_solution[0] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm combines a biased random selection of solutions from the archive with a hybrid local search that integrates route fragmentation and reinsertion while considering both distance and makespan objectives, ensuring capacity constraints are respected.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_makespan = sum([obj[1] for _, obj in archive])\n    probabilities = [1 - (obj[1] / total_makespan) for _, obj in archive]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    selected_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Fragment and reinsert segments\n    # Step 1: Randomly select a route and split it into two parts\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split meaningfully\n            split_pos = random.randint(1, len(route) - 2)\n            segment = route[split_pos:-1]  # Exclude the depot at the end\n            new_route = route[:split_pos] + [0]  # New route with the segment removed\n            new_solution[route_idx] = new_route\n\n            # Step 2: Try to reinsert the segment into the best possible position in another route\n            best_insertion = None\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i]\n                for pos in range(1, len(candidate_route)):\n                    # Check capacity constraint\n                    segment_demand = sum(demand[node] for node in segment)\n                    current_demand = sum(demand[node] for node in candidate_route[1:-1])  # Exclude depots\n                    if current_demand + segment_demand > capacity:\n                        continue\n\n                    # Calculate insertion cost\n                    cost = (\n                        distance_matrix[candidate_route[pos - 1], segment[0]] +\n                        distance_matrix[segment[-1], candidate_route[pos]] -\n                        distance_matrix[candidate_route[pos - 1], candidate_route[pos]]\n                    )\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insertion = (i, pos, segment)\n\n            if best_insertion is not None:\n                i, pos, segment = best_insertion\n                new_route = new_solution[i]\n                new_route = np.concatenate([new_route[:pos], segment, new_route[pos:]])\n                new_solution[i] = new_route\n\n    # Step 3: Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7749197933297868,
            3.179886430501938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_makespan = sum([obj[1] for _, obj in archive])\n    probabilities = [1 - (obj[1] / total_makespan) for _, obj in archive]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    selected_solution = archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Fragment and reinsert segments\n    # Step 1: Randomly select a route and split it into two parts\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can split meaningfully\n            split_pos = random.randint(1, len(route) - 2)\n            segment = route[split_pos:-1]  # Exclude the depot at the end\n            new_route = route[:split_pos] + [0]  # New route with the segment removed\n            new_solution[route_idx] = new_route\n\n            # Step 2: Try to reinsert the segment into the best possible position in another route\n            best_insertion = None\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i]\n                for pos in range(1, len(candidate_route)):\n                    # Check capacity constraint\n                    segment_demand = sum(demand[node] for node in segment)\n                    current_demand = sum(demand[node] for node in candidate_route[1:-1])  # Exclude depots\n                    if current_demand + segment_demand > capacity:\n                        continue\n\n                    # Calculate insertion cost\n                    cost = (\n                        distance_matrix[candidate_route[pos - 1], segment[0]] +\n                        distance_matrix[segment[-1], candidate_route[pos]] -\n                        distance_matrix[candidate_route[pos - 1], candidate_route[pos]]\n                    )\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insertion = (i, pos, segment)\n\n            if best_insertion is not None:\n                i, pos, segment = best_insertion\n                new_route = new_solution[i]\n                new_route = np.concatenate([new_route[:pos], segment, new_route[pos:]])\n                new_solution[i] = new_route\n\n    # Step 3: Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_makespan = float('inf')\n    max_distance = -1\n\n    for sol, (total_dist, makespan) in archive:\n        if makespan < min_makespan or (makespan == min_makespan and total_dist > max_distance):\n            selected_solution = sol.copy()\n            min_makespan = makespan\n            max_distance = total_dist\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating a customer\n            # Find the customer with the largest demand in the split part\n            candidates = part2[1:-1]\n            if len(candidates) > 0:\n                max_demand_node = max(candidates, key=lambda x: demand[x])\n                # Try to insert this customer into another route\n                inserted = False\n                for i, other_route in enumerate(new_solution):\n                    if i == len(new_solution) - 1:  # Skip the current route\n                        continue\n                    # Try inserting at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, max_demand_node)\n                        temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                        if temp_demand <= capacity:\n                            new_solution[i] = temp_route\n                            part2 = np.delete(part2, np.where(part2 == max_demand_node)[0][0])\n                            inserted = True\n                            break\n                    if inserted:\n                        break\n                if not inserted:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        # Create new routes for missing customers\n        for node in missing:\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.8703172121746235,
            0.7185139656066895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    min_makespan = float('inf')\n    max_distance = -1\n\n    for sol, (total_dist, makespan) in archive:\n        if makespan < min_makespan or (makespan == min_makespan and total_dist > max_distance):\n            selected_solution = sol.copy()\n            min_makespan = makespan\n            max_distance = total_dist\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating a customer\n            # Find the customer with the largest demand in the split part\n            candidates = part2[1:-1]\n            if len(candidates) > 0:\n                max_demand_node = max(candidates, key=lambda x: demand[x])\n                # Try to insert this customer into another route\n                inserted = False\n                for i, other_route in enumerate(new_solution):\n                    if i == len(new_solution) - 1:  # Skip the current route\n                        continue\n                    # Try inserting at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, max_demand_node)\n                        temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                        if temp_demand <= capacity:\n                            new_solution[i] = temp_route\n                            part2 = np.delete(part2, np.where(part2 == max_demand_node)[0][0])\n                            inserted = True\n                            break\n                    if inserted:\n                        break\n                if not inserted:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served (fallback)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        # Create new routes for missing customers\n        for node in missing:\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting and demand-aware reinsertion to generate a neighbor solution, ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort by makespan and total distance to prioritize solutions with better objectives\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        # Select one of the top 30% solutions randomly\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware reinsertion\n    # Step 1: Randomly select a route to split\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route can be split meaningfully\n            # Step 2: Find a split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= half_demand:\n                    split_pos = i\n                    break\n\n            # Step 3: Split the route at the chosen position\n            new_route1 = np.array([0] + list(route[1:split_pos + 1]) + [0])\n            new_route2 = np.array([0] + list(route[split_pos + 1:-1]) + [0])\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Step 4: Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, new_route2)\n                new_solution.insert(route_idx, new_route1)\n\n                # Step 5: Attempt demand-aware reinsertion between routes\n                # Select a customer from one route and reinsert into another\n                if len(new_solution) > 1:\n                    from_route_idx = random.randint(0, len(new_solution) - 1)\n                    from_route = new_solution[from_route_idx]\n                    if len(from_route) > 3:\n                        customer_pos = random.randint(1, len(from_route) - 2)\n                        customer = from_route[customer_pos]\n                        customer_demand = demand[customer]\n\n                        # Find a suitable target route\n                        for to_route_idx in range(len(new_solution)):\n                            if to_route_idx == from_route_idx:\n                                continue\n                            to_route = new_solution[to_route_idx]\n                            total_demand_to = sum(demand[to_route[1:-1]])\n\n                            if total_demand_to + customer_demand <= capacity:\n                                # Find the best insertion position in the target route\n                                best_pos = 1\n                                best_cost = float('inf')\n\n                                for pos in range(1, len(to_route)):\n                                    # Calculate insertion cost\n                                    prev_node = to_route[pos - 1]\n                                    next_node = to_route[pos]\n                                    cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n\n                                # Perform the insertion\n                                new_to_route = np.insert(to_route, best_pos, customer)\n                                new_from_route = np.delete(from_route, customer_pos)\n\n                                # Check if original route is still valid\n                                if len(new_from_route) > 2:\n                                    # Update the solution\n                                    new_solution[to_route_idx] = new_to_route\n                                    new_solution[from_route_idx] = new_from_route\n                                    break\n                                else:\n                                    # If original route becomes empty, remove it\n                                    new_solution.pop(from_route_idx)\n                                    new_solution[to_route_idx] = new_to_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8231610339722969,
            3.260712116956711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort by makespan and total distance to prioritize solutions with better objectives\n        sorted_archive = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n        # Select one of the top 30% solutions randomly\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + demand-aware reinsertion\n    # Step 1: Randomly select a route to split\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure route can be split meaningfully\n            # Step 2: Find a split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= half_demand:\n                    split_pos = i\n                    break\n\n            # Step 3: Split the route at the chosen position\n            new_route1 = np.array([0] + list(route[1:split_pos + 1]) + [0])\n            new_route2 = np.array([0] + list(route[split_pos + 1:-1]) + [0])\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Step 4: Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, new_route2)\n                new_solution.insert(route_idx, new_route1)\n\n                # Step 5: Attempt demand-aware reinsertion between routes\n                # Select a customer from one route and reinsert into another\n                if len(new_solution) > 1:\n                    from_route_idx = random.randint(0, len(new_solution) - 1)\n                    from_route = new_solution[from_route_idx]\n                    if len(from_route) > 3:\n                        customer_pos = random.randint(1, len(from_route) - 2)\n                        customer = from_route[customer_pos]\n                        customer_demand = demand[customer]\n\n                        # Find a suitable target route\n                        for to_route_idx in range(len(new_solution)):\n                            if to_route_idx == from_route_idx:\n                                continue\n                            to_route = new_solution[to_route_idx]\n                            total_demand_to = sum(demand[to_route[1:-1]])\n\n                            if total_demand_to + customer_demand <= capacity:\n                                # Find the best insertion position in the target route\n                                best_pos = 1\n                                best_cost = float('inf')\n\n                                for pos in range(1, len(to_route)):\n                                    # Calculate insertion cost\n                                    prev_node = to_route[pos - 1]\n                                    next_node = to_route[pos]\n                                    cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n\n                                # Perform the insertion\n                                new_to_route = np.insert(to_route, best_pos, customer)\n                                new_from_route = np.delete(from_route, customer_pos)\n\n                                # Check if original route is still valid\n                                if len(new_from_route) > 2:\n                                    # Update the solution\n                                    new_solution[to_route_idx] = new_to_route\n                                    new_solution[from_route_idx] = new_from_route\n                                    break\n                                else:\n                                    # If original route becomes empty, remove it\n                                    new_solution.pop(from_route_idx)\n                                    new_solution[to_route_idx] = new_to_route\n                                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted randomness favoring lower makespan and total distance, then applies a hybrid local search combining route splitting, cross-route insertion, and demand-aware node swapping to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Higher weight for better solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search operator\n    # Option 1: Route splitting (split a long route into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough nodes to split\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = route[:split_pos]\n            new_route2 = route[split_pos:]\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Option 2: Cross-route insertion (move a node from one route to another)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 2:  # Ensure routes can be modified\n            node_pos = random.randint(1, len(route1) - 2)\n            node = route1[node_pos]\n            # Check if insertion is feasible\n            if (np.sum(demand[route2[1:-1]]) + demand[node] <= capacity):\n                # Insert node into route2\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate increase in distance\n                    prev_node = route2[pos - 1]\n                    next_node = route2[pos]\n                    increase = (distance_matrix[prev_node][node] +\n                              distance_matrix[node][next_node] -\n                              distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Perform insertion\n                new_route2 = np.insert(route2, best_pos, node)\n                new_solution[route2_idx] = new_route2\n                # Remove node from route1\n                new_route1 = np.delete(route1, node_pos)\n                new_solution[route1_idx] = new_route1\n\n    # Option 3: Demand-aware node swapping (swap nodes between routes if demands are compatible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 2 and len(route2) > 2:\n            node1_pos = random.randint(1, len(route1) - 2)\n            node1 = route1[node1_pos]\n            # Find a compatible node in route2\n            for node2_pos in range(1, len(route2) - 1):\n                node2 = route2[node2_pos]\n                # Check if swapping is feasible\n                if (np.sum(demand[route1[1:-1]]) - demand[node1] + demand[node2] <= capacity and\n                    np.sum(demand[route2[1:-1]]) - demand[node2] + demand[node1] <= capacity):\n                    # Perform swap\n                    new_route1 = route1.copy()\n                    new_route1[node1_pos] = node2\n                    new_route2 = route2.copy()\n                    new_route2[node2_pos] = node1\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8104536665152361,
            0.31960350275039673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Higher weight for better solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search operator\n    # Option 1: Route splitting (split a long route into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with enough nodes to split\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = route[:split_pos]\n            new_route2 = route[split_pos:]\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Option 2: Cross-route insertion (move a node from one route to another)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 2:  # Ensure routes can be modified\n            node_pos = random.randint(1, len(route1) - 2)\n            node = route1[node_pos]\n            # Check if insertion is feasible\n            if (np.sum(demand[route2[1:-1]]) + demand[node] <= capacity):\n                # Insert node into route2\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate increase in distance\n                    prev_node = route2[pos - 1]\n                    next_node = route2[pos]\n                    increase = (distance_matrix[prev_node][node] +\n                              distance_matrix[node][next_node] -\n                              distance_matrix[prev_node][next_node])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                # Perform insertion\n                new_route2 = np.insert(route2, best_pos, node)\n                new_solution[route2_idx] = new_route2\n                # Remove node from route1\n                new_route1 = np.delete(route1, node_pos)\n                new_solution[route1_idx] = new_route1\n\n    # Option 3: Demand-aware node swapping (swap nodes between routes if demands are compatible)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 2 and len(route2) > 2:\n            node1_pos = random.randint(1, len(route1) - 2)\n            node1 = route1[node1_pos]\n            # Find a compatible node in route2\n            for node2_pos in range(1, len(route2) - 1):\n                node2 = route2[node2_pos]\n                # Check if swapping is feasible\n                if (np.sum(demand[route1[1:-1]]) - demand[node1] + demand[node2] <= capacity and\n                    np.sum(demand[route2[1:-1]]) - demand[node2] + demand[node1] <= capacity):\n                    # Perform swap\n                    new_route1 = route1.copy()\n                    new_route1[node1_pos] = node2\n                    new_route2 = route2.copy()\n                    new_route2[node2_pos] = node1\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This novel local search algorithm combines route-splitting with demand-aware node swaps, followed by a makespan-balancing heuristic to generate high-quality neighbors by intelligently redistributing customers across routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route-splitting with demand-aware node selection\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Find nodes with high demand that could be split into a new route\n        demands = demand[route[1:-1]]  # Exclude depots\n        split_candidates = route[1:-1][demands > capacity * 0.3]  # Nodes with demand > 30% capacity\n\n        if len(split_candidates) > 0:\n            split_node = random.choice(split_candidates)\n            split_pos = np.where(route == split_node)[0][0]\n\n            # Create new route with the split node\n            new_route = np.array([0, split_node, 0])\n            new_solution.append(new_route)\n\n            # Remove the node from the original route\n            new_solution[route_idx] = np.delete(route, split_pos)\n\n    # Step 2: Demand-aware node swaps between routes\n    for _ in range(2):  # Perform 2 swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find nodes that could be swapped without violating capacity\n        for node1 in route1[1:-1]:\n            for node2 in route2[1:-1]:\n                # Check capacity constraints\n                route1_demand = np.sum(demand[route1[1:-1]])\n                route2_demand = np.sum(demand[route2[1:-1]])\n\n                new_route1_demand = route1_demand - demand[node1] + demand[node2]\n                new_route2_demand = route2_demand - demand[node2] + demand[node1]\n\n                if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                    # Perform the swap\n                    pos1 = np.where(route1 == node1)[0][0]\n                    pos2 = np.where(route2 == node2)[0][0]\n\n                    new_route1 = np.copy(route1)\n                    new_route1[pos1] = node2\n\n                    new_route2 = np.copy(route2)\n                    new_route2[pos2] = node1\n\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 3: Makespan balancing heuristic\n    # Sort routes by length and try to balance the longest routes\n    new_solution.sort(key=lambda x: len(x), reverse=True)\n\n    for i in range(1, len(new_solution)):\n        if len(new_solution[i]) < 4:  # Skip very short routes\n            continue\n\n        # Try to move a node from a long route to a shorter route\n        for node in new_solution[i][1:-1]:\n            for j in range(i):\n                # Check capacity constraint\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity:\n                    # Perform the move\n                    new_solution[j] = np.append(new_solution[j][:-1], [node, 0])\n                    new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == node)[0][0])\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5449102914558486,
            11.031046092510223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route-splitting with demand-aware node selection\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Find nodes with high demand that could be split into a new route\n        demands = demand[route[1:-1]]  # Exclude depots\n        split_candidates = route[1:-1][demands > capacity * 0.3]  # Nodes with demand > 30% capacity\n\n        if len(split_candidates) > 0:\n            split_node = random.choice(split_candidates)\n            split_pos = np.where(route == split_node)[0][0]\n\n            # Create new route with the split node\n            new_route = np.array([0, split_node, 0])\n            new_solution.append(new_route)\n\n            # Remove the node from the original route\n            new_solution[route_idx] = np.delete(route, split_pos)\n\n    # Step 2: Demand-aware node swaps between routes\n    for _ in range(2):  # Perform 2 swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find nodes that could be swapped without violating capacity\n        for node1 in route1[1:-1]:\n            for node2 in route2[1:-1]:\n                # Check capacity constraints\n                route1_demand = np.sum(demand[route1[1:-1]])\n                route2_demand = np.sum(demand[route2[1:-1]])\n\n                new_route1_demand = route1_demand - demand[node1] + demand[node2]\n                new_route2_demand = route2_demand - demand[node2] + demand[node1]\n\n                if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                    # Perform the swap\n                    pos1 = np.where(route1 == node1)[0][0]\n                    pos2 = np.where(route2 == node2)[0][0]\n\n                    new_route1 = np.copy(route1)\n                    new_route1[pos1] = node2\n\n                    new_route2 = np.copy(route2)\n                    new_route2[pos2] = node1\n\n                    # Update the solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n    # Step 3: Makespan balancing heuristic\n    # Sort routes by length and try to balance the longest routes\n    new_solution.sort(key=lambda x: len(x), reverse=True)\n\n    for i in range(1, len(new_solution)):\n        if len(new_solution[i]) < 4:  # Skip very short routes\n            continue\n\n        # Try to move a node from a long route to a shorter route\n        for node in new_solution[i][1:-1]:\n            for j in range(i):\n                # Check capacity constraint\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity:\n                    # Perform the move\n                    new_solution[j] = np.append(new_solution[j][:-1], [node, 0])\n                    new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == node)[0][0])\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route merging, route splitting, and a novel \"demand-aware\" 2-opt that prioritizes high-demand nodes to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, route splitting, and demand-aware 2-opt\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Route merging (with demand check)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i][1:-1]  # exclude depots\n        route2 = new_solution[j][1:-1]\n        merged_route = np.concatenate([[0], route1, route2, [0]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    if random.random() < 0.5:\n        # Route splitting (with demand check)\n        for idx in range(len(new_solution)):\n            route = new_solution[idx][1:-1]  # exclude depots\n            if len(route) > 1:\n                split_pos = random.randint(1, len(route) - 1)\n                part1 = np.concatenate([[0], route[:split_pos], [0]])\n                part2 = np.concatenate([[0], route[split_pos:], [0]])\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[idx] = part1\n                    new_solution.insert(idx + 1, part2)\n                    break\n\n    # Demand-aware 2-opt (prioritize high-demand nodes)\n    for _ in range(3):  # multiple attempts\n        for idx in range(len(new_solution)):\n            route = new_solution[idx]\n            if len(route) > 4:  # need at least 4 nodes to perform 2-opt\n                # Find high-demand nodes\n                demands = demand[route[1:-1]]\n                high_demand_nodes = np.where(demands > np.median(demands))[0] + 1  # +1 to account for depot\n                if len(high_demand_nodes) >= 2:\n                    a, b = random.sample(list(high_demand_nodes), 2)\n                    if a > b:\n                        a, b = b, a\n                    # Perform 2-opt swap\n                    new_route = np.concatenate([\n                        route[:a+1],\n                        route[a+1:b+1][::-1],\n                        route[b+1:]\n                    ])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5329728403791353,
            5.709764540195465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, route splitting, and demand-aware 2-opt\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Route merging (with demand check)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i][1:-1]  # exclude depots\n        route2 = new_solution[j][1:-1]\n        merged_route = np.concatenate([[0], route1, route2, [0]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    if random.random() < 0.5:\n        # Route splitting (with demand check)\n        for idx in range(len(new_solution)):\n            route = new_solution[idx][1:-1]  # exclude depots\n            if len(route) > 1:\n                split_pos = random.randint(1, len(route) - 1)\n                part1 = np.concatenate([[0], route[:split_pos], [0]])\n                part2 = np.concatenate([[0], route[split_pos:], [0]])\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[idx] = part1\n                    new_solution.insert(idx + 1, part2)\n                    break\n\n    # Demand-aware 2-opt (prioritize high-demand nodes)\n    for _ in range(3):  # multiple attempts\n        for idx in range(len(new_solution)):\n            route = new_solution[idx]\n            if len(route) > 4:  # need at least 4 nodes to perform 2-opt\n                # Find high-demand nodes\n                demands = demand[route[1:-1]]\n                high_demand_nodes = np.where(demands > np.median(demands))[0] + 1  # +1 to account for depot\n                if len(high_demand_nodes) >= 2:\n                    a, b = random.sample(list(high_demand_nodes), 2)\n                    if a > b:\n                        a, b = b, a\n                    # Perform 2-opt swap\n                    new_route = np.concatenate([\n                        route[:a+1],\n                        route[a+1:b+1][::-1],\n                        route[b+1:]\n                    ])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Perform a hybrid local search: route-splitting and cross-route relocation\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts if possible and feasible\n        if len(route) > 3:  # Ensure there are at least two customers to split\n            split_idx = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Check capacity feasibility for both new routes\n            def is_feasible(r):\n                return sum(demand[r[1:-1]]) <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Perform cross-route relocation to improve the solution\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try to move a random customer from route_i to route_j\n        if len(route_i) > 2:  # Ensure there is a customer to move\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if moving the customer to route_j is feasible\n            if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into route_j at a random position\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:insert_pos], [customer], route_j[insert_pos:]])\n\n                # Update the routes\n                new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Ensure the solution is valid (all customers are served)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Revert to the original solution if the new solution is invalid\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8741992008319903,
            1.2943273484706879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Perform a hybrid local search: route-splitting and cross-route relocation\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts if possible and feasible\n        if len(route) > 3:  # Ensure there are at least two customers to split\n            split_idx = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Check capacity feasibility for both new routes\n            def is_feasible(r):\n                return sum(demand[r[1:-1]]) <= capacity\n\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Perform cross-route relocation to improve the solution\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try to move a random customer from route_i to route_j\n        if len(route_i) > 2:  # Ensure there is a customer to move\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if moving the customer to route_j is feasible\n            if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert the customer into route_j at a random position\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([route_j[:insert_pos], [customer], route_j[insert_pos:]])\n\n                # Update the routes\n                new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx + 1:]])\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Ensure the solution is valid (all customers are served)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # Revert to the original solution if the new solution is invalid\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Randomly select a segment to relocate or swap\n    if len(route) > 3:  # Ensure there are nodes to move\n        start = np.random.randint(1, len(route) - 2)  # Avoid depot indices\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Check if segment can be moved to another route or swapped\n        for other_route_idx in range(len(base_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = base_solution[other_route_idx].copy()\n\n            # Try inserting the segment into the other route\n            for pos in range(1, len(other_route)):\n                new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity\n                    # Update the solution\n                    new_solution = base_solution.copy()\n                    new_solution[route_idx] = np.concatenate([route[:start], route[end:]])\n                    new_solution[other_route_idx] = new_route\n                    return new_solution\n\n            # Try swapping segments between routes\n            if len(other_route) > 2:\n                other_start = np.random.randint(1, len(other_route) - 1)\n                other_end = np.random.randint(other_start + 1, len(other_route))\n                other_segment = other_route[other_start:other_end]\n\n                # Check capacity constraints\n                if (np.sum(demand[segment]) <= capacity and\n                    np.sum(demand[other_segment]) <= capacity):\n\n                    # Perform swap\n                    new_route1 = np.concatenate([route[:start], other_segment, route[end:]])\n                    new_route2 = np.concatenate([other_route[:other_start], segment, other_route[other_end:]])\n\n                    # Update the solution\n                    new_solution = base_solution.copy()\n                    new_solution[route_idx] = new_route1\n                    new_solution[other_route_idx] = new_route2\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n",
        "score": [
            -0.43694633184638315,
            0.6680406630039215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Randomly select a segment to relocate or swap\n    if len(route) > 3:  # Ensure there are nodes to move\n        start = np.random.randint(1, len(route) - 2)  # Avoid depot indices\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Check if segment can be moved to another route or swapped\n        for other_route_idx in range(len(base_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = base_solution[other_route_idx].copy()\n\n            # Try inserting the segment into the other route\n            for pos in range(1, len(other_route)):\n                new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:  # Check capacity\n                    # Update the solution\n                    new_solution = base_solution.copy()\n                    new_solution[route_idx] = np.concatenate([route[:start], route[end:]])\n                    new_solution[other_route_idx] = new_route\n                    return new_solution\n\n            # Try swapping segments between routes\n            if len(other_route) > 2:\n                other_start = np.random.randint(1, len(other_route) - 1)\n                other_end = np.random.randint(other_start + 1, len(other_route))\n                other_segment = other_route[other_start:other_end]\n\n                # Check capacity constraints\n                if (np.sum(demand[segment]) <= capacity and\n                    np.sum(demand[other_segment]) <= capacity):\n\n                    # Perform swap\n                    new_route1 = np.concatenate([route[:start], other_segment, route[end:]])\n                    new_route2 = np.concatenate([other_route[:other_start], segment, other_route[other_end:]])\n\n                    # Update the solution\n                    new_solution = base_solution.copy()\n                    new_solution[route_idx] = new_route1\n                    new_solution[other_route_idx] = new_route2\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This function selects a promising solution from the archive, then applies a hybrid local search operator that combines route segment swapping with demand-aware route merging to generate a feasible neighbor solution by intelligently balancing distance and makespan reduction while respecting vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive) // 4)])[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment swapping with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Calculate segment demands\n        segment1_demand = np.sum(demand[segment1])\n        segment2_demand = np.sum(demand[segment2])\n\n        # Check if swapping is feasible\n        new_route1_demand = np.sum(demand[route1]) - segment1_demand + segment2_demand\n        new_route2_demand = np.sum(demand[route2]) - segment2_demand + segment1_demand\n\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Check if routes can be merged (if they have similar demands)\n            if abs(new_route1_demand - new_route2_demand) <= capacity * 0.2:\n                merged_route = np.concatenate([new_route1[:-1], new_route2[1:]])\n                merged_demand = np.sum(demand[merged_route[1:-1]])\n                if merged_demand <= capacity:\n                    new_solution[route1_idx] = merged_route\n                    new_solution = np.delete(new_solution, route2_idx)\n                else:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6882661901776925,
            0.8630796074867249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive) // 4)])[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segment swapping with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Calculate segment demands\n        segment1_demand = np.sum(demand[segment1])\n        segment2_demand = np.sum(demand[segment2])\n\n        # Check if swapping is feasible\n        new_route1_demand = np.sum(demand[route1]) - segment1_demand + segment2_demand\n        new_route2_demand = np.sum(demand[route2]) - segment2_demand + segment1_demand\n\n        if new_route1_demand <= capacity and new_route2_demand <= capacity:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Check if routes can be merged (if they have similar demands)\n            if abs(new_route1_demand - new_route2_demand) <= capacity * 0.2:\n                merged_route = np.concatenate([new_route1[:-1], new_route2[1:]])\n                merged_demand = np.sum(demand[merged_route[1:-1]])\n                if merged_demand <= capacity:\n                    new_solution[route1_idx] = merged_route\n                    new_solution = np.delete(new_solution, route2_idx)\n                else:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by combining a random selection weighted by makespan and distance, then applies a hybrid local search operator that intelligently combines route segment swaps and demand-aware route splits to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, (dist, span) in archive:\n        weight = 1.0 / (dist * span)  # Higher weight for solutions with better combined distance and makespan\n        weights.append(weight)\n\n    weights = np.array(weights)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments\n        split_point = random.randint(1, len(route) - 2)\n        segment1 = route[:split_point + 1]\n        segment2 = route[split_point:]\n\n        # Check capacity feasibility for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # If feasible, perform the split\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If not feasible, try to swap segments between routes\n            if len(new_solution) > 1:\n                # Randomly select another route to swap with\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n                other_route = new_solution[other_route_idx]\n\n                # Try to merge segments\n                if len(other_route) > 3:\n                    # Split the other route\n                    other_split = random.randint(1, len(other_route) - 2)\n                    other_segment1 = other_route[:other_split + 1]\n                    other_segment2 = other_route[other_split:]\n\n                    # Check merged demand\n                    merged_demand = demand1 + np.sum(demand[other_segment2[1:-1]])\n                    if merged_demand <= capacity:\n                        # Perform the merge\n                        new_route = np.concatenate([segment1, other_segment2])\n                        new_solution[other_route_idx] = new_route\n                        new_solution.append(segment2.copy())\n                    else:\n                        new_solution.append(route.copy())\n                else:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Step 3: Ensure all customers are served\n    # Check if all customers are in the new solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Add missing customers to the route with the most remaining capacity\n        for customer in missing_customers:\n            best_route_idx = -1\n            best_capacity = -1\n            for i, route in enumerate(new_solution):\n                current_demand = np.sum(demand[route[1:-1]])\n                if current_demand + demand[customer] <= capacity and current_demand > best_capacity:\n                    best_route_idx = i\n                    best_capacity = current_demand\n\n            if best_route_idx != -1:\n                # Insert the customer into the best route\n                best_route = new_solution[best_route_idx]\n                # Find the best insertion point (greedy)\n                best_insert_pos = 1\n                best_insert_cost = float('inf')\n                for i in range(1, len(best_route)):\n                    cost = distance_matrix[best_route[i-1], customer] + distance_matrix[customer, best_route[i]] - distance_matrix[best_route[i-1], best_route[i]]\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = i\n\n                new_route = np.insert(best_route, best_insert_pos, customer)\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible route, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7988992283135177,
            6.012879729270935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, (dist, span) in archive:\n        weight = 1.0 / (dist * span)  # Higher weight for solutions with better combined distance and makespan\n        weights.append(weight)\n\n    weights = np.array(weights)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two segments\n        split_point = random.randint(1, len(route) - 2)\n        segment1 = route[:split_point + 1]\n        segment2 = route[split_point:]\n\n        # Check capacity feasibility for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # If feasible, perform the split\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If not feasible, try to swap segments between routes\n            if len(new_solution) > 1:\n                # Randomly select another route to swap with\n                other_route_idx = random.randint(0, len(new_solution) - 1)\n                other_route = new_solution[other_route_idx]\n\n                # Try to merge segments\n                if len(other_route) > 3:\n                    # Split the other route\n                    other_split = random.randint(1, len(other_route) - 2)\n                    other_segment1 = other_route[:other_split + 1]\n                    other_segment2 = other_route[other_split:]\n\n                    # Check merged demand\n                    merged_demand = demand1 + np.sum(demand[other_segment2[1:-1]])\n                    if merged_demand <= capacity:\n                        # Perform the merge\n                        new_route = np.concatenate([segment1, other_segment2])\n                        new_solution[other_route_idx] = new_route\n                        new_solution.append(segment2.copy())\n                    else:\n                        new_solution.append(route.copy())\n                else:\n                    new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Step 3: Ensure all customers are served\n    # Check if all customers are in the new solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Add missing customers to the route with the most remaining capacity\n        for customer in missing_customers:\n            best_route_idx = -1\n            best_capacity = -1\n            for i, route in enumerate(new_solution):\n                current_demand = np.sum(demand[route[1:-1]])\n                if current_demand + demand[customer] <= capacity and current_demand > best_capacity:\n                    best_route_idx = i\n                    best_capacity = current_demand\n\n            if best_route_idx != -1:\n                # Insert the customer into the best route\n                best_route = new_solution[best_route_idx]\n                # Find the best insertion point (greedy)\n                best_insert_pos = 1\n                best_insert_cost = float('inf')\n                for i in range(1, len(best_route)):\n                    cost = distance_matrix[best_route[i-1], customer] + distance_matrix[customer, best_route[i]] - distance_matrix[best_route[i-1], best_route[i]]\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = i\n\n                new_route = np.insert(best_route, best_insert_pos, customer)\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible route, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest total distance (promising for distance reduction)\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: Route Splitting and Customer Reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if the split parts are feasible\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    customers = []\n    for route in new_solution:\n        customers.extend(route[1:-1])\n\n    # Randomly shuffle customers for reallocation\n    random.shuffle(customers)\n\n    # Rebuild routes with reallocated customers\n    temp_solution = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        temp_solution.append(np.array(current_route))\n\n    # Merge routes if possible (optional step)\n    final_solution = []\n    for route in temp_solution:\n        if len(route) <= 3:\n            final_solution.append(route)\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(final_solution):\n            if sum(demand[route[1:-1]]) + sum(demand[existing_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate((existing_route[:-1], route[1:]))\n                final_solution[i] = merged_route\n                merged = True\n                break\n        if not merged:\n            final_solution.append(route)\n\n    return final_solution\n\n",
        "score": [
            -0.7603711013134478,
            1.697174996137619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest total distance (promising for distance reduction)\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Apply a hybrid local search: Route Splitting and Customer Reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if the split parts are feasible\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    customers = []\n    for route in new_solution:\n        customers.extend(route[1:-1])\n\n    # Randomly shuffle customers for reallocation\n    random.shuffle(customers)\n\n    # Rebuild routes with reallocated customers\n    temp_solution = []\n    current_route = [0]\n    current_load = 0\n\n    for customer in customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        temp_solution.append(np.array(current_route))\n\n    # Merge routes if possible (optional step)\n    final_solution = []\n    for route in temp_solution:\n        if len(route) <= 3:\n            final_solution.append(route)\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(final_solution):\n            if sum(demand[route[1:-1]]) + sum(demand[existing_route[1:-1]]) <= capacity:\n                merged_route = np.concatenate((existing_route[:-1], route[1:]))\n                final_solution[i] = merged_route\n                merged = True\n                break\n        if not merged:\n            final_solution.append(route)\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of total distance and makespan, then applies a hybrid local search that combines route splitting, customer reallocation, and adaptive 2-opt to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] * 0.3 + obj[1] * 0.7 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider splitting long routes\n            split_pos = random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation (move customers between routes)\n    if len(new_solution) > 1:\n        route_a = random.choice(new_solution)\n        route_b = random.choice([r for r in new_solution if r is not route_a])\n\n        # Find a customer to move\n        if len(route_a) > 3:  # Ensure we don't leave an empty route\n            customer_idx = random.randint(1, len(route_a)-2)\n            customer = route_a[customer_idx]\n\n            # Try to insert into route_b\n            best_pos = -1\n            min_increase = float('inf')\n\n            for pos in range(1, len(route_b)):\n                # Create temporary insertion\n                temp_route = np.insert(route_b, pos, customer)\n                temp_demand = np.sum(demand[temp_route[1:-1]])\n\n                if temp_demand <= capacity:\n                    # Calculate distance increase\n                    dist_before = (distance_matrix[temp_route[pos-1], temp_route[pos]] +\n                                 distance_matrix[temp_route[pos], temp_route[pos+1]])\n                    dist_after = (distance_matrix[temp_route[pos-1], customer] +\n                                distance_matrix[customer, temp_route[pos+1]])\n                    increase = dist_after - dist_before\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the move\n                route_a = np.delete(route_a, customer_idx)\n                route_b = np.insert(route_b, best_pos, customer)\n\n    # Step 3: Adaptive 2-opt (focus on critical segments)\n    for route in new_solution:\n        if len(route) > 4:  # Only optimize long routes\n            # Identify the most \"critical\" segment (highest distance)\n            max_dist = -1\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    dist = (distance_matrix[route[i-1], route[i]] +\n                           distance_matrix[route[j], route[j+1]] +\n                           distance_matrix[route[i], route[j+1]] +\n                           distance_matrix[route[j], route[i+1]])\n\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n\n            if best_i != -1:\n                # Perform 2-opt swap\n                route[best_i:best_j+1] = route[best_i:best_j+1][::-1]\n\n    # Final feasibility check and cleanup\n    for i in range(len(new_solution)-1, -1, -1):\n        if len(new_solution[i]) <= 2:  # Remove empty or single-customer routes\n            new_solution.pop(i)\n\n    return new_solution\n\n",
        "score": [
            -0.7361922926251061,
            4.678668200969696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] * 0.3 + obj[1] * 0.7 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider splitting long routes\n            split_pos = random.randint(2, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reallocation (move customers between routes)\n    if len(new_solution) > 1:\n        route_a = random.choice(new_solution)\n        route_b = random.choice([r for r in new_solution if r is not route_a])\n\n        # Find a customer to move\n        if len(route_a) > 3:  # Ensure we don't leave an empty route\n            customer_idx = random.randint(1, len(route_a)-2)\n            customer = route_a[customer_idx]\n\n            # Try to insert into route_b\n            best_pos = -1\n            min_increase = float('inf')\n\n            for pos in range(1, len(route_b)):\n                # Create temporary insertion\n                temp_route = np.insert(route_b, pos, customer)\n                temp_demand = np.sum(demand[temp_route[1:-1]])\n\n                if temp_demand <= capacity:\n                    # Calculate distance increase\n                    dist_before = (distance_matrix[temp_route[pos-1], temp_route[pos]] +\n                                 distance_matrix[temp_route[pos], temp_route[pos+1]])\n                    dist_after = (distance_matrix[temp_route[pos-1], customer] +\n                                distance_matrix[customer, temp_route[pos+1]])\n                    increase = dist_after - dist_before\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Perform the move\n                route_a = np.delete(route_a, customer_idx)\n                route_b = np.insert(route_b, best_pos, customer)\n\n    # Step 3: Adaptive 2-opt (focus on critical segments)\n    for route in new_solution:\n        if len(route) > 4:  # Only optimize long routes\n            # Identify the most \"critical\" segment (highest distance)\n            max_dist = -1\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    dist = (distance_matrix[route[i-1], route[i]] +\n                           distance_matrix[route[j], route[j+1]] +\n                           distance_matrix[route[i], route[j+1]] +\n                           distance_matrix[route[j], route[i+1]])\n\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n\n            if best_i != -1:\n                # Perform 2-opt swap\n                route[best_i:best_j+1] = route[best_i:best_j+1][::-1]\n\n    # Final feasibility check and cleanup\n    for i in range(len(new_solution)-1, -1, -1):\n        if len(new_solution[i]) <= 2:  # Remove empty or single-customer routes\n            new_solution.pop(i)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining route splitting, merging, and customer reallocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(1.0 / (1.0 + obj[0])) * (1.0 / (1.0 + obj[1])) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Route splitting, merging, and customer reallocation\n    new_solution = []\n\n    # Step 1: Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = random.randint(0, len(base_solution) - 1)\n        selected_route = base_solution[route_idx].copy()\n        remaining_routes = [r for i, r in enumerate(base_solution) if i != route_idx]\n\n        # Step 2: Split the selected route into two parts at a random point\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Step 3: Attempt to merge the second part with another route\n        merged = False\n        for i, route in enumerate(remaining_routes):\n            if np.sum(demand[route[1:-1]]) + np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_route = np.concatenate([route[:-1], second_part])\n                remaining_routes[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            remaining_routes.append(second_part)\n\n        # Add the first part (or modified version) back\n        if len(first_part) > 2:  # If not just depot-depot\n            remaining_routes.append(first_part)\n\n        # Step 4: Randomly reallocate a customer from a route to another if feasible\n        if len(remaining_routes) > 1:\n            source_route_idx = random.randint(0, len(remaining_routes) - 1)\n            source_route = remaining_routes[source_route_idx]\n            if len(source_route) > 2:  # Can remove a customer\n                customer_pos = random.randint(1, len(source_route) - 2)\n                customer = source_route[customer_pos]\n                new_source_route = np.concatenate([source_route[:customer_pos], source_route[customer_pos + 1:]])\n\n                # Try to insert into another route\n                for i, route in enumerate(remaining_routes):\n                    if i != source_route_idx and np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(route)):\n                            cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                        remaining_routes[i] = new_route\n                        remaining_routes[source_route_idx] = new_source_route\n                        break\n\n        new_solution = remaining_routes\n    else:\n        new_solution = base_solution.copy()\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = base_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5348746127957937,
            1.6895563900470734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(1.0 / (1.0 + obj[0])) * (1.0 / (1.0 + obj[1])) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Route splitting, merging, and customer reallocation\n    new_solution = []\n\n    # Step 1: Randomly select a route to modify\n    if len(base_solution) > 1:\n        route_idx = random.randint(0, len(base_solution) - 1)\n        selected_route = base_solution[route_idx].copy()\n        remaining_routes = [r for i, r in enumerate(base_solution) if i != route_idx]\n\n        # Step 2: Split the selected route into two parts at a random point\n        split_point = random.randint(1, len(selected_route) - 2)\n        first_part = selected_route[:split_point + 1]\n        second_part = selected_route[split_point:]\n\n        # Step 3: Attempt to merge the second part with another route\n        merged = False\n        for i, route in enumerate(remaining_routes):\n            if np.sum(demand[route[1:-1]]) + np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_route = np.concatenate([route[:-1], second_part])\n                remaining_routes[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            remaining_routes.append(second_part)\n\n        # Add the first part (or modified version) back\n        if len(first_part) > 2:  # If not just depot-depot\n            remaining_routes.append(first_part)\n\n        # Step 4: Randomly reallocate a customer from a route to another if feasible\n        if len(remaining_routes) > 1:\n            source_route_idx = random.randint(0, len(remaining_routes) - 1)\n            source_route = remaining_routes[source_route_idx]\n            if len(source_route) > 2:  # Can remove a customer\n                customer_pos = random.randint(1, len(source_route) - 2)\n                customer = source_route[customer_pos]\n                new_source_route = np.concatenate([source_route[:customer_pos], source_route[customer_pos + 1:]])\n\n                # Try to insert into another route\n                for i, route in enumerate(remaining_routes):\n                    if i != source_route_idx and np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(route)):\n                            cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                        remaining_routes[i] = new_route\n                        remaining_routes[source_route_idx] = new_source_route\n                        break\n\n        new_solution = remaining_routes\n    else:\n        new_solution = base_solution.copy()\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = base_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total distance (potential for improvement)\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to reallocate\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Check if merging with another route is feasible\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            target_route = new_solution[j]\n\n            # Check capacity constraint\n            if sum(demand[segment]) + sum(demand[target_route[1:-1]]) > capacity:\n                continue\n\n            # Find insertion point in target route\n            min_cost = float('inf')\n            best_pos = -1\n            for pos in range(1, len(target_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[target_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], target_route[pos]] -\n                        distance_matrix[target_route[pos-1], target_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_solution[j] = new_route\n                new_solution[i] = np.concatenate([route[:start], route[end:]])\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 2]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6986612836949326,
            1.6765387952327728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total distance (potential for improvement)\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Randomly select a segment to reallocate\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Check if merging with another route is feasible\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            target_route = new_solution[j]\n\n            # Check capacity constraint\n            if sum(demand[segment]) + sum(demand[target_route[1:-1]]) > capacity:\n                continue\n\n            # Find insertion point in target route\n            min_cost = float('inf')\n            best_pos = -1\n            for pos in range(1, len(target_route)):\n                # Calculate insertion cost\n                cost = (distance_matrix[target_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], target_route[pos]] -\n                        distance_matrix[target_route[pos-1], target_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_solution[j] = new_route\n                new_solution[i] = np.concatenate([route[:start], route[end:]])\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 2]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search that combines route splitting, customer reallocation, and adaptive 2-opt to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_weights = np.array([1.0 / (obj[0] + 1e-6) for _, obj in archive])\n    makespan_weights = np.array([1.0 / (obj[1] + 1e-6) for _, obj in archive])\n    combined_weights = 0.5 * total_distance_weights + 0.5 * makespan_weights\n    combined_weights /= combined_weights.sum()\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider splitting if route has enough customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n                if len(from_route) > 2:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(from_route) - 2)\n                    customer = from_route[customer_pos]\n\n                    # Check feasibility\n                    if (np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity):\n                        # Insert customer into to_route\n                        insert_pos = random.randint(1, len(to_route) - 1)\n                        new_to_route = np.concatenate((to_route[:insert_pos], [customer], to_route[insert_pos:]))\n\n                        # Remove customer from from_route\n                        new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n\n                        # Update routes\n                        new_solution[from_route_idx] = new_from_route\n                        new_solution[to_route_idx] = new_to_route\n\n        # Step 3: Adaptive 2-opt (only on the longest route to balance makespan)\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            i, j = sorted(random.sample(range(1, len(longest_route) - 1), 2))\n            new_route = np.concatenate((\n                longest_route[:i],\n                longest_route[j:i-1:-1],\n                longest_route[j+1:]\n            ))\n\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7704690999706636,
            6.091990888118744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance_weights = np.array([1.0 / (obj[0] + 1e-6) for _, obj in archive])\n    makespan_weights = np.array([1.0 / (obj[1] + 1e-6) for _, obj in archive])\n    combined_weights = 0.5 * total_distance_weights + 0.5 * makespan_weights\n    combined_weights /= combined_weights.sum()\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only consider splitting if route has enough customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n\n                # Check feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i + 1, new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Customer reallocation (move a customer from one route to another)\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if from_route_idx != to_route_idx:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n                if len(from_route) > 2:  # Ensure there's a customer to move\n                    customer_pos = random.randint(1, len(from_route) - 2)\n                    customer = from_route[customer_pos]\n\n                    # Check feasibility\n                    if (np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity):\n                        # Insert customer into to_route\n                        insert_pos = random.randint(1, len(to_route) - 1)\n                        new_to_route = np.concatenate((to_route[:insert_pos], [customer], to_route[insert_pos:]))\n\n                        # Remove customer from from_route\n                        new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos + 1:]))\n\n                        # Update routes\n                        new_solution[from_route_idx] = new_from_route\n                        new_solution[to_route_idx] = new_to_route\n\n        # Step 3: Adaptive 2-opt (only on the longest route to balance makespan)\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            i, j = sorted(random.sample(range(1, len(longest_route) - 1), 2))\n            new_route = np.concatenate((\n                longest_route[:i],\n                longest_route[j:i-1:-1],\n                longest_route[j+1:]\n            ))\n\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and route diversity, then applies a hybrid local search combining route merging and customer reallocation to reduce the makespan and total distance while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1] + 1) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    # Hybrid local search: merge routes and reallocate customers\n    new_solution = selected_solution.copy()\n\n    # Step 1: Try merging two routes if it reduces makespan\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i][1:-1]  # Exclude depots\n        route2 = new_solution[j][1:-1]\n\n        # Check if merged route is feasible\n        total_demand = sum(demand[route1]) + sum(demand[route2])\n        if total_demand <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([[0], route1, route2, [0]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Reallocate customers between routes to balance makespan\n    if len(new_solution) > 1:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            customers = route[1:-1]\n\n            # Try moving a customer to another route\n            if len(customers) > 1:\n                customer = random.choice(customers)\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        other_customers = other_route[1:-1]\n\n                        # Check if moving customer to other route is feasible\n                        if sum(demand[np.concatenate([other_customers, [customer]])]) <= capacity:\n                            # Update routes\n                            new_route = route[route != customer]\n                            new_other_route = np.concatenate([other_route, [customer]])\n                            new_solution[route_idx] = new_route\n                            new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.7351045370293936,
            3.085167497396469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1] + 1) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    # Hybrid local search: merge routes and reallocate customers\n    new_solution = selected_solution.copy()\n\n    # Step 1: Try merging two routes if it reduces makespan\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i][1:-1]  # Exclude depots\n        route2 = new_solution[j][1:-1]\n\n        # Check if merged route is feasible\n        total_demand = sum(demand[route1]) + sum(demand[route2])\n        if total_demand <= capacity:\n            # Create merged route\n            merged_route = np.concatenate([[0], route1, route2, [0]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Reallocate customers between routes to balance makespan\n    if len(new_solution) > 1:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            customers = route[1:-1]\n\n            # Try moving a customer to another route\n            if len(customers) > 1:\n                customer = random.choice(customers)\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        other_customers = other_route[1:-1]\n\n                        # Check if moving customer to other route is feasible\n                        if sum(demand[np.concatenate([other_customers, [customer]])]) <= capacity:\n                            # Update routes\n                            new_route = route[route != customer]\n                            new_other_route = np.concatenate([other_route, [customer]])\n                            new_solution[route_idx] = new_route\n                            new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[min(2, len(archive_sorted) - 1)][0].copy()\n\n    # Randomly pick two distinct routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = random.sample(range(len(selected_solution)), 2)\n    route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n    # Combine the two routes into one (excluding depots)\n    combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate total demand and check feasibility\n    total_demand = sum(demand[customer] for customer in combined_route[1:-1])\n    if total_demand > capacity:\n        return selected_solution  # Return original if merge is infeasible\n\n    # Apply a route-splitting heuristic to balance load and distance\n    new_routes = []\n    current_route = [0]\n    current_load = 0.0\n\n    for customer in combined_route[1:-1]:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    current_route.append(0)\n    new_routes.append(np.array(current_route))\n\n    # Replace the original routes with the new ones\n    selected_solution.pop(route_indices[0])\n    selected_solution.pop(route_indices[1] - 1 if route_indices[0] < route_indices[1] else route_indices[1])\n    selected_solution.extend(new_routes)\n\n    return selected_solution\n\n",
        "score": [
            -0.648218939151793,
            5.682805776596069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[min(2, len(archive_sorted) - 1)][0].copy()\n\n    # Randomly pick two distinct routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_indices = random.sample(range(len(selected_solution)), 2)\n    route1, route2 = selected_solution[route_indices[0]], selected_solution[route_indices[1]]\n\n    # Combine the two routes into one (excluding depots)\n    combined_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate total demand and check feasibility\n    total_demand = sum(demand[customer] for customer in combined_route[1:-1])\n    if total_demand > capacity:\n        return selected_solution  # Return original if merge is infeasible\n\n    # Apply a route-splitting heuristic to balance load and distance\n    new_routes = []\n    current_route = [0]\n    current_load = 0.0\n\n    for customer in combined_route[1:-1]:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    current_route.append(0)\n    new_routes.append(np.array(current_route))\n\n    # Replace the original routes with the new ones\n    selected_solution.pop(route_indices[0])\n    selected_solution.pop(route_indices[1] - 1 if route_indices[0] < route_indices[1] else route_indices[1])\n    selected_solution.extend(new_routes)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining route splitting, demand-based reinsertion, and distance-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting - split long routes into two parts\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has more than 2 customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-based reinsertion - reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # Find customers to remove (randomly select some)\n            customers = route[1:-1]\n            random.shuffle(customers)\n            to_remove = []\n            current_demand = 0\n            for c in customers:\n                if current_demand + demand[c] <= capacity:\n                    current_demand += demand[c]\n                else:\n                    to_remove.append(c)\n\n            # Remove selected customers\n            new_route = route[np.isin(route, [0] + [c for c in route[1:-1] if c not in to_remove], invert=True)]\n\n            # Try to reinsert removed customers into other routes\n            for c in to_remove:\n                best_pos = -1\n                best_cost = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    other_route = new_solution[j]\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[c] > capacity:\n                        continue\n\n                    # Find best insertion position in other route\n                    for k in range(1, len(other_route)):\n                        new_other_route = np.concatenate([other_route[:k], [c], other_route[k:]])\n                        cost_increase = (distance_matrix[other_route[k-1]][c] +\n                                       distance_matrix[c][other_route[k]] -\n                                       distance_matrix[other_route[k-1]][other_route[k]])\n                        if cost_increase < best_cost:\n                            best_cost = cost_increase\n                            best_pos = (j, k, new_other_route)\n\n                if best_pos != -1:\n                    j, k, new_other_route = best_pos\n                    new_solution[j] = new_other_route\n\n            new_solution[i] = new_route\n\n    # Step 3: Distance-aware swaps - swap customers between routes if beneficial\n    for _ in range(5):  # Limit the number of swaps\n        # Select two random routes\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Select random customers from each route\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            continue\n        c_i = random.choice(route_i[1:-1])\n        c_j = random.choice(route_j[1:-1])\n\n        # Calculate new demands\n        new_demand_i = np.sum(demand[route_i[1:-1]]) - demand[c_i] + demand[c_j]\n        new_demand_j = np.sum(demand[route_j[1:-1]]) - demand[c_j] + demand[c_i]\n\n        if new_demand_i > capacity or new_demand_j > capacity:\n            continue\n\n        # Calculate cost difference\n        # Find positions of c_i and c_j in their routes\n        pos_i = np.where(route_i == c_i)[0][0]\n        pos_j = np.where(route_j == c_j)[0][0]\n\n        # Calculate old distances\n        old_dist_i = (distance_matrix[route_i[pos_i-1]][c_i] +\n                     distance_matrix[c_i][route_i[pos_i+1]])\n        old_dist_j = (distance_matrix[route_j[pos_j-1]][c_j] +\n                     distance_matrix[c_j][route_j[pos_j+1]])\n\n        # Calculate new distances\n        new_dist_i = (distance_matrix[route_i[pos_i-1]][c_j] +\n                     distance_matrix[c_j][route_i[pos_i+1]])\n        new_dist_j = (distance_matrix[route_j[pos_j-1]][c_i] +\n                     distance_matrix[c_i][route_j[pos_j+1]])\n\n        cost_diff = (new_dist_i + new_dist_j) - (old_dist_i + old_dist_j)\n\n        if cost_diff < 0:  # Only accept if improvement\n            # Perform the swap\n            route_i[pos_i] = c_j\n            route_j[pos_j] = c_i\n            new_solution[i] = route_i\n            new_solution[j] = route_j\n\n    return new_solution\n\n",
        "score": [
            -0.547761822609742,
            2.7062632739543915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting - split long routes into two parts\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route has more than 2 customers\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Demand-based reinsertion - reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # Find customers to remove (randomly select some)\n            customers = route[1:-1]\n            random.shuffle(customers)\n            to_remove = []\n            current_demand = 0\n            for c in customers:\n                if current_demand + demand[c] <= capacity:\n                    current_demand += demand[c]\n                else:\n                    to_remove.append(c)\n\n            # Remove selected customers\n            new_route = route[np.isin(route, [0] + [c for c in route[1:-1] if c not in to_remove], invert=True)]\n\n            # Try to reinsert removed customers into other routes\n            for c in to_remove:\n                best_pos = -1\n                best_cost = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    other_route = new_solution[j]\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[c] > capacity:\n                        continue\n\n                    # Find best insertion position in other route\n                    for k in range(1, len(other_route)):\n                        new_other_route = np.concatenate([other_route[:k], [c], other_route[k:]])\n                        cost_increase = (distance_matrix[other_route[k-1]][c] +\n                                       distance_matrix[c][other_route[k]] -\n                                       distance_matrix[other_route[k-1]][other_route[k]])\n                        if cost_increase < best_cost:\n                            best_cost = cost_increase\n                            best_pos = (j, k, new_other_route)\n\n                if best_pos != -1:\n                    j, k, new_other_route = best_pos\n                    new_solution[j] = new_other_route\n\n            new_solution[i] = new_route\n\n    # Step 3: Distance-aware swaps - swap customers between routes if beneficial\n    for _ in range(5):  # Limit the number of swaps\n        # Select two random routes\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Select random customers from each route\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            continue\n        c_i = random.choice(route_i[1:-1])\n        c_j = random.choice(route_j[1:-1])\n\n        # Calculate new demands\n        new_demand_i = np.sum(demand[route_i[1:-1]]) - demand[c_i] + demand[c_j]\n        new_demand_j = np.sum(demand[route_j[1:-1]]) - demand[c_j] + demand[c_i]\n\n        if new_demand_i > capacity or new_demand_j > capacity:\n            continue\n\n        # Calculate cost difference\n        # Find positions of c_i and c_j in their routes\n        pos_i = np.where(route_i == c_i)[0][0]\n        pos_j = np.where(route_j == c_j)[0][0]\n\n        # Calculate old distances\n        old_dist_i = (distance_matrix[route_i[pos_i-1]][c_i] +\n                     distance_matrix[c_i][route_i[pos_i+1]])\n        old_dist_j = (distance_matrix[route_j[pos_j-1]][c_j] +\n                     distance_matrix[c_j][route_j[pos_j+1]])\n\n        # Calculate new distances\n        new_dist_i = (distance_matrix[route_i[pos_i-1]][c_j] +\n                     distance_matrix[c_j][route_i[pos_i+1]])\n        new_dist_j = (distance_matrix[route_j[pos_j-1]][c_i] +\n                     distance_matrix[c_i][route_j[pos_j+1]])\n\n        cost_diff = (new_dist_i + new_dist_j) - (old_dist_i + old_dist_j)\n\n        if cost_diff < 0:  # Only accept if improvement\n            # Perform the swap\n            route_i[pos_i] = c_j\n            route_j[pos_j] = c_i\n            new_solution[i] = route_i\n            new_solution[j] = route_j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route balancing and 3-opt with capacity checks\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes > 1:\n        # Step 1: Balance route lengths by redistributing longest routes\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Try moving a segment from longest to shortest route\n            for i in range(1, len(longest_route)-2):\n                for j in range(1, len(shortest_route)-1):\n                    segment = longest_route[i:i+2]\n                    if sum(demand[segment]) <= capacity and sum(demand[shortest_route]) + sum(demand[segment]) <= capacity:\n                        # Insert segment into shortest route\n                        new_shortest = np.insert(shortest_route, j, segment)\n                        new_longest = np.delete(longest_route, slice(i, i+2))\n\n                        # Check if new routes are valid\n                        if len(new_longest) > 2 and len(new_shortest) > 2:\n                            new_solution[shortest_route_idx] = new_shortest\n                            new_solution[longest_route_idx] = new_longest\n                            return new_solution\n\n        # Step 2: 3-opt improvement with capacity checks\n        for route in new_solution:\n            if len(route) > 4:  # Only attempt 3-opt if route has enough nodes\n                for i in range(1, len(route)-3):\n                    for j in range(i+1, len(route)-2):\n                        for k in range(j+1, len(route)-1):\n                            # Try reversing segments\n                            new_route = route.copy()\n                            new_route[i:j+1] = route[i:j+1][::-1]\n                            new_route[j:k+1] = route[j:k+1][::-1]\n                            new_route[k:] = route[k:][::-1]\n\n                            # Check capacity constraint\n                            if all(sum(demand[new_route[np.where(new_route == node)[0]]]) <= capacity for node in np.unique(new_route)):\n                                route[:] = new_route\n                                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6663715306191882,
            1.7967000603675842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Hybrid local search: Combine route balancing and 3-opt with capacity checks\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes > 1:\n        # Step 1: Balance route lengths by redistributing longest routes\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Try moving a segment from longest to shortest route\n            for i in range(1, len(longest_route)-2):\n                for j in range(1, len(shortest_route)-1):\n                    segment = longest_route[i:i+2]\n                    if sum(demand[segment]) <= capacity and sum(demand[shortest_route]) + sum(demand[segment]) <= capacity:\n                        # Insert segment into shortest route\n                        new_shortest = np.insert(shortest_route, j, segment)\n                        new_longest = np.delete(longest_route, slice(i, i+2))\n\n                        # Check if new routes are valid\n                        if len(new_longest) > 2 and len(new_shortest) > 2:\n                            new_solution[shortest_route_idx] = new_shortest\n                            new_solution[longest_route_idx] = new_longest\n                            return new_solution\n\n        # Step 2: 3-opt improvement with capacity checks\n        for route in new_solution:\n            if len(route) > 4:  # Only attempt 3-opt if route has enough nodes\n                for i in range(1, len(route)-3):\n                    for j in range(i+1, len(route)-2):\n                        for k in range(j+1, len(route)-1):\n                            # Try reversing segments\n                            new_route = route.copy()\n                            new_route[i:j+1] = route[i:j+1][::-1]\n                            new_route[j:k+1] = route[j:k+1][::-1]\n                            new_route[k:] = route[k:][::-1]\n\n                            # Check capacity constraint\n                            if all(sum(demand[new_route[np.where(new_route == node)[0]]]) <= capacity for node in np.unique(new_route)):\n                                route[:] = new_route\n                                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{A hybrid local search strategy that combines route merging, split insertion, and adaptive 2-opt moves to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route merging (if two routes can be combined without violating capacity)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route):\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Split insertion (split a long route into two if beneficial)\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 4:  # Only split if route has enough nodes\n        split_pos = random.randint(2, len(longest_route) - 3)\n        route1 = np.concatenate((longest_route[:split_pos], [0]))\n        route2 = np.concatenate(([0], longest_route[split_pos:]))\n        if is_feasible(route1) and is_feasible(route2):\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n\n    # Step 3: Adaptive 2-opt (focus on high-distance segments)\n    for route in new_solution:\n        if len(route) > 4:\n            # Find the segment with highest distance\n            max_dist = -1\n            best_i, best_j = 0, 0\n            for i in range(1, len(route)-2):\n                for j in range(i+2, len(route)-1):\n                    dist = distance_matrix[route[i], route[i+1]] + distance_matrix[route[j], route[j+1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            # Reverse the segment\n            if best_i < best_j:\n                new_segment = route[best_i:best_j+1][::-1]\n                route[best_i:best_j+1] = new_segment\n                if not is_feasible(route):\n                    route[best_i:best_j+1] = new_segment[::-1]  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.8020601508543979,
            2.3814287781715393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then distance\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route merging (if two routes can be combined without violating capacity)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if is_feasible(merged_route):\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Split insertion (split a long route into two if beneficial)\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 4:  # Only split if route has enough nodes\n        split_pos = random.randint(2, len(longest_route) - 3)\n        route1 = np.concatenate((longest_route[:split_pos], [0]))\n        route2 = np.concatenate(([0], longest_route[split_pos:]))\n        if is_feasible(route1) and is_feasible(route2):\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n\n    # Step 3: Adaptive 2-opt (focus on high-distance segments)\n    for route in new_solution:\n        if len(route) > 4:\n            # Find the segment with highest distance\n            max_dist = -1\n            best_i, best_j = 0, 0\n            for i in range(1, len(route)-2):\n                for j in range(i+2, len(route)-1):\n                    dist = distance_matrix[route[i], route[i+1]] + distance_matrix[route[j], route[j+1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            # Reverse the segment\n            if best_i < best_j:\n                new_segment = route[best_i:best_j+1][::-1]\n                route[best_i:best_j+1] = new_segment\n                if not is_feasible(route):\n                    route[best_i:best_j+1] = new_segment[::-1]  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route splitting, customer reinsertion, and partial 2-opt with capacity-aware feasibility checks to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split a long route into two\n        long_route_idx = np.argmax([len(route) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(long_route) - 3)\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # 2. Customer reinsertion with capacity check\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has customers to remove\n            # Remove a random customer\n            remove_pos = random.randint(1, len(route) - 2)\n            removed_customer = route[remove_pos]\n            new_route = np.delete(route, remove_pos)\n\n            # Try to reinsert at another position in the same route\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                if i == remove_pos or i == remove_pos + 1:\n                    continue\n                temp_route = np.insert(new_route, i, removed_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[temp_route[i-1], removed_customer] + \\\n                           distance_matrix[removed_customer, temp_route[i+1]] - \\\n                           distance_matrix[temp_route[i-1], temp_route[i+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos != -1:\n                route[:] = np.insert(new_route, best_pos, removed_customer)\n\n    # 3. Partial 2-opt with capacity check\n    for route in new_solution:\n        if len(route) > 4:  # Ensure route has enough customers for 2-opt\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(route) - 4)\n            j = random.randint(i + 2, len(route) - 2)\n            if i != j:\n                # Create new route by reversing segment between i and j\n                new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6851499990988842,
            8.275069832801819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split a long route into two\n        long_route_idx = np.argmax([len(route) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 4:  # Ensure route has enough customers to split\n            split_pos = random.randint(2, len(long_route) - 3)\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # 2. Customer reinsertion with capacity check\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has customers to remove\n            # Remove a random customer\n            remove_pos = random.randint(1, len(route) - 2)\n            removed_customer = route[remove_pos]\n            new_route = np.delete(route, remove_pos)\n\n            # Try to reinsert at another position in the same route\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(1, len(new_route)):\n                if i == remove_pos or i == remove_pos + 1:\n                    continue\n                temp_route = np.insert(new_route, i, removed_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[temp_route[i-1], removed_customer] + \\\n                           distance_matrix[removed_customer, temp_route[i+1]] - \\\n                           distance_matrix[temp_route[i-1], temp_route[i+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos != -1:\n                route[:] = np.insert(new_route, best_pos, removed_customer)\n\n    # 3. Partial 2-opt with capacity check\n    for route in new_solution:\n        if len(route) > 4:  # Ensure route has enough customers for 2-opt\n            # Select two non-adjacent edges to swap\n            i = random.randint(1, len(route) - 4)\n            j = random.randint(i + 2, len(route) - 2)\n            if i != j:\n                # Create new route by reversing segment between i and j\n                new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with a high potential for improvement (e.g., top 20% in the archive)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = np.random.choice(min(3, len(sorted_archive)), size=1)[0]  # Randomly pick from top 3\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Route splitting - Split the longest route into two if feasible\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    longest_route = base_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_pos = len(longest_route) // 2\n        route1 = longest_route[:split_pos+1]\n        route2 = longest_route[split_pos:]\n\n        # Check capacity constraints\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n            base_solution = new_solution.copy()\n\n    # Step 2.2: Customer reallocation - Move a customer from a long route to a short route if feasible\n    short_route_idx = np.argmin([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    short_route = base_solution[short_route_idx]\n    long_route = base_solution[longest_route_idx]\n\n    if len(long_route) > 3 and len(short_route) < 10:  # Avoid trivial routes\n        candidate_customer = long_route[1]  # Pick a random customer (here, first customer in long route)\n        if sum(demand[short_route[1:-1]]) + demand[candidate_customer] <= capacity:\n            # Insert customer into short route (best insertion)\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(short_route)):\n                cost = distance_matrix[short_route[i-1]][candidate_customer] + distance_matrix[candidate_customer][short_route[i]] - distance_matrix[short_route[i-1]][short_route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            new_short_route = np.insert(short_route, best_pos, candidate_customer)\n            new_long_route = np.delete(long_route, 1)\n\n            new_solution[short_route_idx] = new_short_route\n            new_solution[longest_route_idx] = new_long_route\n\n    # Step 2.3: Partial route reversal - Reverse a segment of a long route to reduce distance\n    if len(long_route) > 4:\n        start_rev = np.random.randint(1, len(long_route)-2)\n        end_rev = np.random.randint(start_rev+1, len(long_route)-1)\n        reversed_segment = long_route[start_rev:end_rev][::-1]\n        new_long_route = np.concatenate([long_route[:start_rev], reversed_segment, long_route[end_rev:]])\n\n        # Check capacity (no change, so always feasible)\n        new_solution[longest_route_idx] = new_long_route\n\n    return new_solution\n\n",
        "score": [
            -0.7774516054588636,
            1.137313187122345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with a high potential for improvement (e.g., top 20% in the archive)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = np.random.choice(min(3, len(sorted_archive)), size=1)[0]  # Randomly pick from top 3\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Route splitting - Split the longest route into two if feasible\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    longest_route = base_solution[longest_route_idx]\n\n    if len(longest_route) > 3:  # Ensure route can be split\n        split_pos = len(longest_route) // 2\n        route1 = longest_route[:split_pos+1]\n        route2 = longest_route[split_pos:]\n\n        # Check capacity constraints\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = route1\n            new_solution.append(route2)\n            base_solution = new_solution.copy()\n\n    # Step 2.2: Customer reallocation - Move a customer from a long route to a short route if feasible\n    short_route_idx = np.argmin([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in base_solution])\n    short_route = base_solution[short_route_idx]\n    long_route = base_solution[longest_route_idx]\n\n    if len(long_route) > 3 and len(short_route) < 10:  # Avoid trivial routes\n        candidate_customer = long_route[1]  # Pick a random customer (here, first customer in long route)\n        if sum(demand[short_route[1:-1]]) + demand[candidate_customer] <= capacity:\n            # Insert customer into short route (best insertion)\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(short_route)):\n                cost = distance_matrix[short_route[i-1]][candidate_customer] + distance_matrix[candidate_customer][short_route[i]] - distance_matrix[short_route[i-1]][short_route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            new_short_route = np.insert(short_route, best_pos, candidate_customer)\n            new_long_route = np.delete(long_route, 1)\n\n            new_solution[short_route_idx] = new_short_route\n            new_solution[longest_route_idx] = new_long_route\n\n    # Step 2.3: Partial route reversal - Reverse a segment of a long route to reduce distance\n    if len(long_route) > 4:\n        start_rev = np.random.randint(1, len(long_route)-2)\n        end_rev = np.random.randint(start_rev+1, len(long_route)-1)\n        reversed_segment = long_route[start_rev:end_rev][::-1]\n        new_long_route = np.concatenate([long_route[:start_rev], reversed_segment, long_route[end_rev:]])\n\n        # Check capacity (no change, so always feasible)\n        new_solution[longest_route_idx] = new_long_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The algorithm combines route segmentation with demand-aware node insertion and swaps to balance distance and makespan by intelligently splitting long routes and redistributing customers while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][1] > np.median([s[1][1] for s in archive]) or sol[1][0] > np.median([s[1][0] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected_solution = random.choice(candidates)[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes and redistribute customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Skip very short routes\n            # Split the route into two parts\n            split_point = len(route) // 2\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Check capacity constraint for both parts\n            if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n                # Replace the original route with the two parts\n                new_solution[i] = part1\n                new_solution.append(part2)\n                break\n\n    # Perform demand-aware node swaps between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find a node in route1 that can be moved to route2\n        for node in route1[1:-1]:\n            if np.sum(demand[route2[1:-1]]) + demand[node] <= capacity:\n                # Move the node to route2\n                route1 = np.delete(route1, np.where(route1 == node)[0][0])\n                route2 = np.insert(route2, -1, node)\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6928016567055838,
            1.8133347928524017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][1] > np.median([s[1][1] for s in archive]) or sol[1][0] > np.median([s[1][0] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected_solution = random.choice(candidates)[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split long routes and redistribute customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Skip very short routes\n            # Split the route into two parts\n            split_point = len(route) // 2\n            part1 = route[:split_point + 1]\n            part2 = route[split_point:]\n\n            # Check capacity constraint for both parts\n            if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n                # Replace the original route with the two parts\n                new_solution[i] = part1\n                new_solution.append(part2)\n                break\n\n    # Perform demand-aware node swaps between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find a node in route1 that can be moved to route2\n        for node in route1[1:-1]:\n            if np.sum(demand[route2[1:-1]]) + demand[node] <= capacity:\n                # Move the node to route2\n                route1 = np.delete(route1, np.where(route1 == node)[0][0])\n                route2 = np.insert(route2, -1, node)\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Convert to mutable lists for easier manipulation\n    selected_solution = [list(route) for route in selected_solution]\n\n    # Hybrid local search: Route Splitting + Intra-Route 2-opt\n    new_solution = []\n    for route in selected_solution:\n        # Route Splitting: Split long routes into two smaller routes\n        if len(route) > 4:  # Only split if route is long enough\n            midpoint = len(route) // 2\n            new_route1 = route[:midpoint] + [0]\n            new_route2 = [0] + route[midpoint:-1]\n\n            # Check capacity constraints\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # If splitting failed, apply Intra-Route 2-opt\n        improved = False\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Reverse segment between i and j\n                new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    # Accept if distance improves\n                    current_dist = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                    new_dist = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                    if new_dist < current_dist:\n                        route = new_route\n                        improved = True\n                        break\n            if improved:\n                break\n\n        new_solution.append(route)\n\n    # Convert back to numpy arrays\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.8354362150511145,
            0.17879021167755127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Convert to mutable lists for easier manipulation\n    selected_solution = [list(route) for route in selected_solution]\n\n    # Hybrid local search: Route Splitting + Intra-Route 2-opt\n    new_solution = []\n    for route in selected_solution:\n        # Route Splitting: Split long routes into two smaller routes\n        if len(route) > 4:  # Only split if route is long enough\n            midpoint = len(route) // 2\n            new_route1 = route[:midpoint] + [0]\n            new_route2 = [0] + route[midpoint:-1]\n\n            # Check capacity constraints\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # If splitting failed, apply Intra-Route 2-opt\n        improved = False\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                # Reverse segment between i and j\n                new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    # Accept if distance improves\n                    current_dist = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                    new_dist = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                    if new_dist < current_dist:\n                        route = new_route\n                        improved = True\n                        break\n            if improved:\n                break\n\n        new_solution.append(route)\n\n    # Convert back to numpy arrays\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Step 2: Find the best insertion point for route2 into route1\n        min_cost = float('inf')\n        best_insert_pos = -1\n\n        for i in range(1, len(route1)):\n            # Insert route2 after route1[i]\n            merged_route = np.concatenate([route1[:i], route2[1:-1], route1[i:]])\n            total_demand = sum(demand[merged_route])\n\n            if total_demand <= capacity:\n                cost = distance_matrix[route1[i-1], route2[1]] + distance_matrix[route2[-2], route1[i]] - distance_matrix[route1[i-1], route1[i]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Perform the merge\n            merged_route = np.concatenate([route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n\n        # Step 3: Rebalance the merged route by splitting it if it's too long\n        if len(new_solution[route_indices[0]]) > 10:  # Arbitrary threshold for rebalancing\n            route = new_solution[route_indices[0]]\n            split_pos = len(route) // 2\n            new_solution[route_indices[0]] = np.concatenate([route[:split_pos], [0]])\n            new_solution.append(np.concatenate([[0], route[split_pos:]]))\n    else:\n        # If only one route, apply a 2-opt-like improvement\n        route = new_solution[0]\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                if distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]] < distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]]:\n                    # Reverse the segment between i and j\n                    new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n                    new_solution[0] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8285152697822645,
            0.7797222137451172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Step 2: Find the best insertion point for route2 into route1\n        min_cost = float('inf')\n        best_insert_pos = -1\n\n        for i in range(1, len(route1)):\n            # Insert route2 after route1[i]\n            merged_route = np.concatenate([route1[:i], route2[1:-1], route1[i:]])\n            total_demand = sum(demand[merged_route])\n\n            if total_demand <= capacity:\n                cost = distance_matrix[route1[i-1], route2[1]] + distance_matrix[route2[-2], route1[i]] - distance_matrix[route1[i-1], route1[i]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Perform the merge\n            merged_route = np.concatenate([route1[:best_insert_pos], route2[1:-1], route1[best_insert_pos:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n\n        # Step 3: Rebalance the merged route by splitting it if it's too long\n        if len(new_solution[route_indices[0]]) > 10:  # Arbitrary threshold for rebalancing\n            route = new_solution[route_indices[0]]\n            split_pos = len(route) // 2\n            new_solution[route_indices[0]] = np.concatenate([route[:split_pos], [0]])\n            new_solution.append(np.concatenate([[0], route[split_pos:]]))\n    else:\n        # If only one route, apply a 2-opt-like improvement\n        route = new_solution[0]\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                if distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]] < distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]]:\n                    # Reverse the segment between i and j\n                    new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n                    new_solution[0] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Identify the most distant consecutive pair in the route (for potential relocation)\n    max_dist = -1\n    split_pos = 1\n    for i in range(1, len(route) - 1):\n        dist = distance_matrix[route[i-1]][route[i]]\n        if dist > max_dist:\n            max_dist = dist\n            split_pos = i\n\n    # Split the route at the most distant pair\n    first_part = route[:split_pos]\n    second_part = route[split_pos:]\n\n    # Reassign the second part to a new route if feasible\n    if np.sum(demand[second_part]) <= capacity:\n        new_solution = [r.copy() for r in base_solution]\n        new_solution[route_idx] = first_part\n        new_solution.append(np.concatenate([second_part, [0]]))\n    else:\n        # If not feasible, try to redistribute the second part to other routes\n        for r in new_solution:\n            if np.sum(demand[r]) + np.sum(demand[second_part]) <= capacity:\n                r = np.concatenate([r[:-1], second_part, [0]])\n                break\n\n    # Randomly swap two nodes between different routes if feasible\n    if len(new_solution) > 1:\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        if len(new_solution[r1]) > 2 and len(new_solution[r2]) > 2:\n            i1 = np.random.randint(1, len(new_solution[r1]) - 1)\n            i2 = np.random.randint(1, len(new_solution[r2]) - 1)\n            node1 = new_solution[r1][i1]\n            node2 = new_solution[r2][i2]\n            if (np.sum(demand[new_solution[r1]]) - demand[node1] + demand[node2] <= capacity and\n                np.sum(demand[new_solution[r2]]) - demand[node2] + demand[node1] <= capacity):\n                new_solution[r1][i1], new_solution[r2][i2] = new_solution[r2][i2], new_solution[r1][i1]\n\n    return new_solution\n\n",
        "score": [
            -0.800370839120937,
            0.21621161699295044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Identify the most distant consecutive pair in the route (for potential relocation)\n    max_dist = -1\n    split_pos = 1\n    for i in range(1, len(route) - 1):\n        dist = distance_matrix[route[i-1]][route[i]]\n        if dist > max_dist:\n            max_dist = dist\n            split_pos = i\n\n    # Split the route at the most distant pair\n    first_part = route[:split_pos]\n    second_part = route[split_pos:]\n\n    # Reassign the second part to a new route if feasible\n    if np.sum(demand[second_part]) <= capacity:\n        new_solution = [r.copy() for r in base_solution]\n        new_solution[route_idx] = first_part\n        new_solution.append(np.concatenate([second_part, [0]]))\n    else:\n        # If not feasible, try to redistribute the second part to other routes\n        for r in new_solution:\n            if np.sum(demand[r]) + np.sum(demand[second_part]) <= capacity:\n                r = np.concatenate([r[:-1], second_part, [0]])\n                break\n\n    # Randomly swap two nodes between different routes if feasible\n    if len(new_solution) > 1:\n        r1, r2 = np.random.choice(len(new_solution), 2, replace=False)\n        if len(new_solution[r1]) > 2 and len(new_solution[r2]) > 2:\n            i1 = np.random.randint(1, len(new_solution[r1]) - 1)\n            i2 = np.random.randint(1, len(new_solution[r2]) - 1)\n            node1 = new_solution[r1][i1]\n            node2 = new_solution[r2][i2]\n            if (np.sum(demand[new_solution[r1]]) - demand[node1] + demand[node2] <= capacity and\n                np.sum(demand[new_solution[r2]]) - demand[node2] + demand[node1] <= capacity):\n                new_solution[r1][i1], new_solution[r2][i2] = new_solution[r2][i2], new_solution[r1][i1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route Splitting + Customer Reallocation + Cross-Route Merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Route Splitting: Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Customer Reallocation: Move a random customer from one route to another\n    if len(new_solution) > 1:\n        source_route_idx = np.random.randint(0, len(new_solution))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure source route has customers to move\n            customer_to_move = np.random.choice(source_route[1:-1])\n            new_solution[source_route_idx] = np.delete(source_route, np.where(source_route == customer_to_move))\n\n            # Find the best target route to insert the customer\n            best_target_idx = -1\n            min_increase = float('inf')\n            for j in range(len(new_solution)):\n                if j != source_route_idx:\n                    target_route = new_solution[j]\n                    for pos in range(1, len(target_route)):\n                        # Insert customer_to_move at position pos\n                        new_route = np.insert(target_route, pos, customer_to_move)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate the increase in total distance\n                            dist_increase = (distance_matrix[new_route[pos-1]][customer_to_move] +\n                                           distance_matrix[customer_to_move][new_route[pos+1]] -\n                                           distance_matrix[new_route[pos-1]][new_route[pos+1]])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_target_idx = j\n                                best_pos = pos\n\n            if best_target_idx != -1:\n                new_solution[best_target_idx] = np.insert(new_solution[best_target_idx], best_pos, customer_to_move)\n\n    # Cross-Route Merging: Attempt to merge two routes if they can be combined without violating capacity\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) + len(route2) - 2 <= len(coords):  # Ensure merged route is feasible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.801007061870151,
            6.207098454236984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with high makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Route Splitting + Customer Reallocation + Cross-Route Merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Route Splitting: Split the route into two parts at a random customer\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Customer Reallocation: Move a random customer from one route to another\n    if len(new_solution) > 1:\n        source_route_idx = np.random.randint(0, len(new_solution))\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:  # Ensure source route has customers to move\n            customer_to_move = np.random.choice(source_route[1:-1])\n            new_solution[source_route_idx] = np.delete(source_route, np.where(source_route == customer_to_move))\n\n            # Find the best target route to insert the customer\n            best_target_idx = -1\n            min_increase = float('inf')\n            for j in range(len(new_solution)):\n                if j != source_route_idx:\n                    target_route = new_solution[j]\n                    for pos in range(1, len(target_route)):\n                        # Insert customer_to_move at position pos\n                        new_route = np.insert(target_route, pos, customer_to_move)\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate the increase in total distance\n                            dist_increase = (distance_matrix[new_route[pos-1]][customer_to_move] +\n                                           distance_matrix[customer_to_move][new_route[pos+1]] -\n                                           distance_matrix[new_route[pos-1]][new_route[pos+1]])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_target_idx = j\n                                best_pos = pos\n\n            if best_target_idx != -1:\n                new_solution[best_target_idx] = np.insert(new_solution[best_target_idx], best_pos, customer_to_move)\n\n    # Cross-Route Merging: Attempt to merge two routes if they can be combined without violating capacity\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) + len(route2) - 2 <= len(coords):  # Ensure merged route is feasible\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines route merging, intra-route 3-opt, and capacity-aware relocations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.dirichlet([1, 1])\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging (if possible)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Intra-route 3-opt\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Try three possible 3-opt moves\n            candidates = [\n                np.concatenate([route[:a], route[b:c+1], route[a:b], route[c+1:]]),\n                np.concatenate([route[:a], route[c:b-1:-1], route[a:b], route[c+1:]]),\n                np.concatenate([route[:a], route[b:c+1], route[b-1:a-1:-1], route[c+1:]])\n            ]\n            # Select the best feasible candidate\n            best_route = route\n            for candidate in candidates:\n                total_demand = np.sum(demand[candidate[1:-1]])\n                if total_demand <= capacity:\n                    if np.sum(distance_matrix[candidate[:-1], candidate[1:]]) < np.sum(distance_matrix[best_route[:-1], best_route[1:]]):\n                        best_route = candidate\n            new_solution[route_idx] = best_route\n\n    # Step 3: Capacity-aware relocation\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:\n            node_idx = random.randint(1, len(route) - 2)\n            node = route[node_idx]\n            # Try to relocate to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                # Find all possible insertion positions\n                for pos in range(1, len(other_route)):\n                    new_route = np.insert(other_route, pos, node)\n                    total_demand = np.sum(demand[new_route[1:-1]])\n                    if total_demand <= capacity:\n                        # Accept if it improves both objectives\n                        old_dist = distance_matrix[route[node_idx-1], node] + distance_matrix[node, route[node_idx+1]]\n                        new_dist = distance_matrix[other_route[pos-1], node] + distance_matrix[node, other_route[pos]]\n                        if new_dist < old_dist:\n                            new_solution[route_idx] = np.delete(route, node_idx)\n                            new_solution[other_route_idx] = new_route\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.5695135100605313,
            7.764068126678467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.dirichlet([1, 1])\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Route merging (if possible)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n            new_solution.append(merged_route)\n\n    # Step 2: Intra-route 3-opt\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            a, b, c = sorted(random.sample(range(1, len(route) - 1), 3))\n            # Try three possible 3-opt moves\n            candidates = [\n                np.concatenate([route[:a], route[b:c+1], route[a:b], route[c+1:]]),\n                np.concatenate([route[:a], route[c:b-1:-1], route[a:b], route[c+1:]]),\n                np.concatenate([route[:a], route[b:c+1], route[b-1:a-1:-1], route[c+1:]])\n            ]\n            # Select the best feasible candidate\n            best_route = route\n            for candidate in candidates:\n                total_demand = np.sum(demand[candidate[1:-1]])\n                if total_demand <= capacity:\n                    if np.sum(distance_matrix[candidate[:-1], candidate[1:]]) < np.sum(distance_matrix[best_route[:-1], best_route[1:]]):\n                        best_route = candidate\n            new_solution[route_idx] = best_route\n\n    # Step 3: Capacity-aware relocation\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:\n            node_idx = random.randint(1, len(route) - 2)\n            node = route[node_idx]\n            # Try to relocate to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n                # Find all possible insertion positions\n                for pos in range(1, len(other_route)):\n                    new_route = np.insert(other_route, pos, node)\n                    total_demand = np.sum(demand[new_route[1:-1]])\n                    if total_demand <= capacity:\n                        # Accept if it improves both objectives\n                        old_dist = distance_matrix[route[node_idx-1], node] + distance_matrix[node, route[node_idx+1]]\n                        new_dist = distance_matrix[other_route[pos-1], node] + distance_matrix[node, other_route[pos]]\n                        if new_dist < old_dist:\n                            new_solution[route_idx] = np.delete(route, node_idx)\n                            new_solution[other_route_idx] = new_route\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = [0] + route[split_idx + 1:]\n\n        # Check capacity constraints\n        part1_demand = sum(demand[node] for node in part1[1:-1])\n        part2_demand = sum(demand[node] for node in part2[1:-1])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            # Replace the original route with the two split routes\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If split fails, try reallocating a random customer to another route\n            if len(new_solution) > 1:\n                customer_to_move = random.choice(route[1:-1])\n                target_route_idx = random.choice([j for j in range(len(new_solution)) if j != i])\n                target_route = new_solution[target_route_idx]\n\n                # Check if adding the customer to the target route is feasible\n                target_demand = sum(demand[node] for node in target_route[1:-1]) + demand[customer_to_move]\n                if target_demand <= capacity:\n                    # Remove from original route\n                    new_solution[i] = np.delete(route, np.where(route == customer_to_move)[0][0])\n                    # Insert into target route (random position)\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_solution[target_route_idx] = np.insert(target_route, insert_pos, customer_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7287450268061992,
            0.273104190826416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random customer\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = [0] + route[split_idx + 1:]\n\n        # Check capacity constraints\n        part1_demand = sum(demand[node] for node in part1[1:-1])\n        part2_demand = sum(demand[node] for node in part2[1:-1])\n\n        if part1_demand <= capacity and part2_demand <= capacity:\n            # Replace the original route with the two split routes\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If split fails, try reallocating a random customer to another route\n            if len(new_solution) > 1:\n                customer_to_move = random.choice(route[1:-1])\n                target_route_idx = random.choice([j for j in range(len(new_solution)) if j != i])\n                target_route = new_solution[target_route_idx]\n\n                # Check if adding the customer to the target route is feasible\n                target_demand = sum(demand[node] for node in target_route[1:-1]) + demand[customer_to_move]\n                if target_demand <= capacity:\n                    # Remove from original route\n                    new_solution[i] = np.delete(route, np.where(route == customer_to_move)[0][0])\n                    # Insert into target route (random position)\n                    insert_pos = random.randint(1, len(target_route) - 1)\n                    new_solution[target_route_idx] = np.insert(target_route, insert_pos, customer_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route merging + intra-route relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n\n        # Try merging routes if feasible\n        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging fails, try relocating a customer from the longer route to the shorter\n            longer_route = new_solution[i] if len(new_solution[i]) > len(new_solution[j]) else new_solution[j]\n            shorter_route = new_solution[j] if len(new_solution[i]) > len(new_solution[j]) else new_solution[i]\n\n            # Find a customer to relocate\n            for k in range(1, len(longer_route)-1):\n                customer = longer_route[k]\n                # Check if relocating this customer to the shorter route is feasible\n                if np.sum(demand[shorter_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert the customer into the shorter route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(shorter_route)):\n                        temp_route = np.insert(shorter_route, pos, customer)\n                        cost = distance_matrix[temp_route[pos-1], customer] + distance_matrix[customer, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    shorter_route = np.insert(shorter_route, best_pos, customer)\n                    longer_route = np.delete(longer_route, k)\n                    break\n\n            # Update the solution\n            if len(new_solution[i]) > len(new_solution[j]):\n                new_solution[i] = longer_route\n                new_solution[j] = shorter_route\n            else:\n                new_solution[j] = longer_route\n                new_solution[i] = shorter_route\n\n    return new_solution\n\n",
        "score": [
            -0.580423800600664,
            1.3585837185382843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: route merging + intra-route relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n\n        # Try merging routes if feasible\n        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging fails, try relocating a customer from the longer route to the shorter\n            longer_route = new_solution[i] if len(new_solution[i]) > len(new_solution[j]) else new_solution[j]\n            shorter_route = new_solution[j] if len(new_solution[i]) > len(new_solution[j]) else new_solution[i]\n\n            # Find a customer to relocate\n            for k in range(1, len(longer_route)-1):\n                customer = longer_route[k]\n                # Check if relocating this customer to the shorter route is feasible\n                if np.sum(demand[shorter_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert the customer into the shorter route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(shorter_route)):\n                        temp_route = np.insert(shorter_route, pos, customer)\n                        cost = distance_matrix[temp_route[pos-1], customer] + distance_matrix[customer, temp_route[pos+1]] - distance_matrix[temp_route[pos-1], temp_route[pos+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    shorter_route = np.insert(shorter_route, best_pos, customer)\n                    longer_route = np.delete(longer_route, k)\n                    break\n\n            # Update the solution\n            if len(new_solution[i]) > len(new_solution[j]):\n                new_solution[i] = longer_route\n                new_solution[j] = shorter_route\n            else:\n                new_solution[j] = longer_route\n                new_solution[i] = shorter_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high total distance or high makespan, then applies a hybrid local search combining route splitting, customer reallocation, and partial 3-opt moves to generate a neighbor solution while ensuring feasibility through demand and capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Split long routes, reallocate customers, and apply partial 3-opt\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Step 1: Split long routes into two if possible\n        if random.random() < 0.3:  # 30% chance to attempt splitting\n            split_pos = len(route) // 2\n            route1 = route[:split_pos + 1]\n            route2 = route[split_pos:]\n            route2[0] = 0  # Ensure route2 starts at depot\n\n            # Check capacity feasibility\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.extend([route1, route2])\n                continue\n\n        # Step 2: Reallocate customers between routes if possible\n        if len(new_solution) > 1 and random.random() < 0.5:  # 50% chance to reallocate\n            other_route = random.choice([r for r in new_solution if r is not route])\n            if len(route) > 3 and len(other_route) > 3:\n                # Try moving a customer from current route to other route\n                candidate = random.choice(route[1:-1])\n                temp_route = np.delete(route, np.where(route == candidate))\n                temp_other = np.append(other_route, candidate)\n                temp_other = np.insert(temp_other, -1, 0)  # Ensure other_route ends at depot\n\n                if (sum(demand[temp_route[1:-1]]) <= capacity and\n                    sum(demand[temp_other[1:-1]]) <= capacity):\n                    new_solution.append(temp_route)\n                    new_solution.append(temp_other)\n                    continue\n\n        # Step 3: Apply partial 3-opt on the route\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 4)\n            j = random.randint(i + 1, len(route) - 3)\n            k = random.randint(j + 1, len(route) - 2)\n\n            # Try different 3-opt configurations\n            for new_route in [\n                np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n                np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]]),\n            ]:\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n                    break\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    missing = all_customers - served\n    if missing:\n        # Reinsert missing customers into random routes\n        for customer in missing:\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                chosen_route = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[chosen_route]) - 1)\n                new_solution[chosen_route] = np.insert(new_solution[chosen_route], insert_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.7494307557779072,
            5.386818289756775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: Split long routes, reallocate customers, and apply partial 3-opt\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Step 1: Split long routes into two if possible\n        if random.random() < 0.3:  # 30% chance to attempt splitting\n            split_pos = len(route) // 2\n            route1 = route[:split_pos + 1]\n            route2 = route[split_pos:]\n            route2[0] = 0  # Ensure route2 starts at depot\n\n            # Check capacity feasibility\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.extend([route1, route2])\n                continue\n\n        # Step 2: Reallocate customers between routes if possible\n        if len(new_solution) > 1 and random.random() < 0.5:  # 50% chance to reallocate\n            other_route = random.choice([r for r in new_solution if r is not route])\n            if len(route) > 3 and len(other_route) > 3:\n                # Try moving a customer from current route to other route\n                candidate = random.choice(route[1:-1])\n                temp_route = np.delete(route, np.where(route == candidate))\n                temp_other = np.append(other_route, candidate)\n                temp_other = np.insert(temp_other, -1, 0)  # Ensure other_route ends at depot\n\n                if (sum(demand[temp_route[1:-1]]) <= capacity and\n                    sum(demand[temp_other[1:-1]]) <= capacity):\n                    new_solution.append(temp_route)\n                    new_solution.append(temp_other)\n                    continue\n\n        # Step 3: Apply partial 3-opt on the route\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 4)\n            j = random.randint(i + 1, len(route) - 3)\n            k = random.randint(j + 1, len(route) - 2)\n\n            # Try different 3-opt configurations\n            for new_route in [\n                np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n                np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]]),\n            ]:\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n                    break\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    missing = all_customers - served\n    if missing:\n        # Reinsert missing customers into random routes\n        for customer in missing:\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                chosen_route = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[chosen_route]) - 1)\n                new_solution[chosen_route] = np.insert(new_solution[chosen_route], insert_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Randomly select a segment to reverse (avoiding depot)\n        if len(selected_route) > 3:\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            selected_route[start:end] = selected_route[start:end][::-1]\n\n            # Check capacity constraint\n            route_demand = np.sum(demand[selected_route[1:-1]])\n            if route_demand > capacity:\n                # If invalid, revert the change\n                selected_route[start:end] = selected_route[start:end][::-1]\n\n        # Randomly select another route to merge (if possible)\n        if len(new_solution) > 1:\n            other_idx = np.random.randint(0, len(new_solution))\n            if other_idx != route_idx:\n                other_route = new_solution[other_idx]\n\n                # Try to merge the selected segment into the other route\n                if len(selected_route) > 3:\n                    segment = selected_route[start:end+1]\n                    segment_demand = np.sum(demand[segment[1:-1]])\n\n                    # Check if the other route can accommodate the segment\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    if other_route_demand + segment_demand <= capacity:\n                        # Insert the segment into the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n\n                        # Remove the segment from the original route\n                        selected_route = np.concatenate([selected_route[:start], selected_route[end+1:]])\n\n                        # Update the solution\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_idx] = other_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7211151966483017,
            0.5874643623828888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Randomly select a segment to reverse (avoiding depot)\n        if len(selected_route) > 3:\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            selected_route[start:end] = selected_route[start:end][::-1]\n\n            # Check capacity constraint\n            route_demand = np.sum(demand[selected_route[1:-1]])\n            if route_demand > capacity:\n                # If invalid, revert the change\n                selected_route[start:end] = selected_route[start:end][::-1]\n\n        # Randomly select another route to merge (if possible)\n        if len(new_solution) > 1:\n            other_idx = np.random.randint(0, len(new_solution))\n            if other_idx != route_idx:\n                other_route = new_solution[other_idx]\n\n                # Try to merge the selected segment into the other route\n                if len(selected_route) > 3:\n                    segment = selected_route[start:end+1]\n                    segment_demand = np.sum(demand[segment[1:-1]])\n\n                    # Check if the other route can accommodate the segment\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    if other_route_demand + segment_demand <= capacity:\n                        # Insert the segment into the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n\n                        # Remove the segment from the original route\n                        selected_route = np.concatenate([selected_route[:start], selected_route[end+1:]])\n\n                        # Update the solution\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_idx] = other_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a high-quality solution from the archive based on Pareto dominance and applies a hybrid local search combining route merging and customer reinsertion to balance distance and makespan objectives, while ensuring feasibility through demand and capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution = np.delete(new_solution, route2_idx, axis=0)\n\n    # Step 2: Customer reinsertion (move a customer from a long route to a short route if feasible)\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        longest_route = new_solution[longest_route_idx].copy()\n        shortest_route = new_solution[shortest_route_idx].copy()\n\n        if len(longest_route) > 3:  # Ensure there are customers to move\n            # Randomly select a customer from the longest route (excluding depot)\n            customer_idx = random.randint(1, len(longest_route) - 2)\n            customer = longest_route[customer_idx]\n\n            # Check if adding this customer to the shortest route is feasible\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from longest route\n                new_longest_route = np.delete(longest_route, customer_idx)\n                new_solution[longest_route_idx] = new_longest_route\n\n                # Insert customer into the shortest route (best position)\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate distance increase if inserted at position i\n                    dist_increase = (distance_matrix[shortest_route[i-1], customer] +\n                                     distance_matrix[customer, shortest_route[i]] -\n                                     distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n                # Insert customer into the shortest route\n                new_shortest_route = np.insert(shortest_route, best_pos, customer)\n                new_solution[shortest_route_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "score": [
            -0.6950344766421248,
            2.4838649928569794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution = np.delete(new_solution, route2_idx, axis=0)\n\n    # Step 2: Customer reinsertion (move a customer from a long route to a short route if feasible)\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        longest_route = new_solution[longest_route_idx].copy()\n        shortest_route = new_solution[shortest_route_idx].copy()\n\n        if len(longest_route) > 3:  # Ensure there are customers to move\n            # Randomly select a customer from the longest route (excluding depot)\n            customer_idx = random.randint(1, len(longest_route) - 2)\n            customer = longest_route[customer_idx]\n\n            # Check if adding this customer to the shortest route is feasible\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from longest route\n                new_longest_route = np.delete(longest_route, customer_idx)\n                new_solution[longest_route_idx] = new_longest_route\n\n                # Insert customer into the shortest route (best position)\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(shortest_route)):\n                    # Calculate distance increase if inserted at position i\n                    dist_increase = (distance_matrix[shortest_route[i-1], customer] +\n                                     distance_matrix[customer, shortest_route[i]] -\n                                     distance_matrix[shortest_route[i-1], shortest_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n                # Insert customer into the shortest route\n                new_shortest_route = np.insert(shortest_route, best_pos, customer)\n                new_solution[shortest_route_idx] = new_shortest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel hybrid local search operator that combines route merging, customer swapping across routes, and capacity-aware route splitting to balance distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][1] > np.mean([s[1][1] for s in archive]) or sol[1][0] > np.mean([s[1][0] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge routes, swap customers, and split routes\n    if len(new_solution) > 1:\n        # Merge two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [r for i, r in enumerate(new_solution) if i not in (route1_idx, route2_idx)]\n            new_solution.append(merged_route)\n        else:\n            # Swap customers between routes if possible\n            for _ in range(2):  # Try a few swaps\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select random customers (excluding depots)\n                    cust1 = random.choice(route1[1:-1])\n                    cust2 = random.choice(route2[1:-1])\n\n                    # Check capacity constraints\n                    new_route1 = route1[route1 != cust1]\n                    new_route2 = route2[route2 != cust2]\n                    new_route1 = np.insert(new_route1, -1, cust2)\n                    new_route2 = np.insert(new_route2, -1, cust1)\n\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Split long routes if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Arbitrary threshold for \"long\" routes\n            split_pos = random.randint(2, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = np.concatenate([[0], route[split_pos:]])\n\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.7145266058891906,
            1.6094829142093658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = [sol for sol in archive if sol[1][1] > np.mean([s[1][1] for s in archive]) or sol[1][0] > np.mean([s[1][0] for s in archive])]\n    if not candidates:\n        candidates = archive\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: merge routes, swap customers, and split routes\n    if len(new_solution) > 1:\n        # Merge two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            new_solution = [r for i, r in enumerate(new_solution) if i not in (route1_idx, route2_idx)]\n            new_solution.append(merged_route)\n        else:\n            # Swap customers between routes if possible\n            for _ in range(2):  # Try a few swaps\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select random customers (excluding depots)\n                    cust1 = random.choice(route1[1:-1])\n                    cust2 = random.choice(route2[1:-1])\n\n                    # Check capacity constraints\n                    new_route1 = route1[route1 != cust1]\n                    new_route2 = route2[route2 != cust2]\n                    new_route1 = np.insert(new_route1, -1, cust2)\n                    new_route2 = np.insert(new_route2, -1, cust1)\n\n                    if (sum(demand[new_route1[1:-1]]) <= capacity and\n                        sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Split long routes if possible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Arbitrary threshold for \"long\" routes\n            split_pos = random.randint(2, len(route) - 2)\n            first_part = route[:split_pos + 1]\n            second_part = np.concatenate([[0], route[split_pos:]])\n\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Prefer solutions with lower makespan, then lower total distance\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid Local Search Strategy:\n    # 1. Route Merging: Attempt to merge two shortest routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argmin([l if i != shortest_route_idx else float('inf') for i, l in enumerate(route_lengths)])\n\n        route1 = new_solution[shortest_route_idx]\n        route2 = new_solution[second_shortest_route_idx]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at the closest point\n            closest_pair = None\n            min_distance = float('inf')\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    d = distance_matrix[route1[i]][route2[j]]\n                    if d < min_distance:\n                        min_distance = d\n                        closest_pair = (i, j)\n\n            if closest_pair:\n                i, j = closest_pair\n                # Merge by inserting route2 into route1\n                merged_route = np.concatenate([route1[:i+1], route2[j+1:-1], route1[i+1:]])\n                new_solution = [merged_route] + [r for idx, r in enumerate(new_solution) if idx not in [shortest_route_idx, second_shortest_route_idx]]\n\n    # 2. Partial Route Reversal: Reverse a segment of a long route to reduce its length\n    if len(new_solution) > 0:\n        # Find the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Try reversing segments to find a shorter path\n        best_reversed_route = longest_route.copy()\n        best_length = sum(distance_matrix[best_reversed_route[i]][best_reversed_route[i+1]] for i in range(len(best_reversed_route)-1))\n\n        # Check all possible segment reversals\n        for i in range(1, len(longest_route)-1):\n            for j in range(i+1, len(longest_route)-1):\n                reversed_segment = longest_route[i:j+1][::-1]\n                candidate_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                candidate_length = sum(distance_matrix[candidate_route[k]][candidate_route[k+1]] for k in range(len(candidate_route)-1))\n\n                if candidate_length < best_length:\n                    best_length = candidate_length\n                    best_reversed_route = candidate_route\n\n        new_solution[longest_route_idx] = best_reversed_route\n\n    # 3. Demand-Aware Customer Reallocation: Move customers between routes to balance demands\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = sum(demand[node] for node in route[1:-1])\n        remaining_capacity = capacity - route_demand\n\n        # Try to reallocate customers from this route to others if it's underutilized\n        if remaining_capacity > 0:\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_route_demand = sum(demand[node] for node in other_route[1:-1])\n\n                # Find customers in other_route that can be moved to this route\n                for k in range(1, len(other_route)-1):\n                    node = other_route[k]\n                    if demand[node] <= remaining_capacity:\n                        # Check if moving this node improves the total distance\n                        old_distance = distance_matrix[other_route[k-1]][other_route[k]] + distance_matrix[other_route[k]][other_route[k+1]]\n                        new_distance = distance_matrix[other_route[k-1]][other_route[k+1]]\n\n                        if new_distance < old_distance:\n                            # Move the node to the current route\n                            new_route = np.concatenate([route[:-1], [node], route[-1:]])\n                            new_solution[i] = new_route\n                            new_solution[j] = np.concatenate([other_route[:k], other_route[k+1:]])\n                            remaining_capacity -= demand[node]\n                            break\n\n    # Ensure all routes are valid (start and end at depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot\")\n\n    return new_solution\n\n",
        "score": [
            -0.8738717497955352,
            7.695179462432861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Prefer solutions with lower makespan, then lower total distance\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid Local Search Strategy:\n    # 1. Route Merging: Attempt to merge two shortest routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argmin([l if i != shortest_route_idx else float('inf') for i, l in enumerate(route_lengths)])\n\n        route1 = new_solution[shortest_route_idx]\n        route2 = new_solution[second_shortest_route_idx]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at the closest point\n            closest_pair = None\n            min_distance = float('inf')\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    d = distance_matrix[route1[i]][route2[j]]\n                    if d < min_distance:\n                        min_distance = d\n                        closest_pair = (i, j)\n\n            if closest_pair:\n                i, j = closest_pair\n                # Merge by inserting route2 into route1\n                merged_route = np.concatenate([route1[:i+1], route2[j+1:-1], route1[i+1:]])\n                new_solution = [merged_route] + [r for idx, r in enumerate(new_solution) if idx not in [shortest_route_idx, second_shortest_route_idx]]\n\n    # 2. Partial Route Reversal: Reverse a segment of a long route to reduce its length\n    if len(new_solution) > 0:\n        # Find the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Try reversing segments to find a shorter path\n        best_reversed_route = longest_route.copy()\n        best_length = sum(distance_matrix[best_reversed_route[i]][best_reversed_route[i+1]] for i in range(len(best_reversed_route)-1))\n\n        # Check all possible segment reversals\n        for i in range(1, len(longest_route)-1):\n            for j in range(i+1, len(longest_route)-1):\n                reversed_segment = longest_route[i:j+1][::-1]\n                candidate_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                candidate_length = sum(distance_matrix[candidate_route[k]][candidate_route[k+1]] for k in range(len(candidate_route)-1))\n\n                if candidate_length < best_length:\n                    best_length = candidate_length\n                    best_reversed_route = candidate_route\n\n        new_solution[longest_route_idx] = best_reversed_route\n\n    # 3. Demand-Aware Customer Reallocation: Move customers between routes to balance demands\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = sum(demand[node] for node in route[1:-1])\n        remaining_capacity = capacity - route_demand\n\n        # Try to reallocate customers from this route to others if it's underutilized\n        if remaining_capacity > 0:\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                other_route_demand = sum(demand[node] for node in other_route[1:-1])\n\n                # Find customers in other_route that can be moved to this route\n                for k in range(1, len(other_route)-1):\n                    node = other_route[k]\n                    if demand[node] <= remaining_capacity:\n                        # Check if moving this node improves the total distance\n                        old_distance = distance_matrix[other_route[k-1]][other_route[k]] + distance_matrix[other_route[k]][other_route[k+1]]\n                        new_distance = distance_matrix[other_route[k-1]][other_route[k+1]]\n\n                        if new_distance < old_distance:\n                            # Move the node to the current route\n                            new_route = np.concatenate([route[:-1], [node], route[-1:]])\n                            new_solution[i] = new_route\n                            new_solution[j] = np.concatenate([other_route[:k], other_route[k+1:]])\n                            remaining_capacity -= demand[node]\n                            break\n\n    # Ensure all routes are valid (start and end at depot)\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            raise ValueError(\"Invalid route: must start and end at depot\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route-segment swapping with a novel demand-balanced route-merging step to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route-segment swapping + demand-balanced route-merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments and swap them\n        split_point = np.random.randint(1, len(route)-1)\n        swapped_route = np.concatenate([route[:split_point], route[split_point:][::-1]])\n\n        # Check capacity constraint\n        if np.sum(demand[swapped_route[1:-1]]) <= capacity:\n            new_solution.append(swapped_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Demand-balanced route-merging step\n    if len(new_solution) > 1:\n        # Find the route with the smallest demand\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        min_demand_idx = np.argmin(demands)\n\n        # Try to merge it with another route\n        for i in range(len(new_solution)):\n            if i == min_demand_idx:\n                continue\n\n            # Check if merging is possible\n            merged_route = np.concatenate([new_solution[min_demand_idx][:-1], new_solution[i][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(min_demand_idx)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6062976658252406,
            1.1476193964481354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Route-segment swapping + demand-balanced route-merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments and swap them\n        split_point = np.random.randint(1, len(route)-1)\n        swapped_route = np.concatenate([route[:split_point], route[split_point:][::-1]])\n\n        # Check capacity constraint\n        if np.sum(demand[swapped_route[1:-1]]) <= capacity:\n            new_solution.append(swapped_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Demand-balanced route-merging step\n    if len(new_solution) > 1:\n        # Find the route with the smallest demand\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        min_demand_idx = np.argmin(demands)\n\n        # Try to merge it with another route\n        for i in range(len(new_solution)):\n            if i == min_demand_idx:\n                continue\n\n            # Check if merging is possible\n            merged_route = np.concatenate([new_solution[min_demand_idx][:-1], new_solution[i][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                new_solution.pop(min_demand_idx)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment for reallocation\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find best insertion point in another route\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        for i, candidate_route in enumerate(selected_solution):\n            if candidate_route is route:\n                continue\n\n            # Check capacity constraint\n            if sum(demand[node] for node in candidate_route[1:-1]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost (considering distance savings)\n                insertion_cost = (distance_matrix[candidate_route[pos-1], segment[0]] +\n                                distance_matrix[segment[-1], candidate_route[pos]] -\n                                distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_route = candidate_route\n                    best_pos = pos\n\n        # Perform the best insertion if found\n        if best_route is not None:\n            # Remove segment from original route\n            modified_route = np.concatenate([route[:start_idx], route[end_idx:]])\n\n            # Insert segment into best position in best_route\n            new_route = np.concatenate([best_route[:best_pos], segment, best_route[best_pos:]])\n\n            # Update solution\n            new_solution.append(modified_route)\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Merge very short routes with nearby routes if possible\n    final_solution = []\n    for route in new_solution:\n        if len(route) <= 3 and len(route) > 1:  # Very short route\n            best_merge_route = None\n            best_merge_cost = float('inf')\n\n            for candidate_route in new_solution:\n                if candidate_route is route:\n                    continue\n\n                # Check capacity constraint\n                if sum(demand[node] for node in candidate_route[1:-1]) + sum(demand[node] for node in route[1:-1]) > capacity:\n                    continue\n\n                # Calculate merge cost\n                merge_cost = (distance_matrix[candidate_route[-2], route[1]] +\n                             distance_matrix[route[-2], candidate_route[-2]] -\n                             distance_matrix[candidate_route[-2], candidate_route[-2]])\n\n                if merge_cost < best_merge_cost:\n                    best_merge_cost = merge_cost\n                    best_merge_route = candidate_route\n\n            if best_merge_route is not None:\n                # Merge routes\n                merged_route = np.concatenate([best_merge_route[:-1], route[1:]])\n                final_solution.append(merged_route)\n            else:\n                final_solution.append(route.copy())\n        else:\n            final_solution.append(route.copy())\n\n    return final_solution\n\n",
        "score": [
            -0.7433334965928321,
            2.9328187108039856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment for reallocation\n        start_idx = random.randint(1, len(route) - 3)\n        end_idx = random.randint(start_idx + 1, len(route) - 2)\n        segment = route[start_idx:end_idx]\n\n        # Calculate segment demand\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Find best insertion point in another route\n        best_route = None\n        best_pos = None\n        best_cost = float('inf')\n\n        for i, candidate_route in enumerate(selected_solution):\n            if candidate_route is route:\n                continue\n\n            # Check capacity constraint\n            if sum(demand[node] for node in candidate_route[1:-1]) + segment_demand > capacity:\n                continue\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                # Calculate insertion cost (considering distance savings)\n                insertion_cost = (distance_matrix[candidate_route[pos-1], segment[0]] +\n                                distance_matrix[segment[-1], candidate_route[pos]] -\n                                distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n\n                if insertion_cost < best_cost:\n                    best_cost = insertion_cost\n                    best_route = candidate_route\n                    best_pos = pos\n\n        # Perform the best insertion if found\n        if best_route is not None:\n            # Remove segment from original route\n            modified_route = np.concatenate([route[:start_idx], route[end_idx:]])\n\n            # Insert segment into best position in best_route\n            new_route = np.concatenate([best_route[:best_pos], segment, best_route[best_pos:]])\n\n            # Update solution\n            new_solution.append(modified_route)\n            new_solution.append(new_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Merge very short routes with nearby routes if possible\n    final_solution = []\n    for route in new_solution:\n        if len(route) <= 3 and len(route) > 1:  # Very short route\n            best_merge_route = None\n            best_merge_cost = float('inf')\n\n            for candidate_route in new_solution:\n                if candidate_route is route:\n                    continue\n\n                # Check capacity constraint\n                if sum(demand[node] for node in candidate_route[1:-1]) + sum(demand[node] for node in route[1:-1]) > capacity:\n                    continue\n\n                # Calculate merge cost\n                merge_cost = (distance_matrix[candidate_route[-2], route[1]] +\n                             distance_matrix[route[-2], candidate_route[-2]] -\n                             distance_matrix[candidate_route[-2], candidate_route[-2]])\n\n                if merge_cost < best_merge_cost:\n                    best_merge_cost = merge_cost\n                    best_merge_route = candidate_route\n\n            if best_merge_route is not None:\n                # Merge routes\n                merged_route = np.concatenate([best_merge_route[:-1], route[1:]])\n                final_solution.append(merged_route)\n            else:\n                final_solution.append(route.copy())\n        else:\n            final_solution.append(route.copy())\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining route-splitting, node insertion, and 2-opt with capacity checks to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for distance to prioritize diversity\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(5):  # Number of search iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Option 1: Split a route at a random point\n        if len(route) > 4 and random.random() < 0.3:\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Option 2: Move a random node to another route\n        if len(new_solution) > 1 and random.random() < 0.5:\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            target_route = new_solution[target_route_idx]\n            if len(route) > 3:\n                node_pos = random.randint(1, len(route) - 2)\n                node = route[node_pos]\n                if (np.sum(demand[target_route[1:-1]]) + demand[node] <= capacity):\n                    # Insert node into target route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1], node] +\n                                distance_matrix[node, target_route[pos]] -\n                                distance_matrix[target_route[pos-1], target_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, node)\n                    new_solution[target_route_idx] = target_route\n                    route = np.delete(route, node_pos)\n                    new_solution[route_idx] = route\n\n        # Option 3: 2-opt within a route with capacity check\n        if len(route) > 4 and random.random() < 0.4:\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            if i + 1 < j:\n                segment = route[i:j+1]\n                reversed_segment = segment[::-1]\n                if np.sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.3405309861748047,
            0.6091518402099609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for distance to prioritize diversity\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(5):  # Number of search iterations\n        # Randomly select a route to modify\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Option 1: Split a route at a random point\n        if len(route) > 4 and random.random() < 0.3:\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Option 2: Move a random node to another route\n        if len(new_solution) > 1 and random.random() < 0.5:\n            target_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            target_route = new_solution[target_route_idx]\n            if len(route) > 3:\n                node_pos = random.randint(1, len(route) - 2)\n                node = route[node_pos]\n                if (np.sum(demand[target_route[1:-1]]) + demand[node] <= capacity):\n                    # Insert node into target route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1], node] +\n                                distance_matrix[node, target_route[pos]] -\n                                distance_matrix[target_route[pos-1], target_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    target_route = np.insert(target_route, best_pos, node)\n                    new_solution[target_route_idx] = target_route\n                    route = np.delete(route, node_pos)\n                    new_solution[route_idx] = route\n\n        # Option 3: 2-opt within a route with capacity check\n        if len(route) > 4 and random.random() < 0.4:\n            i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n            if i + 1 < j:\n                segment = route[i:j+1]\n                reversed_segment = segment[::-1]\n                if np.sum(demand[reversed_segment[1:-1]]) <= capacity:\n                    new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high total distance or high makespan, then applies a hybrid local search combining route merging, customer reallocation, and adaptive 2-opt to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + customer reallocation + adaptive 2-opt\n    if len(new_solution) > 1:\n        # Route merging: merge two shortest routes if capacity allows\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_routes = sorted(range(len(new_solution)), key=lambda x: route_lengths[x])\n        r1, r2 = sorted_routes[0], sorted_routes[1]\n\n        total_demand_r1 = sum(demand[node] for node in new_solution[r1][1:-1])\n        total_demand_r2 = sum(demand[node] for node in new_solution[r2][1:-1])\n\n        if total_demand_r1 + total_demand_r2 <= capacity:\n            merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n            new_solution.pop(max(r1, r2))\n            new_solution.pop(min(r1, r2))\n            new_solution.append(merged_route)\n\n    # Customer reallocation: move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers to move\n            for _ in range(2):  # Try moving 2 customers\n                if len(route) <= 4:\n                    break\n                # Select a random customer to move\n                customer_idx = random.randint(1, len(route)-2)\n                customer = route[customer_idx]\n\n                # Check if moving this customer to another route is feasible\n                for other_route in new_solution:\n                    if np.array_equal(route, other_route):\n                        continue\n                    total_demand = sum(demand[node] for node in other_route[1:-1])\n                    if total_demand + demand[customer] <= capacity:\n                        # Insert customer into the other route\n                        other_route = np.insert(other_route, -1, customer)\n                        route = np.delete(route, customer_idx)\n                        break\n\n    # Adaptive 2-opt: apply 2-opt with probability based on route length\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:\n            # Probability of applying 2-opt based on route length (longer routes get higher chance)\n            route_length = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1))\n            avg_length = sum(sum(distance_matrix[r[j], r[j+1]] for j in range(len(r)-1)) for r in new_solution) / len(new_solution)\n            if route_length > avg_length and random.random() < 0.7:\n                # Perform 2-opt on this route\n                best_improvement = 0\n                best_i, best_j = -1, -1\n                for i1 in range(1, len(route)-2):\n                    for j1 in range(i1+1, len(route)-1):\n                        # Calculate the change in distance\n                        delta = (distance_matrix[route[i1-1], route[i1]] +\n                                distance_matrix[route[j1], route[j1+1]]) - \\\n                               (distance_matrix[route[i1-1], route[j1]] +\n                                distance_matrix[route[i1], route[j1+1]])\n                        if delta < best_improvement:\n                            best_improvement = delta\n                            best_i, best_j = i1, j1\n                if best_i != -1:\n                    # Reverse the segment between best_i and best_j\n                    new_solution[i] = np.concatenate([route[:best_i], route[best_i:best_j+1][::-1], route[best_j+1:]])\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If capacity is exceeded, split the route\n            split_idx = 1\n            current_demand = 0\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_idx = i\n                    break\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.6517254906790695,
            9.432325005531311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + customer reallocation + adaptive 2-opt\n    if len(new_solution) > 1:\n        # Route merging: merge two shortest routes if capacity allows\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        sorted_routes = sorted(range(len(new_solution)), key=lambda x: route_lengths[x])\n        r1, r2 = sorted_routes[0], sorted_routes[1]\n\n        total_demand_r1 = sum(demand[node] for node in new_solution[r1][1:-1])\n        total_demand_r2 = sum(demand[node] for node in new_solution[r2][1:-1])\n\n        if total_demand_r1 + total_demand_r2 <= capacity:\n            merged_route = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n            new_solution.pop(max(r1, r2))\n            new_solution.pop(min(r1, r2))\n            new_solution.append(merged_route)\n\n    # Customer reallocation: move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with enough customers to move\n            for _ in range(2):  # Try moving 2 customers\n                if len(route) <= 4:\n                    break\n                # Select a random customer to move\n                customer_idx = random.randint(1, len(route)-2)\n                customer = route[customer_idx]\n\n                # Check if moving this customer to another route is feasible\n                for other_route in new_solution:\n                    if np.array_equal(route, other_route):\n                        continue\n                    total_demand = sum(demand[node] for node in other_route[1:-1])\n                    if total_demand + demand[customer] <= capacity:\n                        # Insert customer into the other route\n                        other_route = np.insert(other_route, -1, customer)\n                        route = np.delete(route, customer_idx)\n                        break\n\n    # Adaptive 2-opt: apply 2-opt with probability based on route length\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:\n            # Probability of applying 2-opt based on route length (longer routes get higher chance)\n            route_length = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route)-1))\n            avg_length = sum(sum(distance_matrix[r[j], r[j+1]] for j in range(len(r)-1)) for r in new_solution) / len(new_solution)\n            if route_length > avg_length and random.random() < 0.7:\n                # Perform 2-opt on this route\n                best_improvement = 0\n                best_i, best_j = -1, -1\n                for i1 in range(1, len(route)-2):\n                    for j1 in range(i1+1, len(route)-1):\n                        # Calculate the change in distance\n                        delta = (distance_matrix[route[i1-1], route[i1]] +\n                                distance_matrix[route[j1], route[j1+1]]) - \\\n                               (distance_matrix[route[i1-1], route[j1]] +\n                                distance_matrix[route[i1], route[j1+1]])\n                        if delta < best_improvement:\n                            best_improvement = delta\n                            best_i, best_j = i1, j1\n                if best_i != -1:\n                    # Reverse the segment between best_i and best_j\n                    new_solution[i] = np.concatenate([route[:best_i], route[best_i:best_j+1][::-1], route[best_j+1:]])\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If capacity is exceeded, split the route\n            split_idx = 1\n            current_demand = 0\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_idx = i\n                    break\n            new_route1 = np.concatenate([route[:split_idx], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring lower total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and a novel \"route fusion\" operator that merges compatible routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Route splitting with capacity check\n        route_to_split = random.choice([r for r in new_solution if len(r) > 3])\n        split_pos = random.randint(1, len(route_to_split) - 2)\n        new_route1 = np.concatenate([route_to_split[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], route_to_split[split_pos + 1:]])\n\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n            new_solution.extend([new_route1, new_route2])\n\n    # Customer reinsertion with capacity check\n    if len(new_solution) > 1:\n        source_route = random.choice([r for r in new_solution if len(r) > 3])\n        customer_idx = random.choice(range(1, len(source_route) - 1))\n        customer = source_route[customer_idx]\n\n        # Try inserting into other routes\n        for target_route in new_solution:\n            if len(target_route) < 3:\n                continue\n            for pos in range(1, len(target_route)):\n                temp_route = np.insert(target_route, pos, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_route = temp_route.copy()\n                    new_solution = [r for r in new_solution if not np.array_equal(r, source_route)]\n                    new_solution = [r for r in new_solution if not np.array_equal(r, target_route)]\n                    new_solution.extend([np.delete(source_route, customer_idx), new_route])\n                    break\n\n    # Route fusion operator (novel)\n    if len(new_solution) > 1:\n        route1, route2 = random.sample(new_solution, 2)\n        if len(route1) + len(route2) - 3 <= 20:  # Limit route length for efficiency\n            combined_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                new_solution.append(combined_route)\n\n    return new_solution\n\n",
        "score": [
            -0.5641143444623419,
            5.831803798675537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Route splitting with capacity check\n        route_to_split = random.choice([r for r in new_solution if len(r) > 3])\n        split_pos = random.randint(1, len(route_to_split) - 2)\n        new_route1 = np.concatenate([route_to_split[:split_pos + 1], [0]])\n        new_route2 = np.concatenate([[0], route_to_split[split_pos + 1:]])\n\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n            new_solution.extend([new_route1, new_route2])\n\n    # Customer reinsertion with capacity check\n    if len(new_solution) > 1:\n        source_route = random.choice([r for r in new_solution if len(r) > 3])\n        customer_idx = random.choice(range(1, len(source_route) - 1))\n        customer = source_route[customer_idx]\n\n        # Try inserting into other routes\n        for target_route in new_solution:\n            if len(target_route) < 3:\n                continue\n            for pos in range(1, len(target_route)):\n                temp_route = np.insert(target_route, pos, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_route = temp_route.copy()\n                    new_solution = [r for r in new_solution if not np.array_equal(r, source_route)]\n                    new_solution = [r for r in new_solution if not np.array_equal(r, target_route)]\n                    new_solution.extend([np.delete(source_route, customer_idx), new_route])\n                    break\n\n    # Route fusion operator (novel)\n    if len(new_solution) > 1:\n        route1, route2 = random.sample(new_solution, 2)\n        if len(route1) + len(route2) - 3 <= 20:  # Limit route length for efficiency\n            combined_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                new_solution = [r for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)]\n                new_solution.append(combined_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Calculate demands for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        # Check feasibility after split\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break  # Apply only one split per iteration\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) <= 3:\n                continue\n\n            # Select a random customer (excluding depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Check if adding to route2 is feasible\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + demand[customer] <= capacity:\n                # Insert customer into route2 (random position)\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.insert(route2, insert_pos, customer)\n\n                # Remove customer from route1\n                new_route1 = np.delete(route1, customer_idx)\n\n                # Update the solution if it improves makespan\n                new_makespan = max(\n                    sum(distance_matrix[new_route1[k]][new_route1[k+1]] for k in range(len(new_route1)-1)),\n                    sum(distance_matrix[new_route2[k]][new_route2[k+1]] for k in range(len(new_route2)-1))\n                )\n                old_makespan = max(\n                    sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)),\n                    sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                )\n\n                if new_makespan <= old_makespan:\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8244953483988353,
            7.961588263511658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Calculate demands for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        # Check feasibility after split\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            break  # Apply only one split per iteration\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) <= 3:\n                continue\n\n            # Select a random customer (excluding depot)\n            customer_idx = np.random.randint(1, len(route1) - 1)\n            customer = route1[customer_idx]\n\n            # Check if adding to route2 is feasible\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + demand[customer] <= capacity:\n                # Insert customer into route2 (random position)\n                insert_pos = np.random.randint(1, len(route2))\n                new_route2 = np.insert(route2, insert_pos, customer)\n\n                # Remove customer from route1\n                new_route1 = np.delete(route1, customer_idx)\n\n                # Update the solution if it improves makespan\n                new_makespan = max(\n                    sum(distance_matrix[new_route1[k]][new_route1[k+1]] for k in range(len(new_route1)-1)),\n                    sum(distance_matrix[new_route2[k]][new_route2[k+1]] for k in range(len(new_route2)-1))\n                )\n                old_makespan = max(\n                    sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)),\n                    sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                )\n\n                if new_makespan <= old_makespan:\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The algorithm selects a solution from the archive with the highest total distance and applies a hybrid local search operator that combines route segmentation and demand-aware 2-opt to generate a neighbor solution, ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n    total_distances = [obj[0] for obj in archive_objectives]\n    max_distance_idx = total_distances.index(max(total_distances))\n    base_solution = archive_solutions[max_distance_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Segment the route into parts\n        segment_size = max(3, len(route) // 3)\n        segments = [route[i:i+segment_size] for i in range(0, len(route)-1, segment_size-1)]\n\n        # Apply demand-aware 2-opt within segments\n        for seg in segments:\n            if len(seg) < 4:\n                continue\n            i, j = random.sample(range(1, len(seg)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Check demand feasibility\n            seg_demand = sum(demand[seg[k]] for k in range(i, j+1))\n            if seg_demand > capacity:\n                continue\n            # Reverse segment and check distance improvement\n            original_dist = distance_matrix[seg[i-1]][seg[i]] + distance_matrix[seg[j]][seg[j+1]]\n            new_dist = distance_matrix[seg[i-1]][seg[j]] + distance_matrix[seg[i]][seg[j+1]]\n            if new_dist < original_dist:\n                seg[i:j+1] = seg[i:j+1][::-1]\n\n        # Reconstruct the route from segments\n        new_route = []\n        for seg in segments:\n            new_route.extend(seg[:-1])\n        new_route.append(0)\n        new_solution[route_idx] = np.array(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7452912571586793,
            2.909121096134186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n    total_distances = [obj[0] for obj in archive_objectives]\n    max_distance_idx = total_distances.index(max(total_distances))\n    base_solution = archive_solutions[max_distance_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 4:  # Skip very short routes\n            continue\n\n        # Segment the route into parts\n        segment_size = max(3, len(route) // 3)\n        segments = [route[i:i+segment_size] for i in range(0, len(route)-1, segment_size-1)]\n\n        # Apply demand-aware 2-opt within segments\n        for seg in segments:\n            if len(seg) < 4:\n                continue\n            i, j = random.sample(range(1, len(seg)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Check demand feasibility\n            seg_demand = sum(demand[seg[k]] for k in range(i, j+1))\n            if seg_demand > capacity:\n                continue\n            # Reverse segment and check distance improvement\n            original_dist = distance_matrix[seg[i-1]][seg[i]] + distance_matrix[seg[j]][seg[j+1]]\n            new_dist = distance_matrix[seg[i-1]][seg[j]] + distance_matrix[seg[i]][seg[j+1]]\n            if new_dist < original_dist:\n                seg[i:j+1] = seg[i:j+1][::-1]\n\n        # Reconstruct the route from segments\n        new_route = []\n        for seg in segments:\n            new_route.extend(seg[:-1])\n        new_route.append(0)\n        new_solution[route_idx] = np.array(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search operator that combines intra-route 2-opt with inter-route node swapping and demand-aware route merging to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_dist, makespan = obj\n        # Prefer solutions with high makespan or high total distance\n        score = makespan + 0.5 * total_dist\n        candidates.append((score, sol.copy()))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Select the top 3 candidates and pick one randomly\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected = random.choice(candidates[:min(3, len(candidates))])[1]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with demand-aware swaps and route merging\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Intra-route 2-opt with demand check\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check if reversing the segment respects capacity\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            if (sum(demand[node] for node in reversed_segment) <= capacity and\n                sum(demand[node] for node in route[i:j+1]) <= capacity):\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                new_solution[route_idx] = new_route\n\n        # Step 2: Inter-route node swapping with demand check\n        if len(new_solution) > 1:\n            r1, r2 = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[r1], new_solution[r2]\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n            # Select random nodes (excluding depot)\n            n1 = random.randint(1, len(route1)-2)\n            n2 = random.randint(1, len(route2)-2)\n            node1, node2 = route1[n1], route2[n2]\n            # Check capacity feasibility\n            new_route1 = np.concatenate([route1[:n1], [node2], route1[n1+1:]])\n            new_route2 = np.concatenate([route2[:n2], [node1], route2[n2+1:]])\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n        # Step 3: Demand-aware route merging\n        if len(new_solution) > 1:\n            r1, r2 = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[r1], new_solution[r2]\n            if (sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity):\n                # Merge routes by inserting route2 into route1\n                insert_pos = random.randint(1, len(route1)-1)\n                merged_route = np.concatenate([route1[:insert_pos], route2[1:-1], route1[insert_pos:]])\n                new_solution[r1] = merged_route\n                new_solution = [r for i, r in enumerate(new_solution) if i != r2]\n\n    return new_solution\n\n",
        "score": [
            -0.7125102343786165,
            1.7021008431911469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_dist, makespan = obj\n        # Prefer solutions with high makespan or high total distance\n        score = makespan + 0.5 * total_dist\n        candidates.append((score, sol.copy()))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Select the top 3 candidates and pick one randomly\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected = random.choice(candidates[:min(3, len(candidates))])[1]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with demand-aware swaps and route merging\n    for _ in range(3):  # Perform multiple iterations\n        # Step 1: Intra-route 2-opt with demand check\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            # Check if reversing the segment respects capacity\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            if (sum(demand[node] for node in reversed_segment) <= capacity and\n                sum(demand[node] for node in route[i:j+1]) <= capacity):\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n                new_solution[route_idx] = new_route\n\n        # Step 2: Inter-route node swapping with demand check\n        if len(new_solution) > 1:\n            r1, r2 = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[r1], new_solution[r2]\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n            # Select random nodes (excluding depot)\n            n1 = random.randint(1, len(route1)-2)\n            n2 = random.randint(1, len(route2)-2)\n            node1, node2 = route1[n1], route2[n2]\n            # Check capacity feasibility\n            new_route1 = np.concatenate([route1[:n1], [node2], route1[n1+1:]])\n            new_route2 = np.concatenate([route2[:n2], [node1], route2[n2+1:]])\n            if (sum(demand[node] for node in new_route1) <= capacity and\n                sum(demand[node] for node in new_route2) <= capacity):\n                new_solution[r1] = new_route1\n                new_solution[r2] = new_route2\n\n        # Step 3: Demand-aware route merging\n        if len(new_solution) > 1:\n            r1, r2 = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[r1], new_solution[r2]\n            if (sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity):\n                # Merge routes by inserting route2 into route1\n                insert_pos = random.randint(1, len(route1)-1)\n                merged_route = np.concatenate([route1[:insert_pos], route2[1:-1], route1[insert_pos:]])\n                new_solution[r1] = merged_route\n                new_solution = [r for i, r in enumerate(new_solution) if i != r2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n    # Reinsert customers from routes that exceed capacity\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reinsert\n            over_capacity = np.sum(demand[route[1:-1]]) - capacity\n            customers = route[1:-1]\n            np.random.shuffle(customers)\n            to_reinsert = []\n            current_load = 0\n\n            for customer in customers:\n                if current_load + demand[customer] <= over_capacity:\n                    current_load += demand[customer]\n                    to_reinsert.append(customer)\n\n            # Remove from current route\n            new_solution[i] = np.array([0] + [c for c in route[1:-1] if c not in to_reinsert] + [0])\n\n            # Try to insert into other routes\n            for customer in to_reinsert:\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    route_to_insert = new_solution[j]\n                    for pos in range(1, len(route_to_insert)):\n                        # Insert customer at position pos\n                        new_route = np.concatenate([\n                            route_to_insert[:pos],\n                            [customer],\n                            route_to_insert[pos:]\n                        ])\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[route_to_insert[pos-1]][customer] +\n                                   distance_matrix[customer][route_to_insert[pos]] -\n                                   distance_matrix[route_to_insert[pos-1]][route_to_insert[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = j\n                                best_pos = pos\n\n                if best_route is not None:\n                    # Perform the insertion\n                    route_to_insert = new_solution[best_route]\n                    new_solution[best_route] = np.concatenate([\n                        route_to_insert[:best_pos],\n                        [customer],\n                        route_to_insert[best_pos:]\n                    ])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8580098659076074,
            1.00507253408432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n\n    # Reinsert customers from routes that exceed capacity\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reinsert\n            over_capacity = np.sum(demand[route[1:-1]]) - capacity\n            customers = route[1:-1]\n            np.random.shuffle(customers)\n            to_reinsert = []\n            current_load = 0\n\n            for customer in customers:\n                if current_load + demand[customer] <= over_capacity:\n                    current_load += demand[customer]\n                    to_reinsert.append(customer)\n\n            # Remove from current route\n            new_solution[i] = np.array([0] + [c for c in route[1:-1] if c not in to_reinsert] + [0])\n\n            # Try to insert into other routes\n            for customer in to_reinsert:\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for j in range(len(new_solution)):\n                    if i == j:\n                        continue\n                    route_to_insert = new_solution[j]\n                    for pos in range(1, len(route_to_insert)):\n                        # Insert customer at position pos\n                        new_route = np.concatenate([\n                            route_to_insert[:pos],\n                            [customer],\n                            route_to_insert[pos:]\n                        ])\n                        if np.sum(demand[new_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost\n                            cost = (distance_matrix[route_to_insert[pos-1]][customer] +\n                                   distance_matrix[customer][route_to_insert[pos]] -\n                                   distance_matrix[route_to_insert[pos-1]][route_to_insert[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = j\n                                best_pos = pos\n\n                if best_route is not None:\n                    # Perform the insertion\n                    route_to_insert = new_solution[best_route]\n                    new_solution[best_route] = np.concatenate([\n                        route_to_insert[:best_pos],\n                        [customer],\n                        route_to_insert[best_pos:]\n                    ])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route segment swaps and demand-balanced route merges to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: segment swap + demand-balanced merge\n    new_solution = selected_solution.copy()\n\n    # Step 1: Segment Swap\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg1 = route1[seg1_start:seg1_end + 1]\n\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Check capacity constraints for swaps\n            demand1 = sum(demand[seg1])\n            demand2 = sum(demand[seg2])\n\n            # Swap segments if feasible\n            if (sum(demand[route1]) - demand1 + demand2 <= capacity) and \\\n               (sum(demand[route2]) - demand2 + demand1 <= capacity):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Demand-Balanced Merge\n    if len(new_solution) > 1:\n        # Find two routes with complementary demands\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                total_demand1 = sum(demand[route1[1:-1]])  # Exclude depot\n                total_demand2 = sum(demand[route2[1:-1]])\n\n                if total_demand1 + total_demand2 <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.576358822860557,
            1.554182529449463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: segment swap + demand-balanced merge\n    new_solution = selected_solution.copy()\n\n    # Step 1: Segment Swap\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg1 = route1[seg1_start:seg1_end + 1]\n\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n            seg2 = route2[seg2_start:seg2_end + 1]\n\n            # Check capacity constraints for swaps\n            demand1 = sum(demand[seg1])\n            demand2 = sum(demand[seg2])\n\n            # Swap segments if feasible\n            if (sum(demand[route1]) - demand1 + demand2 <= capacity) and \\\n               (sum(demand[route2]) - demand2 + demand1 <= capacity):\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end + 1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Demand-Balanced Merge\n    if len(new_solution) > 1:\n        # Find two routes with complementary demands\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                total_demand1 = sum(demand[route1[1:-1]])  # Exclude depot\n                total_demand2 = sum(demand[route2[1:-1]])\n\n                if total_demand1 + total_demand2 <= capacity:\n                    # Merge the two routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a solution with high total distance or makespan from the archive, then applies a hybrid local search combining route merging, customer reallocation, and 3-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Route merging: try to merge two routes if possible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Customer reallocation: move a customer from one route to another\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n        # Select a customer from route1\n        customer = random.choice(route1[1:-1])\n        # Check if adding to route2 is feasible\n        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer to route2\n            new_route2 = np.insert(route2, best_pos, customer)\n            # Remove customer from route1\n            new_route1 = route1[route1 != customer]\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    # 3-opt move: apply to a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select three distinct edges\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt moves\n            for i in range(8):\n                if i == 0:\n                    new_route = np.concatenate([route[:a], route[b:c+1][::-1], route[c+1:]])\n                elif i == 1:\n                    new_route = np.concatenate([route[:a], route[b:c+1], route[c+1:]])\n                elif i == 2:\n                    new_route = np.concatenate([route[:a+1], route[b:c+1][::-1], route[c+1:]])\n                elif i == 3:\n                    new_route = np.concatenate([route[:a+1], route[b:c+1], route[c+1:]])\n                elif i == 4:\n                    new_route = np.concatenate([route[:a+1], route[c+1:b], route[b:c+1][::-1], route[a+1:]])\n                elif i == 5:\n                    new_route = np.concatenate([route[:a+1], route[c+1:b], route[b:c+1], route[a+1:]])\n                elif i == 6:\n                    new_route = np.concatenate([route[:b], route[a:c+1][::-1], route[c+1:]])\n                elif i == 7:\n                    new_route = np.concatenate([route[:b], route[a:c+1], route[c+1:]])\n                # Check feasibility\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6672643530425892,
            0.43662965297698975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Route merging: try to merge two routes if possible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Customer reallocation: move a customer from one route to another\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n        # Select a customer from route1\n        customer = random.choice(route1[1:-1])\n        # Check if adding to route2 is feasible\n        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            # Find best insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer to route2\n            new_route2 = np.insert(route2, best_pos, customer)\n            # Remove customer from route1\n            new_route1 = route1[route1 != customer]\n            new_solution[i] = new_route1\n            new_solution[j] = new_route2\n\n    # 3-opt move: apply to a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select three distinct edges\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt moves\n            for i in range(8):\n                if i == 0:\n                    new_route = np.concatenate([route[:a], route[b:c+1][::-1], route[c+1:]])\n                elif i == 1:\n                    new_route = np.concatenate([route[:a], route[b:c+1], route[c+1:]])\n                elif i == 2:\n                    new_route = np.concatenate([route[:a+1], route[b:c+1][::-1], route[c+1:]])\n                elif i == 3:\n                    new_route = np.concatenate([route[:a+1], route[b:c+1], route[c+1:]])\n                elif i == 4:\n                    new_route = np.concatenate([route[:a+1], route[c+1:b], route[b:c+1][::-1], route[a+1:]])\n                elif i == 5:\n                    new_route = np.concatenate([route[:a+1], route[c+1:b], route[b:c+1], route[a+1:]])\n                elif i == 6:\n                    new_route = np.concatenate([route[:b], route[a:c+1][::-1], route[c+1:]])\n                elif i == 7:\n                    new_route = np.concatenate([route[:b], route[a:c+1], route[c+1:]])\n                # Check feasibility\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route (highest makespan) in the base solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split the longest route and reinsert segments into other routes\n    if len(longest_route) > 3:  # Ensure the route has at least one customer to split\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        segment = longest_route[split_pos:-1]\n\n        # Remove the segment from the longest route\n        new_longest_route = np.concatenate([longest_route[:split_pos], [0]])\n        new_solution[longest_route_idx] = new_longest_route\n\n        # Try to reinsert the segment into other routes\n        inserted = False\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[segment]) + sum(demand[route[1:-1]]) <= capacity:\n                # Insert the segment into this route\n                new_route = np.concatenate([route[:-1], segment, [0]])\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        # If not inserted, create a new route\n        if not inserted:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, split the route into two\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_pos = np.argmax(cumulative_demand > capacity) + 1\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n",
        "score": [
            -0.6420041225010817,
            1.7682523429393768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route (highest makespan) in the base solution\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Apply a hybrid local search: split the longest route and reinsert segments into other routes\n    if len(longest_route) > 3:  # Ensure the route has at least one customer to split\n        # Randomly select a segment to split\n        split_pos = np.random.randint(1, len(longest_route) - 1)\n        segment = longest_route[split_pos:-1]\n\n        # Remove the segment from the longest route\n        new_longest_route = np.concatenate([longest_route[:split_pos], [0]])\n        new_solution[longest_route_idx] = new_longest_route\n\n        # Try to reinsert the segment into other routes\n        inserted = False\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx and sum(demand[segment]) + sum(demand[route[1:-1]]) <= capacity:\n                # Insert the segment into this route\n                new_route = np.concatenate([route[:-1], segment, [0]])\n                new_solution[i] = new_route\n                inserted = True\n                break\n\n        # If not inserted, create a new route\n        if not inserted:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, split the route into two\n            cumulative_demand = np.cumsum(demand[route[1:-1]])\n            split_pos = np.argmax(cumulative_demand > capacity) + 1\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n            new_solution.remove(route)\n            new_solution.extend([new_route1, new_route2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (capacity constraint)\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them at the closest points\n            min_dist = float('inf')\n            best_merge = (0, 0)\n            for a in range(1, len(route1)):\n                for b in range(1, len(route2)):\n                    dist = distance_matrix[route1[a-1]][route2[b]] + distance_matrix[route2[b-1]][route1[a]]\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_merge = (a, b)\n\n            a, b = best_merge\n            merged_route = np.concatenate([route1[:a], route2[b:], route2[:b], route1[a:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n        else:\n            # If merging is not feasible, try relocating a customer from one route to another\n            for route in new_solution:\n                if len(route) > 3:  # Ensure there are customers to relocate\n                    customer = random.choice(route[1:-1])\n                    for other_route in new_solution:\n                        if other_route is not route and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find the best insertion point for the customer\n                            min_dist = float('inf')\n                            best_pos = 0\n                            for pos in range(1, len(other_route)):\n                                dist = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_pos = pos\n                            # Relocate the customer\n                            other_route = np.insert(other_route, best_pos, customer)\n                            route = np.delete(route, np.where(route == customer))\n\n    return new_solution\n\n",
        "score": [
            -0.8103625780307309,
            8.953080356121063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer relocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (capacity constraint)\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them at the closest points\n            min_dist = float('inf')\n            best_merge = (0, 0)\n            for a in range(1, len(route1)):\n                for b in range(1, len(route2)):\n                    dist = distance_matrix[route1[a-1]][route2[b]] + distance_matrix[route2[b-1]][route1[a]]\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_merge = (a, b)\n\n            a, b = best_merge\n            merged_route = np.concatenate([route1[:a], route2[b:], route2[:b], route1[a:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n        else:\n            # If merging is not feasible, try relocating a customer from one route to another\n            for route in new_solution:\n                if len(route) > 3:  # Ensure there are customers to relocate\n                    customer = random.choice(route[1:-1])\n                    for other_route in new_solution:\n                        if other_route is not route and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find the best insertion point for the customer\n                            min_dist = float('inf')\n                            best_pos = 0\n                            for pos in range(1, len(other_route)):\n                                dist = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_pos = pos\n                            # Relocate the customer\n                            other_route = np.insert(other_route, best_pos, customer)\n                            route = np.delete(route, np.where(route == customer))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split a long route into two if it exceeds a threshold\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Avoid trivial routes\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If demand is close to capacity, split\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Customer Relocation - Move a customer from a long route to a short route if feasible\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Long route candidate\n            for j, candidate_route in enumerate(new_solution):\n                if len(candidate_route) < len(route) and i != j:  # Shorter route candidate\n                    for k in range(1, len(route) - 1):\n                        customer = route[k]\n                        remaining_demand = sum(demand[candidate_route[1:-1]]) + demand[customer]\n                        if remaining_demand <= capacity:\n                            # Insert customer into the candidate route\n                            best_pos = 1\n                            min_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]]\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n                            new_candidate_route = np.concatenate([candidate_route[:best_pos], [customer], candidate_route[best_pos:]])\n                            new_solution[j] = new_candidate_route\n                            new_route = np.concatenate([route[:k], route[k+1:]])\n                            new_solution[i] = new_route\n                            break\n\n    # Step 3: Route Merging - Merge two short routes if their combined demand is feasible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) < 4 and len(new_solution[j]) < 4:  # Small routes\n                combined_demand = sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6840267147336916,
            5.419158011674881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] + x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route Splitting - Split a long route into two if it exceeds a threshold\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Avoid trivial routes\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > capacity * 0.7:  # If demand is close to capacity, split\n                split_pos = len(route) // 2\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Customer Relocation - Move a customer from a long route to a short route if feasible\n    for i, route in enumerate(new_solution):\n        if len(route) > 3:  # Long route candidate\n            for j, candidate_route in enumerate(new_solution):\n                if len(candidate_route) < len(route) and i != j:  # Shorter route candidate\n                    for k in range(1, len(route) - 1):\n                        customer = route[k]\n                        remaining_demand = sum(demand[candidate_route[1:-1]]) + demand[customer]\n                        if remaining_demand <= capacity:\n                            # Insert customer into the candidate route\n                            best_pos = 1\n                            min_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = distance_matrix[candidate_route[pos-1], customer] + distance_matrix[customer, candidate_route[pos]]\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n                            new_candidate_route = np.concatenate([candidate_route[:best_pos], [customer], candidate_route[best_pos:]])\n                            new_solution[j] = new_candidate_route\n                            new_route = np.concatenate([route[:k], route[k+1:]])\n                            new_solution[i] = new_route\n                            break\n\n    # Step 3: Route Merging - Merge two short routes if their combined demand is feasible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            if len(new_solution[i]) < 4 and len(new_solution[j]) < 4:  # Small routes\n                combined_demand = sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search operator combining route segment swaps and capacity-aware node relocations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    # Weighted combination of objectives (adjust weights as needed)\n    scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = random.sample(range(len(new_solution)), 2)\n    route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n    # Step 2: Identify feasible segment swaps\n    def is_feasible(route, cap):\n        return sum(demand[route[1:-1]]) <= cap\n\n    # Find valid segments in each route\n    segments = []\n    for route in [route1, route2]:\n        if len(route) <= 3:\n            segments.append([route])\n            continue\n        possible_segments = []\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                segment = route[i:j+1]\n                if is_feasible(segment, capacity):\n                    possible_segments.append(segment)\n        segments.append(possible_segments if possible_segments else [route])\n\n    # Step 3: Attempt segment swap\n    seg1 = random.choice(segments[0])\n    seg2 = random.choice(segments[1])\n\n    # Find positions to insert segments\n    def find_insert_positions(route, segment):\n        possible_positions = []\n        for i in range(1, len(route)):\n            # Try inserting segment before position i\n            new_route = np.concatenate([route[:i], segment, route[i:]])\n            if is_feasible(new_route, capacity):\n                possible_positions.append((i, new_route))\n        return possible_positions\n\n    pos1 = find_insert_positions(route2, seg1)\n    pos2 = find_insert_positions(route1, seg2)\n\n    if pos1 and pos2:\n        # Perform the swap\n        pos1_idx, new_route1 = random.choice(pos1)\n        pos2_idx, new_route2 = random.choice(pos2)\n\n        # Update the solution\n        new_solution[route_indices[0]] = new_route1\n        new_solution[route_indices[1]] = new_route2\n\n        # Step 4: Capacity-aware node relocation (optional)\n        # Try moving a node from one route to another if beneficial\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            node_to_move = random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                # Check if adding node_to_move to other_route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[node_to_move] <= capacity:\n                    # Find best insertion point in other_route\n                    best_pos = -1\n                    best_dist = float('inf')\n                    for i in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[i-1], node_to_move] +\n                                distance_matrix[node_to_move, other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]])\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_pos = i\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.delete(route, np.where(route == node_to_move))\n                        other_route = np.insert(other_route, best_pos, node_to_move)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8501956278325751,
            10.444491893053055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    norm_total = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-8)\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-8)\n\n    # Weighted combination of objectives (adjust weights as needed)\n    scores = 0.6 * norm_total + 0.4 * norm_makespan\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route_indices = random.sample(range(len(new_solution)), 2)\n    route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n    # Step 2: Identify feasible segment swaps\n    def is_feasible(route, cap):\n        return sum(demand[route[1:-1]]) <= cap\n\n    # Find valid segments in each route\n    segments = []\n    for route in [route1, route2]:\n        if len(route) <= 3:\n            segments.append([route])\n            continue\n        possible_segments = []\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                segment = route[i:j+1]\n                if is_feasible(segment, capacity):\n                    possible_segments.append(segment)\n        segments.append(possible_segments if possible_segments else [route])\n\n    # Step 3: Attempt segment swap\n    seg1 = random.choice(segments[0])\n    seg2 = random.choice(segments[1])\n\n    # Find positions to insert segments\n    def find_insert_positions(route, segment):\n        possible_positions = []\n        for i in range(1, len(route)):\n            # Try inserting segment before position i\n            new_route = np.concatenate([route[:i], segment, route[i:]])\n            if is_feasible(new_route, capacity):\n                possible_positions.append((i, new_route))\n        return possible_positions\n\n    pos1 = find_insert_positions(route2, seg1)\n    pos2 = find_insert_positions(route1, seg2)\n\n    if pos1 and pos2:\n        # Perform the swap\n        pos1_idx, new_route1 = random.choice(pos1)\n        pos2_idx, new_route2 = random.choice(pos2)\n\n        # Update the solution\n        new_solution[route_indices[0]] = new_route1\n        new_solution[route_indices[1]] = new_route2\n\n        # Step 4: Capacity-aware node relocation (optional)\n        # Try moving a node from one route to another if beneficial\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            node_to_move = random.choice(route[1:-1])\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                # Check if adding node_to_move to other_route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[node_to_move] <= capacity:\n                    # Find best insertion point in other_route\n                    best_pos = -1\n                    best_dist = float('inf')\n                    for i in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[i-1], node_to_move] +\n                                distance_matrix[node_to_move, other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]])\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_pos = i\n                    if best_pos != -1:\n                        # Perform the move\n                        route = np.delete(route, np.where(route == node_to_move))\n                        other_route = np.insert(other_route, best_pos, node_to_move)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_index = np.argmax([obj[1] for _, obj in archive])\n    selected_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: split long routes and merge short ones\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 4:  # Split long routes\n            split_point = len(route) // 2\n            new_solution.append(route[:split_point + 1])\n            new_solution.append(route[split_point:])\n        else:\n            new_solution.append(route)\n\n    # Merge adjacent routes if feasible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i]\n        j = i + 1\n        while j < len(new_solution):\n            # Check if merging current_route and new_solution[j] is feasible\n            merged_route = np.concatenate([current_route[:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                current_route = merged_route\n                j += 1\n            else:\n                break\n        merged_solution.append(current_route)\n        i = j\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Insert missing customers into the longest route\n    if missing_customers:\n        longest_route_idx = np.argmax([len(route) for route in merged_solution])\n        longest_route = merged_solution[longest_route_idx]\n        for customer in missing_customers:\n            # Find best insertion point (minimizing insertion cost)\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(longest_route)):\n                cost = (distance_matrix[longest_route[pos-1], customer] +\n                        distance_matrix[customer, longest_route[pos]] -\n                        distance_matrix[longest_route[pos-1], longest_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            longest_route = np.insert(longest_route, best_pos, customer)\n        merged_solution[longest_route_idx] = longest_route\n\n    return merged_solution\n\n",
        "score": [
            -0.8448942586288561,
            2.557512253522873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_index = np.argmax([obj[1] for _, obj in archive])\n    selected_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: split long routes and merge short ones\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 4:  # Split long routes\n            split_point = len(route) // 2\n            new_solution.append(route[:split_point + 1])\n            new_solution.append(route[split_point:])\n        else:\n            new_solution.append(route)\n\n    # Merge adjacent routes if feasible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i]\n        j = i + 1\n        while j < len(new_solution):\n            # Check if merging current_route and new_solution[j] is feasible\n            merged_route = np.concatenate([current_route[:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                current_route = merged_route\n                j += 1\n            else:\n                break\n        merged_solution.append(current_route)\n        i = j\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Insert missing customers into the longest route\n    if missing_customers:\n        longest_route_idx = np.argmax([len(route) for route in merged_solution])\n        longest_route = merged_solution[longest_route_idx]\n        for customer in missing_customers:\n            # Find best insertion point (minimizing insertion cost)\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(longest_route)):\n                cost = (distance_matrix[longest_route[pos-1], customer] +\n                        distance_matrix[customer, longest_route[pos]] -\n                        distance_matrix[longest_route[pos-1], longest_route[pos]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            longest_route = np.insert(longest_route, best_pos, customer)\n        merged_solution[longest_route_idx] = longest_route\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with demand-aware route merging, iteratively improving both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: demand-aware route segment swap + route merge\n    if len(new_solution) > 1:\n        # Step 1: Select two routes with high demand imbalance\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_indices = sorted(range(len(new_solution)), key=lambda i: route_lengths[i], reverse=True)\n\n        if len(route_indices) >= 2:\n            route1_idx, route2_idx = route_indices[0], route_indices[1]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Step 2: Find a feasible segment swap between the two routes\n            for i in range(1, len(route1) - 1):\n                for j in range(1, len(route2) - 1):\n                    # Check capacity feasibility after swap\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route1[i:-1]]) + sum(demand[route2[1:j]]) <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route1[:i], route2[j:-1], route1[i:]])\n                        new_route2 = np.concatenate([route2[:j], route1[i:-1], route2[j:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n            # Step 3: Attempt to merge the two routes if possible\n            if len(new_solution) > 2:\n                # Check if merging two routes is feasible\n                for i in range(len(new_solution)):\n                    for j in range(i + 1, len(new_solution)):\n                        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                        if sum(demand[merged_route[1:-1]]) <= capacity:\n                            # Merge the routes\n                            new_solution = [route for k, route in enumerate(new_solution) if k != i and k != j]\n                            new_solution.append(merged_route)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7090117959692037,
            3.8343900442123413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: demand-aware route segment swap + route merge\n    if len(new_solution) > 1:\n        # Step 1: Select two routes with high demand imbalance\n        route_lengths = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_indices = sorted(range(len(new_solution)), key=lambda i: route_lengths[i], reverse=True)\n\n        if len(route_indices) >= 2:\n            route1_idx, route2_idx = route_indices[0], route_indices[1]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Step 2: Find a feasible segment swap between the two routes\n            for i in range(1, len(route1) - 1):\n                for j in range(1, len(route2) - 1):\n                    # Check capacity feasibility after swap\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route1[i:-1]]) + sum(demand[route2[1:j]]) <= capacity):\n                        # Perform the swap\n                        new_route1 = np.concatenate([route1[:i], route2[j:-1], route1[i:]])\n                        new_route2 = np.concatenate([route2[:j], route1[i:-1], route2[j:]])\n\n                        # Update solution\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n            # Step 3: Attempt to merge the two routes if possible\n            if len(new_solution) > 2:\n                # Check if merging two routes is feasible\n                for i in range(len(new_solution)):\n                    for j in range(i + 1, len(new_solution)):\n                        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                        if sum(demand[merged_route[1:-1]]) <= capacity:\n                            # Merge the routes\n                            new_solution = [route for k, route in enumerate(new_solution) if k != i and k != j]\n                            new_solution.append(merged_route)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If the route has only depot nodes, skip modification\n    if len(route) <= 2:\n        return selected_solution\n\n    # Randomly select a segment of the route to reverse (3-opt style)\n    start = np.random.randint(1, len(route) - 2)\n    end = np.random.randint(start + 1, len(route) - 1)\n    reversed_segment = route[start:end+1][::-1]\n\n    # Check capacity constraint for the reversed segment\n    segment_demand = np.sum(demand[reversed_segment])\n    if segment_demand > capacity:\n        # If invalid, try inserting the segment elsewhere in the route\n        for i in range(1, len(route) - 1):\n            if i >= start and i <= end:\n                continue\n            new_route = np.concatenate([route[:i], reversed_segment, route[i:]])\n            new_segment_demand = np.sum(demand[new_route])\n            if new_segment_demand <= capacity:\n                route = new_route\n                break\n    else:\n        # Apply the reversal if feasible\n        route[start:end+1] = reversed_segment\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    # Optionally, apply a cross-route swap to improve balance\n    if len(selected_solution) > 1:\n        route1_idx = np.random.randint(len(selected_solution))\n        route2_idx = np.random.randint(len(selected_solution))\n        if route1_idx != route2_idx:\n            route1 = selected_solution[route1_idx].copy()\n            route2 = selected_solution[route2_idx].copy()\n\n            # Find feasible swap candidates\n            for i in range(1, len(route1) - 1):\n                for j in range(1, len(route2) - 1):\n                    node1 = route1[i]\n                    node2 = route2[j]\n\n                    # Check if swapping would violate capacity\n                    new_route1 = np.concatenate([route1[:i], [node2], route1[i+1:]])\n                    new_route2 = np.concatenate([route2[:j], [node1], route2[j+1:]])\n\n                    if (np.sum(demand[new_route1]) <= capacity and\n                        np.sum(demand[new_route2]) <= capacity):\n                        selected_solution[route1_idx] = new_route1\n                        selected_solution[route2_idx] = new_route2\n                        break\n\n    return selected_solution\n\n",
        "score": [
            -0.45924598516408716,
            1.4488365650177002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(selected_solution))\n    route = selected_solution[route_idx].copy()\n\n    # If the route has only depot nodes, skip modification\n    if len(route) <= 2:\n        return selected_solution\n\n    # Randomly select a segment of the route to reverse (3-opt style)\n    start = np.random.randint(1, len(route) - 2)\n    end = np.random.randint(start + 1, len(route) - 1)\n    reversed_segment = route[start:end+1][::-1]\n\n    # Check capacity constraint for the reversed segment\n    segment_demand = np.sum(demand[reversed_segment])\n    if segment_demand > capacity:\n        # If invalid, try inserting the segment elsewhere in the route\n        for i in range(1, len(route) - 1):\n            if i >= start and i <= end:\n                continue\n            new_route = np.concatenate([route[:i], reversed_segment, route[i:]])\n            new_segment_demand = np.sum(demand[new_route])\n            if new_segment_demand <= capacity:\n                route = new_route\n                break\n    else:\n        # Apply the reversal if feasible\n        route[start:end+1] = reversed_segment\n\n    # Update the solution with the modified route\n    selected_solution[route_idx] = route\n\n    # Optionally, apply a cross-route swap to improve balance\n    if len(selected_solution) > 1:\n        route1_idx = np.random.randint(len(selected_solution))\n        route2_idx = np.random.randint(len(selected_solution))\n        if route1_idx != route2_idx:\n            route1 = selected_solution[route1_idx].copy()\n            route2 = selected_solution[route2_idx].copy()\n\n            # Find feasible swap candidates\n            for i in range(1, len(route1) - 1):\n                for j in range(1, len(route2) - 1):\n                    node1 = route1[i]\n                    node2 = route2[j]\n\n                    # Check if swapping would violate capacity\n                    new_route1 = np.concatenate([route1[:i], [node2], route1[i+1:]])\n                    new_route2 = np.concatenate([route2[:j], [node1], route2[j+1:]])\n\n                    if (np.sum(demand[new_route1]) <= capacity and\n                        np.sum(demand[new_route2]) <= capacity):\n                        selected_solution[route1_idx] = new_route1\n                        selected_solution[route2_idx] = new_route2\n                        break\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route segment swapping with demand-aware insertion, ensuring feasibility while balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    max_dist = max(total_distances) if total_distances else 1.0\n    max_makespan = max(makespans) if makespans else 1.0\n\n    # Normalize and combine objectives (lower is better)\n    scores = [(dist/max_dist + makespan/max_makespan) for dist, makespan in zip(total_distances, makespans)]\n    selected_idx = np.argmin(scores)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid Local Search: Route Segment Swap + Demand-Aware Insertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Step 2: Select a segment from each route (excluding depot)\n    if len(route1) > 2:\n        seg1_start = random.randint(1, len(route1)-2)\n        seg1_end = random.randint(seg1_start, len(route1)-2)\n        segment1 = route1[seg1_start:seg1_end+1]\n    else:\n        segment1 = route1[1:-1]\n\n    if len(route2) > 2:\n        seg2_start = random.randint(1, len(route2)-2)\n        seg2_end = random.randint(seg2_start, len(route2)-2)\n        segment2 = route2[seg2_start:seg2_end+1]\n    else:\n        segment2 = route2[1:-1]\n\n    # Step 3: Swap segments if feasible\n    def is_feasible(route, segment, capacity, demand):\n        current_load = sum(demand[node] for node in route)\n        segment_load = sum(demand[node] for node in segment)\n        return (current_load - segment_load + segment_load) <= capacity\n\n    if is_feasible(route1, segment2, capacity, demand) and is_feasible(route2, segment1, capacity, demand):\n        # Remove segments\n        route1 = np.concatenate([route1[:seg1_start], route1[seg1_end+1:]])\n        route2 = np.concatenate([route2[:seg2_start], route2[seg2_end+1:]])\n\n        # Insert segments (greedy insertion to minimize distance)\n        def insert_segment(route, segment, distance_matrix):\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route)):\n                cost = distance_matrix[route[i-1], segment[0]] + distance_matrix[segment[-1], route[i]] - distance_matrix[route[i-1], route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            return np.concatenate([route[:best_pos], segment, route[best_pos:]])\n\n        route1 = insert_segment(route1, segment2, distance_matrix)\n        route2 = insert_segment(route2, segment1, distance_matrix)\n\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n    # Step 4: Demand-Aware Insertion (optional)\n    # Try to move a node from a long route to a short route if feasible\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        short_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if long_route_idx != short_route_idx:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            if len(long_route) > 2:\n                # Select a node to move\n                node_to_move = random.choice(long_route[1:-1])\n                node_load = demand[node_to_move]\n\n                # Check if insertion is feasible\n                if sum(demand[node] for node in short_route) + node_load <= capacity:\n                    # Remove node from long route\n                    long_route = np.delete(long_route, np.where(long_route == node_to_move)[0][0])\n                    new_solution[long_route_idx] = long_route\n\n                    # Insert node into short route (greedy)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(short_route)):\n                        cost = (distance_matrix[short_route[i-1], node_to_move] +\n                                distance_matrix[node_to_move, short_route[i]] -\n                                distance_matrix[short_route[i-1], short_route[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                    short_route = np.insert(short_route, best_pos, node_to_move)\n                    new_solution[short_route_idx] = short_route\n\n    return new_solution\n\n",
        "score": [
            -0.4812406441193443,
            0.9047932326793671
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    max_dist = max(total_distances) if total_distances else 1.0\n    max_makespan = max(makespans) if makespans else 1.0\n\n    # Normalize and combine objectives (lower is better)\n    scores = [(dist/max_dist + makespan/max_makespan) for dist, makespan in zip(total_distances, makespans)]\n    selected_idx = np.argmin(scores)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid Local Search: Route Segment Swap + Demand-Aware Insertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select two routes\n    if len(new_solution) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Step 2: Select a segment from each route (excluding depot)\n    if len(route1) > 2:\n        seg1_start = random.randint(1, len(route1)-2)\n        seg1_end = random.randint(seg1_start, len(route1)-2)\n        segment1 = route1[seg1_start:seg1_end+1]\n    else:\n        segment1 = route1[1:-1]\n\n    if len(route2) > 2:\n        seg2_start = random.randint(1, len(route2)-2)\n        seg2_end = random.randint(seg2_start, len(route2)-2)\n        segment2 = route2[seg2_start:seg2_end+1]\n    else:\n        segment2 = route2[1:-1]\n\n    # Step 3: Swap segments if feasible\n    def is_feasible(route, segment, capacity, demand):\n        current_load = sum(demand[node] for node in route)\n        segment_load = sum(demand[node] for node in segment)\n        return (current_load - segment_load + segment_load) <= capacity\n\n    if is_feasible(route1, segment2, capacity, demand) and is_feasible(route2, segment1, capacity, demand):\n        # Remove segments\n        route1 = np.concatenate([route1[:seg1_start], route1[seg1_end+1:]])\n        route2 = np.concatenate([route2[:seg2_start], route2[seg2_end+1:]])\n\n        # Insert segments (greedy insertion to minimize distance)\n        def insert_segment(route, segment, distance_matrix):\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route)):\n                cost = distance_matrix[route[i-1], segment[0]] + distance_matrix[segment[-1], route[i]] - distance_matrix[route[i-1], route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            return np.concatenate([route[:best_pos], segment, route[best_pos:]])\n\n        route1 = insert_segment(route1, segment2, distance_matrix)\n        route2 = insert_segment(route2, segment1, distance_matrix)\n\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n    # Step 4: Demand-Aware Insertion (optional)\n    # Try to move a node from a long route to a short route if feasible\n    if len(new_solution) > 1:\n        long_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        short_route_idx = np.argmin([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n\n        if long_route_idx != short_route_idx:\n            long_route = new_solution[long_route_idx]\n            short_route = new_solution[short_route_idx]\n\n            if len(long_route) > 2:\n                # Select a node to move\n                node_to_move = random.choice(long_route[1:-1])\n                node_load = demand[node_to_move]\n\n                # Check if insertion is feasible\n                if sum(demand[node] for node in short_route) + node_load <= capacity:\n                    # Remove node from long route\n                    long_route = np.delete(long_route, np.where(long_route == node_to_move)[0][0])\n                    new_solution[long_route_idx] = long_route\n\n                    # Insert node into short route (greedy)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(short_route)):\n                        cost = (distance_matrix[short_route[i-1], node_to_move] +\n                                distance_matrix[node_to_move, short_route[i]] -\n                                distance_matrix[short_route[i-1], short_route[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                    short_route = np.insert(short_route, best_pos, node_to_move)\n                    new_solution[short_route_idx] = short_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] - 0.5 * x[1][1])\n    base_solution = selected[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.choice(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: a combination of route splitting and customer reinsertion\n    if len(route) > 3:  # Ensure the route can be split\n        split_point = np.random.randint(1, len(route) - 1)\n        new_route1 = np.concatenate([route[:split_point + 1], [0]])\n        new_route2 = np.concatenate([[0], route[split_point:]])\n\n        # Reinsert customers from the longer route into the shorter one if feasible\n        if len(new_route1) < len(new_route2):\n            temp_route = new_route1\n            new_route1 = new_route2\n            new_route2 = temp_route\n\n        # Try to reinsert customers from new_route2 into new_route1\n        for i in range(1, len(new_route2) - 1):\n            customer = new_route2[i]\n            if np.sum(demand[new_route1[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in new_route1\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_route1)):\n                    new_route = np.concatenate([new_route1[:pos], [customer], new_route1[pos:]])\n                    cost = distance_matrix[new_route[pos - 1], customer] + distance_matrix[customer, new_route[pos + 1]] - distance_matrix[new_route[pos - 1], new_route[pos + 1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route1 = np.concatenate([new_route1[:best_pos], [customer], new_route1[best_pos:]])\n\n        # Update the solution with the new routes\n        new_solution = [r for i, r in enumerate(base_solution) if i != route_idx]\n        if len(new_route1) > 2:  # Ensure the route is valid (more than just depot-depot)\n            new_solution.append(new_route1)\n        if len(new_route2) > 2:\n            new_solution.append(new_route2)\n\n        # Randomly swap customers between routes if feasible\n        if len(new_solution) > 1:\n            route1_idx = np.random.choice(len(new_solution))\n            route1 = new_solution[route1_idx]\n            route2_idx = np.random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n            route2 = new_solution[route2_idx]\n\n            for i in range(1, len(route1) - 1):\n                customer = route1[i]\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Try to insert into route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                        cost = distance_matrix[new_route[pos - 1], customer] + distance_matrix[customer, new_route[pos + 1]] - distance_matrix[new_route[pos - 1], new_route[pos + 1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    if best_cost < 0:  # Only insert if it improves the route\n                        new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                        new_route1 = np.concatenate([route1[:i], route1[i + 1:]])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.7050741907791019,
            1.440367043018341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] - 0.5 * x[1][1])\n    base_solution = selected[0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.choice(len(base_solution))\n    route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: a combination of route splitting and customer reinsertion\n    if len(route) > 3:  # Ensure the route can be split\n        split_point = np.random.randint(1, len(route) - 1)\n        new_route1 = np.concatenate([route[:split_point + 1], [0]])\n        new_route2 = np.concatenate([[0], route[split_point:]])\n\n        # Reinsert customers from the longer route into the shorter one if feasible\n        if len(new_route1) < len(new_route2):\n            temp_route = new_route1\n            new_route1 = new_route2\n            new_route2 = temp_route\n\n        # Try to reinsert customers from new_route2 into new_route1\n        for i in range(1, len(new_route2) - 1):\n            customer = new_route2[i]\n            if np.sum(demand[new_route1[1:-1]]) + demand[customer] <= capacity:\n                # Find the best insertion position in new_route1\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_route1)):\n                    new_route = np.concatenate([new_route1[:pos], [customer], new_route1[pos:]])\n                    cost = distance_matrix[new_route[pos - 1], customer] + distance_matrix[customer, new_route[pos + 1]] - distance_matrix[new_route[pos - 1], new_route[pos + 1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route1 = np.concatenate([new_route1[:best_pos], [customer], new_route1[best_pos:]])\n\n        # Update the solution with the new routes\n        new_solution = [r for i, r in enumerate(base_solution) if i != route_idx]\n        if len(new_route1) > 2:  # Ensure the route is valid (more than just depot-depot)\n            new_solution.append(new_route1)\n        if len(new_route2) > 2:\n            new_solution.append(new_route2)\n\n        # Randomly swap customers between routes if feasible\n        if len(new_solution) > 1:\n            route1_idx = np.random.choice(len(new_solution))\n            route1 = new_solution[route1_idx]\n            route2_idx = np.random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n            route2 = new_solution[route2_idx]\n\n            for i in range(1, len(route1) - 1):\n                customer = route1[i]\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Try to insert into route2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                        cost = distance_matrix[new_route[pos - 1], customer] + distance_matrix[customer, new_route[pos + 1]] - distance_matrix[new_route[pos - 1], new_route[pos + 1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    if best_cost < 0:  # Only insert if it improves the route\n                        new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                        new_route1 = np.concatenate([route1[:i], route1[i + 1:]])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                        break\n\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The algorithm selects a promising solution from the archive, then applies a hybrid local search combining route splitting, customer reallocation, and a novel \"distance-aware\" 2-opt variant that prioritizes reducing the makespan while minimizing total distance, ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if any route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Split if route has more than 2 customers\n            mid = len(route) // 2\n            new_route1 = np.concatenate((route[:mid+1], [0]))\n            new_route2 = np.concatenate(([0], route[mid:]))\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try up to 2 reallocations\n        if len(new_solution) < 2:\n            break\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try moving a customer from route1 to route2\n        if len(route1) > 3:  # Ensure route1 has customers to move\n            customer_to_move = random.choice(route1[1:-1])\n            new_route1 = route1[route1 != customer_to_move]\n            new_route2 = np.concatenate((route2[:-1], [customer_to_move], [0]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: Distance-aware 2-opt variant (prioritize makespan reduction)\n    for route in new_solution:\n        if len(route) > 4:  # Only try if route has enough customers\n            # Select two non-adjacent edges to swap\n            n = len(route) - 1\n            i, j = sorted(random.sample(range(1, n), 2))\n            if abs(i - j) > 1:  # Ensure they're not adjacent\n                # Create new route by reversing the segment between i and j\n                new_route = np.concatenate((route[:i], route[j:i-1:-1], route[j+1:]))\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Compare makespan impact (approximate)\n                    old_route_length = np.sum(distance_matrix[route[:-1], route[1:]])\n                    new_route_length = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n                    # Accept if makespan is reduced or total distance is improved\n                    if new_route_length <= old_route_length:\n                        route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7664945310626751,
            1.1178107857704163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if any route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Split if route has more than 2 customers\n            mid = len(route) // 2\n            new_route1 = np.concatenate((route[:mid+1], [0]))\n            new_route2 = np.concatenate(([0], route[mid:]))\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Customer reallocation (move customers between routes)\n    for _ in range(2):  # Try up to 2 reallocations\n        if len(new_solution) < 2:\n            break\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try moving a customer from route1 to route2\n        if len(route1) > 3:  # Ensure route1 has customers to move\n            customer_to_move = random.choice(route1[1:-1])\n            new_route1 = route1[route1 != customer_to_move]\n            new_route2 = np.concatenate((route2[:-1], [customer_to_move], [0]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                break\n\n    # Step 3: Distance-aware 2-opt variant (prioritize makespan reduction)\n    for route in new_solution:\n        if len(route) > 4:  # Only try if route has enough customers\n            # Select two non-adjacent edges to swap\n            n = len(route) - 1\n            i, j = sorted(random.sample(range(1, n), 2))\n            if abs(i - j) > 1:  # Ensure they're not adjacent\n                # Create new route by reversing the segment between i and j\n                new_route = np.concatenate((route[:i], route[j:i-1:-1], route[j+1:]))\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Compare makespan impact (approximate)\n                    old_route_length = np.sum(distance_matrix[route[:-1], route[1:]])\n                    new_route_length = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n\n                    # Accept if makespan is reduced or total distance is improved\n                    if new_route_length <= old_route_length:\n                        route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a hybrid of Pareto dominance and makespan diversity, then applies a novel route-splitting and merging operator that dynamically balances distance and makespan objectives by considering demand and spatial proximity, while ensuring feasibility through capacity-aware route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = 0\n    min_makespan = archive[0][1][1]\n    for i, (sol, obj) in enumerate(archive):\n        if obj[1] < min_makespan:\n            min_makespan = obj[1]\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware adjustments\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a demand-aware point\n        total_demand = np.sum(demand[route[1:-1]])\n        split_pos = 1\n        current_demand = 0\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand > total_demand * 0.4 and current_demand < total_demand * 0.6:\n                split_pos = i\n                break\n\n        # Create new routes\n        new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route)\n\n    # Merge routes if possible (distance and makespan improvement)\n    if len(new_solution) > len(base_solution):\n        # Try to merge two routes if they are close in space and demand allows\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) == 3 or len(route2) == 3:\n                    continue\n\n                # Check spatial proximity\n                last1 = route1[-2]\n                first2 = route2[1]\n                if distance_matrix[last1][first2] < np.mean(distance_matrix) * 0.5:\n                    # Check demand feasibility\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution = [r for k, r in enumerate(new_solution) if k != i and k != j]\n                        new_solution.append(merged_route)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Reconstruct solution if not all customers are served\n        remaining = all_customers - served\n        new_solution = base_solution.copy()\n        for cust in remaining:\n            # Find best insertion point\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r in range(len(new_solution)):\n                route = new_solution[r]\n                if np.sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                    continue\n                for p in range(1, len(route)):\n                    cost = distance_matrix[route[p-1]][cust] + distance_matrix[cust][route[p]] - distance_matrix[route[p-1]][route[p]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = r\n                        best_pos = p\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, cust)\n\n    return new_solution\n\n",
        "score": [
            -0.9316851187208413,
            7.610150784254074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = 0\n    min_makespan = archive[0][1][1]\n    for i, (sol, obj) in enumerate(archive):\n        if obj[1] < min_makespan:\n            min_makespan = obj[1]\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware adjustments\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a demand-aware point\n        total_demand = np.sum(demand[route[1:-1]])\n        split_pos = 1\n        current_demand = 0\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand > total_demand * 0.4 and current_demand < total_demand * 0.6:\n                split_pos = i\n                break\n\n        # Create new routes\n        new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route)\n\n    # Merge routes if possible (distance and makespan improvement)\n    if len(new_solution) > len(base_solution):\n        # Try to merge two routes if they are close in space and demand allows\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) == 3 or len(route2) == 3:\n                    continue\n\n                # Check spatial proximity\n                last1 = route1[-2]\n                first2 = route2[1]\n                if distance_matrix[last1][first2] < np.mean(distance_matrix) * 0.5:\n                    # Check demand feasibility\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution = [r for k, r in enumerate(new_solution) if k != i and k != j]\n                        new_solution.append(merged_route)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Reconstruct solution if not all customers are served\n        remaining = all_customers - served\n        new_solution = base_solution.copy()\n        for cust in remaining:\n            # Find best insertion point\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r in range(len(new_solution)):\n                route = new_solution[r]\n                if np.sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                    continue\n                for p in range(1, len(route)):\n                    cost = distance_matrix[route[p-1]][cust] + distance_matrix[cust][route[p]] - distance_matrix[route[p-1]][route[p]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = r\n                        best_pos = p\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, cust)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a hybrid of Pareto dominance and makespan diversity, then applies a novel route-splitting and merging operator that dynamically balances distance and makespan objectives by considering demand and spatial proximity, while ensuring feasibility through capacity-aware route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = 0\n    min_makespan = archive[0][1][1]\n    for i, (sol, obj) in enumerate(archive):\n        if obj[1] < min_makespan:\n            min_makespan = obj[1]\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware adjustments\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a demand-aware point\n        total_demand = np.sum(demand[route[1:-1]])\n        split_pos = 1\n        current_demand = 0\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand > total_demand * 0.4 and current_demand < total_demand * 0.6:\n                split_pos = i\n                break\n\n        # Create new routes\n        new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route)\n\n    # Merge routes if possible (distance and makespan improvement)\n    if len(new_solution) > len(base_solution):\n        # Try to merge two routes if they are close in space and demand allows\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) == 3 or len(route2) == 3:\n                    continue\n\n                # Check spatial proximity\n                last1 = route1[-2]\n                first2 = route2[1]\n                if distance_matrix[last1][first2] < np.mean(distance_matrix) * 0.5:\n                    # Check demand feasibility\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution = [r for k, r in enumerate(new_solution) if k != i and k != j]\n                        new_solution.append(merged_route)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Reconstruct solution if not all customers are served\n        remaining = all_customers - served\n        new_solution = base_solution.copy()\n        for cust in remaining:\n            # Find best insertion point\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r in range(len(new_solution)):\n                route = new_solution[r]\n                if np.sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                    continue\n                for p in range(1, len(route)):\n                    cost = distance_matrix[route[p-1]][cust] + distance_matrix[cust][route[p]] - distance_matrix[route[p-1]][route[p]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = r\n                        best_pos = p\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, cust)\n\n    return new_solution\n\n",
        "score": [
            -0.9316851187208413,
            7.610150784254074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = 0\n    min_makespan = archive[0][1][1]\n    for i, (sol, obj) in enumerate(archive):\n        if obj[1] < min_makespan:\n            min_makespan = obj[1]\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and merging with demand-aware adjustments\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split route at a demand-aware point\n        total_demand = np.sum(demand[route[1:-1]])\n        split_pos = 1\n        current_demand = 0\n        for i in range(1, len(route)-1):\n            current_demand += demand[route[i]]\n            if current_demand > total_demand * 0.4 and current_demand < total_demand * 0.6:\n                split_pos = i\n                break\n\n        # Create new routes\n        new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n        new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route)\n\n    # Merge routes if possible (distance and makespan improvement)\n    if len(new_solution) > len(base_solution):\n        # Try to merge two routes if they are close in space and demand allows\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) == 3 or len(route2) == 3:\n                    continue\n\n                # Check spatial proximity\n                last1 = route1[-2]\n                first2 = route2[1]\n                if distance_matrix[last1][first2] < np.mean(distance_matrix) * 0.5:\n                    # Check demand feasibility\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution = [r for k, r in enumerate(new_solution) if k != i and k != j]\n                        new_solution.append(merged_route)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Reconstruct solution if not all customers are served\n        remaining = all_customers - served\n        new_solution = base_solution.copy()\n        for cust in remaining:\n            # Find best insertion point\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n            for r in range(len(new_solution)):\n                route = new_solution[r]\n                if np.sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                    continue\n                for p in range(1, len(route)):\n                    cost = distance_matrix[route[p-1]][cust] + distance_matrix[cust][route[p]] - distance_matrix[route[p-1]][route[p]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = r\n                        best_pos = p\n            if best_route != -1:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, cust)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and partial route reversal\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Reverse the second part (partial route reversal)\n        part2_reversed = np.concatenate([part2[0:1], part2[1:-1][::-1], part2[-1:]])\n\n        # Check feasibility of both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2_reversed[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.extend([part1.copy(), part2_reversed.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    return new_solution\n\n",
        "score": [
            -0.639014432495968,
            0.8023410439491272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and partial route reversal\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Reverse the second part (partial route reversal)\n        part2_reversed = np.concatenate([part2[0:1], part2[1:-1][::-1], part2[-1:]])\n\n        # Check feasibility of both parts\n        demand_part1 = np.sum(demand[part1[1:-1]])\n        demand_part2 = np.sum(demand[part2_reversed[1:-1]])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution.extend([part1.copy(), part2_reversed.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A novel hybrid local search operator combines route segmentation and demand-based insertion, iteratively improving solutions by breaking long routes into segments and reinserting them into other routes while maintaining feasibility, while also balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and demand-based reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes (only depot or single customer)\n            continue\n\n        # Randomly split the route into two segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate total demand of segments\n        demand1 = sum(demand[node] for node in segment1[1:-1])\n        demand2 = sum(demand[node] for node in segment2[1:-1])\n\n        # Try to reinsert segments into other routes\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            # Check if segment1 can fit in other_route\n            if other_demand + demand1 <= capacity:\n                # Find best insertion point in other_route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1], segment1[1]] +\n                            distance_matrix[segment1[-2], other_route[pos]] -\n                            distance_matrix[other_route[pos-1], other_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Insert segment1 into other_route\n                new_other_route = np.concatenate([other_route[:best_pos], segment1[1:-1], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n                new_solution[route_idx] = np.concatenate([segment2, other_route[best_pos:]])\n\n                # Check capacity constraint\n                if (sum(demand[node] for node in new_solution[route_idx][1:-1]) <= capacity and\n                    sum(demand[node] for node in new_solution[other_route_idx][1:-1]) <= capacity):\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7582003326819324,
            2.737753212451935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and demand-based reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes (only depot or single customer)\n            continue\n\n        # Randomly split the route into two segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate total demand of segments\n        demand1 = sum(demand[node] for node in segment1[1:-1])\n        demand2 = sum(demand[node] for node in segment2[1:-1])\n\n        # Try to reinsert segments into other routes\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n\n            # Check if segment1 can fit in other_route\n            if other_demand + demand1 <= capacity:\n                # Find best insertion point in other_route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    cost = (distance_matrix[other_route[pos-1], segment1[1]] +\n                            distance_matrix[segment1[-2], other_route[pos]] -\n                            distance_matrix[other_route[pos-1], other_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                # Insert segment1 into other_route\n                new_other_route = np.concatenate([other_route[:best_pos], segment1[1:-1], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n                new_solution[route_idx] = np.concatenate([segment2, other_route[best_pos:]])\n\n                # Check capacity constraint\n                if (sum(demand[node] for node in new_solution[route_idx][1:-1]) <= capacity and\n                    sum(demand[node] for node in new_solution[other_route_idx][1:-1]) <= capacity):\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] / (obj[1] + 1e-6) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and cross-route insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split route into two parts at a random point\n        split_pos = np.random.randint(1, len(route)-1)\n        first_part = route[:split_pos+1]\n        second_part = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace original route with two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx+1, second_part)\n            break\n\n    # Cross-route insertion: Move a node from one route to another\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a node from route1 to move to route2\n            node_pos = np.random.randint(1, len(route1)-1)\n            node = route1[node_pos]\n\n            # Check capacity constraint for route2 after insertion\n            if np.sum(demand[route2[1:-1]]) + demand[node] <= capacity:\n                # Remove node from route1\n                new_route1 = np.concatenate([route1[:node_pos], route1[node_pos+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Insert node into route2 at the best position\n                best_pos = 1  # Default position after depot\n                best_cost = float('inf')\n\n                for i in range(1, len(route2)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[route2[i-1], node] +\n                           distance_matrix[node, route2[i]] -\n                           distance_matrix[route2[i-1], route2[i]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert node into route2\n                new_route2 = np.concatenate([route2[:best_pos], [node], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.6376721584156059,
            0.2709575295448303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] / (obj[1] + 1e-6) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route splitting and cross-route insertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split route into two parts at a random point\n        split_pos = np.random.randint(1, len(route)-1)\n        first_part = route[:split_pos+1]\n        second_part = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        first_demand = np.sum(demand[first_part[1:-1]])\n        second_demand = np.sum(demand[second_part[1:-1]])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace original route with two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx+1, second_part)\n            break\n\n    # Cross-route insertion: Move a node from one route to another\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a node from route1 to move to route2\n            node_pos = np.random.randint(1, len(route1)-1)\n            node = route1[node_pos]\n\n            # Check capacity constraint for route2 after insertion\n            if np.sum(demand[route2[1:-1]]) + demand[node] <= capacity:\n                # Remove node from route1\n                new_route1 = np.concatenate([route1[:node_pos], route1[node_pos+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Insert node into route2 at the best position\n                best_pos = 1  # Default position after depot\n                best_cost = float('inf')\n\n                for i in range(1, len(route2)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[route2[i-1], node] +\n                           distance_matrix[node, route2[i]] -\n                           distance_matrix[route2[i-1], route2[i]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert node into route2\n                new_route2 = np.concatenate([route2[:best_pos], [node], route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{A novel hybrid local search operator combines route fragmentation and capacity-aware route merging to balance distance and makespan minimization while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to fragment\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Find a split point that maintains capacity constraints\n        valid_splits = []\n        current_load = 0\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load <= capacity:\n                valid_splits.append(i)\n\n        if valid_splits:\n            split_point = random.choice(valid_splits)\n            new_route1 = np.concatenate([route[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point + 1:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n            # Attempt to merge routes to reduce makespan\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    if i < len(new_solution) and j < len(new_solution):\n                        route1 = new_solution[i]\n                        route2 = new_solution[j]\n\n                        # Check if merging is feasible\n                        total_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                        if total_load <= capacity:\n                            # Merge the two routes\n                            merged_route = np.concatenate([route1[:-1], route2[1:]])\n                            new_solution.pop(j)\n                            new_solution.pop(i)\n                            new_solution.append(merged_route)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.6004666738716428,
            1.881527990102768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to fragment\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Find a split point that maintains capacity constraints\n        valid_splits = []\n        current_load = 0\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load <= capacity:\n                valid_splits.append(i)\n\n        if valid_splits:\n            split_point = random.choice(valid_splits)\n            new_route1 = np.concatenate([route[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point + 1:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n            # Attempt to merge routes to reduce makespan\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    if i < len(new_solution) and j < len(new_solution):\n                        route1 = new_solution[i]\n                        route2 = new_solution[j]\n\n                        # Check if merging is feasible\n                        total_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                        if total_load <= capacity:\n                            # Merge the two routes\n                            merged_route = np.concatenate([route1[:-1], route2[1:]])\n                            new_solution.pop(j)\n                            new_solution.pop(i)\n                            new_solution.append(merged_route)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Split and Reinsert with Route Relinking\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for the split parts\n        if sum(demand[part1[1:-1]]) > capacity or sum(demand[part2[1:-1]]) > capacity:\n            continue\n\n        # Reinsert part2 into another route or create a new route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j].copy()\n            candidate_route = np.concatenate([candidate_route[:-1], part2[1:]])\n            if sum(demand[candidate_route[1:-1]]) <= capacity:\n                new_solution[j] = candidate_route\n                new_solution[i] = part1\n                break\n\n    # Route Relinking: Combine routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i].copy()\n            route2 = new_solution[j].copy()\n            combined = np.concatenate([route1[:-1], route2[1:]])\n            if sum(demand[combined[1:-1]]) <= capacity:\n                new_solution[i] = combined\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8197640846821911,
            2.7448301911354065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Split and Reinsert with Route Relinking\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for the split parts\n        if sum(demand[part1[1:-1]]) > capacity or sum(demand[part2[1:-1]]) > capacity:\n            continue\n\n        # Reinsert part2 into another route or create a new route\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            candidate_route = new_solution[j].copy()\n            candidate_route = np.concatenate([candidate_route[:-1], part2[1:]])\n            if sum(demand[candidate_route[1:-1]]) <= capacity:\n                new_solution[j] = candidate_route\n                new_solution[i] = part1\n                break\n\n    # Route Relinking: Combine routes if possible\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route1 = new_solution[i].copy()\n            route2 = new_solution[j].copy()\n            combined = np.concatenate([route1[:-1], route2[1:]])\n            if sum(demand[combined[1:-1]]) <= capacity:\n                new_solution[i] = combined\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge routes, then split and reinsert customers\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 2:  # Skip empty or trivial routes\n            new_solution.append(route.copy())\n\n    # Merge routes with low total demand to reduce vehicle usage\n    merged = False\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand_i = sum(demand[node] for node in route_i[1:-1])\n            total_demand_j = sum(demand[node] for node in route_j[1:-1])\n\n            if total_demand_i + total_demand_j <= capacity:\n                # Merge route_j into route_i\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                merged = True\n                break\n        if merged:\n            break\n\n    # Split long routes into shorter ones if possible\n    for route in new_solution:\n        if len(route) > 4:  # Arbitrary threshold for \"long\" route\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.remove(route)\n                new_solution.extend([new_route1, new_route2])\n                break\n\n    # Demand-aware swaps between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            for k in range(1, len(route_i) - 1):\n                for l in range(1, len(route_j) - 1):\n                    node_i = route_i[k]\n                    node_j = route_j[l]\n                    # Swap nodes if demand constraints are satisfied\n                    new_demand_i = sum(demand[node] for node in route_i[1:-1]) - demand[node_i] + demand[node_j]\n                    new_demand_j = sum(demand[node] for node in route_j[1:-1]) - demand[node_j] + demand[node_i]\n                    if new_demand_i <= capacity and new_demand_j <= capacity:\n                        # Perform swap\n                        new_route_i = route_i.copy()\n                        new_route_j = route_j.copy()\n                        new_route_i[k], new_route_j[l] = new_route_j[l], new_route_i[k]\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8742652264651855,
            2.5043958127498627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge routes, then split and reinsert customers\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 2:  # Skip empty or trivial routes\n            new_solution.append(route.copy())\n\n    # Merge routes with low total demand to reduce vehicle usage\n    merged = False\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand_i = sum(demand[node] for node in route_i[1:-1])\n            total_demand_j = sum(demand[node] for node in route_j[1:-1])\n\n            if total_demand_i + total_demand_j <= capacity:\n                # Merge route_j into route_i\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                merged = True\n                break\n        if merged:\n            break\n\n    # Split long routes into shorter ones if possible\n    for route in new_solution:\n        if len(route) > 4:  # Arbitrary threshold for \"long\" route\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.remove(route)\n                new_solution.extend([new_route1, new_route2])\n                break\n\n    # Demand-aware swaps between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            for k in range(1, len(route_i) - 1):\n                for l in range(1, len(route_j) - 1):\n                    node_i = route_i[k]\n                    node_j = route_j[l]\n                    # Swap nodes if demand constraints are satisfied\n                    new_demand_i = sum(demand[node] for node in route_i[1:-1]) - demand[node_i] + demand[node_j]\n                    new_demand_j = sum(demand[node] for node in route_j[1:-1]) - demand[node_j] + demand[node_i]\n                    if new_demand_i <= capacity and new_demand_j <= capacity:\n                        # Perform swap\n                        new_route_i = route_i.copy()\n                        new_route_j = route_j.copy()\n                        new_route_i[k], new_route_j[l] = new_route_j[l], new_route_i[k]\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or reallocate\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging the two routes if they can fit\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[route1_idx] = merged_route\n            new_solution = [route for i, route in enumerate(new_solution) if i != route2_idx]\n        else:\n            # If merging fails, try reallocating a customer from the longer route to the shorter one\n            if len(route1) > len(route2):\n                long_route, short_route = route1, route2\n            else:\n                long_route, short_route = route2, route1\n\n            # Find a customer in the long route that can be moved to the short route\n            for i in range(1, len(long_route)-1):\n                customer = long_route[i]\n                if np.sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from long route\n                    new_long_route = np.concatenate([long_route[:i], long_route[i+1:]])\n                    # Insert customer into short route (greedy insertion)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for j in range(1, len(short_route)):\n                        cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = j\n                    new_short_route = np.concatenate([short_route[:best_pos], [customer], short_route[best_pos:]])\n\n                    # Update the solution\n                    if route1_idx == route2_idx:\n                        new_solution[route1_idx] = new_long_route\n                        new_solution.append(new_short_route)\n                    else:\n                        new_solution[route1_idx] = new_long_route\n                        new_solution[route2_idx] = new_short_route\n                    break\n\n    # Apply a random 2-opt within a single route to further improve\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure there are enough nodes to perform 2-opt\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7248169465774448,
            0.9736112952232361
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or reallocate\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try merging the two routes if they can fit\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[route1_idx] = merged_route\n            new_solution = [route for i, route in enumerate(new_solution) if i != route2_idx]\n        else:\n            # If merging fails, try reallocating a customer from the longer route to the shorter one\n            if len(route1) > len(route2):\n                long_route, short_route = route1, route2\n            else:\n                long_route, short_route = route2, route1\n\n            # Find a customer in the long route that can be moved to the short route\n            for i in range(1, len(long_route)-1):\n                customer = long_route[i]\n                if np.sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from long route\n                    new_long_route = np.concatenate([long_route[:i], long_route[i+1:]])\n                    # Insert customer into short route (greedy insertion)\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for j in range(1, len(short_route)):\n                        cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = j\n                    new_short_route = np.concatenate([short_route[:best_pos], [customer], short_route[best_pos:]])\n\n                    # Update the solution\n                    if route1_idx == route2_idx:\n                        new_solution[route1_idx] = new_long_route\n                        new_solution.append(new_short_route)\n                    else:\n                        new_solution[route1_idx] = new_long_route\n                        new_solution[route2_idx] = new_short_route\n                    break\n\n    # Apply a random 2-opt within a single route to further improve\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Ensure there are enough nodes to perform 2-opt\n            i, j = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted random selection favoring lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with capacity checks, and a novel \"route fusion\" operator to merge feasible routes while maintaining feasibility, creating diverse neighbors for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on normalized objectives\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    if max_dist == min_dist:\n        norm_distances = np.ones_like(total_distances)\n    else:\n        norm_distances = (total_distances - min_dist) / (max_dist - min_dist)\n\n    if max_makespan == min_makespan:\n        norm_makespans = np.ones_like(makespans)\n    else:\n        norm_makespans = (makespans - min_makespan) / (max_makespan - min_makespan)\n\n    # Weighted selection (favor lower objectives)\n    weights = 1.0 / (1 + norm_distances + norm_makespans)\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Route splitting with reinsertion\n        route_to_split = random.choice(new_solution)\n        if len(route_to_split) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            new_route1 = np.concatenate([route_to_split[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route_to_split[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n                new_solution.extend([new_route1, new_route2])\n\n    # Route fusion (merge two routes if possible)\n    if len(new_solution) > 1:\n        route1, route2 = random.sample(new_solution, 2)\n        if len(route1) > 2 and len(route2) > 2:\n            # Try to merge by connecting last node of route1 to first node of route2\n            last_node1 = route1[-2]\n            first_node2 = route2[1]\n\n            # Check capacity and distance\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [r for r in new_solution if not (np.array_equal(r, route1) or np.array_equal(r, route2))]\n                new_solution.append(merged_route)\n\n    # Customer reinsertion with capacity check\n    for route in new_solution:\n        if len(route) > 3:\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Temporarily remove the customer\n            temp_route = np.delete(route, customer_pos)\n\n            # Try to reinsert at a different position in the same route\n            possible_positions = list(range(1, len(temp_route)))\n            random.shuffle(possible_positions)\n\n            for pos in possible_positions:\n                # Insert and check capacity\n                new_route = np.insert(temp_route, pos, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5751531389513793,
            2.4206584692001343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on normalized objectives\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Normalize objectives\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    if max_dist == min_dist:\n        norm_distances = np.ones_like(total_distances)\n    else:\n        norm_distances = (total_distances - min_dist) / (max_dist - min_dist)\n\n    if max_makespan == min_makespan:\n        norm_makespans = np.ones_like(makespans)\n    else:\n        norm_makespans = (makespans - min_makespan) / (max_makespan - min_makespan)\n\n    # Weighted selection (favor lower objectives)\n    weights = 1.0 / (1 + norm_distances + norm_makespans)\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Route splitting with reinsertion\n        route_to_split = random.choice(new_solution)\n        if len(route_to_split) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(route_to_split) - 2)\n            new_route1 = np.concatenate([route_to_split[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route_to_split[split_pos:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n                new_solution.extend([new_route1, new_route2])\n\n    # Route fusion (merge two routes if possible)\n    if len(new_solution) > 1:\n        route1, route2 = random.sample(new_solution, 2)\n        if len(route1) > 2 and len(route2) > 2:\n            # Try to merge by connecting last node of route1 to first node of route2\n            last_node1 = route1[-2]\n            first_node2 = route2[1]\n\n            # Check capacity and distance\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [r for r in new_solution if not (np.array_equal(r, route1) or np.array_equal(r, route2))]\n                new_solution.append(merged_route)\n\n    # Customer reinsertion with capacity check\n    for route in new_solution:\n        if len(route) > 3:\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Temporarily remove the customer\n            temp_route = np.delete(route, customer_pos)\n\n            # Try to reinsert at a different position in the same route\n            possible_positions = list(range(1, len(temp_route)))\n            random.shuffle(possible_positions)\n\n            for pos in possible_positions:\n                # Insert and check capacity\n                new_route = np.insert(temp_route, pos, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and route-swap strategy\n    if len(new_solution) > 1:\n        # Randomly select two routes for swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if swapping entire routes is feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n\n            # Perform route swap\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n\n            # Apply 3-opt locally within each route\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                if len(route) > 4:  # Only apply if route has enough nodes\n                    # Select three random nodes (excluding depot)\n                    a, b, c = np.random.choice(range(1, len(route)-1), 3, replace=False)\n                    a, b, c = sorted([a, b, c])\n\n                    # Create three possible new routes\n                    option1 = np.concatenate([route[:a+1], route[b+1:c+1], route[a+1:b+1], route[c+1:]])\n                    option2 = np.concatenate([route[:a+1], route[c+1:], route[b+1:c+1], route[a+1:b+1]])\n                    option3 = np.concatenate([route[:b+1], route[c+1:], route[a+1:b+1], route[b+1:c+1]])\n\n                    # Select the best option that maintains feasibility\n                    options = [option1, option2, option3]\n                    best_option = None\n                    min_distance = float('inf')\n\n                    for opt in options:\n                        if np.sum(demand[opt[1:-1]]) <= capacity:\n                            dist = sum(distance_matrix[opt[j], opt[j+1]] for j in range(len(opt)-1))\n                            if dist < min_distance:\n                                min_distance = dist\n                                best_option = opt\n\n                    if best_option is not None:\n                        new_solution[i] = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.6920661319747821,
            3.0170848965644836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt and route-swap strategy\n    if len(new_solution) > 1:\n        # Randomly select two routes for swapping\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if swapping entire routes is feasible\n        if (np.sum(demand[route1[1:-1]]) <= capacity and\n            np.sum(demand[route2[1:-1]]) <= capacity):\n\n            # Perform route swap\n            new_solution[route1_idx], new_solution[route2_idx] = route2, route1\n\n            # Apply 3-opt locally within each route\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                if len(route) > 4:  # Only apply if route has enough nodes\n                    # Select three random nodes (excluding depot)\n                    a, b, c = np.random.choice(range(1, len(route)-1), 3, replace=False)\n                    a, b, c = sorted([a, b, c])\n\n                    # Create three possible new routes\n                    option1 = np.concatenate([route[:a+1], route[b+1:c+1], route[a+1:b+1], route[c+1:]])\n                    option2 = np.concatenate([route[:a+1], route[c+1:], route[b+1:c+1], route[a+1:b+1]])\n                    option3 = np.concatenate([route[:b+1], route[c+1:], route[a+1:b+1], route[b+1:c+1]])\n\n                    # Select the best option that maintains feasibility\n                    options = [option1, option2, option3]\n                    best_option = None\n                    min_distance = float('inf')\n\n                    for opt in options:\n                        if np.sum(demand[opt[1:-1]]) <= capacity:\n                            dist = sum(distance_matrix[opt[j], opt[j+1]] for j in range(len(opt)-1))\n                            if dist < min_distance:\n                                min_distance = dist\n                                best_option = opt\n\n                    if best_option is not None:\n                        new_solution[i] = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted sum of the two objectives, then applies a hybrid local search operator that combines route splitting, node reinsertion with capacity checks, and a novel \"route fusion\" step to balance distance and makespan, ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long, split it)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Node reinsertion with capacity check\n    for _ in range(2):  # Try reinserting a few nodes\n        # Select a random route and a random node (excluding depot)\n        route_idx = random.randint(0, len(new_solution)-1)\n        if len(new_solution[route_idx]) <= 3:\n            continue  # Skip if route has only depot and one customer\n\n        node_pos = random.randint(1, len(new_solution[route_idx])-2)\n        node = new_solution[route_idx][node_pos]\n\n        # Remove the node\n        new_solution[route_idx] = np.concatenate([\n            new_solution[route_idx][:node_pos],\n            new_solution[route_idx][node_pos+1:]\n        ])\n\n        # Try inserting it in another route or a new route\n        best_insert = None\n        best_cost = float('inf')\n\n        # Try inserting in existing routes\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(new_solution[i])):\n                # Create potential new route\n                new_route = np.concatenate([\n                    new_solution[i][:pos],\n                    [node],\n                    new_solution[i][pos:]\n                ])\n                # Check capacity\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insert = (i, pos, new_route.copy())\n\n        # If found a good insertion, apply it\n        if best_insert is not None:\n            i, pos, new_route = best_insert\n            new_solution[i] = new_route\n        else:\n            # If no good insertion found, try creating a new route\n            if np.sum(demand[node]) <= capacity:\n                new_solution.append(np.array([0, node, 0]))\n\n    # Step 3: Route fusion (combine two short routes if beneficial)\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if fusion would reduce makespan or distance\n        if len(route1) + len(route2) - 2 <= 5:  # Only fuse if resulting route is short\n            # Try fusing in both possible orders\n            fusion1 = np.concatenate([route1[:-1], route2[1:]])\n            fusion2 = np.concatenate([route2[:-1], route1[1:]])\n\n            # Check capacity for both fusions\n            if (np.sum(demand[fusion1[1:-1]]) <= capacity and\n                np.sum(demand[fusion2[1:-1]]) <= capacity):\n                # Choose the one with better makespan or distance\n                dist1 = np.sum(distance_matrix[fusion1[:-1], fusion1[1:]])\n                dist2 = np.sum(distance_matrix[fusion2[:-1], fusion2[1:]])\n                makespan1 = dist1\n                makespan2 = dist2\n\n                if min(makespan1, makespan2) < max(\n                    np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                    np.sum(distance_matrix[route2[:-1], route2[1:]])\n                ):\n                    # Apply the better fusion\n                    if makespan1 < makespan2:\n                        new_solution[route1_idx] = fusion1\n                        del new_solution[route2_idx if route2_idx > route1_idx else route2_idx-1]\n                    else:\n                        new_solution[route1_idx] = fusion2\n                        del new_solution[route2_idx if route2_idx > route1_idx else route2_idx-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5114637045869617,
            4.329467803239822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting (if a route is too long, split it)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Node reinsertion with capacity check\n    for _ in range(2):  # Try reinserting a few nodes\n        # Select a random route and a random node (excluding depot)\n        route_idx = random.randint(0, len(new_solution)-1)\n        if len(new_solution[route_idx]) <= 3:\n            continue  # Skip if route has only depot and one customer\n\n        node_pos = random.randint(1, len(new_solution[route_idx])-2)\n        node = new_solution[route_idx][node_pos]\n\n        # Remove the node\n        new_solution[route_idx] = np.concatenate([\n            new_solution[route_idx][:node_pos],\n            new_solution[route_idx][node_pos+1:]\n        ])\n\n        # Try inserting it in another route or a new route\n        best_insert = None\n        best_cost = float('inf')\n\n        # Try inserting in existing routes\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(new_solution[i])):\n                # Create potential new route\n                new_route = np.concatenate([\n                    new_solution[i][:pos],\n                    [node],\n                    new_solution[i][pos:]\n                ])\n                # Check capacity\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    # Calculate insertion cost (distance increase)\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_insert = (i, pos, new_route.copy())\n\n        # If found a good insertion, apply it\n        if best_insert is not None:\n            i, pos, new_route = best_insert\n            new_solution[i] = new_route\n        else:\n            # If no good insertion found, try creating a new route\n            if np.sum(demand[node]) <= capacity:\n                new_solution.append(np.array([0, node, 0]))\n\n    # Step 3: Route fusion (combine two short routes if beneficial)\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if fusion would reduce makespan or distance\n        if len(route1) + len(route2) - 2 <= 5:  # Only fuse if resulting route is short\n            # Try fusing in both possible orders\n            fusion1 = np.concatenate([route1[:-1], route2[1:]])\n            fusion2 = np.concatenate([route2[:-1], route1[1:]])\n\n            # Check capacity for both fusions\n            if (np.sum(demand[fusion1[1:-1]]) <= capacity and\n                np.sum(demand[fusion2[1:-1]]) <= capacity):\n                # Choose the one with better makespan or distance\n                dist1 = np.sum(distance_matrix[fusion1[:-1], fusion1[1:]])\n                dist2 = np.sum(distance_matrix[fusion2[:-1], fusion2[1:]])\n                makespan1 = dist1\n                makespan2 = dist2\n\n                if min(makespan1, makespan2) < max(\n                    np.sum(distance_matrix[route1[:-1], route1[1:]]),\n                    np.sum(distance_matrix[route2[:-1], route2[1:]])\n                ):\n                    # Apply the better fusion\n                    if makespan1 < makespan2:\n                        new_solution[route1_idx] = fusion1\n                        del new_solution[route2_idx if route2_idx > route1_idx else route2_idx-1]\n                    else:\n                        new_solution[route1_idx] = fusion2\n                        del new_solution[route2_idx if route2_idx > route1_idx else route2_idx-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: Route Swap + Partial 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes and swap a segment between them\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Randomly select a segment from route1 (excluding depot)\n            start1, end1 = np.sort(np.random.choice(range(1, len(route1) - 1), 2, replace=False))\n            segment1 = route1[start1:end1 + 1]\n\n            # Check if swapping the segment to route2 is feasible\n            if np.sum(demand[segment1]) <= capacity and np.sum(demand[route2[1:-1]]) + np.sum(demand[segment1]) <= capacity:\n                # Insert the segment into route2\n                insert_pos = np.random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove the segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Step 2: Apply partial 2-opt on the modified routes\n                for route_idx in [route1_idx, route2_idx]:\n                    route = new_solution[route_idx]\n                    if len(route) > 3:\n                        # Select two non-adjacent edges to swap\n                        i, j = np.sort(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n                        if (i + 1) != j:\n                            # Check feasibility of the swap\n                            segment = route[i:j + 1]\n                            reversed_segment = segment[::-1]\n                            if np.sum(demand[segment]) <= capacity:\n                                new_route = np.concatenate([route[:i], reversed_segment, route[j + 1:]])\n                                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6706533664222372,
            1.9165573716163635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: Route Swap + Partial 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes and swap a segment between them\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Randomly select a segment from route1 (excluding depot)\n            start1, end1 = np.sort(np.random.choice(range(1, len(route1) - 1), 2, replace=False))\n            segment1 = route1[start1:end1 + 1]\n\n            # Check if swapping the segment to route2 is feasible\n            if np.sum(demand[segment1]) <= capacity and np.sum(demand[route2[1:-1]]) + np.sum(demand[segment1]) <= capacity:\n                # Insert the segment into route2\n                insert_pos = np.random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove the segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Step 2: Apply partial 2-opt on the modified routes\n                for route_idx in [route1_idx, route2_idx]:\n                    route = new_solution[route_idx]\n                    if len(route) > 3:\n                        # Select two non-adjacent edges to swap\n                        i, j = np.sort(np.random.choice(range(1, len(route) - 2), 2, replace=False))\n                        if (i + 1) != j:\n                            # Check feasibility of the swap\n                            segment = route[i:j + 1]\n                            reversed_segment = segment[::-1]\n                            if np.sum(demand[segment]) <= capacity:\n                                new_route = np.concatenate([route[:i], reversed_segment, route[j + 1:]])\n                                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest makespan and total distance)\n    selected_idx = np.argmin([sol[1][0] + sol[1][1] for sol in archive])\n    selected_sol = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_sol:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random split point\n        split_point = np.random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        def check_capacity(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(part1) and check_capacity(part2):\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                remaining_route = np.delete(route, i)\n                if check_capacity(remaining_route):\n                    # Find the best route to insert the customer (minimizing total distance)\n                    best_route_idx = -1\n                    min_increase = float('inf')\n                    for j, r in enumerate(new_solution):\n                        for k in range(1, len(r)):\n                            # Try inserting customer between r[k-1] and r[k]\n                            new_route = np.insert(r, k, customer)\n                            if check_capacity(new_route):\n                                increase = (distance_matrix[customer, r[k-1]] + distance_matrix[customer, r[k]] - distance_matrix[r[k-1], r[k]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_route_idx = j\n                                    best_insert_pos = k\n\n                    if best_route_idx != -1:\n                        new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n                        new_solution.append(remaining_route.copy())\n                        break\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [r for r in new_solution if len(r) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to the route with the least increase in distance\n    for customer in missing_customers:\n        best_route_idx = -1\n        min_increase = float('inf')\n        for j, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n            for k in range(1, len(route)):\n                increase = distance_matrix[customer, route[k-1]] + distance_matrix[customer, route[k]] - distance_matrix[route[k-1], route[k]]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_route_idx = j\n                    best_insert_pos = k\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n        else:\n            # If no feasible route found, create a new route\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7962756942798441,
            11.20942747592926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest makespan and total distance)\n    selected_idx = np.argmin([sol[1][0] + sol[1][1] for sol in archive])\n    selected_sol = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_sol:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random split point\n        split_point = np.random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        def check_capacity(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if check_capacity(part1) and check_capacity(part2):\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                remaining_route = np.delete(route, i)\n                if check_capacity(remaining_route):\n                    # Find the best route to insert the customer (minimizing total distance)\n                    best_route_idx = -1\n                    min_increase = float('inf')\n                    for j, r in enumerate(new_solution):\n                        for k in range(1, len(r)):\n                            # Try inserting customer between r[k-1] and r[k]\n                            new_route = np.insert(r, k, customer)\n                            if check_capacity(new_route):\n                                increase = (distance_matrix[customer, r[k-1]] + distance_matrix[customer, r[k]] - distance_matrix[r[k-1], r[k]])\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_route_idx = j\n                                    best_insert_pos = k\n\n                    if best_route_idx != -1:\n                        new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n                        new_solution.append(remaining_route.copy())\n                        break\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [r for r in new_solution if len(r) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Assign missing customers to the route with the least increase in distance\n    for customer in missing_customers:\n        best_route_idx = -1\n        min_increase = float('inf')\n        for j, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n            for k in range(1, len(route)):\n                increase = distance_matrix[customer, route[k-1]] + distance_matrix[customer, route[k]] - distance_matrix[route[k-1], route[k]]\n                if increase < min_increase:\n                    min_increase = increase\n                    best_route_idx = j\n                    best_insert_pos = k\n\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n        else:\n            # If no feasible route found, create a new route\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route swapping and intra-route insertion to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # More weight on distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route swapping and intra-route insertion\n    new_solution = base_solution.copy()\n    if len(new_solution) > 1:\n        # Route swapping\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Try to find a feasible swap of customers between routes\n        for _ in range(10):  # Try multiple times\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                break\n\n            # Select random customers from each route (excluding depots)\n            cust_i = random.choice(route_i[1:-1])\n            cust_j = random.choice(route_j[1:-1])\n\n            # Check capacity constraints\n            current_cap_i = sum(demand[route_i[1:-1]])\n            current_cap_j = sum(demand[route_j[1:-1]])\n            new_cap_i = current_cap_i - demand[cust_i] + demand[cust_j]\n            new_cap_j = current_cap_j - demand[cust_j] + demand[cust_i]\n\n            if new_cap_i <= capacity and new_cap_j <= capacity:\n                # Perform the swap\n                route_i[route_i == cust_i] = cust_j\n                route_j[route_j == cust_j] = cust_i\n                break\n\n        # Intra-route insertion\n        for route in new_solution:\n            if len(route) > 4:  # Only for routes with enough customers\n                # Remove a random customer and reinsert it\n                cust = random.choice(route[1:-1])\n                route = route[route != cust]\n\n                # Find best insertion position\n                best_pos = 1\n                best_dist = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert after pos\n                    new_route = np.insert(route, pos, cust)\n                    # Calculate new distance for this segment\n                    dist = distance_matrix[route[pos-1], cust] + distance_matrix[cust, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos = pos\n\n                # Insert at best position\n                route = np.insert(route, best_pos, cust)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6926831800863746,
            6.582984387874603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # More weight on distance\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for sol, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route swapping and intra-route insertion\n    new_solution = base_solution.copy()\n    if len(new_solution) > 1:\n        # Route swapping\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Try to find a feasible swap of customers between routes\n        for _ in range(10):  # Try multiple times\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                break\n\n            # Select random customers from each route (excluding depots)\n            cust_i = random.choice(route_i[1:-1])\n            cust_j = random.choice(route_j[1:-1])\n\n            # Check capacity constraints\n            current_cap_i = sum(demand[route_i[1:-1]])\n            current_cap_j = sum(demand[route_j[1:-1]])\n            new_cap_i = current_cap_i - demand[cust_i] + demand[cust_j]\n            new_cap_j = current_cap_j - demand[cust_j] + demand[cust_i]\n\n            if new_cap_i <= capacity and new_cap_j <= capacity:\n                # Perform the swap\n                route_i[route_i == cust_i] = cust_j\n                route_j[route_j == cust_j] = cust_i\n                break\n\n        # Intra-route insertion\n        for route in new_solution:\n            if len(route) > 4:  # Only for routes with enough customers\n                # Remove a random customer and reinsert it\n                cust = random.choice(route[1:-1])\n                route = route[route != cust]\n\n                # Find best insertion position\n                best_pos = 1\n                best_dist = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert after pos\n                    new_route = np.insert(route, pos, cust)\n                    # Calculate new distance for this segment\n                    dist = distance_matrix[route[pos-1], cust] + distance_matrix[cust, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos = pos\n\n                # Insert at best position\n                route = np.insert(route, best_pos, cust)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Route merging and splitting with demand-aware relocations\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Attempt to merge part2 with another route if possible\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if sum(demand[other_route[1:-1]]) + sum(demand[part2[1:-1]]) <= capacity:\n                new_route = np.concatenate([other_route[:-1], part2[1:]])\n                new_solution[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            # If not merged, try to relocate a segment between routes\n            for i in range(len(new_solution)):\n                other_route = new_solution[i]\n                for j in range(1, len(part2) - 1):\n                    if sum(demand[other_route[1:-1]]) + demand[part2[j]] <= capacity:\n                        # Insert node into other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.concatenate([other_route[:insert_pos], [part2[j]], other_route[insert_pos:]])\n                        new_solution[i] = new_route\n                        part2 = np.delete(part2, j)\n                        break\n\n        new_solution.append(part1)\n        if len(part2) > 2:  # Only add if not empty\n            new_solution.append(part2)\n\n    # Ensure all customers are served and routes are valid\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Create new routes for missing customers\n        for node in missing:\n            new_route = np.array([0, node, 0])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7441269576500813,
            1.4819464981555939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Route merging and splitting with demand-aware relocations\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Attempt to merge part2 with another route if possible\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if sum(demand[other_route[1:-1]]) + sum(demand[part2[1:-1]]) <= capacity:\n                new_route = np.concatenate([other_route[:-1], part2[1:]])\n                new_solution[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            # If not merged, try to relocate a segment between routes\n            for i in range(len(new_solution)):\n                other_route = new_solution[i]\n                for j in range(1, len(part2) - 1):\n                    if sum(demand[other_route[1:-1]]) + demand[part2[j]] <= capacity:\n                        # Insert node into other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.concatenate([other_route[:insert_pos], [part2[j]], other_route[insert_pos:]])\n                        new_solution[i] = new_route\n                        part2 = np.delete(part2, j)\n                        break\n\n        new_solution.append(part1)\n        if len(part2) > 2:  # Only add if not empty\n            new_solution.append(part2)\n\n    # Ensure all customers are served and routes are valid\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Create new routes for missing customers\n        for node in missing:\n            new_route = np.array([0, node, 0])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{The algorithm selects a promising solution from the archive, identifies critical segments with high makespan or distance contributions, and applies a hybrid local search operator that combines route merging, customer reallocation, and adaptive 3-opt moves to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, (total_dist, makespan) in archive:\n        candidates.append((sol, total_dist, makespan))\n    candidates.sort(key=lambda x: (x[2], -x[1]))  # Prioritize low makespan, then high total distance\n    base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and adaptive 3-opt\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n            return new_solution\n\n        # Step 2: Customer reallocation (move a customer from a long route to a shorter one)\n        long_route_idx = np.argmax([np.sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n        short_route_idx = np.argmin([np.sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        if len(long_route) > 3:\n            candidate_customer = random.choice(long_route[1:-1])\n            if np.sum(demand[short_route[1:-1]]) + demand[candidate_customer] <= capacity:\n                # Remove from long route\n                new_long_route = np.delete(long_route, np.where(long_route == candidate_customer)[0])\n                # Insert into short route (best position)\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(short_route)):\n                    temp_route = np.insert(short_route, pos, candidate_customer)\n                    dist = np.sum(distance_matrix[temp_route[:-1], temp_route[1:]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_short_route = np.insert(short_route, best_pos, candidate_customer)\n                new_solution[long_route_idx] = new_long_route\n                new_solution[short_route_idx] = new_short_route\n                return new_solution\n\n    # Step 3: Adaptive 3-opt (if no merging or reallocation was done)\n    for route in new_solution:\n        if len(route) > 4:\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt configurations\n            options = [\n                route.copy(),  # original\n                np.concatenate([route[:a], route[a:b][::-1], route[b:c][::-1], route[c:]]),  # reverse a-b and b-c\n                np.concatenate([route[:a], route[b:c], route[a:b], route[c:]]),  # swap a-b and b-c\n                np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]]),  # reverse b-c and swap a-b\n                np.concatenate([route[:a], route[a:b][::-1], route[c:], route[b:c]]),  # reverse a-b and move b-c to end\n                np.concatenate([route[:a], route[c:], route[b:c][::-1], route[a:b]]),  # move b-c to end and reverse\n                np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]]),  # swap a-b and reverse a-b\n                np.concatenate([route[:a], route[c:], route[a:b], route[b:c][::-1]]),  # move b-c to end and reverse b-c\n            ]\n            # Select the best option that doesn't exceed capacity\n            best_route = route\n            best_dist = np.sum(distance_matrix[route[:-1], route[1:]])\n            for opt in options:\n                if np.sum(demand[opt[1:-1]]) <= capacity:\n                    dist = np.sum(distance_matrix[opt[:-1], opt[1:]])\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_route = opt\n            if not np.array_equal(best_route, route):\n                route[:] = best_route\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6292999484437345,
            1.6136735677719116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidates = []\n    for sol, (total_dist, makespan) in archive:\n        candidates.append((sol, total_dist, makespan))\n    candidates.sort(key=lambda x: (x[2], -x[1]))  # Prioritize low makespan, then high total distance\n    base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging, customer reallocation, and adaptive 3-opt\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n            return new_solution\n\n        # Step 2: Customer reallocation (move a customer from a long route to a shorter one)\n        long_route_idx = np.argmax([np.sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n        short_route_idx = np.argmin([np.sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n        long_route = new_solution[long_route_idx]\n        short_route = new_solution[short_route_idx]\n\n        if len(long_route) > 3:\n            candidate_customer = random.choice(long_route[1:-1])\n            if np.sum(demand[short_route[1:-1]]) + demand[candidate_customer] <= capacity:\n                # Remove from long route\n                new_long_route = np.delete(long_route, np.where(long_route == candidate_customer)[0])\n                # Insert into short route (best position)\n                best_pos = 1\n                min_dist = float('inf')\n                for pos in range(1, len(short_route)):\n                    temp_route = np.insert(short_route, pos, candidate_customer)\n                    dist = np.sum(distance_matrix[temp_route[:-1], temp_route[1:]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pos = pos\n                new_short_route = np.insert(short_route, best_pos, candidate_customer)\n                new_solution[long_route_idx] = new_long_route\n                new_solution[short_route_idx] = new_short_route\n                return new_solution\n\n    # Step 3: Adaptive 3-opt (if no merging or reallocation was done)\n    for route in new_solution:\n        if len(route) > 4:\n            a, b, c = sorted(random.sample(range(1, len(route)-1), 3))\n            # Try all 8 possible 3-opt configurations\n            options = [\n                route.copy(),  # original\n                np.concatenate([route[:a], route[a:b][::-1], route[b:c][::-1], route[c:]]),  # reverse a-b and b-c\n                np.concatenate([route[:a], route[b:c], route[a:b], route[c:]]),  # swap a-b and b-c\n                np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]]),  # reverse b-c and swap a-b\n                np.concatenate([route[:a], route[a:b][::-1], route[c:], route[b:c]]),  # reverse a-b and move b-c to end\n                np.concatenate([route[:a], route[c:], route[b:c][::-1], route[a:b]]),  # move b-c to end and reverse\n                np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]]),  # swap a-b and reverse a-b\n                np.concatenate([route[:a], route[c:], route[a:b], route[b:c][::-1]]),  # move b-c to end and reverse b-c\n            ]\n            # Select the best option that doesn't exceed capacity\n            best_route = route\n            best_dist = np.sum(distance_matrix[route[:-1], route[1:]])\n            for opt in options:\n                if np.sum(demand[opt[1:-1]]) <= capacity:\n                    dist = np.sum(distance_matrix[opt[:-1], opt[1:]])\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_route = opt\n            if not np.array_equal(best_route, route):\n                route[:] = best_route\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This function selects a solution from the archive by prioritizing those with the lowest makespan, then applies a hybrid local search combining route splitting and insertion heuristics to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Try to split the selected route into two\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check feasibility of new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n        else:\n            # If splitting fails, try to move a customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n\n                # Select a customer to move\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Try to insert the customer into the other route\n                for pos in range(1, len(other_route)):\n                    new_other_route = other_route.copy()\n                    new_other_route.insert(pos, customer)\n                    new_selected_route = np.delete(selected_route, customer_pos)\n\n                    # Check feasibility\n                    if (np.sum(demand[new_other_route[1:-1]]) <= capacity and\n                        np.sum(demand[new_selected_route[1:-1]]) <= capacity):\n                        new_solution[other_route_idx] = new_other_route\n                        new_solution[route_idx] = new_selected_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8215406795672437,
            0.10807359218597412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Try to split the selected route into two\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check feasibility of new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n        else:\n            # If splitting fails, try to move a customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n\n                # Select a customer to move\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Try to insert the customer into the other route\n                for pos in range(1, len(other_route)):\n                    new_other_route = other_route.copy()\n                    new_other_route.insert(pos, customer)\n                    new_selected_route = np.delete(selected_route, customer_pos)\n\n                    # Check feasibility\n                    if (np.sum(demand[new_other_route[1:-1]]) <= capacity and\n                        np.sum(demand[new_selected_route[1:-1]]) <= capacity):\n                        new_solution[other_route_idx] = new_other_route\n                        new_solution[route_idx] = new_selected_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This function selects a solution from the archive by prioritizing those with the lowest makespan, then applies a hybrid local search combining route splitting and insertion heuristics to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Try to split the selected route into two\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check feasibility of new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n        else:\n            # If splitting fails, try to move a customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n\n                # Select a customer to move\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Try to insert the customer into the other route\n                for pos in range(1, len(other_route)):\n                    new_other_route = other_route.copy()\n                    new_other_route.insert(pos, customer)\n                    new_selected_route = np.delete(selected_route, customer_pos)\n\n                    # Check feasibility\n                    if (np.sum(demand[new_other_route[1:-1]]) <= capacity and\n                        np.sum(demand[new_selected_route[1:-1]]) <= capacity):\n                        new_solution[other_route_idx] = new_other_route\n                        new_solution[route_idx] = new_selected_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8215406795672437,
            0.10807359218597412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Try to split the selected route into two\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check feasibility of new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution.pop(route_idx)\n            new_solution.insert(route_idx, new_route2)\n            new_solution.insert(route_idx, new_route1)\n        else:\n            # If splitting fails, try to move a customer to another route\n            if len(new_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx].copy()\n\n                # Select a customer to move\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Try to insert the customer into the other route\n                for pos in range(1, len(other_route)):\n                    new_other_route = other_route.copy()\n                    new_other_route.insert(pos, customer)\n                    new_selected_route = np.delete(selected_route, customer_pos)\n\n                    # Check feasibility\n                    if (np.sum(demand[new_other_route[1:-1]]) <= capacity and\n                        np.sum(demand[new_selected_route[1:-1]]) <= capacity):\n                        new_solution[other_route_idx] = new_other_route\n                        new_solution[route_idx] = new_selected_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting + customer reallocation + segment reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 1: Route-splitting: Split a long route into two shorter routes\n        if len(route) > 5:\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility of new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Customer reallocation: Move a customer from one route to another\n        if len(new_solution) > 1:\n            src_route_idx = np.random.randint(len(new_solution))\n            src_route = new_solution[src_route_idx]\n            if len(src_route) <= 3:\n                continue\n\n            customer_pos = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_pos]\n\n            for dest_route_idx in range(len(new_solution)):\n                if dest_route_idx == src_route_idx:\n                    continue\n\n                dest_route = new_solution[dest_route_idx]\n                if np.sum(demand[dest_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Insert customer into the destination route\n                insert_pos = np.random.randint(1, len(dest_route))\n                new_dest_route = np.concatenate([\n                    dest_route[:insert_pos],\n                    [customer],\n                    dest_route[insert_pos:]\n                ])\n\n                # Remove customer from source route\n                new_src_route = np.concatenate([\n                    src_route[:customer_pos],\n                    src_route[customer_pos + 1:]\n                ])\n\n                # Check feasibility\n                if (len(new_src_route) >= 3 and\n                    np.sum(demand[new_src_route[1:-1]]) <= capacity):\n                    new_solution[dest_route_idx] = new_dest_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n        # Step 3: Segment reversal: Reverse a segment of the route to reduce distance\n        if len(route) > 4:\n            start_pos = np.random.randint(1, len(route) - 3)\n            end_pos = np.random.randint(start_pos + 1, len(route) - 1)\n            reversed_segment = route[start_pos:end_pos][::-1]\n            new_route = np.concatenate([\n                route[:start_pos],\n                reversed_segment,\n                route[end_pos:]\n            ])\n\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7623066942301541,
            0.4693085551261902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting + customer reallocation + segment reversal\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 1: Route-splitting: Split a long route into two shorter routes\n        if len(route) > 5:\n            split_pos = np.random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check feasibility of new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Customer reallocation: Move a customer from one route to another\n        if len(new_solution) > 1:\n            src_route_idx = np.random.randint(len(new_solution))\n            src_route = new_solution[src_route_idx]\n            if len(src_route) <= 3:\n                continue\n\n            customer_pos = np.random.randint(1, len(src_route) - 1)\n            customer = src_route[customer_pos]\n\n            for dest_route_idx in range(len(new_solution)):\n                if dest_route_idx == src_route_idx:\n                    continue\n\n                dest_route = new_solution[dest_route_idx]\n                if np.sum(demand[dest_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Insert customer into the destination route\n                insert_pos = np.random.randint(1, len(dest_route))\n                new_dest_route = np.concatenate([\n                    dest_route[:insert_pos],\n                    [customer],\n                    dest_route[insert_pos:]\n                ])\n\n                # Remove customer from source route\n                new_src_route = np.concatenate([\n                    src_route[:customer_pos],\n                    src_route[customer_pos + 1:]\n                ])\n\n                # Check feasibility\n                if (len(new_src_route) >= 3 and\n                    np.sum(demand[new_src_route[1:-1]]) <= capacity):\n                    new_solution[dest_route_idx] = new_dest_route\n                    new_solution[src_route_idx] = new_src_route\n                    break\n\n        # Step 3: Segment reversal: Reverse a segment of the route to reduce distance\n        if len(route) > 4:\n            start_pos = np.random.randint(1, len(route) - 3)\n            end_pos = np.random.randint(start_pos + 1, len(route) - 1)\n            reversed_segment = route[start_pos:end_pos][::-1]\n            new_route = np.concatenate([\n                route[:start_pos],\n                reversed_segment,\n                route[end_pos:]\n            ])\n\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(2, len(sorted_archive) - 1)  # Select from top 3 if available\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reallocate\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Try to merge with another route\n        merged = False\n        for i, other_route in enumerate(base_solution):\n            if np.array_equal(other_route, route):\n                continue\n\n            # Check if the segment can fit in the other route\n            other_demand = sum(demand[other_route[1:-1]])\n            if other_demand + sum(demand[segment]) <= capacity:\n                # Insert segment into the other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate the increase in distance\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    increase = (distance_matrix[prev_node, segment[0]] +\n                                distance_matrix[segment[-1], next_node] -\n                                distance_matrix[prev_node, next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Create new routes\n                new_other_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n                new_route = np.concatenate([route[:start], route[end:]])\n\n                # Update solution\n                new_solution.append(new_other_route)\n                new_solution.append(new_route)\n                merged = True\n                break\n\n        if not merged:\n            # If no merge possible, try to reallocate individual customers\n            for customer in segment:\n                best_route = None\n                best_pos = None\n                best_increase = float('inf')\n\n                for i, other_route in enumerate(base_solution):\n                    if np.array_equal(other_route, route):\n                        continue\n\n                    other_demand = sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        prev_node = other_route[pos - 1]\n                        next_node = other_route[pos]\n                        increase = (distance_matrix[prev_node, customer] +\n                                   distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route = i\n                            best_pos = pos\n\n                if best_route is not None:\n                    # Insert customer into best position\n                    new_other_route = np.concatenate([\n                        base_solution[best_route][:best_pos],\n                        [customer],\n                        base_solution[best_route][best_pos:]\n                    ])\n                    new_solution.append(new_other_route)\n\n            # Remove the customer from original route\n            new_route = np.concatenate([route[:start], route[end:]])\n            if len(new_route) > 2:  # Only add if route has customers\n                new_solution.append(new_route)\n\n    # Remove empty routes and ensure all customers are served\n    final_solution = []\n    served_customers = set()\n\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n            served_customers.update(route[1:-1])\n\n    # Add any unserved customers to new routes\n    all_customers = set(range(1, len(demand)))\n    unserved = all_customers - served_customers\n\n    while unserved:\n        customer = unserved.pop()\n        best_route = None\n        best_pos = None\n        best_increase = float('inf')\n\n        for i, route in enumerate(final_solution):\n            route_demand = sum(demand[route[1:-1]])\n            if route_demand + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                prev_node = route[pos - 1]\n                next_node = route[pos]\n                increase = (distance_matrix[prev_node, customer] +\n                           distance_matrix[customer, next_node] -\n                           distance_matrix[prev_node, next_node])\n\n                if increase < best_increase:\n                    best_increase = increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            new_route = np.concatenate([\n                final_solution[best_route][:best_pos],\n                [customer],\n                final_solution[best_route][best_pos:]\n            ])\n            final_solution[best_route] = new_route\n        else:\n            # Create a new route if no feasible insertion found\n            final_solution.append(np.array([0, customer, 0]))\n\n    return final_solution\n\n",
        "score": [
            -0.7389062414807401,
            5.472671836614609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_idx = min(2, len(sorted_archive) - 1)  # Select from top 3 if available\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to reallocate\n        start = np.random.randint(1, len(route) - 2)\n        end = np.random.randint(start + 1, len(route) - 1)\n        segment = route[start:end]\n\n        # Try to merge with another route\n        merged = False\n        for i, other_route in enumerate(base_solution):\n            if np.array_equal(other_route, route):\n                continue\n\n            # Check if the segment can fit in the other route\n            other_demand = sum(demand[other_route[1:-1]])\n            if other_demand + sum(demand[segment]) <= capacity:\n                # Insert segment into the other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    # Calculate the increase in distance\n                    prev_node = other_route[pos - 1]\n                    next_node = other_route[pos]\n                    increase = (distance_matrix[prev_node, segment[0]] +\n                                distance_matrix[segment[-1], next_node] -\n                                distance_matrix[prev_node, next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Create new routes\n                new_other_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n                new_route = np.concatenate([route[:start], route[end:]])\n\n                # Update solution\n                new_solution.append(new_other_route)\n                new_solution.append(new_route)\n                merged = True\n                break\n\n        if not merged:\n            # If no merge possible, try to reallocate individual customers\n            for customer in segment:\n                best_route = None\n                best_pos = None\n                best_increase = float('inf')\n\n                for i, other_route in enumerate(base_solution):\n                    if np.array_equal(other_route, route):\n                        continue\n\n                    other_demand = sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        prev_node = other_route[pos - 1]\n                        next_node = other_route[pos]\n                        increase = (distance_matrix[prev_node, customer] +\n                                   distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n\n                        if increase < best_increase:\n                            best_increase = increase\n                            best_route = i\n                            best_pos = pos\n\n                if best_route is not None:\n                    # Insert customer into best position\n                    new_other_route = np.concatenate([\n                        base_solution[best_route][:best_pos],\n                        [customer],\n                        base_solution[best_route][best_pos:]\n                    ])\n                    new_solution.append(new_other_route)\n\n            # Remove the customer from original route\n            new_route = np.concatenate([route[:start], route[end:]])\n            if len(new_route) > 2:  # Only add if route has customers\n                new_solution.append(new_route)\n\n    # Remove empty routes and ensure all customers are served\n    final_solution = []\n    served_customers = set()\n\n    for route in new_solution:\n        if len(route) > 2:\n            final_solution.append(route)\n            served_customers.update(route[1:-1])\n\n    # Add any unserved customers to new routes\n    all_customers = set(range(1, len(demand)))\n    unserved = all_customers - served_customers\n\n    while unserved:\n        customer = unserved.pop()\n        best_route = None\n        best_pos = None\n        best_increase = float('inf')\n\n        for i, route in enumerate(final_solution):\n            route_demand = sum(demand[route[1:-1]])\n            if route_demand + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                prev_node = route[pos - 1]\n                next_node = route[pos]\n                increase = (distance_matrix[prev_node, customer] +\n                           distance_matrix[customer, next_node] -\n                           distance_matrix[prev_node, next_node])\n\n                if increase < best_increase:\n                    best_increase = increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route is not None:\n            new_route = np.concatenate([\n                final_solution[best_route][:best_pos],\n                [customer],\n                final_solution[best_route][best_pos:]\n            ])\n            final_solution[best_route] = new_route\n        else:\n            # Create a new route if no feasible insertion found\n            final_solution.append(np.array([0, customer, 0]))\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search: route-splitting followed by inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Route-splitting: find the most distant pair to split\n        max_dist = -1\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        if split_pos > 0:\n            # Split the route at the most distant pair\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check feasibility of the split\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Inter-route insertion: move customers between routes to balance makespan\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if len(new_solution[longest_route_idx]) <= 3:  # Skip trivial routes\n            break\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Find the customer with the smallest demand in the longest route\n        min_demand_idx = np.argmin(demand[longest_route[1:-1]]) + 1  # +1 to account for depot\n        customer = longest_route[min_demand_idx]\n\n        # Try to insert this customer into the shortest route\n        best_pos = -1\n        min_increase = float('inf')\n\n        for pos in range(1, len(shortest_route)):\n            # Calculate the increase in distance if inserted at this position\n            increase = (distance_matrix[shortest_route[pos-1]][customer] +\n                        distance_matrix[customer][shortest_route[pos]] -\n                        distance_matrix[shortest_route[pos-1]][shortest_route[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        if best_pos != -1:\n            # Check capacity constraint\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform the insertion\n                new_shortest_route = np.insert(shortest_route, best_pos, customer)\n                new_longest_route = np.delete(longest_route, min_demand_idx)\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.6414644972010555,
            1.114307463169098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search: route-splitting followed by inter-route insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Route-splitting: find the most distant pair to split\n        max_dist = -1\n        split_pos = -1\n        for j in range(1, len(route)-1):\n            dist = distance_matrix[route[j-1]][route[j]] + distance_matrix[route[j]][route[j+1]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        if split_pos > 0:\n            # Split the route at the most distant pair\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check feasibility of the split\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Inter-route insertion: move customers between routes to balance makespan\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find the longest and shortest routes\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        if len(new_solution[longest_route_idx]) <= 3:  # Skip trivial routes\n            break\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Find the customer with the smallest demand in the longest route\n        min_demand_idx = np.argmin(demand[longest_route[1:-1]]) + 1  # +1 to account for depot\n        customer = longest_route[min_demand_idx]\n\n        # Try to insert this customer into the shortest route\n        best_pos = -1\n        min_increase = float('inf')\n\n        for pos in range(1, len(shortest_route)):\n            # Calculate the increase in distance if inserted at this position\n            increase = (distance_matrix[shortest_route[pos-1]][customer] +\n                        distance_matrix[customer][shortest_route[pos]] -\n                        distance_matrix[shortest_route[pos-1]][shortest_route[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        if best_pos != -1:\n            # Check capacity constraint\n            if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform the insertion\n                new_shortest_route = np.insert(shortest_route, best_pos, customer)\n                new_longest_route = np.delete(longest_route, min_demand_idx)\n\n                # Update the solution\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search steps:\n    # 1. Randomly select two routes and attempt to merge them if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged\n            new_solution.pop(j)\n\n    # 2. For each route, perform a cross-route customer relocation\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 3:  # Ensure there are customers to move\n            # Select a random customer from the route\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Try to insert this customer into another route\n            for l in range(len(new_solution)):\n                if k != l and sum(demand[new_solution[l][1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the target route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(new_solution[l])):\n                        # Calculate the cost of inserting the customer\n                        prev_node = new_solution[l][pos-1]\n                        next_node = new_solution[l][pos]\n                        increase = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the insertion\n                    new_solution[l] = np.insert(new_solution[l], best_pos, customer)\n                    new_solution[k] = np.delete(new_solution[k], customer_idx)\n                    break\n\n    # 3. Perform a limited 3-opt on the longest route to refine it\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:  # Ensure enough nodes for 3-opt\n            # Select three random edges to reverse\n            a, b, c = sorted(random.sample(range(1, len(longest_route)-1), 3))\n            new_route = np.concatenate([\n                longest_route[:a],\n                longest_route[a:b][::-1],\n                longest_route[b:c],\n                longest_route[c:][::-1]\n            ])\n            # Check feasibility (capacity constraint)\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7112451112761226,
            1.380751520395279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search steps:\n    # 1. Randomly select two routes and attempt to merge them if feasible\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged\n            new_solution.pop(j)\n\n    # 2. For each route, perform a cross-route customer relocation\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 3:  # Ensure there are customers to move\n            # Select a random customer from the route\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Try to insert this customer into another route\n            for l in range(len(new_solution)):\n                if k != l and sum(demand[new_solution[l][1:-1]]) + demand[customer] <= capacity:\n                    # Find the best insertion position in the target route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(new_solution[l])):\n                        # Calculate the cost of inserting the customer\n                        prev_node = new_solution[l][pos-1]\n                        next_node = new_solution[l][pos]\n                        increase = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform the insertion\n                    new_solution[l] = np.insert(new_solution[l], best_pos, customer)\n                    new_solution[k] = np.delete(new_solution[k], customer_idx)\n                    break\n\n    # 3. Perform a limited 3-opt on the longest route to refine it\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:  # Ensure enough nodes for 3-opt\n            # Select three random edges to reverse\n            a, b, c = sorted(random.sample(range(1, len(longest_route)-1), 3))\n            new_route = np.concatenate([\n                longest_route[:a],\n                longest_route[a:b][::-1],\n                longest_route[b:c],\n                longest_route[c:][::-1]\n            ])\n            # Check feasibility (capacity constraint)\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and then applies a hybrid local search strategy that combines route merging, customer reallocation, and capacity-aware route splitting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Randomly select a customer in the route (excluding depot)\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to reallocate the customer to another route\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if i != route_idx:\n                    total_demand = sum(demand[node] for node in route[1:-1])\n                    if total_demand + demand[customer] <= capacity:\n                        feasible_routes.append(i)\n\n            if feasible_routes:\n                target_route_idx = random.choice(feasible_routes)\n                target_route = new_solution[target_route_idx]\n\n                # Insert customer into the target route (greedy insertion)\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[i-1]][customer] +\n                               distance_matrix[customer][target_route[i]] -\n                               distance_matrix[target_route[i-1]][target_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Insert and remove from original route\n                new_target_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_target_route\n                new_selected_route = np.delete(selected_route, customer_idx)\n                new_solution[route_idx] = new_selected_route\n\n                # If the original route becomes empty, remove it\n                if len(new_selected_route) == 2:  # Only depot\n                    new_solution.pop(route_idx)\n\n    # If no reallocation possible, try merging two routes\n    if len(new_solution) > 1 and random.random() < 0.3:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes (greedy insertion of route2 into route1)\n            merged_route = route1.copy()\n            for customer in route2[1:-1]:\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(merged_route)):\n                    increase = (distance_matrix[merged_route[i-1]][customer] +\n                               distance_matrix[customer][merged_route[i]] -\n                               distance_matrix[merged_route[i-1]][merged_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n                merged_route = np.insert(merged_route, best_pos, customer)\n\n            # Replace the two routes with the merged one\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If infeasible, split the route\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_pos = i\n                    break\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution.remove(route)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.6291966261376459,
            1.2147513031959534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Randomly select a customer in the route (excluding depot)\n        if len(selected_route) > 2:\n            customer_idx = random.randint(1, len(selected_route) - 2)\n            customer = selected_route[customer_idx]\n\n            # Try to reallocate the customer to another route\n            feasible_routes = []\n            for i, route in enumerate(new_solution):\n                if i != route_idx:\n                    total_demand = sum(demand[node] for node in route[1:-1])\n                    if total_demand + demand[customer] <= capacity:\n                        feasible_routes.append(i)\n\n            if feasible_routes:\n                target_route_idx = random.choice(feasible_routes)\n                target_route = new_solution[target_route_idx]\n\n                # Insert customer into the target route (greedy insertion)\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[i-1]][customer] +\n                               distance_matrix[customer][target_route[i]] -\n                               distance_matrix[target_route[i-1]][target_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n\n                # Insert and remove from original route\n                new_target_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_target_route\n                new_selected_route = np.delete(selected_route, customer_idx)\n                new_solution[route_idx] = new_selected_route\n\n                # If the original route becomes empty, remove it\n                if len(new_selected_route) == 2:  # Only depot\n                    new_solution.pop(route_idx)\n\n    # If no reallocation possible, try merging two routes\n    if len(new_solution) > 1 and random.random() < 0.3:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes (greedy insertion of route2 into route1)\n            merged_route = route1.copy()\n            for customer in route2[1:-1]:\n                best_pos = 1\n                min_increase = float('inf')\n                for i in range(1, len(merged_route)):\n                    increase = (distance_matrix[merged_route[i-1]][customer] +\n                               distance_matrix[customer][merged_route[i]] -\n                               distance_matrix[merged_route[i-1]][merged_route[i]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n                merged_route = np.insert(merged_route, best_pos, customer)\n\n            # Replace the two routes with the merged one\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n    # Ensure the solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity:\n            # If infeasible, split the route\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand > capacity:\n                    split_pos = i\n                    break\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution.remove(route)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A hybrid local search operator that combines route merging, route splitting, and demand-aware node relocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    top_30_percent = int(0.3 * len(archive_sorted))\n    selected_solution = random.choice(archive_sorted[:max(1, top_30_percent)])[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Route Merging (if possible)\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n                new_solution.append(merged_route)\n\n        # Step 2: Route Splitting (if possible)\n        if len(new_solution) > 0:\n            route_to_split = random.choice(new_solution)\n            if len(route_to_split) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(route_to_split) - 3)\n                first_part = np.concatenate([route_to_split[:split_pos], [0]])\n                second_part = np.concatenate([[0], route_to_split[split_pos:]])\n\n                # Check feasibility\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    # Replace the original route with the split parts\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n                    new_solution.extend([first_part, second_part])\n\n        # Step 3: Demand-Aware Node Relocation\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Ensure it's worth relocating\n                node_to_move = random.choice(route[1:-1])\n                # Find potential insertion points in other routes\n                for other_route in new_solution:\n                    if len(other_route) > 2 and not np.array_equal(other_route, route):\n                        for pos in range(1, len(other_route)):\n                            # Check feasibility\n                            if (np.sum(demand[route[1:-1]]) - demand[node_to_move] <= capacity and\n                                np.sum(demand[other_route[1:pos]] + demand[node_to_move]) <= capacity):\n                                # Perform relocation\n                                new_route = np.concatenate([route[:route.tolist().index(node_to_move)],\n                                                           route[route.tolist().index(node_to_move)+1:]])\n                                new_other_route = np.concatenate([other_route[:pos], [node_to_move], other_route[pos:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                                new_solution = [r for r in new_solution if not np.array_equal(r, other_route)]\n                                new_solution.extend([new_route, new_other_route])\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.6887506803081022,
            9.48434066772461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    top_30_percent = int(0.3 * len(archive_sorted))\n    selected_solution = random.choice(archive_sorted[:max(1, top_30_percent)])[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search steps\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Route Merging (if possible)\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n                new_solution.append(merged_route)\n\n        # Step 2: Route Splitting (if possible)\n        if len(new_solution) > 0:\n            route_to_split = random.choice(new_solution)\n            if len(route_to_split) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(route_to_split) - 3)\n                first_part = np.concatenate([route_to_split[:split_pos], [0]])\n                second_part = np.concatenate([[0], route_to_split[split_pos:]])\n\n                # Check feasibility\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    # Replace the original route with the split parts\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route_to_split)]\n                    new_solution.extend([first_part, second_part])\n\n        # Step 3: Demand-Aware Node Relocation\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:  # Ensure it's worth relocating\n                node_to_move = random.choice(route[1:-1])\n                # Find potential insertion points in other routes\n                for other_route in new_solution:\n                    if len(other_route) > 2 and not np.array_equal(other_route, route):\n                        for pos in range(1, len(other_route)):\n                            # Check feasibility\n                            if (np.sum(demand[route[1:-1]]) - demand[node_to_move] <= capacity and\n                                np.sum(demand[other_route[1:pos]] + demand[node_to_move]) <= capacity):\n                                # Perform relocation\n                                new_route = np.concatenate([route[:route.tolist().index(node_to_move)],\n                                                           route[route.tolist().index(node_to_move)+1:]])\n                                new_other_route = np.concatenate([other_route[:pos], [node_to_move], other_route[pos:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                                new_solution = [r for r in new_solution if not np.array_equal(r, other_route)]\n                                new_solution.extend([new_route, new_other_route])\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_indices = [i for i, (sol, obj) in enumerate(archive) if obj[1] > np.percentile([o[1] for _, o in archive], 75)]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer reallocation + partial route reversal\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route at a random point if it's too long\n        if len(route) > 10:\n            split_pos = np.random.randint(2, len(route) - 1)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n            continue\n\n        # Step 2: Reallocate customers to other routes if possible\n        for i in range(1, len(route) - 1):\n            customer = route[i]\n            current_load = sum(demand[route[1:-1]])\n            if current_load - demand[customer] <= capacity:\n                # Try to reallocate to another route\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n                    other_load = sum(demand[other_route[1:-1]])\n                    if other_load + demand[customer] <= capacity:\n                        # Insert customer into the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                        new_solution[other_route_idx] = new_route\n                        # Remove customer from original route\n                        new_solution[route_idx] = np.concatenate([route[:i], route[i+1:]])\n                        break\n\n        # Step 3: Partial route reversal to reduce distance\n        if len(route) > 4:\n            start = np.random.randint(1, len(route) - 3)\n            end = np.random.randint(start + 1, len(route) - 1)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7986624760178886,
            7.079304546117783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    candidate_indices = [i for i, (sol, obj) in enumerate(archive) if obj[1] > np.percentile([o[1] for _, o in archive], 75)]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer reallocation + partial route reversal\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Split the route at a random point if it's too long\n        if len(route) > 10:\n            split_pos = np.random.randint(2, len(route) - 1)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[route_idx] = new_route1\n            new_solution.append(new_route2)\n            continue\n\n        # Step 2: Reallocate customers to other routes if possible\n        for i in range(1, len(route) - 1):\n            customer = route[i]\n            current_load = sum(demand[route[1:-1]])\n            if current_load - demand[customer] <= capacity:\n                # Try to reallocate to another route\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n                    other_load = sum(demand[other_route[1:-1]])\n                    if other_load + demand[customer] <= capacity:\n                        # Insert customer into the other route\n                        insert_pos = np.random.randint(1, len(other_route))\n                        new_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                        new_solution[other_route_idx] = new_route\n                        # Remove customer from original route\n                        new_solution[route_idx] = np.concatenate([route[:i], route[i+1:]])\n                        break\n\n        # Step 3: Partial route reversal to reduce distance\n        if len(route) > 4:\n            start = np.random.randint(1, len(route) - 3)\n            end = np.random.randint(start + 1, len(route) - 1)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Sort by makespan ascending, then total distance descending\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and customer relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route at the point that maximizes improvement in makespan\n        best_split = None\n        best_improvement = 0\n        for i in range(1, len(route)-2):\n            split_route1 = route[:i+1]\n            split_route2 = [route[0]] + route[i+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n                np.sum(demand[split_route2[1:-1]]) <= capacity):\n                # Calculate improvement (negative makespan reduction)\n                original_makespan = distance_matrix[route[0], route[-2]] + distance_matrix[route[-2], route[-1]]\n                new_makespan = (distance_matrix[split_route1[0], split_route1[-2]] + distance_matrix[split_route1[-2], split_route1[-1]] +\n                               distance_matrix[split_route2[0], split_route2[-2]] + distance_matrix[split_route2[-2], split_route2[-1]])\n                improvement = original_makespan - new_makespan\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_split = (split_route1, split_route2)\n\n        if best_split is not None:\n            new_solution.extend(best_split)\n        else:\n            # If no good split, try relocating a customer to another route\n            customer_to_relocate = np.random.choice(route[1:-1])\n            for other_route in selected_solution:\n                if other_route is route or len(other_route) >= len(route):\n                    continue\n\n                # Try inserting customer_to_relocate into other_route\n                best_insert_pos = None\n                best_insert_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[other_route[i-1], customer_to_relocate] +\n                           distance_matrix[customer_to_relocate, other_route[i]] -\n                           distance_matrix[other_route[i-1], other_route[i]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = i\n\n                if best_insert_pos is not None:\n                    # Check capacity constraint\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer_to_relocate] <= capacity:\n                        # Perform the relocation\n                        modified_route = np.insert(other_route, best_insert_pos, customer_to_relocate)\n                        new_solution.append(modified_route)\n                        route = np.delete(route, np.where(route == customer_to_relocate)[0][0])\n                        if len(route) > 2:  # Only add if not empty\n                            new_solution.append(route)\n                        break\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7684382297505263,
            9.80646139383316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Sort by makespan ascending, then total distance descending\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and customer relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route at the point that maximizes improvement in makespan\n        best_split = None\n        best_improvement = 0\n        for i in range(1, len(route)-2):\n            split_route1 = route[:i+1]\n            split_route2 = [route[0]] + route[i+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[split_route1[1:-1]]) <= capacity and\n                np.sum(demand[split_route2[1:-1]]) <= capacity):\n                # Calculate improvement (negative makespan reduction)\n                original_makespan = distance_matrix[route[0], route[-2]] + distance_matrix[route[-2], route[-1]]\n                new_makespan = (distance_matrix[split_route1[0], split_route1[-2]] + distance_matrix[split_route1[-2], split_route1[-1]] +\n                               distance_matrix[split_route2[0], split_route2[-2]] + distance_matrix[split_route2[-2], split_route2[-1]])\n                improvement = original_makespan - new_makespan\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_split = (split_route1, split_route2)\n\n        if best_split is not None:\n            new_solution.extend(best_split)\n        else:\n            # If no good split, try relocating a customer to another route\n            customer_to_relocate = np.random.choice(route[1:-1])\n            for other_route in selected_solution:\n                if other_route is route or len(other_route) >= len(route):\n                    continue\n\n                # Try inserting customer_to_relocate into other_route\n                best_insert_pos = None\n                best_insert_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[other_route[i-1], customer_to_relocate] +\n                           distance_matrix[customer_to_relocate, other_route[i]] -\n                           distance_matrix[other_route[i-1], other_route[i]])\n\n                    if cost < best_insert_cost:\n                        best_insert_cost = cost\n                        best_insert_pos = i\n\n                if best_insert_pos is not None:\n                    # Check capacity constraint\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer_to_relocate] <= capacity:\n                        # Perform the relocation\n                        modified_route = np.insert(other_route, best_insert_pos, customer_to_relocate)\n                        new_solution.append(modified_route)\n                        route = np.delete(route, np.where(route == customer_to_relocate)[0][0])\n                        if len(route) > 2:  # Only add if not empty\n                            new_solution.append(route)\n                        break\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n            # Reoptimize the merged route using 2-opt\n            improved_route = two_opt(merged_route, distance_matrix)\n            new_solution[-1] = improved_route\n\n    # Customer reallocation: move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has customers to move\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Try to reallocate to another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                # Check capacity constraint\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        cost = distance_matrix[other_route[pos-1], customer] + \\\n                               distance_matrix[customer, other_route[pos]] - \\\n                               distance_matrix[other_route[pos-1], other_route[pos]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, customer_idx)\n                    break\n\n    # Ensure depot is correctly placed at start and end\n    for i in range(len(new_solution)):\n        new_solution[i] = np.concatenate([[0], new_solution[i][1:], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8170297929841084,
            2.4287731051445007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n            new_solution.append(merged_route)\n\n            # Reoptimize the merged route using 2-opt\n            improved_route = two_opt(merged_route, distance_matrix)\n            new_solution[-1] = improved_route\n\n    # Customer reallocation: move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # Ensure route has customers to move\n            # Randomly select a customer to move\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n\n            # Try to reallocate to another route\n            for other_route in new_solution:\n                if other_route is route:\n                    continue\n                # Check capacity constraint\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion cost\n                        cost = distance_matrix[other_route[pos-1], customer] + \\\n                               distance_matrix[customer, other_route[pos]] - \\\n                               distance_matrix[other_route[pos-1], other_route[pos]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    # Perform insertion\n                    other_route = np.insert(other_route, best_pos, customer)\n                    route = np.delete(route, customer_idx)\n                    break\n\n    # Ensure depot is correctly placed at start and end\n    for i in range(len(new_solution)):\n        new_solution[i] = np.concatenate([[0], new_solution[i][1:], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The novel local search operator combines route merging and split with a demand-aware insertion heuristic to balance distance and makespan objectives, while ensuring feasibility through capacity checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply route merging and split with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two random routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Remove the two routes from the solution\n        new_solution = [route for i, route in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n\n        # Combine the two routes into one\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint for the merged route\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Apply demand-aware insertion to improve the merged route\n            improved_route = []\n            current_demand = 0\n            for node in merged_route:\n                if node == 0:\n                    improved_route.append(node)\n                else:\n                    if current_demand + demand[node] <= capacity:\n                        improved_route.append(node)\n                        current_demand += demand[node]\n                    else:\n                        # Insert the node into the best position in the route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(improved_route)):\n                            temp_route = np.insert(improved_route, pos, node)\n                            temp_demand = sum(demand[n] for n in temp_route if n != 0)\n                            if temp_demand <= capacity:\n                                cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                        improved_route = np.insert(improved_route, best_pos, node)\n                        current_demand = sum(demand[n] for n in improved_route if n != 0)\n\n            # Split the improved route if it exceeds capacity\n            split_routes = []\n            current_route = [0]\n            current_demand = 0\n            for node in improved_route[1:-1]:\n                if current_demand + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_demand += demand[node]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_demand = demand[node]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n\n            # Add the split routes back to the solution\n            new_solution.extend(split_routes)\n\n    return new_solution\n\n",
        "score": [
            -0.8125274153409164,
            0.2952588200569153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply route merging and split with demand-aware insertion\n    if len(new_solution) > 1:\n        # Select two random routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Remove the two routes from the solution\n        new_solution = [route for i, route in enumerate(new_solution) if i not in [route1_idx, route2_idx]]\n\n        # Combine the two routes into one\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint for the merged route\n        total_demand = sum(demand[node] for node in merged_route if node != 0)\n        if total_demand <= capacity:\n            # Apply demand-aware insertion to improve the merged route\n            improved_route = []\n            current_demand = 0\n            for node in merged_route:\n                if node == 0:\n                    improved_route.append(node)\n                else:\n                    if current_demand + demand[node] <= capacity:\n                        improved_route.append(node)\n                        current_demand += demand[node]\n                    else:\n                        # Insert the node into the best position in the route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(improved_route)):\n                            temp_route = np.insert(improved_route, pos, node)\n                            temp_demand = sum(demand[n] for n in temp_route if n != 0)\n                            if temp_demand <= capacity:\n                                cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n                        improved_route = np.insert(improved_route, best_pos, node)\n                        current_demand = sum(demand[n] for n in improved_route if n != 0)\n\n            # Split the improved route if it exceeds capacity\n            split_routes = []\n            current_route = [0]\n            current_demand = 0\n            for node in improved_route[1:-1]:\n                if current_demand + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_demand += demand[node]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, node]\n                    current_demand = demand[node]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n\n            # Add the split routes back to the solution\n            new_solution.extend(split_routes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - 0.5 * x[1][0])[0].copy()\n\n    # Hybrid local search: combine route splitting and customer swap\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n\n    # Step 2: Split the longest route into two parts at a random position\n    route_to_split = selected_solution[longest_route_idx]\n    split_pos = np.random.randint(1, len(route_to_split) - 1)\n    part1 = route_to_split[:split_pos + 1]\n    part2 = route_to_split[split_pos:-1]\n\n    # Step 3: Check capacity constraints for the split parts\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If split violates capacity, perform a customer swap instead\n        # Select two random routes (excluding the depot)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select two random customers from each route (excluding depots)\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_pos = np.random.randint(1, len(route1) - 1)\n                cust2_pos = np.random.randint(1, len(route2) - 1)\n\n                # Swap the customers\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                # Check capacity constraints\n                if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8110995176574729,
            0.26780450344085693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - 0.5 * x[1][0])[0].copy()\n\n    # Hybrid local search: combine route splitting and customer swap\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution])\n\n    # Step 2: Split the longest route into two parts at a random position\n    route_to_split = selected_solution[longest_route_idx]\n    split_pos = np.random.randint(1, len(route_to_split) - 1)\n    part1 = route_to_split[:split_pos + 1]\n    part2 = route_to_split[split_pos:-1]\n\n    # Step 3: Check capacity constraints for the split parts\n    if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If split violates capacity, perform a customer swap instead\n        # Select two random routes (excluding the depot)\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Select two random customers from each route (excluding depots)\n            if len(route1) > 2 and len(route2) > 2:\n                cust1_pos = np.random.randint(1, len(route1) - 1)\n                cust2_pos = np.random.randint(1, len(route2) - 1)\n\n                # Swap the customers\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                # Check capacity constraints\n                if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining route splitting, partial route reversal, and cross-route insertion to generate a neighbor solution that balances distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = [route.copy() for route in archive_sorted[0][0]]\n\n    # Choose a random route to modify\n    route_idx = random.randint(0, len(base_solution) - 1)\n    route = base_solution[route_idx].copy()\n\n    # Hybrid local search: split, reverse, and insert\n    if len(route) > 3:  # Ensure we can split and reverse\n        # Split the route into two parts\n        split_pos = random.randint(2, len(route) - 2)\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Reverse the second part\n        part2_reversed = part2[::-1]\n\n        # Check capacity constraints\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2_reversed[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            base_solution[route_idx] = part1\n            base_solution.insert(route_idx + 1, part2_reversed)\n\n            # Try to merge with adjacent routes if possible\n            if route_idx > 0:\n                prev_route = base_solution[route_idx - 1]\n                if np.sum(demand[prev_route[1:-1]]) + np.sum(demand[part1[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], part1[1:]])\n                    base_solution[route_idx - 1] = merged_route\n                    base_solution.pop(route_idx)\n                    route_idx -= 1\n\n            if route_idx < len(base_solution) - 1:\n                next_route = base_solution[route_idx + 1]\n                if np.sum(demand[next_route[1:-1]]) + np.sum(demand[part2_reversed[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([part2_reversed[:-1], next_route[1:]])\n                    base_solution[route_idx + 1] = merged_route\n                    base_solution.pop(route_idx)\n\n    # Cross-route insertion: move a customer from one route to another\n    if len(base_solution) > 1:\n        from_route_idx = random.randint(0, len(base_solution) - 1)\n        to_route_idx = random.choice([i for i in range(len(base_solution)) if i != from_route_idx])\n\n        from_route = base_solution[from_route_idx]\n        to_route = base_solution[to_route_idx]\n\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Check capacity constraint\n            if (np.sum(demand[from_route[1:-1]]) - demand[customer] <= capacity and\n                np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity):\n\n                # Find the best insertion position in the target route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(to_route)):\n                    new_route = np.insert(to_route, i, customer)\n                    cost = (distance_matrix[new_route[i-1], customer] +\n                           distance_matrix[customer, new_route[i+1]] -\n                           distance_matrix[new_route[i-1], new_route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the insertion\n                to_route = np.insert(to_route, best_pos, customer)\n                from_route = np.delete(from_route, customer_pos)\n\n                # Update the solution\n                base_solution[from_route_idx] = from_route\n                base_solution[to_route_idx] = to_route\n\n    return base_solution\n\n",
        "score": [
            -0.6836024585673703,
            0.415714293718338
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = [route.copy() for route in archive_sorted[0][0]]\n\n    # Choose a random route to modify\n    route_idx = random.randint(0, len(base_solution) - 1)\n    route = base_solution[route_idx].copy()\n\n    # Hybrid local search: split, reverse, and insert\n    if len(route) > 3:  # Ensure we can split and reverse\n        # Split the route into two parts\n        split_pos = random.randint(2, len(route) - 2)\n        part1 = route[:split_pos]\n        part2 = route[split_pos:]\n\n        # Reverse the second part\n        part2_reversed = part2[::-1]\n\n        # Check capacity constraints\n        if (np.sum(demand[part1[1:-1]]) <= capacity and\n            np.sum(demand[part2_reversed[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            base_solution[route_idx] = part1\n            base_solution.insert(route_idx + 1, part2_reversed)\n\n            # Try to merge with adjacent routes if possible\n            if route_idx > 0:\n                prev_route = base_solution[route_idx - 1]\n                if np.sum(demand[prev_route[1:-1]]) + np.sum(demand[part1[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], part1[1:]])\n                    base_solution[route_idx - 1] = merged_route\n                    base_solution.pop(route_idx)\n                    route_idx -= 1\n\n            if route_idx < len(base_solution) - 1:\n                next_route = base_solution[route_idx + 1]\n                if np.sum(demand[next_route[1:-1]]) + np.sum(demand[part2_reversed[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([part2_reversed[:-1], next_route[1:]])\n                    base_solution[route_idx + 1] = merged_route\n                    base_solution.pop(route_idx)\n\n    # Cross-route insertion: move a customer from one route to another\n    if len(base_solution) > 1:\n        from_route_idx = random.randint(0, len(base_solution) - 1)\n        to_route_idx = random.choice([i for i in range(len(base_solution)) if i != from_route_idx])\n\n        from_route = base_solution[from_route_idx]\n        to_route = base_solution[to_route_idx]\n\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Check capacity constraint\n            if (np.sum(demand[from_route[1:-1]]) - demand[customer] <= capacity and\n                np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity):\n\n                # Find the best insertion position in the target route\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(to_route)):\n                    new_route = np.insert(to_route, i, customer)\n                    cost = (distance_matrix[new_route[i-1], customer] +\n                           distance_matrix[customer, new_route[i+1]] -\n                           distance_matrix[new_route[i-1], new_route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform the insertion\n                to_route = np.insert(to_route, best_pos, customer)\n                from_route = np.delete(from_route, customer_pos)\n\n                # Update the solution\n                base_solution[from_route_idx] = from_route\n                base_solution[to_route_idx] = to_route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # 1. Route splitting: split long routes into two\n        if distance_matrix[route[-2], 0] + distance_matrix[0, route[1]] > 1.5 * np.mean(distance_matrix[route[:-1], route[1:]]):\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # 2. Customer reallocation: move customers between routes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                new_demand = np.sum(demand[other_route[1:-1]]) + demand[customer]\n\n                if new_demand <= capacity:\n                    # Insert customer into other route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_cost < 0:  # Only accept improving moves\n                        new_route = np.insert(other_route, best_pos, customer)\n                        new_solution[j] = new_route\n                        new_solution[i] = np.delete(route, k)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6378789928345246,
            2.310179263353348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # 1. Route splitting: split long routes into two\n        if distance_matrix[route[-2], 0] + distance_matrix[0, route[1]] > 1.5 * np.mean(distance_matrix[route[:-1], route[1:]]):\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n            # Check capacity constraints\n            if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n        # 2. Customer reallocation: move customers between routes\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            for k in range(1, len(route)-1):\n                customer = route[k]\n                new_demand = np.sum(demand[other_route[1:-1]]) + demand[customer]\n\n                if new_demand <= capacity:\n                    # Insert customer into other route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    if best_cost < 0:  # Only accept improving moves\n                        new_route = np.insert(other_route, best_pos, customer)\n                        new_solution[j] = new_route\n                        new_solution[i] = np.delete(route, k)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm combines a biased random selection of solutions from the archive, followed by a hybrid local search that intelligently redistributes customers between routes while considering both distance and makespan, and applies a novel route-shaking operator to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by makespan and select one with probability inversely proportional to rank\n        sorted_solutions = sorted(archive, key=lambda x: x[1][1])\n        ranks = np.arange(1, len(sorted_solutions) + 1)\n        probabilities = 1 / ranks\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(sorted_solutions), p=probabilities)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: redistribute customers between routes\n    for _ in range(2):  # Perform 2 redistribution attempts\n        # Select a random route with more than 2 customers\n        candidate_routes = [i for i, route in enumerate(new_solution) if len(route) > 3]\n        if not candidate_routes:\n            break\n\n        route_idx = random.choice(candidate_routes)\n        route = new_solution[route_idx]\n\n        # Select a customer to move\n        customer_idx = random.randint(1, len(route) - 2)  # Exclude depot\n        customer = route[customer_idx]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find the best insertion position in the other route\n            best_pos = 1\n            min_increase = float('inf')\n            for i in range(1, len(other_route)):\n                # Calculate distance increase\n                prev_node = other_route[i-1]\n                next_node = other_route[i]\n                dist_increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = i\n\n            # Insert and remove\n            new_route = np.insert(other_route, best_pos, customer)\n            new_solution[other_route_idx] = new_route\n            new_solution[route_idx] = np.delete(route, customer_idx)\n\n            # Check if original route is now empty (except depot)\n            if len(new_solution[route_idx]) == 2:\n                del new_solution[route_idx]\n\n            break\n\n    # Novel route-shaking operator: randomly swap customers between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Select two different routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Select customers to swap (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_idx = random.randint(1, len(route1) - 2)\n            cust2_idx = random.randint(1, len(route2) - 2)\n\n            cust1, cust2 = route1[cust1_idx], route2[cust2_idx]\n\n            # Check capacity constraints after swap\n            total1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            total2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if total1 <= capacity and total2 <= capacity:\n                # Perform swap\n                route1[cust1_idx], route2[cust2_idx] = cust2, cust1\n                new_solution[route_indices[0]], new_solution[route_indices[1]] = route1, route2\n\n    # Convert back to list of arrays\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.6032231833291312,
            1.3948019444942474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by makespan and select one with probability inversely proportional to rank\n        sorted_solutions = sorted(archive, key=lambda x: x[1][1])\n        ranks = np.arange(1, len(sorted_solutions) + 1)\n        probabilities = 1 / ranks\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(sorted_solutions), p=probabilities)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: redistribute customers between routes\n    for _ in range(2):  # Perform 2 redistribution attempts\n        # Select a random route with more than 2 customers\n        candidate_routes = [i for i, route in enumerate(new_solution) if len(route) > 3]\n        if not candidate_routes:\n            break\n\n        route_idx = random.choice(candidate_routes)\n        route = new_solution[route_idx]\n\n        # Select a customer to move\n        customer_idx = random.randint(1, len(route) - 2)  # Exclude depot\n        customer = route[customer_idx]\n\n        # Try to insert into another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find the best insertion position in the other route\n            best_pos = 1\n            min_increase = float('inf')\n            for i in range(1, len(other_route)):\n                # Calculate distance increase\n                prev_node = other_route[i-1]\n                next_node = other_route[i]\n                dist_increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = i\n\n            # Insert and remove\n            new_route = np.insert(other_route, best_pos, customer)\n            new_solution[other_route_idx] = new_route\n            new_solution[route_idx] = np.delete(route, customer_idx)\n\n            # Check if original route is now empty (except depot)\n            if len(new_solution[route_idx]) == 2:\n                del new_solution[route_idx]\n\n            break\n\n    # Novel route-shaking operator: randomly swap customers between routes\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Select two different routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Select customers to swap (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_idx = random.randint(1, len(route1) - 2)\n            cust2_idx = random.randint(1, len(route2) - 2)\n\n            cust1, cust2 = route1[cust1_idx], route2[cust2_idx]\n\n            # Check capacity constraints after swap\n            total1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            total2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if total1 <= capacity and total2 <= capacity:\n                # Perform swap\n                route1[cust1_idx], route2[cust2_idx] = cust2, cust1\n                new_solution[route_indices[0]], new_solution[route_indices[1]] = route1, route2\n\n    # Convert back to list of arrays\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then select a middle solution (avoiding extremes)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and 2-opt with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route Splitting (if makespan is large)\n        if distance_matrix[route[0], route[-1]] > 2 * np.mean(distance_matrix[route[:-1], route[1:]]):\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Modified 2-opt (avoids pure 2-opt)\n        for j in range(1, len(route) - 2):\n            for k in range(j + 2, len(route) - 1):\n                # Reverse segment and check capacity\n                reversed_segment = route[j:k+1][::-1]\n                candidate_route = np.concatenate((route[:j], reversed_segment, route[k+1:]))\n\n                if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                    new_solution[i] = candidate_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7112956991050302,
            3.225229859352112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by total distance and makespan, then select a middle solution (avoiding extremes)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Combine route splitting and 2-opt with capacity checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route Splitting (if makespan is large)\n        if distance_matrix[route[0], route[-1]] > 2 * np.mean(distance_matrix[route[:-1], route[1:]]):\n            split_pos = len(route) // 2\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n        # Step 2: Modified 2-opt (avoids pure 2-opt)\n        for j in range(1, len(route) - 2):\n            for k in range(j + 2, len(route) - 1):\n                # Reverse segment and check capacity\n                reversed_segment = route[j:k+1][::-1]\n                candidate_route = np.concatenate((route[:j], reversed_segment, route[k+1:]))\n\n                if np.sum(demand[candidate_route[1:-1]]) <= capacity:\n                    new_solution[i] = candidate_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The algorithm intelligently selects a solution with high potential for improvement by prioritizing those with low total distance and high makespan, then applies a hybrid local search combining route fragmentation and capacity-aware reinsertion to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] / (obj[1] + 1e-6) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + capacity-aware reinsertion\n    for _ in range(3):  # Repeat for multiple attempts\n        # Randomly select a route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split the route at a random point (not depot)\n        split_pos = random.randint(1, len(route) - 2)\n        fragment = route[split_pos:-1]  # Exclude the depot at end\n\n        # Remove fragment from original route\n        new_solution[route_idx] = np.concatenate([route[:split_pos], [0]])\n\n        # Try to reinsert fragment into other routes or create new route\n        inserted = False\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n            # Check capacity constraint\n            if sum(demand[fragment]) + sum(demand[candidate_route[1:-1]]) <= capacity:\n                # Insert fragment at the best position\n                best_pos = 1  # After depot\n                min_cost = float('inf')\n                for j in range(1, len(candidate_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[candidate_route[j-1], fragment[0]] +\n                           distance_matrix[fragment[-1], candidate_route[j]] -\n                           distance_matrix[candidate_route[j-1], candidate_route[j]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n                # Perform insertion\n                new_solution[i] = np.concatenate([\n                    candidate_route[:best_pos],\n                    fragment,\n                    candidate_route[best_pos:]\n                ])\n                inserted = True\n                break\n\n        if not inserted and sum(demand[fragment]) <= capacity:\n            # Create new route if no suitable insertion found\n            new_route = np.concatenate([[0], fragment, [0]])\n            new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6860409519725292,
            1.2192350625991821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] / (obj[1] + 1e-6) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + capacity-aware reinsertion\n    for _ in range(3):  # Repeat for multiple attempts\n        # Randomly select a route to fragment\n        if len(new_solution) < 2:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Split the route at a random point (not depot)\n        split_pos = random.randint(1, len(route) - 2)\n        fragment = route[split_pos:-1]  # Exclude the depot at end\n\n        # Remove fragment from original route\n        new_solution[route_idx] = np.concatenate([route[:split_pos], [0]])\n\n        # Try to reinsert fragment into other routes or create new route\n        inserted = False\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n            candidate_route = new_solution[i]\n            # Check capacity constraint\n            if sum(demand[fragment]) + sum(demand[candidate_route[1:-1]]) <= capacity:\n                # Insert fragment at the best position\n                best_pos = 1  # After depot\n                min_cost = float('inf')\n                for j in range(1, len(candidate_route)):\n                    # Calculate insertion cost\n                    cost = (distance_matrix[candidate_route[j-1], fragment[0]] +\n                           distance_matrix[fragment[-1], candidate_route[j]] -\n                           distance_matrix[candidate_route[j-1], candidate_route[j]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n                # Perform insertion\n                new_solution[i] = np.concatenate([\n                    candidate_route[:best_pos],\n                    fragment,\n                    candidate_route[best_pos:]\n                ])\n                inserted = True\n                break\n\n        if not inserted and sum(demand[fragment]) <= capacity:\n            # Create new route if no suitable insertion found\n            new_route = np.concatenate([[0], fragment, [0]])\n            new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objectives (prioritizing solutions with shorter total distance and lower makespan) and applies a hybrid local search strategy that combines route swapping and partial reordering, ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([(dist, span) for _, (dist, span) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 0.6 * (1 - normalized[:, 0]) + 0.4 * (1 - normalized[:, 1])  # Prioritize distance then makespan\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap customers between routes and reorder within routes\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select two routes for potential swapping\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Step 2: Find feasible customer swaps (respecting capacity)\n        feasible_swaps = []\n        for ci in range(1, len(route_i) - 1):\n            for cj in range(1, len(route_j) - 1):\n                # Check if swapping customers would violate capacity\n                total_i = np.sum(demand[route_i[1:-1]]) - demand[route_i[ci]] + demand[route_j[cj]]\n                total_j = np.sum(demand[route_j[1:-1]]) - demand[route_j[cj]] + demand[route_i[ci]]\n                if total_i <= capacity and total_j <= capacity:\n                    feasible_swaps.append((ci, cj))\n\n        if feasible_swaps:\n            ci, cj = random.choice(feasible_swaps)\n            # Perform the swap\n            route_i[ci], route_j[cj] = route_j[cj], route_i[ci]\n\n    # Step 3: Reorder customers within a randomly selected route\n    if len(new_solution) > 0:\n        k = random.randint(0, len(new_solution) - 1)\n        route_k = new_solution[k]\n        if len(route_k) > 4:  # Only reorder if route has enough customers\n            # Select a segment to reorder\n            start = random.randint(1, len(route_k) - 3)\n            end = random.randint(start + 1, len(route_k) - 2)\n            segment = route_k[start:end]\n            np.random.shuffle(segment)\n            route_k[start:end] = segment\n\n    # Ensure all routes are feasible (capacity constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return [route.copy() for route in new_solution]\n\n",
        "score": [
            -0.6408377712804589,
            4.32202211022377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([(dist, span) for _, (dist, span) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 0.6 * (1 - normalized[:, 0]) + 0.4 * (1 - normalized[:, 1])  # Prioritize distance then makespan\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap customers between routes and reorder within routes\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select two routes for potential swapping\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        # Step 2: Find feasible customer swaps (respecting capacity)\n        feasible_swaps = []\n        for ci in range(1, len(route_i) - 1):\n            for cj in range(1, len(route_j) - 1):\n                # Check if swapping customers would violate capacity\n                total_i = np.sum(demand[route_i[1:-1]]) - demand[route_i[ci]] + demand[route_j[cj]]\n                total_j = np.sum(demand[route_j[1:-1]]) - demand[route_j[cj]] + demand[route_i[ci]]\n                if total_i <= capacity and total_j <= capacity:\n                    feasible_swaps.append((ci, cj))\n\n        if feasible_swaps:\n            ci, cj = random.choice(feasible_swaps)\n            # Perform the swap\n            route_i[ci], route_j[cj] = route_j[cj], route_i[ci]\n\n    # Step 3: Reorder customers within a randomly selected route\n    if len(new_solution) > 0:\n        k = random.randint(0, len(new_solution) - 1)\n        route_k = new_solution[k]\n        if len(route_k) > 4:  # Only reorder if route has enough customers\n            # Select a segment to reorder\n            start = random.randint(1, len(route_k) - 3)\n            end = random.randint(start + 1, len(route_k) - 2)\n            segment = route_k[start:end]\n            np.random.shuffle(segment)\n            route_k[start:end] = segment\n\n    # Ensure all routes are feasible (capacity constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to base solution\n            return base_solution\n\n    return [route.copy() for route in new_solution]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route splitting with customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                # Find the route with minimal additional distance to insert this customer\n                best_route_idx = -1\n                min_additional_distance = float('inf')\n                for i, route_candidate in enumerate(new_solution):\n                    if np.sum(demand[route_candidate[1:-1]]) + demand[customer] > capacity:\n                        continue\n                    # Calculate insertion cost (simplified)\n                    insertion_cost = distance_matrix[route_candidate[-2], customer] + distance_matrix[customer, route_candidate[-1]] - distance_matrix[route_candidate[-2], route_candidate[-1]]\n                    if insertion_cost < min_additional_distance:\n                        min_additional_distance = insertion_cost\n                        best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Insert into the best route\n                    best_route = new_solution[best_route_idx]\n                    insert_pos = np.random.randint(1, len(best_route))\n                    best_route = np.insert(best_route, insert_pos, customer)\n                    new_solution[best_route_idx] = best_route\n                else:\n                    # If no suitable route found, create a new route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = set(range(1, len(demand))) - served_customers\n    for customer in missing_customers:\n        # Assign to the route with minimal additional distance\n        best_route_idx = -1\n        min_additional_distance = float('inf')\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n            insertion_cost = distance_matrix[route[-2], customer] + distance_matrix[customer, route[-1]] - distance_matrix[route[-2], route[-1]]\n            if insertion_cost < min_additional_distance:\n                min_additional_distance = insertion_cost\n                best_route_idx = i\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            insert_pos = np.random.randint(1, len(best_route))\n            best_route = np.insert(best_route, insert_pos, customer)\n            new_solution[best_route_idx] = best_route\n        else:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.8218514150707137,
            7.260518282651901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine route splitting with customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if (np.sum(demand[part1[1:-1]]) <= capacity) and (np.sum(demand[part2[1:-1]]) <= capacity):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If split violates capacity, try reallocating customers to other routes\n            for customer in route[1:-1]:\n                # Find the route with minimal additional distance to insert this customer\n                best_route_idx = -1\n                min_additional_distance = float('inf')\n                for i, route_candidate in enumerate(new_solution):\n                    if np.sum(demand[route_candidate[1:-1]]) + demand[customer] > capacity:\n                        continue\n                    # Calculate insertion cost (simplified)\n                    insertion_cost = distance_matrix[route_candidate[-2], customer] + distance_matrix[customer, route_candidate[-1]] - distance_matrix[route_candidate[-2], route_candidate[-1]]\n                    if insertion_cost < min_additional_distance:\n                        min_additional_distance = insertion_cost\n                        best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Insert into the best route\n                    best_route = new_solution[best_route_idx]\n                    insert_pos = np.random.randint(1, len(best_route))\n                    best_route = np.insert(best_route, insert_pos, customer)\n                    new_solution[best_route_idx] = best_route\n                else:\n                    # If no suitable route found, create a new route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = set(range(1, len(demand))) - served_customers\n    for customer in missing_customers:\n        # Assign to the route with minimal additional distance\n        best_route_idx = -1\n        min_additional_distance = float('inf')\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n            insertion_cost = distance_matrix[route[-2], customer] + distance_matrix[customer, route[-1]] - distance_matrix[route[-2], route[-1]]\n            if insertion_cost < min_additional_distance:\n                min_additional_distance = insertion_cost\n                best_route_idx = i\n\n        if best_route_idx != -1:\n            best_route = new_solution[best_route_idx]\n            insert_pos = np.random.randint(1, len(best_route))\n            best_route = np.insert(best_route, insert_pos, customer)\n            new_solution[best_route_idx] = best_route\n        else:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution with high potential for improvement by prioritizing those with the longest makespan or high total distance, then applies a hybrid local search combining route splitting, cross-exchange, and demand-balanced insertion to generate a neighbor solution that balances both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: split, cross-exchange, and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split a long route into two)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos+1]\n        new_route2 = [0] + longest_route[split_pos+1:]\n\n        # Ensure capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Cross-exchange (swap segments between two routes)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find exchange segments\n        pos1 = random.randint(1, len(route1)-2)\n        pos2 = random.randint(1, len(route2)-2)\n\n        # Propose new routes\n        new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n        new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n        # Check capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Demand-balanced insertion (move a customer to a route with similar demand)\n    all_customers = set(range(1, len(coords)))\n    assigned_customers = set(np.concatenate([route[1:-1] for route in new_solution]))\n    unassigned = list(all_customers - assigned_customers)\n\n    if unassigned:\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n        target_demand = sum(demand[target_route[1:-1]])\n\n        # Find a customer with demand closest to the average demand of the route\n        best_cust = None\n        min_diff = float('inf')\n        for cust in unassigned:\n            diff = abs(demand[cust] - target_demand / len(target_route))\n            if diff < min_diff:\n                min_diff = diff\n                best_cust = cust\n\n        if best_cust is not None:\n            # Insert at the position that minimizes the increase in route length\n            best_pos = 1\n            best_increase = float('inf')\n            for i in range(1, len(target_route)):\n                increase = (distance_matrix[target_route[i-1]][best_cust] +\n                           distance_matrix[best_cust][target_route[i]] -\n                           distance_matrix[target_route[i-1]][target_route[i]])\n                if increase < best_increase:\n                    best_increase = increase\n                    best_pos = i\n\n            # Check capacity constraint\n            if target_demand + demand[best_cust] <= capacity:\n                new_route = np.insert(target_route, best_pos, best_cust)\n                new_solution[target_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7327398387727277,
            0.5810457766056061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: split, cross-exchange, and demand-balanced insertion\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split a long route into two)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos+1]\n        new_route2 = [0] + longest_route[split_pos+1:]\n\n        # Ensure capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Cross-exchange (swap segments between two routes)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find exchange segments\n        pos1 = random.randint(1, len(route1)-2)\n        pos2 = random.randint(1, len(route2)-2)\n\n        # Propose new routes\n        new_route1 = np.concatenate([route1[:pos1], route2[pos2:-1], route1[pos1:]])\n        new_route2 = np.concatenate([route2[:pos2], route1[pos1:-1], route2[pos2:]])\n\n        # Check capacity constraints\n        if (sum(demand[new_route1[1:-1]]) <= capacity and\n            sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Demand-balanced insertion (move a customer to a route with similar demand)\n    all_customers = set(range(1, len(coords)))\n    assigned_customers = set(np.concatenate([route[1:-1] for route in new_solution]))\n    unassigned = list(all_customers - assigned_customers)\n\n    if unassigned:\n        target_route_idx = random.randint(0, len(new_solution)-1)\n        target_route = new_solution[target_route_idx]\n        target_demand = sum(demand[target_route[1:-1]])\n\n        # Find a customer with demand closest to the average demand of the route\n        best_cust = None\n        min_diff = float('inf')\n        for cust in unassigned:\n            diff = abs(demand[cust] - target_demand / len(target_route))\n            if diff < min_diff:\n                min_diff = diff\n                best_cust = cust\n\n        if best_cust is not None:\n            # Insert at the position that minimizes the increase in route length\n            best_pos = 1\n            best_increase = float('inf')\n            for i in range(1, len(target_route)):\n                increase = (distance_matrix[target_route[i-1]][best_cust] +\n                           distance_matrix[best_cust][target_route[i]] -\n                           distance_matrix[target_route[i-1]][target_route[i]])\n                if increase < best_increase:\n                    best_increase = increase\n                    best_pos = i\n\n            # Check capacity constraint\n            if target_demand + demand[best_cust] <= capacity:\n                new_route = np.insert(target_route, best_pos, best_cust)\n                new_solution[target_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search combining route-splitting, cross-route relocation, and capacity-aware route merging to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-splitting, cross-route relocation, and capacity-aware merging\n    for _ in range(5):  # Perform multiple iterations\n        # Step 1: Route-splitting - Split long routes if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = route[:split_pos+1]\n                new_route2 = [0] + route[split_pos+1:]\n\n                # Check if both new routes are feasible\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Cross-route relocation - Move a customer from one route to another\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # Ensure route1 has customers to move\n                # Select a customer to move from route1\n                customer_pos = np.random.randint(1, len(route1)-1)\n                customer = route1[customer_pos]\n\n                # Check if moving this customer to route2 is feasible\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route1\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Add customer to route2 (insert at best position)\n                    best_pos = 1  # Default to first position\n                    min_increase = float('inf')\n                    for pos in range(1, len(route2)):\n                        # Calculate distance increase\n                        increase = (distance_matrix[route2[pos-1], customer] +\n                                  distance_matrix[customer, route2[pos]] -\n                                  distance_matrix[route2[pos-1], route2[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    new_route2 = np.insert(route2, best_pos, customer)\n                    new_solution[route2_idx] = new_route2\n\n        # Step 3: Capacity-aware route merging - Merge routes if possible\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is feasible\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 20):  # Limit route length\n                    # Create merged route (route1 + route2)\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                    # Remove the two routes and add the merged one\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(merged_route)\n                    break  # Only merge one pair per iteration\n\n    # Convert back to list of numpy arrays and return\n    return [np.array(route) for route in new_solution]\n\n",
        "score": [
            -0.8205938082584844,
            9.81450966000557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-splitting, cross-route relocation, and capacity-aware merging\n    for _ in range(5):  # Perform multiple iterations\n        # Step 1: Route-splitting - Split long routes if possible\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only split if route is long enough\n                split_pos = np.random.randint(1, len(route)-1)\n                new_route1 = route[:split_pos+1]\n                new_route2 = [0] + route[split_pos+1:]\n\n                # Check if both new routes are feasible\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break  # Only split one route per iteration\n\n        # Step 2: Cross-route relocation - Move a customer from one route to another\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # Ensure route1 has customers to move\n                # Select a customer to move from route1\n                customer_pos = np.random.randint(1, len(route1)-1)\n                customer = route1[customer_pos]\n\n                # Check if moving this customer to route2 is feasible\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Remove customer from route1\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Add customer to route2 (insert at best position)\n                    best_pos = 1  # Default to first position\n                    min_increase = float('inf')\n                    for pos in range(1, len(route2)):\n                        # Calculate distance increase\n                        increase = (distance_matrix[route2[pos-1], customer] +\n                                  distance_matrix[customer, route2[pos]] -\n                                  distance_matrix[route2[pos-1], route2[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    new_route2 = np.insert(route2, best_pos, customer)\n                    new_solution[route2_idx] = new_route2\n\n        # Step 3: Capacity-aware route merging - Merge routes if possible\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is feasible\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 20):  # Limit route length\n                    # Create merged route (route1 + route2)\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                    # Remove the two routes and add the merged one\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                    new_solution.append(merged_route)\n                    break  # Only merge one pair per iteration\n\n    # Convert back to list of numpy arrays and return\n    return [np.array(route) for route in new_solution]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0]\n    else:\n        # Sort solutions by makespan (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][1])\n        # Select with probability inversely proportional to rank\n        ranks = np.arange(1, len(sorted_archive) + 1)\n        probabilities = 1 / ranks\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(sorted_archive), p=probabilities)\n        selected_solution = sorted_archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search operator: Route Swap + Customer Reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to swap a customer between the two routes\n        for _ in range(2):  # Try twice\n            # Select a random customer from route1 (excluding depot)\n            if len(route1) > 2:\n                cust1_idx = np.random.randint(1, len(route1) - 1)\n                cust1 = route1[cust1_idx]\n\n                # Check if moving cust1 to route2 would violate capacity\n                route2_demand = sum(demand[route2[1:-1]])\n                if route2_demand + demand[cust1] <= capacity:\n                    # Remove cust1 from route1\n                    route1 = np.delete(route1, cust1_idx)\n                    # Insert cust1 into route2 (random position)\n                    insert_pos = np.random.randint(1, len(route2))\n                    route2 = np.insert(route2, insert_pos, cust1)\n                    # Update routes\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Apply Customer Reallocation: Move a customer to a different route if it improves both objectives\n    for route in new_solution:\n        if len(route) > 2:\n            # Select a random customer\n            cust_idx = np.random.randint(1, len(route) - 1)\n            cust = route[cust_idx]\n\n            # Try to move this customer to another route\n            for other_route in new_solution:\n                if len(other_route) < len(route):  # Prefer shorter routes to balance makespan\n                    other_demand = sum(demand[other_route[1:-1]])\n                    if other_demand + demand[cust] <= capacity:\n                        # Calculate current and new distances\n                        current_dist = distance_matrix[route[cust_idx - 1], cust] + distance_matrix[cust, route[cust_idx + 1]]\n                        new_dist = distance_matrix[other_route[-2], cust] + distance_matrix[cust, other_route[-1]]\n\n                        if new_dist < current_dist:\n                            # Remove from current route\n                            route = np.delete(route, cust_idx)\n                            # Add to other route\n                            other_route = np.insert(other_route, -1, cust)\n                            break\n\n    # Ensure all routes are valid (start and end with depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.4966983798370474,
            2.1757118105888367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0]\n    else:\n        # Sort solutions by makespan (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][1])\n        # Select with probability inversely proportional to rank\n        ranks = np.arange(1, len(sorted_archive) + 1)\n        probabilities = 1 / ranks\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(sorted_archive), p=probabilities)\n        selected_solution = sorted_archive[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a hybrid local search operator: Route Swap + Customer Reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to swap a customer between the two routes\n        for _ in range(2):  # Try twice\n            # Select a random customer from route1 (excluding depot)\n            if len(route1) > 2:\n                cust1_idx = np.random.randint(1, len(route1) - 1)\n                cust1 = route1[cust1_idx]\n\n                # Check if moving cust1 to route2 would violate capacity\n                route2_demand = sum(demand[route2[1:-1]])\n                if route2_demand + demand[cust1] <= capacity:\n                    # Remove cust1 from route1\n                    route1 = np.delete(route1, cust1_idx)\n                    # Insert cust1 into route2 (random position)\n                    insert_pos = np.random.randint(1, len(route2))\n                    route2 = np.insert(route2, insert_pos, cust1)\n                    # Update routes\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Apply Customer Reallocation: Move a customer to a different route if it improves both objectives\n    for route in new_solution:\n        if len(route) > 2:\n            # Select a random customer\n            cust_idx = np.random.randint(1, len(route) - 1)\n            cust = route[cust_idx]\n\n            # Try to move this customer to another route\n            for other_route in new_solution:\n                if len(other_route) < len(route):  # Prefer shorter routes to balance makespan\n                    other_demand = sum(demand[other_route[1:-1]])\n                    if other_demand + demand[cust] <= capacity:\n                        # Calculate current and new distances\n                        current_dist = distance_matrix[route[cust_idx - 1], cust] + distance_matrix[cust, route[cust_idx + 1]]\n                        new_dist = distance_matrix[other_route[-2], cust] + distance_matrix[cust, other_route[-1]]\n\n                        if new_dist < current_dist:\n                            # Remove from current route\n                            route = np.delete(route, cust_idx)\n                            # Add to other route\n                            other_route = np.insert(other_route, -1, cust)\n                            break\n\n    # Ensure all routes are valid (start and end with depot)\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive with high potential for improvement, then applies a hybrid local search combining route segment swapping and demand-aware node reinsertion to generate a feasible neighbor solution while balancing distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment swap + demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n\n        # Find feasible swap points\n        def find_swap_points(r1, r2):\n            for a in range(1, len(r1)-1):\n                for b in range(1, len(r2)-1):\n                    if (np.sum(demand[r1[a+1:]]) + np.sum(demand[r2[1:b]])) <= capacity and \\\n                       (np.sum(demand[r2[b+1:]]) + np.sum(demand[r1[1:a]])) <= capacity:\n                        return a, b\n            return None, None\n\n        a, b = find_swap_points(route_i, route_j)\n        if a is not None and b is not None:\n            # Perform segment swap\n            new_route_i = np.concatenate([route_i[:a+1], route_j[b+1:-1], route_i[a+1:]])\n            new_route_j = np.concatenate([route_j[:b+1], route_i[a+1:-1], route_j[b+1:]])\n\n            # Update solution\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n            # Demand-aware reinsertion for further improvement\n            for route in new_solution:\n                if len(route) > 3:  # Only process routes with more than 2 customers\n                    # Randomly select a node to reinsert\n                    pos = random.randint(1, len(route)-2)\n                    node = route[pos]\n\n                    # Remove node\n                    temp_route = np.delete(route, pos)\n\n                    # Find best insertion point\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for k in range(1, len(temp_route)):\n                        # Try inserting at position k\n                        new_temp_route = np.insert(temp_route, k, node)\n                        if np.sum(demand[new_temp_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost (distance increase)\n                            cost = (distance_matrix[new_temp_route[k-1], node] +\n                                   distance_matrix[node, new_temp_route[k+1]] -\n                                   distance_matrix[new_temp_route[k-1], new_temp_route[k]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = k\n\n                    # Perform best insertion\n                    route[:] = np.insert(temp_route, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7515722405722232,
            8.607192307710648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment swap + demand-aware reinsertion\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i].copy()\n        route_j = new_solution[j].copy()\n\n        # Find feasible swap points\n        def find_swap_points(r1, r2):\n            for a in range(1, len(r1)-1):\n                for b in range(1, len(r2)-1):\n                    if (np.sum(demand[r1[a+1:]]) + np.sum(demand[r2[1:b]])) <= capacity and \\\n                       (np.sum(demand[r2[b+1:]]) + np.sum(demand[r1[1:a]])) <= capacity:\n                        return a, b\n            return None, None\n\n        a, b = find_swap_points(route_i, route_j)\n        if a is not None and b is not None:\n            # Perform segment swap\n            new_route_i = np.concatenate([route_i[:a+1], route_j[b+1:-1], route_i[a+1:]])\n            new_route_j = np.concatenate([route_j[:b+1], route_i[a+1:-1], route_j[b+1:]])\n\n            # Update solution\n            new_solution[i] = new_route_i\n            new_solution[j] = new_route_j\n\n            # Demand-aware reinsertion for further improvement\n            for route in new_solution:\n                if len(route) > 3:  # Only process routes with more than 2 customers\n                    # Randomly select a node to reinsert\n                    pos = random.randint(1, len(route)-2)\n                    node = route[pos]\n\n                    # Remove node\n                    temp_route = np.delete(route, pos)\n\n                    # Find best insertion point\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for k in range(1, len(temp_route)):\n                        # Try inserting at position k\n                        new_temp_route = np.insert(temp_route, k, node)\n                        if np.sum(demand[new_temp_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost (distance increase)\n                            cost = (distance_matrix[new_temp_route[k-1], node] +\n                                   distance_matrix[node, new_temp_route[k+1]] -\n                                   distance_matrix[new_temp_route[k-1], new_temp_route[k]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = k\n\n                    # Perform best insertion\n                    route[:] = np.insert(temp_route, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - 0.3 * x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (potential for fragmentation)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][:-1], new_solution[i][1:]].sum())\n    longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n    # Step 2: Fragment the longest route into smaller segments based on demand\n    fragments = []\n    current_fragment = []\n    current_demand = 0.0\n    for node in longest_route:\n        if current_demand + demand[node] > capacity:\n            if current_fragment:\n                fragments.append(current_fragment)\n                current_fragment = []\n                current_demand = 0.0\n        current_fragment.append(node)\n        current_demand += demand[node]\n    if current_fragment:\n        fragments.append(current_fragment)\n\n    # Step 3: Insert fragments into other routes or create new routes\n    for fragment in fragments:\n        fragment_demand = sum(demand[node] for node in fragment)\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand + fragment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertions in this route\n            for j in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[j-1]\n                next_node = route[j]\n                insertion_cost = distance_matrix[prev_node, fragment[0]] + distance_matrix[fragment[-1], next_node] - distance_matrix[prev_node, next_node]\n\n                if insertion_cost < min_increase:\n                    best_insertion = (i, j, insertion_cost)\n                    min_increase = insertion_cost\n\n        if best_insertion:\n            route_idx, pos, _ = best_insertion\n            new_solution[route_idx] = np.concatenate([new_solution[route_idx][:pos], fragment, new_solution[route_idx][pos:]])\n        else:\n            # Create a new route if no feasible insertion found\n            new_solution.append(np.concatenate([[0], fragment, [0]]))\n\n    # Step 4: Perform cross-route swaps to further optimize\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        improved = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                route1_demand = sum(demand[node] for node in route1[1:-1])\n                route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                # Try swapping nodes between routes\n                for k in range(1, len(route1)-1):\n                    for l in range(1, len(route2)-1):\n                        node1 = route1[k]\n                        node2 = route2[l]\n                        if (route1_demand - demand[node1] + demand[node2] <= capacity and\n                            route2_demand - demand[node2] + demand[node1] <= capacity):\n\n                            # Calculate cost difference\n                            orig_cost = (distance_matrix[route1[k-1], node1] + distance_matrix[node1, route1[k+1]] +\n                                       distance_matrix[route2[l-1], node2] + distance_matrix[node2, route2[l+1]])\n                            new_cost = (distance_matrix[route1[k-1], node2] + distance_matrix[node2, route1[k+1]] +\n                                       distance_matrix[route2[l-1], node1] + distance_matrix[node1, route2[l+1]])\n\n                            if new_cost < orig_cost:\n                                # Perform swap\n                                new_solution[i] = np.concatenate([route1[:k], [node2], route1[k+1:]])\n                                new_solution[j] = np.concatenate([route2[:l], [node1], route2[l+1:]])\n                                improved = True\n                                break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.811979541630893,
            1.403531402349472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - 0.3 * x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Identify the longest route (potential for fragmentation)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][:-1], new_solution[i][1:]].sum())\n    longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n    # Step 2: Fragment the longest route into smaller segments based on demand\n    fragments = []\n    current_fragment = []\n    current_demand = 0.0\n    for node in longest_route:\n        if current_demand + demand[node] > capacity:\n            if current_fragment:\n                fragments.append(current_fragment)\n                current_fragment = []\n                current_demand = 0.0\n        current_fragment.append(node)\n        current_demand += demand[node]\n    if current_fragment:\n        fragments.append(current_fragment)\n\n    # Step 3: Insert fragments into other routes or create new routes\n    for fragment in fragments:\n        fragment_demand = sum(demand[node] for node in fragment)\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == longest_route_idx:\n                continue\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand + fragment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertions in this route\n            for j in range(1, len(route)):\n                # Calculate insertion cost\n                prev_node = route[j-1]\n                next_node = route[j]\n                insertion_cost = distance_matrix[prev_node, fragment[0]] + distance_matrix[fragment[-1], next_node] - distance_matrix[prev_node, next_node]\n\n                if insertion_cost < min_increase:\n                    best_insertion = (i, j, insertion_cost)\n                    min_increase = insertion_cost\n\n        if best_insertion:\n            route_idx, pos, _ = best_insertion\n            new_solution[route_idx] = np.concatenate([new_solution[route_idx][:pos], fragment, new_solution[route_idx][pos:]])\n        else:\n            # Create a new route if no feasible insertion found\n            new_solution.append(np.concatenate([[0], fragment, [0]]))\n\n    # Step 4: Perform cross-route swaps to further optimize\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        improved = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                route1_demand = sum(demand[node] for node in route1[1:-1])\n                route2_demand = sum(demand[node] for node in route2[1:-1])\n\n                # Try swapping nodes between routes\n                for k in range(1, len(route1)-1):\n                    for l in range(1, len(route2)-1):\n                        node1 = route1[k]\n                        node2 = route2[l]\n                        if (route1_demand - demand[node1] + demand[node2] <= capacity and\n                            route2_demand - demand[node2] + demand[node1] <= capacity):\n\n                            # Calculate cost difference\n                            orig_cost = (distance_matrix[route1[k-1], node1] + distance_matrix[node1, route1[k+1]] +\n                                       distance_matrix[route2[l-1], node2] + distance_matrix[node2, route2[l+1]])\n                            new_cost = (distance_matrix[route1[k-1], node2] + distance_matrix[node2, route1[k+1]] +\n                                       distance_matrix[route2[l-1], node1] + distance_matrix[node1, route2[l+1]])\n\n                            if new_cost < orig_cost:\n                                # Perform swap\n                                new_solution[i] = np.concatenate([route1[:k], [node2], route1[k+1:]])\n                                new_solution[j] = np.concatenate([route2[:l], [node1], route2[l+1:]])\n                                improved = True\n                                break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1] * 0.5)[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining route splitting and intra-route 2-opt with demand constraints\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to split or optimize\n        split_point = np.random.randint(1, len(route) - 1)\n        segment = route[split_point:-1]\n\n        # Check if splitting the segment into a new route is feasible\n        segment_demand = np.sum(demand[segment])\n        if segment_demand <= capacity:\n            # Create a new route from the segment\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n            # Remove the segment from the original route\n            modified_route = np.concatenate([route[:split_point], [0]])\n            if len(modified_route) > 2:  # Ensure the modified route is non-trivial\n                new_solution.append(modified_route)\n        else:\n            # Apply intra-route 2-opt with demand constraints\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Check demand feasibility for the reversed segment\n            if np.sum(demand[route[i:j+1]]) <= capacity:\n                route[i:j+1] = route[i:j+1][::-1]\n            new_solution.append(route.copy())\n\n    # Ensure all customers are served (edge case handling)\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unserved = set(range(1, len(demand))) - served_customers\n    if unserved:\n        # Assign unserved customers to the route with the most remaining capacity\n        for customer in unserved:\n            best_route_idx = np.argmax([capacity - np.sum(demand[route[1:-1]]) for route in new_solution])\n            best_route = new_solution[best_route_idx]\n            # Insert customer at the position that minimizes additional distance\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(best_route)):\n                increase = (distance_matrix[best_route[pos-1], customer] +\n                            distance_matrix[customer, best_route[pos]] -\n                            distance_matrix[best_route[pos-1], best_route[pos]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n            best_route = np.insert(best_route, best_pos, customer)\n            new_solution[best_route_idx] = best_route\n\n    return new_solution\n\n",
        "score": [
            -0.9068223252096317,
            4.164235174655914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1] * 0.5)[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining route splitting and intra-route 2-opt with demand constraints\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to split or optimize\n        split_point = np.random.randint(1, len(route) - 1)\n        segment = route[split_point:-1]\n\n        # Check if splitting the segment into a new route is feasible\n        segment_demand = np.sum(demand[segment])\n        if segment_demand <= capacity:\n            # Create a new route from the segment\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n            # Remove the segment from the original route\n            modified_route = np.concatenate([route[:split_point], [0]])\n            if len(modified_route) > 2:  # Ensure the modified route is non-trivial\n                new_solution.append(modified_route)\n        else:\n            # Apply intra-route 2-opt with demand constraints\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Check demand feasibility for the reversed segment\n            if np.sum(demand[route[i:j+1]]) <= capacity:\n                route[i:j+1] = route[i:j+1][::-1]\n            new_solution.append(route.copy())\n\n    # Ensure all customers are served (edge case handling)\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    unserved = set(range(1, len(demand))) - served_customers\n    if unserved:\n        # Assign unserved customers to the route with the most remaining capacity\n        for customer in unserved:\n            best_route_idx = np.argmax([capacity - np.sum(demand[route[1:-1]]) for route in new_solution])\n            best_route = new_solution[best_route_idx]\n            # Insert customer at the position that minimizes additional distance\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(best_route)):\n                increase = (distance_matrix[best_route[pos-1], customer] +\n                            distance_matrix[customer, best_route[pos]] -\n                            distance_matrix[best_route[pos-1], best_route[pos]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = pos\n            best_route = np.insert(best_route, best_pos, customer)\n            new_solution[best_route_idx] = best_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        part1 = selected_route[:split_point]\n        part2 = selected_route[split_point:]\n\n        # Reverse the second part to create a new route\n        new_route = np.concatenate([part1, part2[::-1]])\n\n        # Check feasibility of the new route\n        total_demand = np.sum(demand[new_route[1:-1]])\n        if total_demand <= capacity:\n            selected_solution[route_idx] = new_route\n\n    # Randomly swap customers between two different routes if possible\n    if len(selected_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(selected_solution), 2, replace=False)\n        route1 = selected_solution[route1_idx].copy()\n        route2 = selected_solution[route2_idx].copy()\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depot)\n            cust1_idx = np.random.randint(1, len(route1) - 1)\n            cust2_idx = np.random.randint(1, len(route2) - 1)\n\n            # Swap the customers\n            new_route1 = route1.copy()\n            new_route1[cust1_idx] = route2[cust2_idx]\n            new_route2 = route2.copy()\n            new_route2[cust2_idx] = route1[cust1_idx]\n\n            # Check feasibility of the new routes\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                selected_solution[route1_idx] = new_route1\n                selected_solution[route2_idx] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7784829530603667,
            0.34239688515663147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly select a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        part1 = selected_route[:split_point]\n        part2 = selected_route[split_point:]\n\n        # Reverse the second part to create a new route\n        new_route = np.concatenate([part1, part2[::-1]])\n\n        # Check feasibility of the new route\n        total_demand = np.sum(demand[new_route[1:-1]])\n        if total_demand <= capacity:\n            selected_solution[route_idx] = new_route\n\n    # Randomly swap customers between two different routes if possible\n    if len(selected_solution) > 1:\n        route1_idx, route2_idx = np.random.choice(len(selected_solution), 2, replace=False)\n        route1 = selected_solution[route1_idx].copy()\n        route2 = selected_solution[route2_idx].copy()\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depot)\n            cust1_idx = np.random.randint(1, len(route1) - 1)\n            cust2_idx = np.random.randint(1, len(route2) - 1)\n\n            # Swap the customers\n            new_route1 = route1.copy()\n            new_route1[cust1_idx] = route2[cust2_idx]\n            new_route2 = route2.copy()\n            new_route2[cust2_idx] = route1[cust1_idx]\n\n            # Check feasibility of the new routes\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                selected_solution[route1_idx] = new_route1\n                selected_solution[route2_idx] = new_route2\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{A hybrid local search operator that combines route-segment relocation with demand-aware rebalancing to improve both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-segment relocation with demand-aware rebalancing\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) <= 3:  # Skip if route is too short\n            continue\n        segment_start = random.randint(1, len(route1) - 3)\n        segment_end = random.randint(segment_start + 1, len(route1) - 2)\n        segment = route1[segment_start:segment_end]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Check if moving the segment to route2 is feasible\n        if sum(demand[node] for node in route2) + segment_demand > capacity:\n            continue\n\n        # Insert the segment into route2 at a position that minimizes distance increase\n        best_pos = 1\n        min_increase = float('inf')\n        for pos in range(1, len(route2)):\n            # Calculate distance increase\n            prev_node = route2[pos - 1]\n            next_node = route2[pos]\n            new_distance = distance_matrix[prev_node, segment[0]] + sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix[segment[-1], next_node]\n            old_distance = distance_matrix[prev_node, next_node]\n            increase = new_distance - old_distance\n\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        # Perform the move\n        route1 = np.concatenate([route1[:segment_start], route1[segment_end:]])\n        route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n\n        # Update the solution\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n        # Demand-aware rebalancing: Check if any route can be split to reduce makespan\n        for route in new_solution:\n            if len(route) < 4:  # Skip if route is too short\n                continue\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand <= capacity:\n                continue\n\n            # Find a split point that balances demand\n            cumulative_demand = 0\n            split_pos = 1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity / 2:\n                    split_pos = i\n                    break\n\n            # Split the route\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Update the solution\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.6814247941984345,
            0.9555084407329559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-segment relocation with demand-aware rebalancing\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) <= 3:  # Skip if route is too short\n            continue\n        segment_start = random.randint(1, len(route1) - 3)\n        segment_end = random.randint(segment_start + 1, len(route1) - 2)\n        segment = route1[segment_start:segment_end]\n        segment_demand = sum(demand[node] for node in segment)\n\n        # Check if moving the segment to route2 is feasible\n        if sum(demand[node] for node in route2) + segment_demand > capacity:\n            continue\n\n        # Insert the segment into route2 at a position that minimizes distance increase\n        best_pos = 1\n        min_increase = float('inf')\n        for pos in range(1, len(route2)):\n            # Calculate distance increase\n            prev_node = route2[pos - 1]\n            next_node = route2[pos]\n            new_distance = distance_matrix[prev_node, segment[0]] + sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix[segment[-1], next_node]\n            old_distance = distance_matrix[prev_node, next_node]\n            increase = new_distance - old_distance\n\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        # Perform the move\n        route1 = np.concatenate([route1[:segment_start], route1[segment_end:]])\n        route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n\n        # Update the solution\n        new_solution[route1_idx] = route1\n        new_solution[route2_idx] = route2\n\n        # Demand-aware rebalancing: Check if any route can be split to reduce makespan\n        for route in new_solution:\n            if len(route) < 4:  # Skip if route is too short\n                continue\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand <= capacity:\n                continue\n\n            # Find a split point that balances demand\n            cumulative_demand = 0\n            split_pos = 1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity / 2:\n                    split_pos = i\n                    break\n\n            # Split the route\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            # Update the solution\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a hybrid local search combining route splitting and demand-based relocations to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and relocate customers based on demand\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Calculate current demand and distance\n        current_demand = np.sum(demand[route[1:-1]])\n        current_distance = np.sum([distance_matrix[route[j], route[j+1]] for j in range(len(route)-1)])\n\n        # Try to split the route if it's too long\n        if current_demand > capacity * 0.7:  # If route is over 70% capacity\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos+1:]\n\n            # Ensure split routes are feasible\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Try to relocate customers from this route to others based on demand\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            best_pos = None\n            best_improvement = 0\n\n            # Try inserting into other routes\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                other_route = new_solution[k]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position in other route\n                for pos in range(1, len(other_route)):\n                    # Calculate change in distance\n                    delta = (distance_matrix[other_route[pos-1], customer] +\n                            distance_matrix[customer, other_route[pos]] -\n                            distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if delta < best_improvement:\n                        best_improvement = delta\n                        best_pos = (k, pos)\n\n            # Perform the best relocation if beneficial\n            if best_pos is not None and best_improvement < 0:\n                k, pos = best_pos\n                new_solution[k] = np.insert(new_solution[k], pos, customer)\n                new_solution[i] = np.delete(new_solution[i], j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8360298679105239,
            4.881693720817566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and relocate customers based on demand\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Calculate current demand and distance\n        current_demand = np.sum(demand[route[1:-1]])\n        current_distance = np.sum([distance_matrix[route[j], route[j+1]] for j in range(len(route)-1)])\n\n        # Try to split the route if it's too long\n        if current_demand > capacity * 0.7:  # If route is over 70% capacity\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos+1:]\n\n            # Ensure split routes are feasible\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                continue\n\n        # Try to relocate customers from this route to others based on demand\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            best_pos = None\n            best_improvement = 0\n\n            # Try inserting into other routes\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n                other_route = new_solution[k]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position in other route\n                for pos in range(1, len(other_route)):\n                    # Calculate change in distance\n                    delta = (distance_matrix[other_route[pos-1], customer] +\n                            distance_matrix[customer, other_route[pos]] -\n                            distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if delta < best_improvement:\n                        best_improvement = delta\n                        best_pos = (k, pos)\n\n            # Perform the best relocation if beneficial\n            if best_pos is not None and best_improvement < 0:\n                k, pos = best_pos\n                new_solution[k] = np.insert(new_solution[k], pos, customer)\n                new_solution[i] = np.delete(new_solution[i], j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high total distance\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator: \"Route Shuffle and Merge\"\n    # - Randomly shuffle nodes within a route to explore new sequences\n    # - Merge two routes if their combined load is within capacity\n    new_solution = []\n    routes_to_merge = []\n\n    for route in selected_solution:\n        if len(route) > 3:  # Skip very short routes\n            # Shuffle nodes (excluding depot)\n            shuffled_nodes = np.random.permutation(route[1:-1])\n            new_route = np.concatenate([[0], shuffled_nodes, [0]])\n            new_solution.append(new_route)\n        else:\n            routes_to_merge.append(route)\n\n    # Attempt to merge routes\n    for i in range(len(routes_to_merge)):\n        for j in range(i + 1, len(routes_to_merge)):\n            route1, route2 = routes_to_merge[i], routes_to_merge[j]\n            combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if combined_load <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                routes_to_merge[i] = None  # Mark as merged\n                routes_to_merge[j] = None\n                break\n\n    # Add unmerged routes\n    for route in routes_to_merge:\n        if route is not None:\n            new_solution.append(route)\n\n    # Step 3: Ensure feasibility by checking capacity constraints\n    feasible_solution = []\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) <= capacity:\n            feasible_solution.append(route)\n        else:\n            # If infeasible, split the route into multiple valid segments\n            current_load = 0\n            current_segment = [0]\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_segment.append(node)\n                    current_load += demand[node]\n                else:\n                    current_segment.append(0)\n                    feasible_solution.append(np.array(current_segment))\n                    current_segment = [0, node]\n                    current_load = demand[node]\n            current_segment.append(0)\n            feasible_solution.append(np.array(current_segment))\n\n    return feasible_solution\n\n",
        "score": [
            -0.6286925626678754,
            1.0173366069793701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))  # Prioritize low makespan, then high total distance\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator: \"Route Shuffle and Merge\"\n    # - Randomly shuffle nodes within a route to explore new sequences\n    # - Merge two routes if their combined load is within capacity\n    new_solution = []\n    routes_to_merge = []\n\n    for route in selected_solution:\n        if len(route) > 3:  # Skip very short routes\n            # Shuffle nodes (excluding depot)\n            shuffled_nodes = np.random.permutation(route[1:-1])\n            new_route = np.concatenate([[0], shuffled_nodes, [0]])\n            new_solution.append(new_route)\n        else:\n            routes_to_merge.append(route)\n\n    # Attempt to merge routes\n    for i in range(len(routes_to_merge)):\n        for j in range(i + 1, len(routes_to_merge)):\n            route1, route2 = routes_to_merge[i], routes_to_merge[j]\n            combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if combined_load <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                routes_to_merge[i] = None  # Mark as merged\n                routes_to_merge[j] = None\n                break\n\n    # Add unmerged routes\n    for route in routes_to_merge:\n        if route is not None:\n            new_solution.append(route)\n\n    # Step 3: Ensure feasibility by checking capacity constraints\n    feasible_solution = []\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) <= capacity:\n            feasible_solution.append(route)\n        else:\n            # If infeasible, split the route into multiple valid segments\n            current_load = 0\n            current_segment = [0]\n            for node in route[1:-1]:\n                if current_load + demand[node] <= capacity:\n                    current_segment.append(node)\n                    current_load += demand[node]\n                else:\n                    current_segment.append(0)\n                    feasible_solution.append(np.array(current_segment))\n                    current_segment = [0, node]\n                    current_load = demand[node]\n            current_segment.append(0)\n            feasible_solution.append(np.array(current_segment))\n\n    return feasible_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted random choice favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route splitting, node reallocation, and depot-based route merging to generate a feasible neighbor solution while intelligently balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route is long enough\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.append(route[:split_pos+1], 0)\n            new_route2 = np.insert(route[split_pos:], 0, 0)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Node reallocation - move nodes between routes to balance load\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random node from route1 (excluding depot)\n        if len(route1) <= 2:\n            continue\n        node_pos = random.randint(1, len(route1)-2)\n        node = route1[node_pos]\n\n        # Check if moving this node to route2 is feasible\n        new_route2 = np.insert(route2, -1, node)\n        if np.sum(demand[new_route2[1:-1]]) <= capacity:\n            # Update both routes\n            new_route1 = np.delete(route1, node_pos)\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Depot-based route merging - merge short routes that can be combined\n    for i in range(len(new_solution)-1):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            if len(route1) + len(route2) - 2 > 20:  # Don't make too long routes\n                continue\n\n            # Try to merge by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Update solution\n                new_solution[i] = merged_route\n                del new_solution[j]\n                break\n\n    # Ensure solution is valid (all customers served)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - all_nodes\n\n    # Add missing nodes to random routes if possible\n    for node in missing_nodes:\n        # Find routes with enough capacity\n        possible_routes = []\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                possible_routes.append(i)\n\n        if possible_routes:\n            # Insert at random position\n            route_idx = random.choice(possible_routes)\n            pos = random.randint(1, len(new_solution[route_idx])-1)\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7302172650801351,
            1.6119858920574188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a new solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into smaller segments\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route is long enough\n            split_pos = random.randint(2, len(route)-3)\n            new_route1 = np.append(route[:split_pos+1], 0)\n            new_route2 = np.insert(route[split_pos:], 0, 0)\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                break\n\n    # Step 2: Node reallocation - move nodes between routes to balance load\n    for _ in range(2):  # Try a few times\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select a random node from route1 (excluding depot)\n        if len(route1) <= 2:\n            continue\n        node_pos = random.randint(1, len(route1)-2)\n        node = route1[node_pos]\n\n        # Check if moving this node to route2 is feasible\n        new_route2 = np.insert(route2, -1, node)\n        if np.sum(demand[new_route2[1:-1]]) <= capacity:\n            # Update both routes\n            new_route1 = np.delete(route1, node_pos)\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Step 3: Depot-based route merging - merge short routes that can be combined\n    for i in range(len(new_solution)-1):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is possible\n            if len(route1) + len(route2) - 2 > 20:  # Don't make too long routes\n                continue\n\n            # Try to merge by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Update solution\n                new_solution[i] = merged_route\n                del new_solution[j]\n                break\n\n    # Ensure solution is valid (all customers served)\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    missing_nodes = set(range(1, len(demand))) - all_nodes\n\n    # Add missing nodes to random routes if possible\n    for node in missing_nodes:\n        # Find routes with enough capacity\n        possible_routes = []\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                possible_routes.append(i)\n\n        if possible_routes:\n            # Insert at random position\n            route_idx = random.choice(possible_routes)\n            pos = random.randint(1, len(new_solution[route_idx])-1)\n            new_solution[route_idx] = np.insert(new_solution[route_idx], pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with high total distance and makespan, then applies a hybrid local search combining route segment relocation and route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [obj[0] * obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation + route merging\n    new_solution = base_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Step 1: Select a random segment from a random route\n    route_idx1 = random.randint(0, n_routes - 1)\n    route1 = new_solution[route_idx1]\n    if len(route1) <= 3:  # route is just depot-depot or depot-customer-depot\n        return new_solution\n\n    start_idx = random.randint(1, len(route1) - 3)\n    end_idx = random.randint(start_idx + 1, len(route1) - 2)\n    segment = route1[start_idx:end_idx].copy()\n\n    # Step 2: Try to insert the segment into another route\n    route_idx2 = random.randint(0, n_routes - 1)\n    while route_idx2 == route_idx1 and n_routes > 1:\n        route_idx2 = random.randint(0, n_routes - 1)\n    route2 = new_solution[route_idx2]\n\n    # Check capacity constraint for route2\n    segment_demand = sum(demand[segment])\n    if sum(demand[route2]) + segment_demand > capacity:\n        return new_solution\n\n    # Find best insertion position in route2\n    best_pos = 1\n    best_cost = float('inf')\n    for pos in range(1, len(route2)):\n        # Insert segment between pos-1 and pos\n        new_route = np.concatenate([\n            route2[:pos],\n            segment,\n            route2[pos:]\n        ])\n        # Calculate cost increase\n        cost_increase = (\n            distance_matrix[route2[pos-1], segment[0]] +\n            distance_matrix[segment[-1], route2[pos]] -\n            distance_matrix[route2[pos-1], route2[pos]]\n        )\n        if cost_increase < best_cost:\n            best_cost = cost_increase\n            best_pos = pos\n\n    # Perform insertion\n    new_route = np.concatenate([\n        route2[:best_pos],\n        segment,\n        route2[best_pos:]\n    ])\n    new_solution[route_idx2] = new_route\n\n    # Remove segment from original route\n    new_solution[route_idx1] = np.concatenate([\n        route1[:start_idx],\n        route1[end_idx:]\n    ])\n\n    # Step 3: Try to merge routes if possible\n    if len(new_solution[route_idx1]) == 2:  # route is just depot-depot\n        new_solution.pop(route_idx1)\n\n    return new_solution\n\n",
        "score": [
            -0.6748931031479634,
            0.9318485260009766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [obj[0] * obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation + route merging\n    new_solution = base_solution.copy()\n    n_routes = len(new_solution)\n\n    if n_routes < 2:\n        return new_solution\n\n    # Step 1: Select a random segment from a random route\n    route_idx1 = random.randint(0, n_routes - 1)\n    route1 = new_solution[route_idx1]\n    if len(route1) <= 3:  # route is just depot-depot or depot-customer-depot\n        return new_solution\n\n    start_idx = random.randint(1, len(route1) - 3)\n    end_idx = random.randint(start_idx + 1, len(route1) - 2)\n    segment = route1[start_idx:end_idx].copy()\n\n    # Step 2: Try to insert the segment into another route\n    route_idx2 = random.randint(0, n_routes - 1)\n    while route_idx2 == route_idx1 and n_routes > 1:\n        route_idx2 = random.randint(0, n_routes - 1)\n    route2 = new_solution[route_idx2]\n\n    # Check capacity constraint for route2\n    segment_demand = sum(demand[segment])\n    if sum(demand[route2]) + segment_demand > capacity:\n        return new_solution\n\n    # Find best insertion position in route2\n    best_pos = 1\n    best_cost = float('inf')\n    for pos in range(1, len(route2)):\n        # Insert segment between pos-1 and pos\n        new_route = np.concatenate([\n            route2[:pos],\n            segment,\n            route2[pos:]\n        ])\n        # Calculate cost increase\n        cost_increase = (\n            distance_matrix[route2[pos-1], segment[0]] +\n            distance_matrix[segment[-1], route2[pos]] -\n            distance_matrix[route2[pos-1], route2[pos]]\n        )\n        if cost_increase < best_cost:\n            best_cost = cost_increase\n            best_pos = pos\n\n    # Perform insertion\n    new_route = np.concatenate([\n        route2[:best_pos],\n        segment,\n        route2[best_pos:]\n    ])\n    new_solution[route_idx2] = new_route\n\n    # Remove segment from original route\n    new_solution[route_idx1] = np.concatenate([\n        route1[:start_idx],\n        route1[end_idx:]\n    ])\n\n    # Step 3: Try to merge routes if possible\n    if len(new_solution[route_idx1]) == 2:  # route is just depot-depot\n        new_solution.pop(route_idx1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high total distance and moderate makespan (promising for improvement)\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine route merging with customer relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx - 1:]\n\n        # Relocate a random customer from part1 to part2 if feasible\n        if len(part1) > 2:\n            candidate_idx = np.random.randint(1, len(part1) - 1)\n            candidate = part1[candidate_idx]\n            if np.sum(demand[part2]) + demand[candidate] <= capacity:\n                part1 = np.delete(part1, candidate_idx)\n                part2 = np.insert(part2, 1, candidate)\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        route1 = new_solution[i]\n        merged = False\n        for j in range(i + 1, len(new_solution)):\n            route2 = new_solution[j]\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                merged_solution.append(merged_route)\n                merged = True\n                i = j + 1\n                break\n        if not merged:\n            merged_solution.append(route1)\n            i += 1\n\n    return merged_solution\n\n",
        "score": [
            -0.771245554940631,
            2.125688672065735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high total distance and moderate makespan (promising for improvement)\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine route merging with customer relocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx - 1:]\n\n        # Relocate a random customer from part1 to part2 if feasible\n        if len(part1) > 2:\n            candidate_idx = np.random.randint(1, len(part1) - 1)\n            candidate = part1[candidate_idx]\n            if np.sum(demand[part2]) + demand[candidate] <= capacity:\n                part1 = np.delete(part1, candidate_idx)\n                part2 = np.insert(part2, 1, candidate)\n\n        new_solution.append(part1)\n        new_solution.append(part2)\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        route1 = new_solution[i]\n        merged = False\n        for j in range(i + 1, len(new_solution)):\n            route2 = new_solution[j]\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge route2 into route1\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                merged_solution.append(merged_route)\n                merged = True\n                i = j + 1\n                break\n        if not merged:\n            merged_solution.append(route1)\n            i += 1\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the smallest makespan, then applies a hybrid local search combining route segmentation and capacity-aware insertion to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to perturb\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Segment the route into two parts at a random point\n        if len(selected_route) > 3:  # Ensure at least two nodes between depot and split\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            segment = selected_route[split_pos:-1]\n            remaining_route = selected_route[:split_pos + 1]\n\n            # Check capacity feasibility of remaining route\n            remaining_demand = np.sum(demand[remaining_route[1:-1]])\n            if remaining_demand <= capacity:\n                # Try to insert the segment into another route or create a new route\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n                    candidate_route = new_solution[i].copy()\n                    candidate_route = np.concatenate([candidate_route[:-1], segment, [0]])\n\n                    # Check capacity feasibility\n                    candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                    if candidate_demand <= capacity:\n                        new_solution[i] = candidate_route\n                        new_solution[route_idx] = remaining_route\n                        break\n                else:\n                    # If no feasible insertion found, create a new route\n                    new_route = np.concatenate([[0], segment, [0]])\n                    new_solution[route_idx] = remaining_route\n                    new_solution.append(new_route)\n            else:\n                # If remaining route exceeds capacity, try to split further\n                split_pos2 = np.random.randint(1, len(remaining_route) - 1)\n                segment2 = remaining_route[split_pos2:-1]\n                new_segment = remaining_route[:split_pos2 + 1]\n\n                # Check capacity of new segments\n                new_segment_demand = np.sum(demand[new_segment[1:-1]])\n                segment2_demand = np.sum(demand[segment2[1:-1]])\n                if new_segment_demand <= capacity and segment2_demand <= capacity:\n                    new_solution[route_idx] = new_segment\n                    new_solution.append(np.concatenate([[0], segment2, [0]]))\n        else:\n            # If route is too short, try to merge it with another route\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i].copy()\n                candidate_route = np.concatenate([candidate_route[:-1], selected_route[1:-1], [0]])\n\n                # Check capacity feasibility\n                candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                if candidate_demand <= capacity:\n                    new_solution[i] = candidate_route\n                    new_solution.pop(route_idx)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7901356032243045,
            0.2437613308429718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to perturb\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Segment the route into two parts at a random point\n        if len(selected_route) > 3:  # Ensure at least two nodes between depot and split\n            split_pos = np.random.randint(1, len(selected_route) - 1)\n            segment = selected_route[split_pos:-1]\n            remaining_route = selected_route[:split_pos + 1]\n\n            # Check capacity feasibility of remaining route\n            remaining_demand = np.sum(demand[remaining_route[1:-1]])\n            if remaining_demand <= capacity:\n                # Try to insert the segment into another route or create a new route\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n                    candidate_route = new_solution[i].copy()\n                    candidate_route = np.concatenate([candidate_route[:-1], segment, [0]])\n\n                    # Check capacity feasibility\n                    candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                    if candidate_demand <= capacity:\n                        new_solution[i] = candidate_route\n                        new_solution[route_idx] = remaining_route\n                        break\n                else:\n                    # If no feasible insertion found, create a new route\n                    new_route = np.concatenate([[0], segment, [0]])\n                    new_solution[route_idx] = remaining_route\n                    new_solution.append(new_route)\n            else:\n                # If remaining route exceeds capacity, try to split further\n                split_pos2 = np.random.randint(1, len(remaining_route) - 1)\n                segment2 = remaining_route[split_pos2:-1]\n                new_segment = remaining_route[:split_pos2 + 1]\n\n                # Check capacity of new segments\n                new_segment_demand = np.sum(demand[new_segment[1:-1]])\n                segment2_demand = np.sum(demand[segment2[1:-1]])\n                if new_segment_demand <= capacity and segment2_demand <= capacity:\n                    new_solution[route_idx] = new_segment\n                    new_solution.append(np.concatenate([[0], segment2, [0]]))\n        else:\n            # If route is too short, try to merge it with another route\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i].copy()\n                candidate_route = np.concatenate([candidate_route[:-1], selected_route[1:-1], [0]])\n\n                # Check capacity feasibility\n                candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                if candidate_demand <= capacity:\n                    new_solution[i] = candidate_route\n                    new_solution.pop(route_idx)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route splitting and customer swapping\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand1 = sum(demand[node] for node in part1[1:-1])\n        demand2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = part1\n            if len(part2) > 2:  # Only add if not just depot nodes\n                new_solution.append(part2)\n\n    # Randomly swap customers between routes to balance load\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform 2 random swaps\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue  # Skip if route is too small\n\n            # Select random customers from each route (excluding depots)\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n\n            # Check capacity constraints after swap\n            demand1_after = sum(demand[node] for node in route1[1:-1]) - demand[cust1] + demand[cust2]\n            demand2_after = sum(demand[node] for node in route2[1:-1]) - demand[cust2] + demand[cust1]\n\n            if demand1_after <= capacity and demand2_after <= capacity:\n                # Perform the swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    return new_solution\n\n",
        "score": [
            -0.8421443594780433,
            0.7368426620960236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route splitting and customer swapping\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue  # Skip trivial routes\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand1 = sum(demand[node] for node in part1[1:-1])\n        demand2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[i] = part1\n            if len(part2) > 2:  # Only add if not just depot nodes\n                new_solution.append(part2)\n\n    # Randomly swap customers between routes to balance load\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform 2 random swaps\n            route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue  # Skip if route is too small\n\n            # Select random customers from each route (excluding depots)\n            cust1 = np.random.choice(route1[1:-1])\n            cust2 = np.random.choice(route2[1:-1])\n\n            # Check capacity constraints after swap\n            demand1_after = sum(demand[node] for node in route1[1:-1]) - demand[cust1] + demand[cust2]\n            demand2_after = sum(demand[node] for node in route2[1:-1]) - demand[cust2] + demand[cust1]\n\n            if demand1_after <= capacity and demand2_after <= capacity:\n                # Perform the swap\n                route1[route1 == cust1] = cust2\n                route2[route2 == cust2] = cust1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The algorithm selects a promising solution from the archive, then applies a hybrid local search combining route splitting, customer reallocation, and capacity-aware edge swapping to generate a feasible neighbor solution while balancing total distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swapping\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts if possible\n        if len(selected_route) > 4:  # Ensure the route can be split meaningfully\n            split_pos = random.randint(2, len(selected_route) - 3)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Recalculate demands for the new routes\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            # Check capacity constraints\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 3: Customer reallocation between routes\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a customer from route1 (excluding depot)\n        if len(route1) > 2:\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if adding this customer to route2 is feasible\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Calculate the cost of inserting the customer between route2[i-1] and route2[i]\n                    cost = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                # Insert the customer into route2\n                route2 = np.insert(route2, best_pos, customer)\n                # Remove the customer from route1\n                route1 = np.delete(route1, customer_idx)\n\n                # Update the routes in the solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Step 4: Edge swapping between routes (if possible)\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select an edge from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            edge1_idx = random.randint(1, len(route1) - 2)\n            edge2_idx = random.randint(1, len(route2) - 2)\n\n            # Extract the edges\n            edge1 = (route1[edge1_idx], route1[edge1_idx + 1])\n            edge2 = (route2[edge2_idx], route2[edge2_idx + 1])\n\n            # Calculate the new demands after swapping\n            demand_route1 = sum(demand[node] for node in route1[1:-1]) - demand[edge1[0]] + demand[edge2[0]]\n            demand_route2 = sum(demand[node] for node in route2[1:-1]) - demand[edge2[0]] + demand[edge1[0]]\n\n            # Check capacity constraints\n            if demand_route1 <= capacity and demand_route2 <= capacity:\n                # Perform the edge swap\n                route1[edge1_idx + 1] = edge2[0]\n                route2[edge2_idx + 1] = edge1[0]\n\n                # Update the routes in the solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Ensure the solution is feasible (all customers are served and capacity is respected)\n    # Verify that all customers are included in the solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # If not all customers are served, revert to the original solution\n        return selected_solution\n\n    # Verify capacity constraints\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If capacity is violated, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5944845419864916,
            10.50227814912796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, customer reallocation, and edge swapping\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Split the route into two parts if possible\n        if len(selected_route) > 4:  # Ensure the route can be split meaningfully\n            split_pos = random.randint(2, len(selected_route) - 3)\n            new_route1 = selected_route[:split_pos + 1]\n            new_route2 = selected_route[split_pos:]\n\n            # Recalculate demands for the new routes\n            demand1 = sum(demand[node] for node in new_route1[1:-1])\n            demand2 = sum(demand[node] for node in new_route2[1:-1])\n\n            # Check capacity constraints\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Step 3: Customer reallocation between routes\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a customer from route1 (excluding depot)\n        if len(route1) > 2:\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if adding this customer to route2 is feasible\n            current_demand_route2 = sum(demand[node] for node in route2[1:-1])\n            if current_demand_route2 + demand[customer] <= capacity:\n                # Find the best insertion position in route2\n                best_pos = 1\n                min_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Calculate the cost of inserting the customer between route2[i-1] and route2[i]\n                    cost = distance_matrix[route2[i-1], customer] + distance_matrix[customer, route2[i]] - distance_matrix[route2[i-1], route2[i]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n\n                # Insert the customer into route2\n                route2 = np.insert(route2, best_pos, customer)\n                # Remove the customer from route1\n                route1 = np.delete(route1, customer_idx)\n\n                # Update the routes in the solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Step 4: Edge swapping between routes (if possible)\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select an edge from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            edge1_idx = random.randint(1, len(route1) - 2)\n            edge2_idx = random.randint(1, len(route2) - 2)\n\n            # Extract the edges\n            edge1 = (route1[edge1_idx], route1[edge1_idx + 1])\n            edge2 = (route2[edge2_idx], route2[edge2_idx + 1])\n\n            # Calculate the new demands after swapping\n            demand_route1 = sum(demand[node] for node in route1[1:-1]) - demand[edge1[0]] + demand[edge2[0]]\n            demand_route2 = sum(demand[node] for node in route2[1:-1]) - demand[edge2[0]] + demand[edge1[0]]\n\n            # Check capacity constraints\n            if demand_route1 <= capacity and demand_route2 <= capacity:\n                # Perform the edge swap\n                route1[edge1_idx + 1] = edge2[0]\n                route2[edge2_idx + 1] = edge1[0]\n\n                # Update the routes in the solution\n                new_solution[route1_idx] = route1\n                new_solution[route2_idx] = route2\n\n    # Ensure the solution is feasible (all customers are served and capacity is respected)\n    # Verify that all customers are included in the solution\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # If not all customers are served, revert to the original solution\n        return selected_solution\n\n    # Verify capacity constraints\n    for route in new_solution:\n        route_demand = sum(demand[node] for node in route[1:-1])\n        if route_demand > capacity:\n            # If capacity is violated, revert to the original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined objective score (weighted sum of distance and makespan), then applies a hybrid local search operator combining route fragmentation and customer reinsertion with capacity-aware swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragmentation + Reinsertion + Capacity-aware Swaps\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty routes\n            continue\n\n        # Randomly select a segment to fragment\n        start_idx = random.randint(1, len(route) - 2)\n        end_idx = random.randint(start_idx + 1, len(route) - 1)\n        segment = route[start_idx:end_idx]\n\n        # Create new routes by removing the segment\n        new_route1 = np.concatenate([route[:start_idx], route[end_idx:]])\n        new_solution.append(new_route1)\n\n        # Reinsert the segment into a new route or existing routes\n        remaining_capacity = capacity - np.sum(demand[route])\n        if remaining_capacity >= np.sum(demand[segment]):\n            # Try to reinsert into existing routes\n            inserted = False\n            for i, r in enumerate(new_solution):\n                if np.sum(demand[r]) + np.sum(demand[segment]) <= capacity:\n                    # Find best insertion position\n                    best_pos = 0\n                    best_cost = float('inf')\n                    for pos in range(1, len(r)):\n                        cost = (distance_matrix[r[pos-1], segment[0]] +\n                                distance_matrix[segment[-1], r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert segment\n                    new_route = np.concatenate([r[:best_pos], segment, r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # Create new route for the segment\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n        else:\n            # Split segment into smaller parts\n            current_segment = segment.copy()\n            while len(current_segment) > 0:\n                # Find largest possible segment that fits\n                max_len = 1\n                for l in range(1, len(current_segment)):\n                    if np.sum(demand[current_segment[:l+1]]) <= capacity:\n                        max_len = l + 1\n                    else:\n                        break\n                # Create new route for the segment\n                new_solution.append(np.concatenate([[0], current_segment[:max_len], [0]]))\n                current_segment = current_segment[max_len:]\n\n    # Perform capacity-aware swaps between routes\n    for _ in range(3):  # Limit the number of swaps\n        if len(new_solution) < 2:\n            break\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find feasible swaps\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check capacity constraints\n                if (np.sum(demand[route1]) - demand[route1[k]] + demand[route2[l]] <= capacity and\n                    np.sum(demand[route2]) - demand[route2[l]] + demand[route1[k]] <= capacity):\n                    # Perform swap\n                    new_route1 = np.concatenate([route1[:k], [route2[l]], route1[k+1:]])\n                    new_route2 = np.concatenate([route2[:l], [route1[k]], route2[l+1:]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7332424618950169,
            2.7121590971946716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragmentation + Reinsertion + Capacity-aware Swaps\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 2:  # Skip empty routes\n            continue\n\n        # Randomly select a segment to fragment\n        start_idx = random.randint(1, len(route) - 2)\n        end_idx = random.randint(start_idx + 1, len(route) - 1)\n        segment = route[start_idx:end_idx]\n\n        # Create new routes by removing the segment\n        new_route1 = np.concatenate([route[:start_idx], route[end_idx:]])\n        new_solution.append(new_route1)\n\n        # Reinsert the segment into a new route or existing routes\n        remaining_capacity = capacity - np.sum(demand[route])\n        if remaining_capacity >= np.sum(demand[segment]):\n            # Try to reinsert into existing routes\n            inserted = False\n            for i, r in enumerate(new_solution):\n                if np.sum(demand[r]) + np.sum(demand[segment]) <= capacity:\n                    # Find best insertion position\n                    best_pos = 0\n                    best_cost = float('inf')\n                    for pos in range(1, len(r)):\n                        cost = (distance_matrix[r[pos-1], segment[0]] +\n                                distance_matrix[segment[-1], r[pos]] -\n                                distance_matrix[r[pos-1], r[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    # Insert segment\n                    new_route = np.concatenate([r[:best_pos], segment, r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # Create new route for the segment\n                new_solution.append(np.concatenate([[0], segment, [0]]))\n        else:\n            # Split segment into smaller parts\n            current_segment = segment.copy()\n            while len(current_segment) > 0:\n                # Find largest possible segment that fits\n                max_len = 1\n                for l in range(1, len(current_segment)):\n                    if np.sum(demand[current_segment[:l+1]]) <= capacity:\n                        max_len = l + 1\n                    else:\n                        break\n                # Create new route for the segment\n                new_solution.append(np.concatenate([[0], current_segment[:max_len], [0]]))\n                current_segment = current_segment[max_len:]\n\n    # Perform capacity-aware swaps between routes\n    for _ in range(3):  # Limit the number of swaps\n        if len(new_solution) < 2:\n            break\n        # Select two random routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find feasible swaps\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Check capacity constraints\n                if (np.sum(demand[route1]) - demand[route1[k]] + demand[route2[l]] <= capacity and\n                    np.sum(demand[route2]) - demand[route2[l]] + demand[route1[k]] <= capacity):\n                    # Perform swap\n                    new_route1 = np.concatenate([route1[:k], [route2[l]], route1[k+1:]])\n                    new_route2 = np.concatenate([route2[:l], [route1[k]], route2[l+1:]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break\n            else:\n                continue\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        idx = np.random.randint(0, len(selected_solution))\n        route_to_modify = selected_solution[idx].copy()\n    else:\n        route_to_modify = selected_solution[0].copy()\n\n    # Step 3: Hybrid local search: route merging, split insertion, and adaptive perturbation\n    new_solution = []\n\n    # a) Route merging: attempt to merge with a nearby route if feasible\n    merged = False\n    for i, route in enumerate(selected_solution):\n        if i != idx and len(route) > 1:\n            # Check if merging is feasible (capacity and proximity)\n            total_demand = sum(demand[route[1:-1]]) + sum(demand[route_to_modify[1:-1]])\n            if total_demand <= capacity:\n                # Find closest nodes between routes\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for j in range(1, len(route)):\n                    for k in range(1, len(route_to_modify)):\n                        dist = distance_matrix[route[j-1], route_to_modify[k-1]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (j, k)\n\n                # Merge the routes\n                new_route = np.concatenate([route[:best_pair[0]], route_to_modify[best_pair[1]:], route[best_pair[0]:]])\n                new_solution.append(new_route)\n                merged = True\n                break\n\n    if not merged:\n        # b) Split insertion: split the route and insert into another route if feasible\n        split_pos = np.random.randint(1, len(route_to_modify)-1)\n        part1 = route_to_modify[:split_pos+1]\n        part2 = route_to_modify[split_pos:]\n\n        # Try inserting part2 into another route\n        inserted = False\n        for i, route in enumerate(selected_solution):\n            if i != idx and len(route) > 1:\n                total_demand = sum(demand[route[1:-1]]) + sum(demand[part2[1:-1]])\n                if total_demand <= capacity:\n                    # Find best insertion point\n                    min_dist = float('inf')\n                    best_pos = 0\n                    for j in range(1, len(route)):\n                        dist = distance_matrix[route[j-1], part2[0]] + distance_matrix[part2[-2], route[j]] - distance_matrix[route[j-1], route[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = j\n\n                    new_route = np.concatenate([route[:best_pos], part2, route[best_pos:]])\n                    new_solution.append(new_route)\n                    inserted = True\n                    break\n\n        if not inserted:\n            # c) Adaptive perturbation: randomly swap or reverse segments if no better merge/insertion found\n            if len(route_to_modify) > 3:\n                if np.random.rand() < 0.5:\n                    # Random swap\n                    i, j = np.random.choice(range(1, len(route_to_modify)-1), 2, replace=False)\n                    route_to_modify[i], route_to_modify[j] = route_to_modify[j], route_to_modify[i]\n                else:\n                    # Random reverse\n                    i, j = sorted(np.random.choice(range(1, len(route_to_modify)-1), 2, replace=False))\n                    route_to_modify[i:j+1] = route_to_modify[i:j+1][::-1]\n\n            new_solution.append(route_to_modify)\n\n    # Rebuild the solution with the modified route\n    final_solution = []\n    for route in selected_solution:\n        if route is not route_to_modify:\n            final_solution.append(route)\n\n    if merged:\n        # Remove the merged route\n        pass\n    else:\n        final_solution.append(route_to_modify)\n\n    return final_solution\n\n",
        "score": [
            -0.684871162432552,
            0.728535920381546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        idx = np.random.randint(0, len(selected_solution))\n        route_to_modify = selected_solution[idx].copy()\n    else:\n        route_to_modify = selected_solution[0].copy()\n\n    # Step 3: Hybrid local search: route merging, split insertion, and adaptive perturbation\n    new_solution = []\n\n    # a) Route merging: attempt to merge with a nearby route if feasible\n    merged = False\n    for i, route in enumerate(selected_solution):\n        if i != idx and len(route) > 1:\n            # Check if merging is feasible (capacity and proximity)\n            total_demand = sum(demand[route[1:-1]]) + sum(demand[route_to_modify[1:-1]])\n            if total_demand <= capacity:\n                # Find closest nodes between routes\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for j in range(1, len(route)):\n                    for k in range(1, len(route_to_modify)):\n                        dist = distance_matrix[route[j-1], route_to_modify[k-1]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (j, k)\n\n                # Merge the routes\n                new_route = np.concatenate([route[:best_pair[0]], route_to_modify[best_pair[1]:], route[best_pair[0]:]])\n                new_solution.append(new_route)\n                merged = True\n                break\n\n    if not merged:\n        # b) Split insertion: split the route and insert into another route if feasible\n        split_pos = np.random.randint(1, len(route_to_modify)-1)\n        part1 = route_to_modify[:split_pos+1]\n        part2 = route_to_modify[split_pos:]\n\n        # Try inserting part2 into another route\n        inserted = False\n        for i, route in enumerate(selected_solution):\n            if i != idx and len(route) > 1:\n                total_demand = sum(demand[route[1:-1]]) + sum(demand[part2[1:-1]])\n                if total_demand <= capacity:\n                    # Find best insertion point\n                    min_dist = float('inf')\n                    best_pos = 0\n                    for j in range(1, len(route)):\n                        dist = distance_matrix[route[j-1], part2[0]] + distance_matrix[part2[-2], route[j]] - distance_matrix[route[j-1], route[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = j\n\n                    new_route = np.concatenate([route[:best_pos], part2, route[best_pos:]])\n                    new_solution.append(new_route)\n                    inserted = True\n                    break\n\n        if not inserted:\n            # c) Adaptive perturbation: randomly swap or reverse segments if no better merge/insertion found\n            if len(route_to_modify) > 3:\n                if np.random.rand() < 0.5:\n                    # Random swap\n                    i, j = np.random.choice(range(1, len(route_to_modify)-1), 2, replace=False)\n                    route_to_modify[i], route_to_modify[j] = route_to_modify[j], route_to_modify[i]\n                else:\n                    # Random reverse\n                    i, j = sorted(np.random.choice(range(1, len(route_to_modify)-1), 2, replace=False))\n                    route_to_modify[i:j+1] = route_to_modify[i:j+1][::-1]\n\n            new_solution.append(route_to_modify)\n\n    # Rebuild the solution with the modified route\n    final_solution = []\n    for route in selected_solution:\n        if route is not route_to_modify:\n            final_solution.append(route)\n\n    if merged:\n        # Remove the merged route\n        pass\n    else:\n        final_solution.append(route_to_modify)\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search combining route splitting, intra-route 2-opt with demand feasibility checks, and inter-route node swaps to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid Local Search: Combine route splitting, intra-route 2-opt, and inter-route swaps\n    for _ in range(5):  # Number of iterations\n        # Step 1: Randomly split a route if it's too long\n        if len(new_solution) > 1 and random.random() < 0.3:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Avoid splitting very short routes\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = new_route1\n                    new_solution.insert(route_idx + 1, new_route2)\n\n        # Step 2: Intra-route 2-opt with demand feasibility\n        for route in new_solution:\n            if len(route) > 4:\n                i, j = sorted(random.sample(range(1, len(route) - 2), 2))\n                new_route = np.concatenate((route[:i], route[j:i-1:-1], route[j+1:]))\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n        # Step 3: Inter-route node swap if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                pos1 = random.randint(1, len(route1) - 2)\n                pos2 = random.randint(1, len(route2) - 2)\n                node1, node2 = route1[pos1], route2[pos2]\n                new_route1 = np.concatenate((route1[:pos1], [node2], route1[pos1+1:]))\n                new_route2 = np.concatenate((route2[:pos2], [node1], route2[pos2+1:]))\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    route1[:] = new_route1\n                    route2[:] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7682427190891372,
            3.737631529569626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid Local Search: Combine route splitting, intra-route 2-opt, and inter-route swaps\n    for _ in range(5):  # Number of iterations\n        # Step 1: Randomly split a route if it's too long\n        if len(new_solution) > 1 and random.random() < 0.3:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Avoid splitting very short routes\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = new_route1\n                    new_solution.insert(route_idx + 1, new_route2)\n\n        # Step 2: Intra-route 2-opt with demand feasibility\n        for route in new_solution:\n            if len(route) > 4:\n                i, j = sorted(random.sample(range(1, len(route) - 2), 2))\n                new_route = np.concatenate((route[:i], route[j:i-1:-1], route[j+1:]))\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n\n        # Step 3: Inter-route node swap if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                pos1 = random.randint(1, len(route1) - 2)\n                pos2 = random.randint(1, len(route2) - 2)\n                node1, node2 = route1[pos1], route2[pos2]\n                new_route1 = np.concatenate((route1[:pos1], [node2], route1[pos1+1:]))\n                new_route2 = np.concatenate((route2[:pos2], [node1], route2[pos2+1:]))\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    route1[:] = new_route1\n                    route2[:] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator:\n    # 1. Randomly select two routes (with replacement) and swap a segment between them\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=True)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find feasible split points in both routes\n        def find_feasible_splits(route, cap):\n            splits = []\n            current_load = 0\n            for i in range(1, len(route) - 1):\n                current_load += demand[route[i]]\n                if current_load <= cap:\n                    splits.append(i)\n            return splits\n\n        splits1 = find_feasible_splits(route1, capacity)\n        splits2 = find_feasible_splits(route2, capacity)\n\n        if splits1 and splits2:\n            split1 = np.random.choice(splits1)\n            split2 = np.random.choice(splits2)\n\n            # Swap segments\n            new_route1 = np.concatenate([route1[:split1], route2[split2:], route1[split1:]])\n            new_route2 = np.concatenate([route2[:split2], route1[split1:], route2[split2:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # 2. Randomly reverse a segment of a route to reduce distance\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure there's space to reverse\n            start = np.random.randint(1, len(route) - 2)\n            end = np.random.randint(start + 1, len(route) - 1)\n\n            # Check capacity constraint for reversed segment\n            segment_demand = np.sum(demand[route[start:end]])\n            if segment_demand <= capacity:\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # 3. Randomly reinsert a customer from one route to another to balance makespan\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:  # Ensure there's a customer to move\n            cust_idx = np.random.randint(1, len(route1) - 1)\n            cust = route1[cust_idx]\n\n            # Check if moving the customer violates capacity in new route\n            if np.sum(demand[route2]) + demand[cust] <= capacity:\n                new_route1 = np.concatenate([route1[:cust_idx], route1[cust_idx+1:]])\n                new_route2 = np.insert(route2, -1, cust)\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8035505053131116,
            0.4166371822357178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator:\n    # 1. Randomly select two routes (with replacement) and swap a segment between them\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=True)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find feasible split points in both routes\n        def find_feasible_splits(route, cap):\n            splits = []\n            current_load = 0\n            for i in range(1, len(route) - 1):\n                current_load += demand[route[i]]\n                if current_load <= cap:\n                    splits.append(i)\n            return splits\n\n        splits1 = find_feasible_splits(route1, capacity)\n        splits2 = find_feasible_splits(route2, capacity)\n\n        if splits1 and splits2:\n            split1 = np.random.choice(splits1)\n            split2 = np.random.choice(splits2)\n\n            # Swap segments\n            new_route1 = np.concatenate([route1[:split1], route2[split2:], route1[split1:]])\n            new_route2 = np.concatenate([route2[:split2], route1[split1:], route2[split2:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # 2. Randomly reverse a segment of a route to reduce distance\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure there's space to reverse\n            start = np.random.randint(1, len(route) - 2)\n            end = np.random.randint(start + 1, len(route) - 1)\n\n            # Check capacity constraint for reversed segment\n            segment_demand = np.sum(demand[route[start:end]])\n            if segment_demand <= capacity:\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # 3. Randomly reinsert a customer from one route to another to balance makespan\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = np.random.choice(len(new_solution), size=2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:  # Ensure there's a customer to move\n            cust_idx = np.random.randint(1, len(route1) - 1)\n            cust = route1[cust_idx]\n\n            # Check if moving the customer violates capacity in new route\n            if np.sum(demand[route2]) + demand[cust] <= capacity:\n                new_route1 = np.concatenate([route1[:cust_idx], route1[cust_idx+1:]])\n                new_route2 = np.insert(route2, -1, cust)\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search strategy combining route merging, customer reallocation, and route splitting\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging - combine two routes if their combined load is within capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if idx in (i, j) else route for idx, route in enumerate(new_solution)]\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Customer reallocation - move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        for route in new_solution:\n            if len(route) > 3:  # Only consider routes with more than one customer\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n\n                # Try to insert into another route\n                for other_route in new_solution:\n                    if other_route is not route:\n                        total_demand = sum(demand[other_route[1:-1]]) + demand[customer]\n                        if total_demand <= capacity:\n                            # Find best insertion point in other_route\n                            min_cost = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(other_route)):\n                                cost = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                # Perform the move\n                                other_route = np.insert(other_route, best_pos, customer)\n                                route = np.delete(route, customer_idx)\n                                break\n\n    # Step 3: Route splitting - split a long route into two if feasible\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than two customers\n            split_pos = np.random.randint(2, len(route)-2)\n            first_part = route[:split_pos+1]\n            second_part = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7564340949819728,
            3.149394452571869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search strategy combining route merging, customer reallocation, and route splitting\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging - combine two routes if their combined load is within capacity\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if total_demand <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if idx in (i, j) else route for idx, route in enumerate(new_solution)]\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Customer reallocation - move a customer from one route to another if feasible\n    if len(new_solution) > 1:\n        for route in new_solution:\n            if len(route) > 3:  # Only consider routes with more than one customer\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n\n                # Try to insert into another route\n                for other_route in new_solution:\n                    if other_route is not route:\n                        total_demand = sum(demand[other_route[1:-1]]) + demand[customer]\n                        if total_demand <= capacity:\n                            # Find best insertion point in other_route\n                            min_cost = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(other_route)):\n                                cost = distance_matrix[other_route[pos-1]][customer] + distance_matrix[customer][other_route[pos]] - distance_matrix[other_route[pos-1]][other_route[pos]]\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                # Perform the move\n                                other_route = np.insert(other_route, best_pos, customer)\n                                route = np.delete(route, customer_idx)\n                                break\n\n    # Step 3: Route splitting - split a long route into two if feasible\n    for i, route in enumerate(new_solution):\n        if len(route) > 4:  # Only consider routes with more than two customers\n            split_pos = np.random.randint(2, len(route)-2)\n            first_part = route[:split_pos+1]\n            second_part = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a high-quality solution from the archive, then applies a hybrid local search combining route segment relocation and capacity-aware route merging to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: route segment relocation with capacity check\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can move a segment\n            # Select a random segment from the route (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Check capacity constraint for the segment\n            segment_demand = sum(demand[node] for node in segment)\n            if segment_demand <= capacity:\n                # Find another route to insert the segment\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    target_route_idx = random.choice(other_routes)\n                    target_route = new_solution[target_route_idx]\n\n                    # Check if inserting the segment would violate capacity\n                    target_route_demand = sum(demand[node] for node in target_route[1:-1])\n                    if target_route_demand + segment_demand <= capacity:\n                        # Insert the segment into the target route\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target_route = np.concatenate([\n                            target_route[:insert_pos],\n                            segment,\n                            target_route[insert_pos:]\n                        ])\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove the segment from the original route\n                        new_route = np.concatenate([route[:start], route[end:]])\n                        new_solution[route_idx] = new_route\n\n    # Additional improvement: merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to merge with another route\n        other_routes = [i for i in range(len(new_solution)) if i != shortest_route_idx]\n        for target_route_idx in other_routes:\n            target_route = new_solution[target_route_idx]\n            total_demand = sum(demand[node] for node in shortest_route[1:-1]) + sum(demand[node] for node in target_route[1:-1])\n            if total_demand <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([shortest_route[:-1], target_route[1:]])\n                new_solution = [route for i, route in enumerate(new_solution) if i not in {shortest_route_idx, target_route_idx}]\n                new_solution.append(merged_route)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6880780804240834,
            1.4014267921447754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum of objectives\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: route segment relocation with capacity check\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure we can move a segment\n            # Select a random segment from the route (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            segment = route[start:end]\n\n            # Check capacity constraint for the segment\n            segment_demand = sum(demand[node] for node in segment)\n            if segment_demand <= capacity:\n                # Find another route to insert the segment\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    target_route_idx = random.choice(other_routes)\n                    target_route = new_solution[target_route_idx]\n\n                    # Check if inserting the segment would violate capacity\n                    target_route_demand = sum(demand[node] for node in target_route[1:-1])\n                    if target_route_demand + segment_demand <= capacity:\n                        # Insert the segment into the target route\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target_route = np.concatenate([\n                            target_route[:insert_pos],\n                            segment,\n                            target_route[insert_pos:]\n                        ])\n                        new_solution[target_route_idx] = new_target_route\n\n                        # Remove the segment from the original route\n                        new_route = np.concatenate([route[:start], route[end:]])\n                        new_solution[route_idx] = new_route\n\n    # Additional improvement: merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Try to merge with another route\n        other_routes = [i for i in range(len(new_solution)) if i != shortest_route_idx]\n        for target_route_idx in other_routes:\n            target_route = new_solution[target_route_idx]\n            total_demand = sum(demand[node] for node in shortest_route[1:-1]) + sum(demand[node] for node in target_route[1:-1])\n            if total_demand <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([shortest_route[:-1], target_route[1:]])\n                new_solution = [route for i, route in enumerate(new_solution) if i not in {shortest_route_idx, target_route_idx}]\n                new_solution.append(merged_route)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route merging and intra-route 2-opt with demand-aware swaps\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Intra-route optimization with demand-aware swaps\n        improved_route = route.copy()\n        for _ in range(5):  # Limited iterations to balance exploration/exploitation\n            i, j = sorted(random.sample(range(1, len(improved_route)-1), 2))\n            if i == j:\n                continue\n\n            # Check if swapping customers i and j maintains capacity constraints\n            segment = improved_route[i:j+1]\n            segment_demand = sum(demand[improved_route[k]] for k in range(i, j+1))\n\n            # Try reversing the segment (demand-aware 2-opt)\n            reversed_segment = segment[::-1]\n            reversed_demand = sum(demand[node] for node in reversed_segment)\n\n            if reversed_demand <= capacity:\n                improved_route[i:j+1] = reversed_segment\n\n        new_solution.append(improved_route)\n\n    # Route merging: attempt to combine two shortest routes if possible\n    if len(new_solution) > 1:\n        # Sort routes by length (excluding depot)\n        new_solution.sort(key=lambda r: len(r) - 2)\n\n        # Try merging the two shortest routes\n        route1, route2 = new_solution[0], new_solution[1]\n        merged_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2) - demand[0]  # Subtract depot demand\n\n        if merged_demand <= capacity:\n            # Create merged route (route1 + route2[1:-1])\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + new_solution[2:]\n        else:\n            # If merging fails, try a partial merge by splitting at a demand-feasible point\n            cumulative_demand = 0\n            split_idx = 0\n            for i in range(1, len(route2)-1):\n                cumulative_demand += demand[route2[i]]\n                if cumulative_demand <= capacity - sum(demand[node] for node in route1):\n                    split_idx = i\n                else:\n                    break\n\n            if split_idx > 0:\n                partial_merge = np.concatenate([route1[:-1], route2[1:split_idx+1]])\n                remaining_route = np.concatenate([[0], route2[split_idx+1:]])\n                new_solution = [partial_merge, remaining_route] + new_solution[2:]\n\n    return new_solution\n\n",
        "score": [
            -0.7805308374896875,
            1.96082004904747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route merging and intra-route 2-opt with demand-aware swaps\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Intra-route optimization with demand-aware swaps\n        improved_route = route.copy()\n        for _ in range(5):  # Limited iterations to balance exploration/exploitation\n            i, j = sorted(random.sample(range(1, len(improved_route)-1), 2))\n            if i == j:\n                continue\n\n            # Check if swapping customers i and j maintains capacity constraints\n            segment = improved_route[i:j+1]\n            segment_demand = sum(demand[improved_route[k]] for k in range(i, j+1))\n\n            # Try reversing the segment (demand-aware 2-opt)\n            reversed_segment = segment[::-1]\n            reversed_demand = sum(demand[node] for node in reversed_segment)\n\n            if reversed_demand <= capacity:\n                improved_route[i:j+1] = reversed_segment\n\n        new_solution.append(improved_route)\n\n    # Route merging: attempt to combine two shortest routes if possible\n    if len(new_solution) > 1:\n        # Sort routes by length (excluding depot)\n        new_solution.sort(key=lambda r: len(r) - 2)\n\n        # Try merging the two shortest routes\n        route1, route2 = new_solution[0], new_solution[1]\n        merged_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2) - demand[0]  # Subtract depot demand\n\n        if merged_demand <= capacity:\n            # Create merged route (route1 + route2[1:-1])\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route] + new_solution[2:]\n        else:\n            # If merging fails, try a partial merge by splitting at a demand-feasible point\n            cumulative_demand = 0\n            split_idx = 0\n            for i in range(1, len(route2)-1):\n                cumulative_demand += demand[route2[i]]\n                if cumulative_demand <= capacity - sum(demand[node] for node in route1):\n                    split_idx = i\n                else:\n                    break\n\n            if split_idx > 0:\n                partial_merge = np.concatenate([route1[:-1], route2[1:split_idx+1]])\n                remaining_route = np.concatenate([[0], route2[split_idx+1:]])\n                new_solution = [partial_merge, remaining_route] + new_solution[2:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The new algorithm combines a randomized route-segment swapping strategy with a capacity-aware edge insertion heuristic to balance distance and makespan reduction, ensuring feasibility through demand checks and distance updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by distance then makespan\n    selected_solution = random.choice(archive[:max(1, len(archive)//3)])[0].copy()  # Randomly pick from top third\n\n    # Hybrid local search: Route-segment swap + edge insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to swap\n        start, end = sorted(random.sample(range(1, len(route)-1), 2))\n        segment = route[start:end+1]\n\n        # Try inserting the segment into another route\n        for other_route in selected_solution:\n            if other_route is route or len(other_route) <= 2:\n                continue\n\n            # Check capacity feasibility\n            if np.sum(demand[segment[1:-1]]) + np.sum(demand[other_route[1:-1]]) > capacity:\n                continue\n\n            # Find best insertion point in other route\n            best_insert_pos = -1\n            min_increase = float('inf')\n            for i in range(1, len(other_route)):\n                # Calculate distance increase if inserted\n                dist_increase = (distance_matrix[other_route[i-1], segment[1]] +\n                                distance_matrix[segment[-2], other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]] +\n                                distance_matrix[segment[1], segment[-2]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_insert_pos = i\n\n            if best_insert_pos != -1:\n                # Perform the insertion\n                modified_route = np.concatenate([\n                    other_route[:best_insert_pos],\n                    segment,\n                    other_route[best_insert_pos:]\n                ])\n                new_solution.append(modified_route)\n                break\n        else:\n            new_solution.append(route.copy())\n\n    # Ensure all routes are feasible\n    for i, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split the route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i:i+1] = [new_route1, new_route2]\n\n    return new_solution\n\n",
        "score": [
            -0.8099487725596706,
            4.3853369653224945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by distance then makespan\n    selected_solution = random.choice(archive[:max(1, len(archive)//3)])[0].copy()  # Randomly pick from top third\n\n    # Hybrid local search: Route-segment swap + edge insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly select a segment to swap\n        start, end = sorted(random.sample(range(1, len(route)-1), 2))\n        segment = route[start:end+1]\n\n        # Try inserting the segment into another route\n        for other_route in selected_solution:\n            if other_route is route or len(other_route) <= 2:\n                continue\n\n            # Check capacity feasibility\n            if np.sum(demand[segment[1:-1]]) + np.sum(demand[other_route[1:-1]]) > capacity:\n                continue\n\n            # Find best insertion point in other route\n            best_insert_pos = -1\n            min_increase = float('inf')\n            for i in range(1, len(other_route)):\n                # Calculate distance increase if inserted\n                dist_increase = (distance_matrix[other_route[i-1], segment[1]] +\n                                distance_matrix[segment[-2], other_route[i]] -\n                                distance_matrix[other_route[i-1], other_route[i]] +\n                                distance_matrix[segment[1], segment[-2]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_insert_pos = i\n\n            if best_insert_pos != -1:\n                # Perform the insertion\n                modified_route = np.concatenate([\n                    other_route[:best_insert_pos],\n                    segment,\n                    other_route[best_insert_pos:]\n                ])\n                new_solution.append(modified_route)\n                break\n        else:\n            new_solution.append(route.copy())\n\n    # Ensure all routes are feasible\n    for i, route in enumerate(new_solution):\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split the route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i:i+1] = [new_route1, new_route2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high total distance and low makespan, then applies a hybrid local search combining route splitting and customer reallocation to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance objectives\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n        part2[0] = 0  # Ensure part2 starts at depot\n\n        # Check capacity feasibility\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            # If split violates capacity, try reallocating customers\n            reallocated = False\n            temp_route = route.copy()\n            for i in range(1, len(temp_route) - 1):\n                for j in range(len(new_solution)):\n                    if sum(demand[new_solution[j][1:-1]]) + demand[temp_route[i]] <= capacity:\n                        # Move customer to another route\n                        new_solution[j] = np.append(new_solution[j][:-1], [temp_route[i], 0])\n                        temp_route = np.delete(temp_route, i)\n                        reallocated = True\n                        break\n                if reallocated:\n                    break\n            new_solution.append(temp_route)\n\n    # Ensure all customers are served (fallback)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Add missing customers to the route with most remaining capacity\n        for customer in missing:\n            best_route = min(new_solution, key=lambda r: sum(demand[r[1:-1]]))\n            if sum(demand[best_route[1:-1]]) + demand[customer] <= capacity:\n                best_route[-1] = customer\n                best_route = np.append(best_route, 0)\n\n    return new_solution\n\n",
        "score": [
            -0.7334848994305427,
            2.7808741629123688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()\n\n    # Hybrid local search: Split long routes and reallocate customers to balance objectives\n    new_solution = []\n    for route in selected:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n        part2[0] = 0  # Ensure part2 starts at depot\n\n        # Check capacity feasibility\n        if sum(demand[part1[1:-1]]) <= capacity and sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            # If split violates capacity, try reallocating customers\n            reallocated = False\n            temp_route = route.copy()\n            for i in range(1, len(temp_route) - 1):\n                for j in range(len(new_solution)):\n                    if sum(demand[new_solution[j][1:-1]]) + demand[temp_route[i]] <= capacity:\n                        # Move customer to another route\n                        new_solution[j] = np.append(new_solution[j][:-1], [temp_route[i], 0])\n                        temp_route = np.delete(temp_route, i)\n                        reallocated = True\n                        break\n                if reallocated:\n                    break\n            new_solution.append(temp_route)\n\n    # Ensure all customers are served (fallback)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Add missing customers to the route with most remaining capacity\n        for customer in missing:\n            best_route = min(new_solution, key=lambda r: sum(demand[r[1:-1]]))\n            if sum(demand[best_route[1:-1]]) + demand[customer] <= capacity:\n                best_route[-1] = customer\n                best_route = np.append(best_route, 0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1], -x[1][0]))[0].copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(selected_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = np.random.choice(len(selected_solution), size=2, replace=False)\n        route1, route2 = selected_solution[route1_idx], selected_solution[route2_idx]\n\n        # Merge routes and check feasibility\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            # Valid merge, reinsert customers from the other route\n            selected_solution.pop(max(route1_idx, route2_idx))\n            selected_solution.pop(min(route1_idx, route2_idx))\n            selected_solution.append(merged_route)\n\n            # Reinsert customers from the removed route\n            removed_customers = route2[1:-1]\n            for customer in removed_customers:\n                best_pos = None\n                best_cost = float('inf')\n                for i, route in enumerate(selected_solution):\n                    for j in range(1, len(route)):\n                        # Insert customer between j-1 and j\n                        new_route = np.insert(route, j, customer)\n                        new_demand = np.sum(demand[new_route[1:-1]])\n                        if new_demand > capacity:\n                            continue\n                        # Calculate insertion cost (delta in distance)\n                        delta = (distance_matrix[route[j-1], customer] +\n                                 distance_matrix[customer, route[j]] -\n                                 distance_matrix[route[j-1], route[j]])\n                        if delta < best_cost:\n                            best_cost = delta\n                            best_pos = (i, j)\n                if best_pos is not None:\n                    i, j = best_pos\n                    selected_solution[i] = np.insert(selected_solution[i], j, customer)\n    else:\n        # For single route, perform a modified 2-opt with demand check\n        route = selected_solution[0]\n        n = len(route) - 1  # exclude depot\n        for _ in range(10):  # limited iterations\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            # Check demand feasibility for the swapped segment\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[0] = new_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7068083777482124,
            0.6349168121814728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1], -x[1][0]))[0].copy()\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(selected_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = np.random.choice(len(selected_solution), size=2, replace=False)\n        route1, route2 = selected_solution[route1_idx], selected_solution[route2_idx]\n\n        # Merge routes and check feasibility\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        total_demand = np.sum(demand[merged_route[1:-1]])\n        if total_demand <= capacity:\n            # Valid merge, reinsert customers from the other route\n            selected_solution.pop(max(route1_idx, route2_idx))\n            selected_solution.pop(min(route1_idx, route2_idx))\n            selected_solution.append(merged_route)\n\n            # Reinsert customers from the removed route\n            removed_customers = route2[1:-1]\n            for customer in removed_customers:\n                best_pos = None\n                best_cost = float('inf')\n                for i, route in enumerate(selected_solution):\n                    for j in range(1, len(route)):\n                        # Insert customer between j-1 and j\n                        new_route = np.insert(route, j, customer)\n                        new_demand = np.sum(demand[new_route[1:-1]])\n                        if new_demand > capacity:\n                            continue\n                        # Calculate insertion cost (delta in distance)\n                        delta = (distance_matrix[route[j-1], customer] +\n                                 distance_matrix[customer, route[j]] -\n                                 distance_matrix[route[j-1], route[j]])\n                        if delta < best_cost:\n                            best_cost = delta\n                            best_pos = (i, j)\n                if best_pos is not None:\n                    i, j = best_pos\n                    selected_solution[i] = np.insert(selected_solution[i], j, customer)\n    else:\n        # For single route, perform a modified 2-opt with demand check\n        route = selected_solution[0]\n        n = len(route) - 1  # exclude depot\n        for _ in range(10):  # limited iterations\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            # Check demand feasibility for the swapped segment\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[0] = new_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan and applies a hybrid local search operator that combines route splitting, customer reallocation, and route merging to reduce both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split, reallocate, and merge\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the sum of the two new routes\n        best_split = 1\n        min_split_cost = float('inf')\n        for split in range(1, len(longest_route)-1):\n            cost1 = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(split-1))\n            cost2 = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(split, len(longest_route)-1))\n            if cost1 + cost2 < min_split_cost:\n                min_split_cost = cost1 + cost2\n                best_split = split\n\n        route1 = longest_route[:best_split+1]\n        route2 = longest_route[best_split:]\n\n        # Ensure capacity constraints are met\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n        # Step 2: Reallocate customers from the two new routes to other routes if beneficial\n        for route in [route1, route2]:\n            for i in range(1, len(route)-1):\n                customer = route[i]\n                # Check if moving this customer to another route would reduce total distance\n                for other_route in new_solution:\n                    if other_route is route:\n                        continue\n                    # Check if adding the customer to other_route is feasible\n                    if sum(demand[node] for node in other_route[1:-1]) + demand[customer] <= capacity:\n                        # Calculate the cost of removing customer from route and adding to other_route\n                        cost_remove = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]] - distance_matrix[route[i-1], route[i+1]]\n                        cost_add = distance_matrix[other_route[-2], customer] + distance_matrix[customer, 0] - distance_matrix[other_route[-2], 0]\n                        if cost_remove + cost_add < 0:\n                            # Perform the reallocation\n                            route = np.delete(route, i)\n                            other_route[-1] = customer\n                            other_route = np.append(other_route, 0)\n\n        # Step 3: Merge routes if possible to reduce total routes\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                # Check if merging route1 and route2 is feasible\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    # Calculate the cost of merging\n                    cost_merge = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0] - distance_matrix[route1[-2], 0] - distance_matrix[route2[-2], 0]\n                    if cost_merge < 0:\n                        # Perform the merge\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8629436582844912,
            4.500570863485336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split, reallocate, and merge\n    if len(new_solution) > 1:\n        # Step 1: Split the longest route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1)) for i in range(len(new_solution))])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the sum of the two new routes\n        best_split = 1\n        min_split_cost = float('inf')\n        for split in range(1, len(longest_route)-1):\n            cost1 = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(split-1))\n            cost2 = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(split, len(longest_route)-1))\n            if cost1 + cost2 < min_split_cost:\n                min_split_cost = cost1 + cost2\n                best_split = split\n\n        route1 = longest_route[:best_split+1]\n        route2 = longest_route[best_split:]\n\n        # Ensure capacity constraints are met\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n        # Step 2: Reallocate customers from the two new routes to other routes if beneficial\n        for route in [route1, route2]:\n            for i in range(1, len(route)-1):\n                customer = route[i]\n                # Check if moving this customer to another route would reduce total distance\n                for other_route in new_solution:\n                    if other_route is route:\n                        continue\n                    # Check if adding the customer to other_route is feasible\n                    if sum(demand[node] for node in other_route[1:-1]) + demand[customer] <= capacity:\n                        # Calculate the cost of removing customer from route and adding to other_route\n                        cost_remove = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]] - distance_matrix[route[i-1], route[i+1]]\n                        cost_add = distance_matrix[other_route[-2], customer] + distance_matrix[customer, 0] - distance_matrix[other_route[-2], 0]\n                        if cost_remove + cost_add < 0:\n                            # Perform the reallocation\n                            route = np.delete(route, i)\n                            other_route[-1] = customer\n                            other_route = np.append(other_route, 0)\n\n        # Step 3: Merge routes if possible to reduce total routes\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                # Check if merging route1 and route2 is feasible\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    # Calculate the cost of merging\n                    cost_merge = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0] - distance_matrix[route1[-2], 0] - distance_matrix[route2[-2], 0]\n                    if cost_merge < 0:\n                        # Perform the merge\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (lexicographic order)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution with a 70% chance of being in the top 30% of the archive\n        selection_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Route splitting + customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) < 4:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 2)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity feasibility for both new routes\n        if (np.sum(demand[route1[1:-1]]) <= capacity) and (np.sum(demand[route2[1:-1]]) <= capacity):\n            # Reallocate customers between the two new routes with a probability\n            if np.random.random() < 0.5:\n                # Try to move a customer from route1 to route2\n                for j in range(1, len(route1) - 1):\n                    candidate = route1[j]\n                    # Check if moving this customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[candidate] <= capacity:\n                        # Find the best insertion position in route2\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for k in range(1, len(route2)):\n                            # Insert candidate between route2[k-1] and route2[k]\n                            cost = distance_matrix[route2[k-1]][candidate] + distance_matrix[candidate][route2[k]] - distance_matrix[route2[k-1]][route2[k]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = k\n                        # Perform the move\n                        route1 = np.concatenate([route1[:j], route1[j+1:]])\n                        route2 = np.concatenate([route2[:best_pos], [candidate], route2[best_pos:]])\n                        break\n\n            # Update the solution with the new routes\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break  # Only perform one split per iteration\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6900377392339767,
            0.2355853021144867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (lexicographic order)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution with a 70% chance of being in the top 30% of the archive\n        selection_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Route splitting + customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) < 4:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 2)\n        route1 = route[:split_pos + 1]\n        route2 = route[split_pos:]\n\n        # Check capacity feasibility for both new routes\n        if (np.sum(demand[route1[1:-1]]) <= capacity) and (np.sum(demand[route2[1:-1]]) <= capacity):\n            # Reallocate customers between the two new routes with a probability\n            if np.random.random() < 0.5:\n                # Try to move a customer from route1 to route2\n                for j in range(1, len(route1) - 1):\n                    candidate = route1[j]\n                    # Check if moving this customer to route2 is feasible\n                    if np.sum(demand[route2[1:-1]]) + demand[candidate] <= capacity:\n                        # Find the best insertion position in route2\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for k in range(1, len(route2)):\n                            # Insert candidate between route2[k-1] and route2[k]\n                            cost = distance_matrix[route2[k-1]][candidate] + distance_matrix[candidate][route2[k]] - distance_matrix[route2[k-1]][route2[k]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = k\n                        # Perform the move\n                        route1 = np.concatenate([route1[:j], route1[j+1:]])\n                        route2 = np.concatenate([route2[:best_pos], [candidate], route2[best_pos:]])\n                        break\n\n            # Update the solution with the new routes\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break  # Only perform one split per iteration\n\n    # Ensure the solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route[1:-1]]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines route merging, split insertion, and adaptive 2-opt with capacity-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (combine two routes if it reduces makespan)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is possible without exceeding capacity\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Split insertion (split a long route into two shorter ones)\n    for route in new_solution:\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([route1, route2])\n                break\n\n    # Step 3: Adaptive 2-opt with capacity constraints\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two edges to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate((route[:a], route[a:b][::-1], route[b:]))\n\n            # Check capacity constraints\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Replace the original route with the improved one\n                new_solution = [new_route if np.array_equal(r, route) else r for r in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.5735070728537934,
            3.1612539887428284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (combine two routes if it reduces makespan)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is possible without exceeding capacity\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n    # Step 2: Split insertion (split a long route into two shorter ones)\n    for route in new_solution:\n        if len(route) > 4:  # Only split if route has enough nodes\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n                # Replace the original route with the two new routes\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.extend([route1, route2])\n                break\n\n    # Step 3: Adaptive 2-opt with capacity constraints\n    for route in new_solution:\n        if len(route) > 3:\n            # Randomly select two edges to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            new_route = np.concatenate((route[:a], route[a:b][::-1], route[b:]))\n\n            # Check capacity constraints\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Replace the original route with the improved one\n                new_solution = [new_route if np.array_equal(r, route) else r for r in new_solution]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity feasibility for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Randomly reallocate a customer from one route to another to improve balance\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(0, len(new_solution))\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure there's a customer to move\n            customer_idx = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find best insertion position in the target route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(to_route)):\n                # Check capacity constraint\n                if np.sum(demand[to_route[1:pos]]) + demand[customer] <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[to_route[pos-1], customer] +\n                                   distance_matrix[customer, to_route[pos]] -\n                                   distance_matrix[to_route[pos-1], to_route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            # Perform the move if feasible\n            if min_increase < float('inf'):\n                new_to_route = np.insert(to_route, best_pos, customer)\n                new_from_route = np.delete(from_route, customer_idx)\n\n                # Update the solution\n                new_solution[to_route_idx] = new_to_route\n                new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.764719475682894,
            1.073994219303131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: Combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_pos = np.random.randint(1, len(route) - 1)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity feasibility for both new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Randomly reallocate a customer from one route to another to improve balance\n    if len(new_solution) > 1:\n        from_route_idx = np.random.randint(0, len(new_solution))\n        from_route = new_solution[from_route_idx]\n        if len(from_route) > 3:  # Ensure there's a customer to move\n            customer_idx = np.random.randint(1, len(from_route) - 1)\n            customer = from_route[customer_idx]\n\n            # Try to insert into another route\n            to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n            to_route = new_solution[to_route_idx]\n\n            # Find best insertion position in the target route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(to_route)):\n                # Check capacity constraint\n                if np.sum(demand[to_route[1:pos]]) + demand[customer] <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[to_route[pos-1], customer] +\n                                   distance_matrix[customer, to_route[pos]] -\n                                   distance_matrix[to_route[pos-1], to_route[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n            # Perform the move if feasible\n            if min_increase < float('inf'):\n                new_to_route = np.insert(to_route, best_pos, customer)\n                new_from_route = np.delete(from_route, customer_idx)\n\n                # Update the solution\n                new_solution[to_route_idx] = new_to_route\n                new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or reallocate\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if i == route1_idx else route for i, route in enumerate(new_solution) if i != route2_idx]\n        else:\n            # Reallocate customers between routes if merging is not feasible\n            for customer in route2[1:-1]:\n                # Find feasible insertion positions in route1\n                feasible_positions = []\n                for i in range(1, len(route1)):\n                    temp_route = np.insert(route1, i, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        feasible_positions.append(i)\n                if feasible_positions:\n                    insert_pos = random.choice(feasible_positions)\n                    route1 = np.insert(route1, insert_pos, customer)\n                    route2 = np.delete(route2, np.where(route2 == customer)[0][0])\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.6254984003526127,
            8.132353484630585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge or reallocate\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if i == route1_idx else route for i, route in enumerate(new_solution) if i != route2_idx]\n        else:\n            # Reallocate customers between routes if merging is not feasible\n            for customer in route2[1:-1]:\n                # Find feasible insertion positions in route1\n                feasible_positions = []\n                for i in range(1, len(route1)):\n                    temp_route = np.insert(route1, i, customer)\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        feasible_positions.append(i)\n                if feasible_positions:\n                    insert_pos = random.choice(feasible_positions)\n                    route1 = np.insert(route1, insert_pos, customer)\n                    route2 = np.delete(route2, np.where(route2 == customer)[0][0])\n            new_solution[route1_idx] = route1\n            new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion, and route merging to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reinsertion, and route merging\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random feasible point\n        split_pos = np.random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        if np.sum(demand[current_route[1:-1]]) > capacity:\n            # Find customers exceeding capacity\n            excess_customers = []\n            total_demand = 0\n            for node in current_route[1:-1]:\n                if total_demand + demand[node] <= capacity:\n                    total_demand += demand[node]\n                else:\n                    excess_customers.append(node)\n\n            # Remove excess customers\n            new_route = [0]\n            for node in current_route[1:-1]:\n                if node not in excess_customers:\n                    new_route.append(node)\n            new_route.append(0)\n\n            # Try to reinsert excess customers into other routes\n            for node in excess_customers:\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    candidate_route = new_solution[j]\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[node] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    for pos in range(1, len(candidate_route)):\n                        prev_node = candidate_route[pos - 1]\n                        next_node = candidate_route[pos]\n                        insertion_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node] - distance_matrix[prev_node, next_node]\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route = j\n                            best_pos = pos\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n            new_solution[i] = np.array(new_route)\n\n    # Merge routes if possible\n    merged_solution = []\n    used_routes = set()\n    for i in range(len(new_solution)):\n        if i in used_routes:\n            continue\n        current_route = new_solution[i]\n        merged_routes = [current_route]\n\n        for j in range(i + 1, len(new_solution)):\n            if j in used_routes:\n                continue\n            candidate_route = new_solution[j]\n\n            # Check if merging is feasible\n            merged_demand = np.sum(demand[current_route[1:-1]]) + np.sum(demand[candidate_route[1:-1]])\n            if merged_demand > capacity:\n                continue\n\n            # Check if merging reduces total distance\n            last_node_i = current_route[-2]\n            first_node_j = candidate_route[1]\n            merged_distance = distance_matrix[last_node_i, first_node_j]\n\n            original_distance = distance_matrix[last_node_i, 0] + distance_matrix[0, first_node_j]\n\n            if merged_distance < original_distance:\n                # Merge the routes\n                merged_route = np.concatenate([current_route[:-1], candidate_route[1:]])\n                merged_routes.append(candidate_route)\n                used_routes.add(j)\n\n        if len(merged_routes) > 1:\n            # Create merged route\n            merged_route = merged_routes[0]\n            for route in merged_routes[1:]:\n                merged_route = np.concatenate([merged_route[:-1], route[1:]])\n            merged_solution.append(merged_route)\n        else:\n            merged_solution.append(current_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.6658896622576662,
            2.992182493209839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0]\n    base_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting, customer reinsertion, and route merging\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random feasible point\n        split_pos = np.random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Reinsert customers from overloaded routes\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        if np.sum(demand[current_route[1:-1]]) > capacity:\n            # Find customers exceeding capacity\n            excess_customers = []\n            total_demand = 0\n            for node in current_route[1:-1]:\n                if total_demand + demand[node] <= capacity:\n                    total_demand += demand[node]\n                else:\n                    excess_customers.append(node)\n\n            # Remove excess customers\n            new_route = [0]\n            for node in current_route[1:-1]:\n                if node not in excess_customers:\n                    new_route.append(node)\n            new_route.append(0)\n\n            # Try to reinsert excess customers into other routes\n            for node in excess_customers:\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    candidate_route = new_solution[j]\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[node] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    for pos in range(1, len(candidate_route)):\n                        prev_node = candidate_route[pos - 1]\n                        next_node = candidate_route[pos]\n                        insertion_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node] - distance_matrix[prev_node, next_node]\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route = j\n                            best_pos = pos\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, node)\n\n            new_solution[i] = np.array(new_route)\n\n    # Merge routes if possible\n    merged_solution = []\n    used_routes = set()\n    for i in range(len(new_solution)):\n        if i in used_routes:\n            continue\n        current_route = new_solution[i]\n        merged_routes = [current_route]\n\n        for j in range(i + 1, len(new_solution)):\n            if j in used_routes:\n                continue\n            candidate_route = new_solution[j]\n\n            # Check if merging is feasible\n            merged_demand = np.sum(demand[current_route[1:-1]]) + np.sum(demand[candidate_route[1:-1]])\n            if merged_demand > capacity:\n                continue\n\n            # Check if merging reduces total distance\n            last_node_i = current_route[-2]\n            first_node_j = candidate_route[1]\n            merged_distance = distance_matrix[last_node_i, first_node_j]\n\n            original_distance = distance_matrix[last_node_i, 0] + distance_matrix[0, first_node_j]\n\n            if merged_distance < original_distance:\n                # Merge the routes\n                merged_route = np.concatenate([current_route[:-1], candidate_route[1:]])\n                merged_routes.append(candidate_route)\n                used_routes.add(j)\n\n        if len(merged_routes) > 1:\n            # Create merged route\n            merged_route = merged_routes[0]\n            for route in merged_routes[1:]:\n                merged_route = np.concatenate([merged_route[:-1], route[1:]])\n            merged_solution.append(merged_route)\n        else:\n            merged_solution.append(current_route)\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them via the nearest customer\n            last_node = route1[-2]\n            first_node = route2[1]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Check feasibility and update\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Randomly select a route for reinsertion\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        if len(route) > 3:\n            pos = np.random.randint(1, len(route)-1)\n            customer = route[pos]\n\n            # Remove customer from route\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find the best insertion position in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for idx, r in enumerate(new_solution):\n                if idx != route_idx:\n                    for p in range(1, len(r)):\n                        # Insert customer and check feasibility\n                        candidate_route = np.insert(r, p, customer)\n                        if sum(demand[candidate_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost (delta distance)\n                            prev_node = candidate_route[p-1]\n                            next_node = candidate_route[p+1]\n                            cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = idx\n                                best_pos = p\n\n            # Perform the best insertion if found\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_route = np.insert(best_route, best_pos, customer)\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7829929141324324,
            6.1915905475616455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting them via the nearest customer\n            last_node = route1[-2]\n            first_node = route2[1]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Check feasibility and update\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    # Randomly select a route for reinsertion\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        if len(route) > 3:\n            pos = np.random.randint(1, len(route)-1)\n            customer = route[pos]\n\n            # Remove customer from route\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find the best insertion position in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for idx, r in enumerate(new_solution):\n                if idx != route_idx:\n                    for p in range(1, len(r)):\n                        # Insert customer and check feasibility\n                        candidate_route = np.insert(r, p, customer)\n                        if sum(demand[candidate_route[1:-1]]) <= capacity:\n                            # Calculate insertion cost (delta distance)\n                            prev_node = candidate_route[p-1]\n                            next_node = candidate_route[p+1]\n                            cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = idx\n                                best_pos = p\n\n            # Perform the best insertion if found\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_route = np.insert(best_route, best_pos, customer)\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware placement, and cross-route swaps to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, reinsertion, and cross-route swaps\n    # 1. Route splitting: split long routes to reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has enough customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # 2. Demand-aware reinsertion: move customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # Find customers to remove\n            excess = route_demand - capacity\n            customers = route[1:-1]\n            to_remove = []\n            current_excess = 0\n            for c in customers:\n                if current_excess >= excess:\n                    break\n                current_excess += demand[c]\n                to_remove.append(c)\n\n            # Find best positions to reinsert\n            for c in to_remove:\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    temp_route = new_solution[j].copy()\n                    for pos in range(1, len(temp_route)):\n                        temp_route = np.insert(temp_route, pos, c)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[temp_route[pos-1]][c] + distance_matrix[c][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = j\n                                best_pos = pos\n                        temp_route = np.delete(temp_route, pos)\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, c)\n                    route = np.delete(route, np.where(route == c)[0][0])\n\n    # 3. Cross-route swaps: improve total distance and makespan\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Select random customers from each route\n        cust1 = random.choice(route1[1:-1])\n        cust2 = random.choice(route2[1:-1])\n\n        # Check feasibility after swap\n        new_route1 = route1.copy()\n        new_route2 = route2.copy()\n\n        # Replace cust1 in route1 with cust2\n        pos1 = np.where(new_route1 == cust1)[0][0]\n        new_route1[pos1] = cust2\n\n        # Replace cust2 in route2 with cust1\n        pos2 = np.where(new_route2 == cust2)[0][0]\n        new_route2[pos2] = cust1\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7243959943359852,
            4.179242968559265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, reinsertion, and cross-route swaps\n    # 1. Route splitting: split long routes to reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has enough customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # 2. Demand-aware reinsertion: move customers from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # Find customers to remove\n            excess = route_demand - capacity\n            customers = route[1:-1]\n            to_remove = []\n            current_excess = 0\n            for c in customers:\n                if current_excess >= excess:\n                    break\n                current_excess += demand[c]\n                to_remove.append(c)\n\n            # Find best positions to reinsert\n            for c in to_remove:\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    temp_route = new_solution[j].copy()\n                    for pos in range(1, len(temp_route)):\n                        temp_route = np.insert(temp_route, pos, c)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[temp_route[pos-1]][c] + distance_matrix[c][temp_route[pos+1]] - distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = j\n                                best_pos = pos\n                        temp_route = np.delete(temp_route, pos)\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, c)\n                    route = np.delete(route, np.where(route == c)[0][0])\n\n    # 3. Cross-route swaps: improve total distance and makespan\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) < 3 or len(route2) < 3:\n            continue\n\n        # Select random customers from each route\n        cust1 = random.choice(route1[1:-1])\n        cust2 = random.choice(route2[1:-1])\n\n        # Check feasibility after swap\n        new_route1 = route1.copy()\n        new_route2 = route2.copy()\n\n        # Replace cust1 in route1 with cust2\n        pos1 = np.where(new_route1 == cust1)[0][0]\n        new_route1[pos1] = cust2\n\n        # Replace cust2 in route2 with cust1\n        pos2 = np.where(new_route2 == cust2)[0][0]\n        new_route2[pos2] = cust1\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects a promising solution from the archive, identifies high-impact route segments, and applies a hybrid local search combining route segment swapping and capacity-aware edge insertion to generate a high-quality neighbor solution while respecting vehicle capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Identify the longest route (potential makespan reducer)\n    longest_route_idx = np.argmax([len(route) - 1 for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Find the most \"expensive\" segment in the longest route (high distance / demand ratio)\n    max_ratio = -1\n    best_segment = None\n    for i in range(1, len(longest_route) - 2):\n        u, v = longest_route[i], longest_route[i+1]\n        segment_distance = distance_matrix[u][v]\n        segment_demand = demand[v]\n        ratio = segment_distance / (segment_demand + 1e-6)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_segment = (i, i+1)\n\n    # Extract the segment and remove it from the route\n    segment = longest_route[best_segment[0]:best_segment[1]+1]\n    new_longest_route = np.concatenate([longest_route[:best_segment[0]], longest_route[best_segment[1]+1:]])\n\n    # Try to reinsert the segment into another route or create a new route\n    best_improvement = 0\n    best_insertion = None\n    for route_idx, route in enumerate(selected_solution):\n        if route_idx == longest_route_idx:\n            continue\n        # Check capacity constraint\n        if np.sum(demand[route[1:-1]]) + np.sum(demand[segment[1:-1]]) > capacity:\n            continue\n        # Find the best insertion point in this route\n        for i in range(1, len(route)):\n            u, v = route[i-1], segment[1]\n            w, x = segment[-2], route[i]\n            insertion_cost = distance_matrix[u][v] + distance_matrix[w][x] - distance_matrix[u][x]\n            if insertion_cost < best_improvement:\n                best_improvement = insertion_cost\n                best_insertion = (route_idx, i, segment)\n\n    # If no valid insertion found, try creating a new route\n    if best_insertion is None:\n        if np.sum(demand[segment[1:-1]]) <= capacity:\n            # Create new route and add to solution\n            new_route = np.array([0] + list(segment[1:-1]) + [0])\n            new_solution = list(selected_solution)\n            new_solution.append(new_route)\n            # Remove the segment from the original route\n            new_solution[longest_route_idx] = new_longest_route\n            return new_solution\n        else:\n            return selected_solution\n\n    # Apply the best insertion\n    route_idx, pos, segment = best_insertion\n    route = selected_solution[route_idx]\n    new_route = np.concatenate([route[:pos], segment, route[pos:]])\n    new_solution = list(selected_solution)\n    new_solution[route_idx] = new_route\n    new_solution[longest_route_idx] = new_longest_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7981832250557076,
            1.4143314063549042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Identify the longest route (potential makespan reducer)\n    longest_route_idx = np.argmax([len(route) - 1 for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx]\n\n    # Find the most \"expensive\" segment in the longest route (high distance / demand ratio)\n    max_ratio = -1\n    best_segment = None\n    for i in range(1, len(longest_route) - 2):\n        u, v = longest_route[i], longest_route[i+1]\n        segment_distance = distance_matrix[u][v]\n        segment_demand = demand[v]\n        ratio = segment_distance / (segment_demand + 1e-6)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_segment = (i, i+1)\n\n    # Extract the segment and remove it from the route\n    segment = longest_route[best_segment[0]:best_segment[1]+1]\n    new_longest_route = np.concatenate([longest_route[:best_segment[0]], longest_route[best_segment[1]+1:]])\n\n    # Try to reinsert the segment into another route or create a new route\n    best_improvement = 0\n    best_insertion = None\n    for route_idx, route in enumerate(selected_solution):\n        if route_idx == longest_route_idx:\n            continue\n        # Check capacity constraint\n        if np.sum(demand[route[1:-1]]) + np.sum(demand[segment[1:-1]]) > capacity:\n            continue\n        # Find the best insertion point in this route\n        for i in range(1, len(route)):\n            u, v = route[i-1], segment[1]\n            w, x = segment[-2], route[i]\n            insertion_cost = distance_matrix[u][v] + distance_matrix[w][x] - distance_matrix[u][x]\n            if insertion_cost < best_improvement:\n                best_improvement = insertion_cost\n                best_insertion = (route_idx, i, segment)\n\n    # If no valid insertion found, try creating a new route\n    if best_insertion is None:\n        if np.sum(demand[segment[1:-1]]) <= capacity:\n            # Create new route and add to solution\n            new_route = np.array([0] + list(segment[1:-1]) + [0])\n            new_solution = list(selected_solution)\n            new_solution.append(new_route)\n            # Remove the segment from the original route\n            new_solution[longest_route_idx] = new_longest_route\n            return new_solution\n        else:\n            return selected_solution\n\n    # Apply the best insertion\n    route_idx, pos, segment = best_insertion\n    route = selected_solution[route_idx]\n    new_route = np.concatenate([route[:pos], segment, route[pos:]])\n    new_solution = list(selected_solution)\n    new_solution[route_idx] = new_route\n    new_solution[longest_route_idx] = new_longest_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1] * 0.3 + x[1][0] * 0.7))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route splitting, customer reinsertion, and 2-opt*\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route Splitting (split long routes into two)\n        if len(route) > 5 and np.random.rand() < 0.3:\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                continue\n\n        # Step 2: Customer Reinsertion (reinsert a customer from another route)\n        if len(new_solution) > 1 and np.random.rand() < 0.4:\n            other_route_idx = np.random.choice([j for j in range(len(new_solution)) if j != i])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) <= 3:\n                continue\n\n            # Select a random customer from other_route and reinsert into current route\n            cust_pos = np.random.randint(1, len(other_route)-1)\n            customer = other_route[cust_pos]\n\n            # Find best insertion position in current route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                new_cost = (distance_matrix[route[pos-1], customer] +\n                           distance_matrix[customer, route[pos]] -\n                           distance_matrix[route[pos-1], route[pos]])\n\n                if new_cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                    best_cost = new_cost\n                    best_pos = pos\n\n            # Perform reinsertion\n            if best_cost < float('inf'):\n                new_route = np.insert(route, best_pos, customer)\n                new_solution[i] = new_route\n                new_solution[other_route_idx] = np.delete(other_route, cust_pos)\n                continue\n\n        # Step 3: 2-opt* (improved 2-opt with capacity check)\n        for _ in range(2):\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = route.copy()\n            new_route[a:b+1] = route[b:a-1:-1]  # Reverse segment\n\n            if (np.sum(demand[new_route[1:-1]]) <= capacity and\n                distance_matrix[route[a-1], route[a]] + distance_matrix[route[b], route[b+1]] >\n                distance_matrix[route[a-1], route[b]] + distance_matrix[route[a], route[b+1]]):\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5283398759151738,
            5.031997233629227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1] * 0.3 + x[1][0] * 0.7))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route splitting, customer reinsertion, and 2-opt*\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Route Splitting (split long routes into two)\n        if len(route) > 5 and np.random.rand() < 0.3:\n            split_pos = np.random.randint(2, len(route)-2)\n            new_route1 = np.concatenate((route[:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n                continue\n\n        # Step 2: Customer Reinsertion (reinsert a customer from another route)\n        if len(new_solution) > 1 and np.random.rand() < 0.4:\n            other_route_idx = np.random.choice([j for j in range(len(new_solution)) if j != i])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) <= 3:\n                continue\n\n            # Select a random customer from other_route and reinsert into current route\n            cust_pos = np.random.randint(1, len(other_route)-1)\n            customer = other_route[cust_pos]\n\n            # Find best insertion position in current route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                new_cost = (distance_matrix[route[pos-1], customer] +\n                           distance_matrix[customer, route[pos]] -\n                           distance_matrix[route[pos-1], route[pos]])\n\n                if new_cost < best_cost and np.sum(demand[new_route[1:-1]]) <= capacity:\n                    best_cost = new_cost\n                    best_pos = pos\n\n            # Perform reinsertion\n            if best_cost < float('inf'):\n                new_route = np.insert(route, best_pos, customer)\n                new_solution[i] = new_route\n                new_solution[other_route_idx] = np.delete(other_route, cust_pos)\n                continue\n\n        # Step 3: 2-opt* (improved 2-opt with capacity check)\n        for _ in range(2):\n            a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n            new_route = route.copy()\n            new_route[a:b+1] = route[b:a-1:-1]  # Reverse segment\n\n            if (np.sum(demand[new_route[1:-1]]) <= capacity and\n                distance_matrix[route[a-1], route[a]] + distance_matrix[route[b], route[b+1]] >\n                distance_matrix[route[a-1], route[b]] + distance_matrix[route[a], route[b+1]]):\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive with the highest total distance and applies a hybrid local search operator that combines route splitting, inter-route swaps, and demand-balanced route merging to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route is long enough\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Inter-route swaps (try to balance demands)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find customers to swap\n            if len(route1) > 2 and len(route2) > 2:\n                cust1 = random.choice(route1[1:-1])\n                cust2 = random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], [cust1]), [cust2], [0]])\n                new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], [cust2]), [cust1], [0]])\n\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Step 3: Demand-balanced route merging (merge small routes)\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n\n            # Check if merging would balance demands\n            if (len(route1) + len(route2) - 2 <= 10 and  # Prevent overly long routes\n                np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(i + 1)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.812285197127703,
            0.8853212296962738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route splitting (split long routes into two)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only split if route is long enough\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_point:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break\n\n    # Step 2: Inter-route swaps (try to balance demands)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find customers to swap\n            if len(route1) > 2 and len(route2) > 2:\n                cust1 = random.choice(route1[1:-1])\n                cust2 = random.choice(route2[1:-1])\n\n                # Check capacity constraints\n                new_route1 = np.concatenate([[0], np.setdiff1d(route1[1:-1], [cust1]), [cust2], [0]])\n                new_route2 = np.concatenate([[0], np.setdiff1d(route2[1:-1], [cust2]), [cust1], [0]])\n\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Step 3: Demand-balanced route merging (merge small routes)\n    if len(new_solution) > 1:\n        for i in range(len(new_solution) - 1):\n            route1 = new_solution[i]\n            route2 = new_solution[i + 1]\n\n            # Check if merging would balance demands\n            if (len(route1) + len(route2) - 2 <= 10 and  # Prevent overly long routes\n                np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(i + 1)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a promising solution from the archive using a tournament selection based on normalized objective values, then applies a hybrid local search combining route splitting, customer reallocation, and inter-route 2-opt to balance distance and makespan objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = archive[0][0].copy()\n    if len(archive) > 1:\n        # Normalize objectives\n        total_dists = np.array([sol[1][0] for sol in archive])\n        makespans = np.array([sol[1][1] for sol in archive])\n        total_dists_norm = (total_dists - total_dists.min()) / (total_dists.max() - total_dists.min() + 1e-8)\n        makespans_norm = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-8)\n        scores = total_dists_norm + makespans_norm\n        selected_idx = np.argmin(scores)\n        selected = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (if any route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only consider splitting if route has more than 2 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select a customer from route1\n            customer_pos = random.randint(1, len(route1)-2)\n            customer = route1[customer_pos]\n\n            # Check if moving to route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                # Add to route2 (insert at random position)\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Inter-route 2-opt with capacity check\n    if len(new_solution) > 1:\n        for _ in range(3):\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select segments from each route\n            seg1_start = random.randint(1, len(route1)-2)\n            seg1_end = random.randint(seg1_start, len(route1)-2)\n            seg2_start = random.randint(1, len(route2)-2)\n            seg2_end = random.randint(seg2_start, len(route2)-2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end+1]\n            seg2 = route2[seg2_start:seg2_end+1]\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:seg1_start]]) + np.sum(demand[seg2]) + np.sum(demand[route1[seg1_end+1:-1]]) <= capacity and\n                np.sum(demand[route2[1:seg2_start]]) + np.sum(demand[seg1]) + np.sum(demand[route2[seg2_end+1:-1]]) <= capacity):\n\n                # Create new routes\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    seg2,\n                    route1[seg1_end+1:]\n                ])\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    seg1,\n                    route2[seg2_end+1:]\n                ])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.45303921176352424,
            1.6200445294380188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = archive[0][0].copy()\n    if len(archive) > 1:\n        # Normalize objectives\n        total_dists = np.array([sol[1][0] for sol in archive])\n        makespans = np.array([sol[1][1] for sol in archive])\n        total_dists_norm = (total_dists - total_dists.min()) / (total_dists.max() - total_dists.min() + 1e-8)\n        makespans_norm = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-8)\n        scores = total_dists_norm + makespans_norm\n        selected_idx = np.argmin(scores)\n        selected = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (if any route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only consider splitting if route has more than 2 customers\n                split_pos = random.randint(1, len(route)-2)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 3 or len(route2) <= 3:\n                continue\n\n            # Select a customer from route1\n            customer_pos = random.randint(1, len(route1)-2)\n            customer = route1[customer_pos]\n\n            # Check if moving to route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove from route1\n                new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                # Add to route2 (insert at random position)\n                insert_pos = random.randint(1, len(route2)-1)\n                new_route2 = np.concatenate([route2[:insert_pos], [customer], route2[insert_pos:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 3: Inter-route 2-opt with capacity check\n    if len(new_solution) > 1:\n        for _ in range(3):\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) <= 2 or len(route2) <= 2:\n                continue\n\n            # Select segments from each route\n            seg1_start = random.randint(1, len(route1)-2)\n            seg1_end = random.randint(seg1_start, len(route1)-2)\n            seg2_start = random.randint(1, len(route2)-2)\n            seg2_end = random.randint(seg2_start, len(route2)-2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end+1]\n            seg2 = route2[seg2_start:seg2_end+1]\n\n            # Check capacity constraints\n            if (np.sum(demand[route1[1:seg1_start]]) + np.sum(demand[seg2]) + np.sum(demand[route1[seg1_end+1:-1]]) <= capacity and\n                np.sum(demand[route2[1:seg2_start]]) + np.sum(demand[seg1]) + np.sum(demand[route2[seg2_end+1:-1]]) <= capacity):\n\n                # Create new routes\n                new_route1 = np.concatenate([\n                    route1[:seg1_start],\n                    seg2,\n                    route1[seg1_end+1:]\n                ])\n                new_route2 = np.concatenate([\n                    route2[:seg2_start],\n                    seg1,\n                    route2[seg2_end+1:]\n                ])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    target_route = new_solution[longest_route_idx]\n\n    # Step 3: Apply a hybrid local search operator: Route Splitting with Customer Swapping\n    if len(target_route) > 3:  # Ensure route can be split\n        split_pos = len(target_route) // 2\n        # Split the route into two parts\n        part1 = target_route[:split_pos + 1]\n        part2 = target_route[split_pos:]\n        # Swap last customer of part1 with first customer of part2 (if feasible)\n        if np.sum(demand[part1[1:-1]]) + demand[part2[1]] <= capacity and np.sum(demand[part2[1:-1]]) + demand[part1[-2]] <= capacity:\n            part1[-1], part2[1] = part2[1], part1[-1]\n        # Update the solution\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n\n    # Step 4: Ensure feasibility (capacity constraint)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity violated, revert to original route\n            new_solution = selected_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8148526152941412,
            0.5042790174484253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    target_route = new_solution[longest_route_idx]\n\n    # Step 3: Apply a hybrid local search operator: Route Splitting with Customer Swapping\n    if len(target_route) > 3:  # Ensure route can be split\n        split_pos = len(target_route) // 2\n        # Split the route into two parts\n        part1 = target_route[:split_pos + 1]\n        part2 = target_route[split_pos:]\n        # Swap last customer of part1 with first customer of part2 (if feasible)\n        if np.sum(demand[part1[1:-1]]) + demand[part2[1]] <= capacity and np.sum(demand[part2[1:-1]]) + demand[part1[-2]] <= capacity:\n            part1[-1], part2[1] = part2[1], part1[-1]\n        # Update the solution\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n\n    # Step 4: Ensure feasibility (capacity constraint)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity violated, revert to original route\n            new_solution = selected_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{A hybrid local search operator that combines route merging, customer reallocation, and partial 2-opt moves to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - x[1][1])[0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge short routes and reallocate customers\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution.pop(shortest_route_idx)\n\n        # Try to merge with another route\n        best_merge = None\n        best_merge_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            # Check all possible insertion points\n            for j in range(1, len(route)):\n                # Insert all customers from shortest_route into route at position j\n                temp_route = np.concatenate([route[:j], shortest_route[1:-1], route[j:]])\n                # Check capacity constraint\n                if sum(demand[temp_route]) <= capacity:\n                    # Calculate cost increase\n                    cost = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(len(temp_route)-1))\n                    if cost < best_merge_cost:\n                        best_merge_cost = cost\n                        best_merge = (i, temp_route)\n\n        if best_merge is not None:\n            i, merged_route = best_merge\n            new_solution[i] = merged_route\n        else:\n            # If no merge possible, reinsert the shortest route back\n            new_solution.insert(shortest_route_idx, shortest_route)\n\n    # Apply partial 2-opt to the longest route\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a random segment to optimize (at least 3 customers)\n        if len(longest_route) > 4:\n            start = np.random.randint(1, len(longest_route) - 3)\n            end = np.random.randint(start + 2, len(longest_route) - 1)\n\n            # Try reversing the segment\n            reversed_segment = longest_route[start:end+1][::-1]\n            candidate_route = np.concatenate([longest_route[:start], reversed_segment, longest_route[end+1:]])\n\n            # Check capacity constraint\n            if sum(demand[candidate_route]) <= capacity:\n                # Calculate cost change\n                old_cost = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(len(longest_route)-1))\n                new_cost = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n\n                if new_cost < old_cost:\n                    new_solution[longest_route_idx] = candidate_route\n\n    return new_solution\n\n",
        "score": [
            -0.47787351387872434,
            3.84738352894783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - x[1][1])[0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge short routes and reallocate customers\n    if len(new_solution) > 1:\n        # Find the shortest route\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution.pop(shortest_route_idx)\n\n        # Try to merge with another route\n        best_merge = None\n        best_merge_cost = float('inf')\n\n        for i, route in enumerate(new_solution):\n            # Check all possible insertion points\n            for j in range(1, len(route)):\n                # Insert all customers from shortest_route into route at position j\n                temp_route = np.concatenate([route[:j], shortest_route[1:-1], route[j:]])\n                # Check capacity constraint\n                if sum(demand[temp_route]) <= capacity:\n                    # Calculate cost increase\n                    cost = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(len(temp_route)-1))\n                    if cost < best_merge_cost:\n                        best_merge_cost = cost\n                        best_merge = (i, temp_route)\n\n        if best_merge is not None:\n            i, merged_route = best_merge\n            new_solution[i] = merged_route\n        else:\n            # If no merge possible, reinsert the shortest route back\n            new_solution.insert(shortest_route_idx, shortest_route)\n\n    # Apply partial 2-opt to the longest route\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a random segment to optimize (at least 3 customers)\n        if len(longest_route) > 4:\n            start = np.random.randint(1, len(longest_route) - 3)\n            end = np.random.randint(start + 2, len(longest_route) - 1)\n\n            # Try reversing the segment\n            reversed_segment = longest_route[start:end+1][::-1]\n            candidate_route = np.concatenate([longest_route[:start], reversed_segment, longest_route[end+1:]])\n\n            # Check capacity constraint\n            if sum(demand[candidate_route]) <= capacity:\n                # Calculate cost change\n                old_cost = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(len(longest_route)-1))\n                new_cost = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n\n                if new_cost < old_cost:\n                    new_solution[longest_route_idx] = candidate_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring solutions with lower makespan and total distance, then applies a hybrid local search combining route segmentation and customer reallocation to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Split the route into two segments at a random customer node\n        if len(selected_route) > 3:\n            split_pos = random.randint(1, len(selected_route) - 2)\n            segment1 = selected_route[:split_pos + 1]\n            segment2 = selected_route[split_pos:]\n\n            # Check if segments are feasible\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                # Try to reallocate customers between segments\n                for i in range(1, len(segment1) - 1):\n                    for j in range(1, len(segment2) - 1):\n                        # Swap customers if feasible\n                        new_segment1 = np.concatenate([segment1[:i], [segment2[j]], segment1[i+1:]])\n                        new_segment2 = np.concatenate([segment2[:j], [segment1[i]], segment2[j+1:]])\n\n                        if (np.sum(demand[new_segment1[1:-1]]) <= capacity and\n                            np.sum(demand[new_segment2[1:-1]]) <= capacity):\n                            # Update the solution\n                            new_solution[route_idx] = new_segment1\n                            if len(new_segment2) > 2:\n                                new_solution.insert(route_idx + 1, new_segment2)\n                            break\n\n    # Randomly try to merge two routes if they can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.4616708851936705,
            1.3746741116046906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Route segmentation and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Split the route into two segments at a random customer node\n        if len(selected_route) > 3:\n            split_pos = random.randint(1, len(selected_route) - 2)\n            segment1 = selected_route[:split_pos + 1]\n            segment2 = selected_route[split_pos:]\n\n            # Check if segments are feasible\n            if np.sum(demand[segment1[1:-1]]) <= capacity and np.sum(demand[segment2[1:-1]]) <= capacity:\n                # Try to reallocate customers between segments\n                for i in range(1, len(segment1) - 1):\n                    for j in range(1, len(segment2) - 1):\n                        # Swap customers if feasible\n                        new_segment1 = np.concatenate([segment1[:i], [segment2[j]], segment1[i+1:]])\n                        new_segment2 = np.concatenate([segment2[:j], [segment1[i]], segment2[j+1:]])\n\n                        if (np.sum(demand[new_segment1[1:-1]]) <= capacity and\n                            np.sum(demand[new_segment2[1:-1]]) <= capacity):\n                            # Update the solution\n                            new_solution[route_idx] = new_segment1\n                            if len(new_segment2) > 2:\n                                new_solution.insert(route_idx + 1, new_segment2)\n                            break\n\n    # Randomly try to merge two routes if they can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{A novel hybrid local search operator combines route segmentation, inter-route insertion, and capacity-aware route merging to intelligently balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    total_makespan = sum(makespans)\n    if total_makespan == 0:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        probs = [1.0 / (m + 0.1) for m in makespans]\n        probs = [p / sum(probs) for p in probs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + inter-route insertion + merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge or split\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Try inter-route insertion (move a segment from one route to another)\n        if len(route1) > 3 and len(route2) > 2:\n            # Select a random segment from route1 (excluding depot)\n            seg_start = random.randint(1, len(route1)-3)\n            seg_end = random.randint(seg_start+1, len(route1)-2)\n            segment = route1[seg_start:seg_end]\n            seg_demand = sum(demand[segment])\n\n            # Check if insertion is feasible in route2\n            if seg_demand <= capacity - sum(demand[route2]):\n                # Find best insertion point in route2\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    cost = (distance_matrix[route2[i-1], segment[0]] +\n                            distance_matrix[segment[-1], route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                if best_pos != -1:\n                    # Perform insertion\n                    new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n                    new_solution[route1_idx] = np.concatenate([route1[:seg_start], route1[seg_end:]])\n\n        # Step 3: Try route merging if insertion didn't happen\n        if len(new_solution[route1_idx]) > 2 and len(new_solution[route2_idx]) > 2:\n            # Check if merging is feasible\n            if sum(demand[new_solution[route1_idx][1:-1]]) + sum(demand[new_solution[route2_idx][1:-1]]) <= capacity:\n                # Try to merge the two routes\n                merged_route = np.concatenate([\n                    new_solution[route1_idx][:-1],\n                    new_solution[route2_idx][1:]\n                ])\n                # Remove the merged routes and add the new one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Step 4: Randomly select a route for 2-opt improvement (but with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select two random edges to reverse\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n            # Check if reversal is feasible\n            if sum(demand[route[i:j]]) == sum(demand[route[i:j][::-1]]):\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.4752153059414023,
            0.9388753473758698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    total_makespan = sum(makespans)\n    if total_makespan == 0:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        probs = [1.0 / (m + 0.1) for m in makespans]\n        probs = [p / sum(probs) for p in probs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + inter-route insertion + merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge or split\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Try inter-route insertion (move a segment from one route to another)\n        if len(route1) > 3 and len(route2) > 2:\n            # Select a random segment from route1 (excluding depot)\n            seg_start = random.randint(1, len(route1)-3)\n            seg_end = random.randint(seg_start+1, len(route1)-2)\n            segment = route1[seg_start:seg_end]\n            seg_demand = sum(demand[segment])\n\n            # Check if insertion is feasible in route2\n            if seg_demand <= capacity - sum(demand[route2]):\n                # Find best insertion point in route2\n                best_pos = -1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    cost = (distance_matrix[route2[i-1], segment[0]] +\n                            distance_matrix[segment[-1], route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                if best_pos != -1:\n                    # Perform insertion\n                    new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n                    new_solution[route1_idx] = np.concatenate([route1[:seg_start], route1[seg_end:]])\n\n        # Step 3: Try route merging if insertion didn't happen\n        if len(new_solution[route1_idx]) > 2 and len(new_solution[route2_idx]) > 2:\n            # Check if merging is feasible\n            if sum(demand[new_solution[route1_idx][1:-1]]) + sum(demand[new_solution[route2_idx][1:-1]]) <= capacity:\n                # Try to merge the two routes\n                merged_route = np.concatenate([\n                    new_solution[route1_idx][:-1],\n                    new_solution[route2_idx][1:]\n                ])\n                # Remove the merged routes and add the new one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Step 4: Randomly select a route for 2-opt improvement (but with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Select two random edges to reverse\n            i = random.randint(1, len(route)-3)\n            j = random.randint(i+1, len(route)-2)\n            # Check if reversal is feasible\n            if sum(demand[route[i:j]]) == sum(demand[route[i:j][::-1]]):\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted balance between total distance and makespan, then applies a hybrid local search combining route segment swapping and demand-aware insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to create a weighted selection\n        distances = np.array([s[1][0] for s in archive])\n        makespans = np.array([s[1][1] for s in archive])\n\n        # Normalize objectives\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n\n        # Avoid division by zero\n        if max_dist == min_dist:\n            normalized_dist = np.ones_like(distances)\n        else:\n            normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n        if max_make == min_make:\n            normalized_make = np.ones_like(makespans)\n        else:\n            normalized_make = (makespans - min_make) / (max_make - min_make)\n\n        # Weighted selection (prioritize solutions with better balance)\n        weights = 0.6 * normalized_dist + 0.4 * normalized_make\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route segment swapping between two routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 3 and len(route2) > 3:\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Check feasibility\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Demand-aware insertion (move a customer to a different route if beneficial)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least one customer to move\n            # Select a random customer to move (excluding depot)\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n\n            # Try inserting into a different route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n\n                # Find insertion position that minimizes total distance\n                min_increase = float('inf')\n                best_pos = -1\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos - 1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Check if insertion is feasible\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer)\n                    if is_feasible(new_target_route, demand, capacity):\n                        # Remove customer from original route\n                        new_route = np.delete(route, cust_idx)\n                        if is_feasible(new_route, demand, capacity):\n                            new_solution[target_route_idx] = new_target_route\n                            new_solution[route_idx] = new_route\n                            break  # Only move one customer per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.7504525430405982,
            10.135554015636444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to create a weighted selection\n        distances = np.array([s[1][0] for s in archive])\n        makespans = np.array([s[1][1] for s in archive])\n\n        # Normalize objectives\n        min_dist, max_dist = np.min(distances), np.max(distances)\n        min_make, max_make = np.min(makespans), np.max(makespans)\n\n        # Avoid division by zero\n        if max_dist == min_dist:\n            normalized_dist = np.ones_like(distances)\n        else:\n            normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n        if max_make == min_make:\n            normalized_make = np.ones_like(makespans)\n        else:\n            normalized_make = (makespans - min_make) / (max_make - min_make)\n\n        # Weighted selection (prioritize solutions with better balance)\n        weights = 0.6 * normalized_dist + 0.4 * normalized_make\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route, demand, capacity):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    # Step 1: Route segment swapping between two routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 3 and len(route2) > 3:\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n            new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n            # Check feasibility\n            if is_feasible(new_route1, demand, capacity) and is_feasible(new_route2, demand, capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Demand-aware insertion (move a customer to a different route if beneficial)\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least one customer to move\n            # Select a random customer to move (excluding depot)\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n\n            # Try inserting into a different route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx == route_idx:\n                    continue\n                target_route = new_solution[target_route_idx]\n\n                # Find insertion position that minimizes total distance\n                min_increase = float('inf')\n                best_pos = -1\n\n                for pos in range(1, len(target_route)):\n                    # Calculate distance increase\n                    prev_node = target_route[pos - 1]\n                    next_node = target_route[pos]\n                    increase = (distance_matrix[prev_node][customer] +\n                               distance_matrix[customer][next_node] -\n                               distance_matrix[prev_node][next_node])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Check if insertion is feasible\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer)\n                    if is_feasible(new_target_route, demand, capacity):\n                        # Remove customer from original route\n                        new_route = np.delete(route, cust_idx)\n                        if is_feasible(new_route, demand, capacity):\n                            new_solution[target_route_idx] = new_target_route\n                            new_solution[route_idx] = new_route\n                            break  # Only move one customer per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify the longest route (highest makespan)\n    longest_route_idx = max(range(len(selected_solution)), key=lambda i: distance_matrix[selected_solution[i][0], selected_solution[i][-1]])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Split the longest route into two parts at a demand-aware split point\n    total_demand = sum(demand[node] for node in longest_route[1:-1])\n    half_demand = total_demand / 2\n    cumulative_demand = 0\n    split_pos = 1\n    for i in range(1, len(longest_route)-1):\n        cumulative_demand += demand[longest_route[i]]\n        if cumulative_demand >= half_demand:\n            split_pos = i\n            break\n\n    # Step 4: Create two new routes\n    route1 = np.concatenate(([0], longest_route[1:split_pos+1], [0]))\n    route2 = np.concatenate(([0], longest_route[split_pos+1:-1], [0]))\n\n    # Step 5: Check capacity feasibility and adjust if needed\n    if sum(demand[node] for node in route1[1:-1]) > capacity:\n        # If route1 exceeds capacity, try to relocate nodes to route2\n        for node in route1[1:-1][::-1]:\n            if sum(demand[node] for node in route2[1:-1]) + demand[node] <= capacity:\n                route1 = np.array([n for n in route1 if n != node])\n                route2 = np.insert(route2, -1, node)\n            if sum(demand[node] for node in route1[1:-1]) <= capacity:\n                break\n\n    # Step 6: Replace the original route with the two new routes\n    new_solution = selected_solution[:longest_route_idx] + [route1, route2] + selected_solution[longest_route_idx+1:]\n\n    # Step 7: Optionally apply a distance-aware 2-opt on the new routes\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                if distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]] > \\\n                   distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]:\n                    route[i:j+1] = route[j:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.2931634825409558,
            8.336725652217865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify the longest route (highest makespan)\n    longest_route_idx = max(range(len(selected_solution)), key=lambda i: distance_matrix[selected_solution[i][0], selected_solution[i][-1]])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Step 3: Split the longest route into two parts at a demand-aware split point\n    total_demand = sum(demand[node] for node in longest_route[1:-1])\n    half_demand = total_demand / 2\n    cumulative_demand = 0\n    split_pos = 1\n    for i in range(1, len(longest_route)-1):\n        cumulative_demand += demand[longest_route[i]]\n        if cumulative_demand >= half_demand:\n            split_pos = i\n            break\n\n    # Step 4: Create two new routes\n    route1 = np.concatenate(([0], longest_route[1:split_pos+1], [0]))\n    route2 = np.concatenate(([0], longest_route[split_pos+1:-1], [0]))\n\n    # Step 5: Check capacity feasibility and adjust if needed\n    if sum(demand[node] for node in route1[1:-1]) > capacity:\n        # If route1 exceeds capacity, try to relocate nodes to route2\n        for node in route1[1:-1][::-1]:\n            if sum(demand[node] for node in route2[1:-1]) + demand[node] <= capacity:\n                route1 = np.array([n for n in route1 if n != node])\n                route2 = np.insert(route2, -1, node)\n            if sum(demand[node] for node in route1[1:-1]) <= capacity:\n                break\n\n    # Step 6: Replace the original route with the two new routes\n    new_solution = selected_solution[:longest_route_idx] + [route1, route2] + selected_solution[longest_route_idx+1:]\n\n    # Step 7: Optionally apply a distance-aware 2-opt on the new routes\n    for route in new_solution:\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                if distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]] > \\\n                   distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]:\n                    route[i:j+1] = route[j:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.choice(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Identify customers in the selected route (excluding depots)\n    customers_in_route = selected_route[1:-1]\n\n    # If the route has only depot, skip modification\n    if len(customers_in_route) < 2:\n        return base_solution\n\n    # Randomly select two customers in the route to swap\n    i, j = np.random.choice(len(customers_in_route), 2, replace=False)\n    customer_i, customer_j = customers_in_route[i], customers_in_route[j]\n\n    # Check if swapping these customers maintains capacity constraints\n    # Calculate total demand in the route excluding customer_i and customer_j\n    total_demand = np.sum(demand[customers_in_route])\n    total_demand -= demand[customer_i] + demand[customer_j]\n\n    # Check if adding customer_j and customer_i back in swapped positions is feasible\n    if (total_demand + demand[customer_j] <= capacity) and (total_demand + demand[customer_i] <= capacity):\n        # Perform the swap\n        selected_route[1:-1][i], selected_route[1:-1][j] = customer_j, customer_i\n        base_solution[route_idx] = selected_route\n\n    # Randomly select another route to attempt a cross-route swap\n    other_route_idx = np.random.choice(len(base_solution))\n    if other_route_idx != route_idx:\n        other_route = base_solution[other_route_idx].copy()\n        other_customers = other_route[1:-1]\n\n        if len(other_customers) > 0:\n            # Select a random customer from the other route\n            k = np.random.choice(len(other_customers))\n            customer_k = other_customers[k]\n\n            # Check if moving customer_k to the selected route is feasible\n            total_demand_selected = np.sum(demand[selected_route[1:-1]])\n            if total_demand_selected + demand[customer_k] <= capacity:\n                # Remove customer_k from other route and add to selected route\n                other_route = np.delete(other_route, k + 1)\n                selected_route = np.insert(selected_route, -1, customer_k)\n\n                # Update the solution\n                base_solution[route_idx] = selected_route\n                base_solution[other_route_idx] = other_route\n\n    return base_solution\n\n",
        "score": [
            -0.49450433543951755,
            0.9189350008964539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.choice(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Identify customers in the selected route (excluding depots)\n    customers_in_route = selected_route[1:-1]\n\n    # If the route has only depot, skip modification\n    if len(customers_in_route) < 2:\n        return base_solution\n\n    # Randomly select two customers in the route to swap\n    i, j = np.random.choice(len(customers_in_route), 2, replace=False)\n    customer_i, customer_j = customers_in_route[i], customers_in_route[j]\n\n    # Check if swapping these customers maintains capacity constraints\n    # Calculate total demand in the route excluding customer_i and customer_j\n    total_demand = np.sum(demand[customers_in_route])\n    total_demand -= demand[customer_i] + demand[customer_j]\n\n    # Check if adding customer_j and customer_i back in swapped positions is feasible\n    if (total_demand + demand[customer_j] <= capacity) and (total_demand + demand[customer_i] <= capacity):\n        # Perform the swap\n        selected_route[1:-1][i], selected_route[1:-1][j] = customer_j, customer_i\n        base_solution[route_idx] = selected_route\n\n    # Randomly select another route to attempt a cross-route swap\n    other_route_idx = np.random.choice(len(base_solution))\n    if other_route_idx != route_idx:\n        other_route = base_solution[other_route_idx].copy()\n        other_customers = other_route[1:-1]\n\n        if len(other_customers) > 0:\n            # Select a random customer from the other route\n            k = np.random.choice(len(other_customers))\n            customer_k = other_customers[k]\n\n            # Check if moving customer_k to the selected route is feasible\n            total_demand_selected = np.sum(demand[selected_route[1:-1]])\n            if total_demand_selected + demand[customer_k] <= capacity:\n                # Remove customer_k from other route and add to selected route\n                other_route = np.delete(other_route, k + 1)\n                selected_route = np.insert(selected_route, -1, customer_k)\n\n                # Update the solution\n                base_solution[route_idx] = selected_route\n                base_solution[other_route_idx] = other_route\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split the route into two and reinsert customers using a nearest neighbor approach\n        if len(selected_route) > 3:  # Ensure the route has enough nodes to split\n            split_pos = np.random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos + 1:]\n\n            # Reinsert nodes from part2 into part1 using nearest neighbor\n            unassigned = part2[1:-1]\n            np.random.shuffle(unassigned)\n            for node in unassigned:\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Insert node at position i\n                    temp_route = np.insert(part1, i, node)\n                    cost = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route) - 1))\n                    if cost < best_cost and sum(demand[temp_route[1:-1]]) <= capacity:\n                        best_cost = cost\n                        best_pos = i\n                part1 = np.insert(part1, best_pos, node)\n\n            # Update the route\n            new_solution[route_idx] = part1\n\n    return new_solution\n\n",
        "score": [
            -0.8265622011964413,
            1.6235458254814148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split the route into two and reinsert customers using a nearest neighbor approach\n        if len(selected_route) > 3:  # Ensure the route has enough nodes to split\n            split_pos = np.random.randint(1, len(selected_route) - 2)\n            part1 = selected_route[:split_pos + 1]\n            part2 = selected_route[split_pos + 1:]\n\n            # Reinsert nodes from part2 into part1 using nearest neighbor\n            unassigned = part2[1:-1]\n            np.random.shuffle(unassigned)\n            for node in unassigned:\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(part1)):\n                    # Insert node at position i\n                    temp_route = np.insert(part1, i, node)\n                    cost = sum(distance_matrix[temp_route[j], temp_route[j+1]] for j in range(len(temp_route) - 1))\n                    if cost < best_cost and sum(demand[temp_route[1:-1]]) <= capacity:\n                        best_cost = cost\n                        best_pos = i\n                part1 = np.insert(part1, best_pos, node)\n\n            # Update the route\n            new_solution[route_idx] = part1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The algorithm selects a solution from the archive using a weighted random selection based on the inverse of the sum of normalized objective values, then applies a hybrid local search combining route splitting, intra-route 2-opt, and inter-route insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 1:\n        normalized = (objectives - np.min(objectives)) / (np.max(objectives) - np.min(objectives) + 1e-6)\n        weights = 1.0 / (normalized + 1e-6)\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        # Try route splitting\n        route_to_split = np.random.choice(len(new_solution))\n        split_point = np.random.randint(2, len(new_solution[route_to_split]) - 1)\n        new_route1 = new_solution[route_to_split][:split_point + 1]\n        new_route2 = new_solution[route_to_split][split_point:]\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_to_split] = new_route1\n            new_solution.append(new_route2)\n\n    # Apply intra-route 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:\n            a, b = sorted(np.random.choice(range(1, len(route)-2), 2, replace=False))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Apply inter-route insertion\n    if len(new_solution) > 1:\n        from_route_idx = np.random.choice(len(new_solution))\n        to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n\n        from_route = new_solution[from_route_idx]\n        to_route = new_solution[to_route_idx]\n\n        if len(from_route) > 3:\n            node_pos = np.random.randint(1, len(from_route)-1)\n            node = from_route[node_pos]\n\n            # Find best insertion point in to_route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(to_route)):\n                new_route = np.concatenate([to_route[:pos], [node], to_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_cost < float('inf'):\n                new_route = np.concatenate([to_route[:best_pos], [node], to_route[best_pos:]])\n                new_solution[to_route_idx] = new_route\n                new_solution[from_route_idx] = np.concatenate([from_route[:node_pos], from_route[node_pos+1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.527812724909441,
            2.082060217857361
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 1:\n        normalized = (objectives - np.min(objectives)) / (np.max(objectives) - np.min(objectives) + 1e-6)\n        weights = 1.0 / (normalized + 1e-6)\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        # Try route splitting\n        route_to_split = np.random.choice(len(new_solution))\n        split_point = np.random.randint(2, len(new_solution[route_to_split]) - 1)\n        new_route1 = new_solution[route_to_split][:split_point + 1]\n        new_route2 = new_solution[route_to_split][split_point:]\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route_to_split] = new_route1\n            new_solution.append(new_route2)\n\n    # Apply intra-route 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:\n            a, b = sorted(np.random.choice(range(1, len(route)-2), 2, replace=False))\n            new_route = np.concatenate([route[:a], route[b:a-1:-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n\n    # Apply inter-route insertion\n    if len(new_solution) > 1:\n        from_route_idx = np.random.choice(len(new_solution))\n        to_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n\n        from_route = new_solution[from_route_idx]\n        to_route = new_solution[to_route_idx]\n\n        if len(from_route) > 3:\n            node_pos = np.random.randint(1, len(from_route)-1)\n            node = from_route[node_pos]\n\n            # Find best insertion point in to_route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(to_route)):\n                new_route = np.concatenate([to_route[:pos], [node], to_route[pos:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[new_route[pos-1], node] +\n                            distance_matrix[node, new_route[pos+1]] -\n                            distance_matrix[new_route[pos-1], new_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_cost < float('inf'):\n                new_route = np.concatenate([to_route[:best_pos], [node], to_route[best_pos:]])\n                new_solution[to_route_idx] = new_route\n                new_solution[from_route_idx] = np.concatenate([from_route[:node_pos], from_route[node_pos+1:]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route balancing and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 1: Randomly select a segment to reallocate\n        start_idx = np.random.randint(1, len(route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(route) - 1)\n        segment = route[start_idx:end_idx]\n\n        # Step 2: Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Step 3: Find the best target route to insert the segment\n        best_insertion = None\n        min_increase = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:  # Skip the same route\n                continue\n            target_route = new_solution[j]\n\n            # Check capacity constraint\n            if np.sum(demand[target_route]) + segment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions in the target route\n            for k in range(1, len(target_route)):\n                # Insert segment into target_route at position k\n                temp_route = np.concatenate([target_route[:k], segment, target_route[k:]])\n\n                # Calculate the increase in total distance\n                old_dist = distance_matrix[target_route[k-1]][target_route[k]]\n                new_dist = (distance_matrix[target_route[k-1]][segment[0]] +\n                             distance_matrix[segment[-1]][target_route[k]])\n                increase = new_dist - old_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (j, k, temp_route)\n\n        # Perform the best insertion if found\n        if best_insertion is not None:\n            j, k, temp_route = best_insertion\n            new_solution[j] = temp_route\n            new_solution[i] = np.concatenate([route[:start_idx], route[end_idx:]])\n\n    # Step 4: Check for empty routes and remove them\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4259888508781938,
            7.006680876016617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine route balancing and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 1: Randomly select a segment to reallocate\n        start_idx = np.random.randint(1, len(route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(route) - 1)\n        segment = route[start_idx:end_idx]\n\n        # Step 2: Calculate total demand of the segment\n        segment_demand = np.sum(demand[segment])\n\n        # Step 3: Find the best target route to insert the segment\n        best_insertion = None\n        min_increase = float('inf')\n\n        for j in range(len(new_solution)):\n            if i == j:  # Skip the same route\n                continue\n            target_route = new_solution[j]\n\n            # Check capacity constraint\n            if np.sum(demand[target_route]) + segment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions in the target route\n            for k in range(1, len(target_route)):\n                # Insert segment into target_route at position k\n                temp_route = np.concatenate([target_route[:k], segment, target_route[k:]])\n\n                # Calculate the increase in total distance\n                old_dist = distance_matrix[target_route[k-1]][target_route[k]]\n                new_dist = (distance_matrix[target_route[k-1]][segment[0]] +\n                             distance_matrix[segment[-1]][target_route[k]])\n                increase = new_dist - old_dist\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (j, k, temp_route)\n\n        # Perform the best insertion if found\n        if best_insertion is not None:\n            j, k, temp_route = best_insertion\n            new_solution[j] = temp_route\n            new_solution[i] = np.concatenate([route[:start_idx], route[end_idx:]])\n\n    # Step 4: Check for empty routes and remove them\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The algorithm selects a solution with the largest makespan from the archive, then applies a hybrid local search combining route-shaking and partial 2-opt to balance distance and makespan, ensuring feasibility by checking capacity constraints at each step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-shaking + Partial 2-opt\n    for _ in range(3):  # Repeat for diversification\n        # Step 1: Route-shaking - Randomly select a route and perturb it\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Ensure route has enough nodes to shake\n                # Select a random segment and reverse it\n                start = random.randint(1, len(route) - 3)\n                end = random.randint(start + 1, len(route) - 2)\n                shaken_segment = route[start:end][::-1]\n                new_route = np.concatenate([route[:start], shaken_segment, route[end:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 2: Partial 2-opt - Apply to one route\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                # Select two random edges and swap them\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n                if j - i > 1:  # Ensure valid swap\n                    new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7488325049314978,
            0.7397048473358154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Route-shaking + Partial 2-opt\n    for _ in range(3):  # Repeat for diversification\n        # Step 1: Route-shaking - Randomly select a route and perturb it\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Ensure route has enough nodes to shake\n                # Select a random segment and reverse it\n                start = random.randint(1, len(route) - 3)\n                end = random.randint(start + 1, len(route) - 2)\n                shaken_segment = route[start:end][::-1]\n                new_route = np.concatenate([route[:start], shaken_segment, route[end:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Step 2: Partial 2-opt - Apply to one route\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                # Select two random edges and swap them\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n                if j - i > 1:  # Ensure valid swap\n                    new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The algorithm selects a solution from the archive with a high potential for improvement by prioritizing those with the largest makespan and total distance, then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-constrained swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # 1. Route Splitting: Split a long route into two shorter routes\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_split_cost = float('inf')\n        best_split_point = -1\n        for i in range(1, len(longest_route)-1):\n            cost_before = sum(distance_matrix[longest_route[j], longest_route[j+1]] for j in range(i-1))\n            cost_after = sum(distance_matrix[longest_route[j], longest_route[j+1]] for j in range(i, len(longest_route)-1))\n            total_cost = cost_before + cost_after + distance_matrix[0, longest_route[i]]\n            if total_cost < min_split_cost:\n                min_split_cost = total_cost\n                best_split_point = i\n\n        if best_split_point != -1:\n            # Split the route\n            route1 = longest_route[:best_split_point+1]\n            route2 = [0] + longest_route[best_split_point:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n\n    # 2. Demand-Aware Relocation: Relocate a customer to another route if it improves makespan\n    # Find the route with the highest makespan\n    makespans = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    worst_route_idx = np.argmax(makespans)\n    worst_route = new_solution[worst_route_idx]\n\n    if len(worst_route) > 3:  # Ensure there are customers to relocate\n        # Find the customer with the highest demand in the worst route\n        customers = worst_route[1:-1]\n        customer_demands = [demand[node] for node in customers]\n        max_demand_idx = np.argmax(customer_demands)\n        customer_to_relocate = customers[max_demand_idx]\n\n        # Find the best insertion point in another route\n        best_insert_route_idx = -1\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == worst_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[node] for node in route[1:-1])\n\n            if current_demand + demand[customer_to_relocate] > capacity:\n                continue\n\n            for j in range(1, len(route)):\n                # Calculate insertion cost\n                cost_before = distance_matrix[route[j-1], route[j]]\n                cost_after = distance_matrix[customer_to_relocate, route[j]] + distance_matrix[route[j-1], customer_to_relocate]\n\n                if cost_after < cost_before:\n                    if cost_after < best_insert_cost:\n                        best_insert_cost = cost_after\n                        best_insert_route_idx = i\n                        best_insert_pos = j\n\n        if best_insert_route_idx != -1:\n            # Perform relocation\n            worst_route = np.delete(worst_route, max_demand_idx + 1)  # +1 because of leading 0\n            new_solution[worst_route_idx] = worst_route\n\n            insert_route = new_solution[best_insert_route_idx]\n            insert_route = np.insert(insert_route, best_insert_pos, customer_to_relocate)\n            new_solution[best_insert_route_idx] = insert_route\n\n    # 3. Capacity-Constrained Swap: Swap two customers between routes if it improves total distance\n    if len(new_solution) > 1:\n        # Select two different routes\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[0], route_indices[1]\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a customer from each route\n            customer1 = random.choice(route1[1:-1])\n            customer2 = random.choice(route2[1:-1])\n\n            # Calculate new demands\n            demand1 = sum(demand[node] for node in route1[1:-1]) - demand[customer1] + demand[customer2]\n            demand2 = sum(demand[node] for node in route2[1:-1]) - demand[customer2] + demand[customer1]\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Find positions in route1 and route2\n                pos1 = np.where(route1 == customer1)[0][0]\n                pos2 = np.where(route2 == customer2)[0][0]\n\n                # Calculate cost change\n                cost1_before = distance_matrix[route1[pos1-1], customer1] + distance_matrix[customer1, route1[pos1+1]]\n                cost1_after = distance_matrix[route1[pos1-1], customer2] + distance_matrix[customer2, route1[pos1+1]]\n\n                cost2_before = distance_matrix[route2[pos2-1], customer2] + distance_matrix[customer2, route2[pos2+1]]\n                cost2_after = distance_matrix[route2[pos2-1], customer1] + distance_matrix[customer1, route2[pos2+1]]\n\n                if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                    # Perform swap\n                    route1[pos1] = customer2\n                    route2[pos2] = customer1\n\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.7901769008072332,
            1.830122947692871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # 1. Route Splitting: Split a long route into two shorter routes\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_split_cost = float('inf')\n        best_split_point = -1\n        for i in range(1, len(longest_route)-1):\n            cost_before = sum(distance_matrix[longest_route[j], longest_route[j+1]] for j in range(i-1))\n            cost_after = sum(distance_matrix[longest_route[j], longest_route[j+1]] for j in range(i, len(longest_route)-1))\n            total_cost = cost_before + cost_after + distance_matrix[0, longest_route[i]]\n            if total_cost < min_split_cost:\n                min_split_cost = total_cost\n                best_split_point = i\n\n        if best_split_point != -1:\n            # Split the route\n            route1 = longest_route[:best_split_point+1]\n            route2 = [0] + longest_route[best_split_point:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n\n    # 2. Demand-Aware Relocation: Relocate a customer to another route if it improves makespan\n    # Find the route with the highest makespan\n    makespans = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    worst_route_idx = np.argmax(makespans)\n    worst_route = new_solution[worst_route_idx]\n\n    if len(worst_route) > 3:  # Ensure there are customers to relocate\n        # Find the customer with the highest demand in the worst route\n        customers = worst_route[1:-1]\n        customer_demands = [demand[node] for node in customers]\n        max_demand_idx = np.argmax(customer_demands)\n        customer_to_relocate = customers[max_demand_idx]\n\n        # Find the best insertion point in another route\n        best_insert_route_idx = -1\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == worst_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[node] for node in route[1:-1])\n\n            if current_demand + demand[customer_to_relocate] > capacity:\n                continue\n\n            for j in range(1, len(route)):\n                # Calculate insertion cost\n                cost_before = distance_matrix[route[j-1], route[j]]\n                cost_after = distance_matrix[customer_to_relocate, route[j]] + distance_matrix[route[j-1], customer_to_relocate]\n\n                if cost_after < cost_before:\n                    if cost_after < best_insert_cost:\n                        best_insert_cost = cost_after\n                        best_insert_route_idx = i\n                        best_insert_pos = j\n\n        if best_insert_route_idx != -1:\n            # Perform relocation\n            worst_route = np.delete(worst_route, max_demand_idx + 1)  # +1 because of leading 0\n            new_solution[worst_route_idx] = worst_route\n\n            insert_route = new_solution[best_insert_route_idx]\n            insert_route = np.insert(insert_route, best_insert_pos, customer_to_relocate)\n            new_solution[best_insert_route_idx] = insert_route\n\n    # 3. Capacity-Constrained Swap: Swap two customers between routes if it improves total distance\n    if len(new_solution) > 1:\n        # Select two different routes\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[0], route_indices[1]\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a customer from each route\n            customer1 = random.choice(route1[1:-1])\n            customer2 = random.choice(route2[1:-1])\n\n            # Calculate new demands\n            demand1 = sum(demand[node] for node in route1[1:-1]) - demand[customer1] + demand[customer2]\n            demand2 = sum(demand[node] for node in route2[1:-1]) - demand[customer2] + demand[customer1]\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Find positions in route1 and route2\n                pos1 = np.where(route1 == customer1)[0][0]\n                pos2 = np.where(route2 == customer2)[0][0]\n\n                # Calculate cost change\n                cost1_before = distance_matrix[route1[pos1-1], customer1] + distance_matrix[customer1, route1[pos1+1]]\n                cost1_after = distance_matrix[route1[pos1-1], customer2] + distance_matrix[customer2, route1[pos1+1]]\n\n                cost2_before = distance_matrix[route2[pos2-1], customer2] + distance_matrix[customer2, route2[pos2+1]]\n                cost2_after = distance_matrix[route2[pos2-1], customer1] + distance_matrix[customer1, route2[pos2+1]]\n\n                if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                    # Perform swap\n                    route1[pos1] = customer2\n                    route2[pos2] = customer1\n\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{'A novel hybrid local search operator combines route splitting and merging with a demand-aware insertion heuristic to balance distance and makespan, while ensuring feasibility through capacity checks and intelligent route selection.'}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Split the route into two parts at a random point\n        if len(route) > 3:  # Ensure we can split meaningfully\n            split_pos = np.random.randint(1, len(route)-1)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Randomly select a customer to reinsert in a demand-aware manner\n    if len(new_solution) > 1:\n        # Choose a route to remove a customer from\n        from_route_idx = np.random.randint(0, len(new_solution))\n        from_route = new_solution[from_route_idx]\n\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            # Select a customer to remove (not depot)\n            customer_pos = np.random.randint(1, len(from_route)-1)\n            customer = from_route[customer_pos]\n\n            # Remove the customer from the route\n            new_from_route = np.concatenate([from_route[:customer_pos], from_route[customer_pos+1:]])\n            new_solution[from_route_idx] = new_from_route\n\n            # Find the best insertion point for the customer in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == from_route_idx:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Try inserting the customer at position 'pos'\n                    new_route = np.concatenate([route[:pos], [customer], route[pos:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate insertion cost (delta distance)\n                    prev_node = route[pos-1]\n                    next_node = route[pos]\n                    cost = (distance_matrix[prev_node][customer] +\n                           distance_matrix[customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_route = np.concatenate([best_route[:best_pos], [customer], best_route[best_pos:]])\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8080129496682242,
            3.395795702934265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly choose a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        # Split the route into two parts at a random point\n        if len(route) > 3:  # Ensure we can split meaningfully\n            split_pos = np.random.randint(1, len(route)-1)\n            new_route1 = route[:split_pos+1]\n            new_route2 = [0] + route[split_pos:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n    # Randomly select a customer to reinsert in a demand-aware manner\n    if len(new_solution) > 1:\n        # Choose a route to remove a customer from\n        from_route_idx = np.random.randint(0, len(new_solution))\n        from_route = new_solution[from_route_idx]\n\n        if len(from_route) > 3:  # Ensure we can remove a customer\n            # Select a customer to remove (not depot)\n            customer_pos = np.random.randint(1, len(from_route)-1)\n            customer = from_route[customer_pos]\n\n            # Remove the customer from the route\n            new_from_route = np.concatenate([from_route[:customer_pos], from_route[customer_pos+1:]])\n            new_solution[from_route_idx] = new_from_route\n\n            # Find the best insertion point for the customer in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == from_route_idx:\n                    continue\n\n                for pos in range(1, len(route)):\n                    # Try inserting the customer at position 'pos'\n                    new_route = np.concatenate([route[:pos], [customer], route[pos:]])\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate insertion cost (delta distance)\n                    prev_node = route[pos-1]\n                    next_node = route[pos]\n                    cost = (distance_matrix[prev_node][customer] +\n                           distance_matrix[customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = i\n                        best_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_route = np.concatenate([best_route[:best_pos], [customer], best_route[best_pos:]])\n                new_solution[best_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    promising_solution = min(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in promising_solution]\n\n    # Apply a hybrid local search operator: combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by concatenating and removing duplicates\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            merged_route = np.unique(merged_route, axis=0)  # Remove duplicates (if any)\n\n            # Reinsert customers from the merged route into new routes to balance makespan\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)  # Randomize insertion order\n            new_routes = []\n\n            current_route = [0]\n            current_load = 0\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n\n            # Replace the old routes with the new ones\n            new_solution = [route for i, route in enumerate(new_solution) if i not in route_indices] + new_routes\n\n    return new_solution\n\n",
        "score": [
            -0.5051352925085032,
            10.740576267242432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    promising_solution = min(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in promising_solution]\n\n    # Apply a hybrid local search operator: combine route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by concatenating and removing duplicates\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            merged_route = np.unique(merged_route, axis=0)  # Remove duplicates (if any)\n\n            # Reinsert customers from the merged route into new routes to balance makespan\n            customers = merged_route[1:-1]\n            np.random.shuffle(customers)  # Randomize insertion order\n            new_routes = []\n\n            current_route = [0]\n            current_load = 0\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n\n            # Replace the old routes with the new ones\n            new_solution = [route for i, route in enumerate(new_solution) if i not in route_indices] + new_routes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 1) Merge two routes if feasible, 2) Reallocate customers, 3) Capacity-aware swaps\n    new_solution = []\n\n    # Step 1: Merge two routes if merging reduces makespan and total distance\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i], base_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [merged_route if idx == i else route for idx, route in enumerate(base_solution) if idx != j]\n            if len(new_solution) == len(base_solution) - 1:\n                return new_solution\n\n    # Step 2: Reallocate customers from the longest route to others if feasible\n    longest_route = max(base_solution, key=lambda r: len(r))\n    if len(longest_route) > 3:\n        candidate = np.random.choice(longest_route[1:-1])\n        for route in base_solution:\n            if route[0] == 0 and np.sum(demand[route]) + demand[candidate] <= capacity:\n                new_route = np.insert(route, -1, candidate)\n                new_solution = [new_route if r[0] == route[0] else r for r in base_solution]\n                new_solution = [np.delete(r, np.where(r == candidate)) if r[0] != 0 else r for r in new_solution]\n                return new_solution\n\n    # Step 3: Capacity-aware swaps between two routes\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i], base_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1, pos2 = np.random.randint(1, len(route1)-1), np.random.randint(1, len(route2)-1)\n            swap1, swap2 = route1[pos1], route2[pos2]\n\n            new_route1 = np.concatenate([route1[:pos1], [swap2], route1[pos1+1:]])\n            new_route2 = np.concatenate([route2[:pos2], [swap1], route2[pos2+1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [new_route1 if idx == i else (new_route2 if idx == j else route)\n                               for idx, route in enumerate(base_solution)]\n                return new_solution\n\n    # Fallback: return the original solution if no improvement\n    return base_solution\n\n",
        "score": [
            -0.7501411552274676,
            0.5722053349018097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 1) Merge two routes if feasible, 2) Reallocate customers, 3) Capacity-aware swaps\n    new_solution = []\n\n    # Step 1: Merge two routes if merging reduces makespan and total distance\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i], base_solution[j]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [merged_route if idx == i else route for idx, route in enumerate(base_solution) if idx != j]\n            if len(new_solution) == len(base_solution) - 1:\n                return new_solution\n\n    # Step 2: Reallocate customers from the longest route to others if feasible\n    longest_route = max(base_solution, key=lambda r: len(r))\n    if len(longest_route) > 3:\n        candidate = np.random.choice(longest_route[1:-1])\n        for route in base_solution:\n            if route[0] == 0 and np.sum(demand[route]) + demand[candidate] <= capacity:\n                new_route = np.insert(route, -1, candidate)\n                new_solution = [new_route if r[0] == route[0] else r for r in base_solution]\n                new_solution = [np.delete(r, np.where(r == candidate)) if r[0] != 0 else r for r in new_solution]\n                return new_solution\n\n    # Step 3: Capacity-aware swaps between two routes\n    if len(base_solution) > 1:\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        route1, route2 = base_solution[i], base_solution[j]\n        if len(route1) > 3 and len(route2) > 3:\n            pos1, pos2 = np.random.randint(1, len(route1)-1), np.random.randint(1, len(route2)-1)\n            swap1, swap2 = route1[pos1], route2[pos2]\n\n            new_route1 = np.concatenate([route1[:pos1], [swap2], route1[pos1+1:]])\n            new_route2 = np.concatenate([route2[:pos2], [swap1], route2[pos2+1:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution = [new_route1 if idx == i else (new_route2 if idx == j else route)\n                               for idx, route in enumerate(base_solution)]\n                return new_solution\n\n    # Fallback: return the original solution if no improvement\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{A novel hybrid local search operator combines route splitting, demand-aware node insertion, and adaptive 2-opt to balance distance and makespan minimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Route splitting with demand-aware node insertion\n        for route in new_solution:\n            if len(route) > 3:  # Only consider routes with more than 2 customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                # Check capacity feasibility for both new routes\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                    # Insert nodes from the longer route into the shorter one if beneficial\n                    if len(new_route1) > len(new_route2):\n                        temp_route = new_route1\n                        new_route1 = new_route2\n                        new_route2 = temp_route\n\n                    # Try inserting nodes from new_route2 into new_route1\n                    for node in new_route2[1:-1]:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(new_route1)):\n                            insert_cost = (distance_matrix[new_route1[i-1], node] +\n                                         distance_matrix[node, new_route1[i]] -\n                                         distance_matrix[new_route1[i-1], new_route1[i]])\n                            if insert_cost < best_cost and np.sum(demand[new_route1[1:-1]]) + demand[node] <= capacity:\n                                best_cost = insert_cost\n                                best_pos = i\n                        if best_cost < float('inf'):\n                            new_route1 = np.insert(new_route1, best_pos, node)\n\n                    # Update the solution\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                    new_solution.append(new_route1)\n                    if len(new_route2) > 2:  # Only add if it has customers\n                        new_solution.append(new_route2)\n                    break\n    else:\n        # Adaptive 2-opt with demand-aware node swapping\n        for route in new_solution:\n            if len(route) > 4:  # Only consider routes with more than 3 customers\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n\n                # Create two possible 2-opt swaps\n                swap1 = np.concatenate([route[:i], route[j:j+1], route[i+1:j], route[i:i+1], route[j+1:]])\n                swap2 = np.concatenate([route[:i], route[j:j+1][::-1], route[i+1:j], route[i:i+1], route[j+1:]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[swap1[1:-1]]) <= capacity and\n                    np.sum(demand[swap2[1:-1]]) <= capacity):\n\n                    # Choose the swap that improves makespan more (or distance if makespan is equal)\n                    original_makespan = sum(distance_matrix[route[k-1], route[k]] for k in range(1, len(route)))\n                    swap1_makespan = sum(distance_matrix[swap1[k-1], swap1[k]] for k in range(1, len(swap1)))\n                    swap2_makespan = sum(distance_matrix[swap2[k-1], swap2[k]] for k in range(1, len(swap2)))\n\n                    if swap1_makespan < swap2_makespan and swap1_makespan < original_makespan:\n                        route[:] = swap1\n                    elif swap2_makespan < swap1_makespan and swap2_makespan < original_makespan:\n                        route[:] = swap2\n                    elif swap1_makespan == swap2_makespan and swap1_makespan < original_makespan:\n                        if random.random() < 0.5:\n                            route[:] = swap1\n                        else:\n                            route[:] = swap2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6571331757791627,
            3.0812512636184692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Route splitting with demand-aware node insertion\n        for route in new_solution:\n            if len(route) > 3:  # Only consider routes with more than 2 customers\n                split_pos = random.randint(1, len(route) - 2)\n                new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                # Check capacity feasibility for both new routes\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n                    # Insert nodes from the longer route into the shorter one if beneficial\n                    if len(new_route1) > len(new_route2):\n                        temp_route = new_route1\n                        new_route1 = new_route2\n                        new_route2 = temp_route\n\n                    # Try inserting nodes from new_route2 into new_route1\n                    for node in new_route2[1:-1]:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(new_route1)):\n                            insert_cost = (distance_matrix[new_route1[i-1], node] +\n                                         distance_matrix[node, new_route1[i]] -\n                                         distance_matrix[new_route1[i-1], new_route1[i]])\n                            if insert_cost < best_cost and np.sum(demand[new_route1[1:-1]]) + demand[node] <= capacity:\n                                best_cost = insert_cost\n                                best_pos = i\n                        if best_cost < float('inf'):\n                            new_route1 = np.insert(new_route1, best_pos, node)\n\n                    # Update the solution\n                    new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                    new_solution.append(new_route1)\n                    if len(new_route2) > 2:  # Only add if it has customers\n                        new_solution.append(new_route2)\n                    break\n    else:\n        # Adaptive 2-opt with demand-aware node swapping\n        for route in new_solution:\n            if len(route) > 4:  # Only consider routes with more than 3 customers\n                i = random.randint(1, len(route) - 3)\n                j = random.randint(i + 1, len(route) - 2)\n\n                # Create two possible 2-opt swaps\n                swap1 = np.concatenate([route[:i], route[j:j+1], route[i+1:j], route[i:i+1], route[j+1:]])\n                swap2 = np.concatenate([route[:i], route[j:j+1][::-1], route[i+1:j], route[i:i+1], route[j+1:]])\n\n                # Check capacity feasibility\n                if (np.sum(demand[swap1[1:-1]]) <= capacity and\n                    np.sum(demand[swap2[1:-1]]) <= capacity):\n\n                    # Choose the swap that improves makespan more (or distance if makespan is equal)\n                    original_makespan = sum(distance_matrix[route[k-1], route[k]] for k in range(1, len(route)))\n                    swap1_makespan = sum(distance_matrix[swap1[k-1], swap1[k]] for k in range(1, len(swap1)))\n                    swap2_makespan = sum(distance_matrix[swap2[k-1], swap2[k]] for k in range(1, len(swap2)))\n\n                    if swap1_makespan < swap2_makespan and swap1_makespan < original_makespan:\n                        route[:] = swap1\n                    elif swap2_makespan < swap1_makespan and swap2_makespan < original_makespan:\n                        route[:] = swap2\n                    elif swap1_makespan == swap2_makespan and swap1_makespan < original_makespan:\n                        if random.random() < 0.5:\n                            route[:] = swap1\n                        else:\n                            route[:] = swap2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_to_modify = random.choice(selected_solution)\n        other_routes = [r for r in selected_solution if not np.array_equal(r, route_to_modify)]\n\n        # Find the most distant customer in the selected route\n        max_dist = 0\n        split_point = 1\n        for i in range(1, len(route_to_modify) - 1):\n            dist = distance_matrix[route_to_modify[i-1]][route_to_modify[i]]\n            if dist > max_dist:\n                max_dist = dist\n                split_point = i\n\n        # Split the route at the most distant point\n        first_part = route_to_modify[:split_point + 1]\n        second_part = route_to_modify[split_point:]\n\n        # Check capacity feasibility for both parts\n        first_capacity = sum(demand[first_part[1:-1]])\n        second_capacity = sum(demand[second_part[1:-1]])\n\n        if first_capacity <= capacity and second_capacity <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for r in selected_solution if not np.array_equal(r, route_to_modify)]\n            new_solution.extend([first_part, second_part])\n        else:\n            # If split violates capacity, try moving a customer to another route\n            if other_routes:\n                target_route = random.choice(other_routes)\n                target_capacity = sum(demand[target_route[1:-1]])\n                customer_to_move = route_to_modify[split_point]\n\n                if target_capacity + demand[customer_to_move] <= capacity:\n                    # Move the customer to the target route\n                    modified_route = np.delete(route_to_modify, split_point)\n                    modified_route = np.insert(modified_route, len(modified_route) - 1, customer_to_move)\n                    new_target_route = np.insert(target_route, len(target_route) - 1, customer_to_move)\n\n                    new_solution = [r for r in selected_solution if not np.array_equal(r, route_to_modify) and not np.array_equal(r, target_route)]\n                    new_solution.extend([modified_route, new_target_route])\n                else:\n                    new_solution = selected_solution\n            else:\n                new_solution = selected_solution\n    else:\n        new_solution = selected_solution\n\n    return np.array(new_solution, dtype=object)\n\n",
        "score": [
            -0.7648049264859869,
            0.3659454882144928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Randomly choose a route to modify\n    if len(selected_solution) > 1:\n        route_to_modify = random.choice(selected_solution)\n        other_routes = [r for r in selected_solution if not np.array_equal(r, route_to_modify)]\n\n        # Find the most distant customer in the selected route\n        max_dist = 0\n        split_point = 1\n        for i in range(1, len(route_to_modify) - 1):\n            dist = distance_matrix[route_to_modify[i-1]][route_to_modify[i]]\n            if dist > max_dist:\n                max_dist = dist\n                split_point = i\n\n        # Split the route at the most distant point\n        first_part = route_to_modify[:split_point + 1]\n        second_part = route_to_modify[split_point:]\n\n        # Check capacity feasibility for both parts\n        first_capacity = sum(demand[first_part[1:-1]])\n        second_capacity = sum(demand[second_part[1:-1]])\n\n        if first_capacity <= capacity and second_capacity <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for r in selected_solution if not np.array_equal(r, route_to_modify)]\n            new_solution.extend([first_part, second_part])\n        else:\n            # If split violates capacity, try moving a customer to another route\n            if other_routes:\n                target_route = random.choice(other_routes)\n                target_capacity = sum(demand[target_route[1:-1]])\n                customer_to_move = route_to_modify[split_point]\n\n                if target_capacity + demand[customer_to_move] <= capacity:\n                    # Move the customer to the target route\n                    modified_route = np.delete(route_to_modify, split_point)\n                    modified_route = np.insert(modified_route, len(modified_route) - 1, customer_to_move)\n                    new_target_route = np.insert(target_route, len(target_route) - 1, customer_to_move)\n\n                    new_solution = [r for r in selected_solution if not np.array_equal(r, route_to_modify) and not np.array_equal(r, target_route)]\n                    new_solution.extend([modified_route, new_target_route])\n                else:\n                    new_solution = selected_solution\n            else:\n                new_solution = selected_solution\n    else:\n        new_solution = selected_solution\n\n    return np.array(new_solution, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Apply a hybrid local search operator: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:-1]\n\n        # Reallocate customers from part2 to existing routes if possible\n        temp_route = part1.copy()\n        remaining_customers = part2.copy()[1:-1]\n\n        # Try to reallocate customers to other routes\n        for customer in remaining_customers:\n            for i, r in enumerate(new_solution):\n                if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(r)):\n                        increase = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.insert(r, best_pos, customer)\n                    new_solution[i] = new_route\n                    break\n            else:\n                # If not reallocated, add to the current route\n                temp_route = np.insert(temp_route, -1, customer)\n\n        # Add the modified route back\n        if len(temp_route) > 2:  # Only add if it has customers\n            new_solution.append(temp_route)\n\n    # Ensure all customers are included (fallback in case of missing customers)\n    all_customers = set(range(1, len(demand)))\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n\n    missing_customers = all_customers - assigned_customers\n    if missing_customers:\n        for customer in missing_customers:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_pos = -1\n            min_increase = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n                for pos in range(1, len(route)):\n                    increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n            if best_route_idx != -1:\n                new_route = np.insert(new_solution[best_route_idx], best_pos, customer)\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible route found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7367292160969383,
            9.925494998693466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Apply a hybrid local search operator: combine route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:-1]\n\n        # Reallocate customers from part2 to existing routes if possible\n        temp_route = part1.copy()\n        remaining_customers = part2.copy()[1:-1]\n\n        # Try to reallocate customers to other routes\n        for customer in remaining_customers:\n            for i, r in enumerate(new_solution):\n                if sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(r)):\n                        increase = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.insert(r, best_pos, customer)\n                    new_solution[i] = new_route\n                    break\n            else:\n                # If not reallocated, add to the current route\n                temp_route = np.insert(temp_route, -1, customer)\n\n        # Add the modified route back\n        if len(temp_route) > 2:  # Only add if it has customers\n            new_solution.append(temp_route)\n\n    # Ensure all customers are included (fallback in case of missing customers)\n    all_customers = set(range(1, len(demand)))\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n\n    missing_customers = all_customers - assigned_customers\n    if missing_customers:\n        for customer in missing_customers:\n            # Find the route with the least increase in distance\n            best_route_idx = -1\n            best_pos = -1\n            min_increase = float('inf')\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n                for pos in range(1, len(route)):\n                    increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n            if best_route_idx != -1:\n                new_route = np.insert(new_solution[best_route_idx], best_pos, customer)\n                new_solution[best_route_idx] = new_route\n            else:\n                # If no feasible route found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Randomly select a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split the route into two parts and reinsert nodes between them\n        if len(selected_route) > 4:  # Ensure the route has enough nodes to split\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:-1]\n\n            # Randomly shuffle the nodes in part2\n            np.random.shuffle(part2)\n\n            # Reconstruct the route\n            new_route = np.concatenate([part1, part2, [0]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = new_route\n\n    return selected_solution\n\n",
        "score": [
            -0.6741691216141323,
            0.5947065651416779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Randomly select a route to modify\n    if len(selected_solution) > 1:\n        route_idx = np.random.randint(0, len(selected_solution))\n        selected_route = selected_solution[route_idx].copy()\n\n        # Apply a hybrid local search: split the route into two parts and reinsert nodes between them\n        if len(selected_route) > 4:  # Ensure the route has enough nodes to split\n            split_pos = np.random.randint(2, len(selected_route) - 2)\n            part1 = selected_route[:split_pos]\n            part2 = selected_route[split_pos:-1]\n\n            # Randomly shuffle the nodes in part2\n            np.random.shuffle(part2)\n\n            # Reconstruct the route\n            new_route = np.concatenate([part1, part2, [0]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                selected_solution[route_idx] = new_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] * 0.7 + x[1][0] * 0.3))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reinsertion with distance-based filtering\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two segments at a random customer\n        split_idx = np.random.randint(1, len(route)-1)\n        segment1 = route[:split_idx+1]\n        segment2 = route[split_idx:]\n\n        # Check capacity constraints for both segments\n        if (np.sum(demand[segment1[1:-1]]) <= capacity) and (np.sum(demand[segment2[1:-1]]) <= capacity):\n            new_solution.append(segment1)\n            new_solution.append(segment2)\n        else:\n            # If split violates capacity, try reinserting customers from the longer segment\n            longer_segment = segment1 if len(segment1) > len(segment2) else segment2\n            customers = longer_segment[1:-1]\n\n            # Sort customers by distance to depot to prioritize reinsertion\n            depot_distances = distance_matrix[0, customers]\n            sorted_customers = customers[np.argsort(depot_distances)]\n\n            # Reinsert customers one by one into existing routes or new routes\n            for customer in sorted_customers:\n                inserted = False\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position (minimum distance increase)\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for pos in range(1, len(r)):\n                            increase = (distance_matrix[r[pos-1], customer] +\n                                      distance_matrix[customer, r[pos]] -\n                                      distance_matrix[r[pos-1], r[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert customer\n                        new_route = np.insert(r, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no suitable existing route found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7421047014422086,
            0.5855846107006073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1] * 0.7 + x[1][0] * 0.3))[0].copy()\n\n    # Hybrid local search: combine route splitting and customer reinsertion with distance-based filtering\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two segments at a random customer\n        split_idx = np.random.randint(1, len(route)-1)\n        segment1 = route[:split_idx+1]\n        segment2 = route[split_idx:]\n\n        # Check capacity constraints for both segments\n        if (np.sum(demand[segment1[1:-1]]) <= capacity) and (np.sum(demand[segment2[1:-1]]) <= capacity):\n            new_solution.append(segment1)\n            new_solution.append(segment2)\n        else:\n            # If split violates capacity, try reinserting customers from the longer segment\n            longer_segment = segment1 if len(segment1) > len(segment2) else segment2\n            customers = longer_segment[1:-1]\n\n            # Sort customers by distance to depot to prioritize reinsertion\n            depot_distances = distance_matrix[0, customers]\n            sorted_customers = customers[np.argsort(depot_distances)]\n\n            # Reinsert customers one by one into existing routes or new routes\n            for customer in sorted_customers:\n                inserted = False\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position (minimum distance increase)\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for pos in range(1, len(r)):\n                            increase = (distance_matrix[r[pos-1], customer] +\n                                      distance_matrix[customer, r[pos]] -\n                                      distance_matrix[r[pos-1], r[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert customer\n                        new_route = np.insert(r, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no suitable existing route found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A novel hybrid local search operator combines route-segment relocation with capacity-aware route merging, intelligently selected from promising solutions in the archive to balance total distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route-segment relocation with capacity-aware merging\n    if len(new_solution) > 1:  # Only if there are multiple routes\n        # Select two distinct routes\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        # Select a random segment from route i\n        route_i = new_solution[i]\n        if len(route_i) > 3:  # At least one customer node to move\n            start, end = random.sample(range(1, len(route_i) - 1), 2)\n            if start > end:\n                start, end = end, start\n            segment = route_i[start:end+1]\n\n            # Check capacity constraint for route j after adding the segment\n            current_capacity_j = sum(demand[new_solution[j][1:-1]])\n            segment_demand = sum(demand[segment])\n            if current_capacity_j + segment_demand <= capacity:\n                # Insert segment into route j\n                # Choose a random position in route j (excluding depot)\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_route_j = np.concatenate([new_solution[j][:insert_pos], segment, new_solution[j][insert_pos:]])\n\n                # Remove the segment from route i\n                new_route_i = np.concatenate([route_i[:start], route_i[end+1:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6923954568688904,
            1.0143723487854004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: route-segment relocation with capacity-aware merging\n    if len(new_solution) > 1:  # Only if there are multiple routes\n        # Select two distinct routes\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        # Select a random segment from route i\n        route_i = new_solution[i]\n        if len(route_i) > 3:  # At least one customer node to move\n            start, end = random.sample(range(1, len(route_i) - 1), 2)\n            if start > end:\n                start, end = end, start\n            segment = route_i[start:end+1]\n\n            # Check capacity constraint for route j after adding the segment\n            current_capacity_j = sum(demand[new_solution[j][1:-1]])\n            segment_demand = sum(demand[segment])\n            if current_capacity_j + segment_demand <= capacity:\n                # Insert segment into route j\n                # Choose a random position in route j (excluding depot)\n                insert_pos = random.randint(1, len(new_solution[j]) - 1)\n                new_route_j = np.concatenate([new_solution[j][:insert_pos], segment, new_solution[j][insert_pos:]])\n\n                # Remove the segment from route i\n                new_route_i = np.concatenate([route_i[:start], route_i[end+1:]])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] - 0.5 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: merge two shortest routes and shuffle segments\n    if len(new_solution) > 1:\n        # Merge two routes with the smallest total distance\n        route_dists = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        i, j = np.argsort(route_dists)[:2]\n        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n\n        # Check capacity feasibility\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            # Shuffle segments of the merged route\n            segments = np.split(merged_route[1:-1], np.random.randint(1, len(merged_route)-2))\n            np.random.shuffle(segments)\n            shuffled = np.concatenate([np.array([0]), *segments, np.array([0])])\n\n            # Replace the two routes with the new shuffled route\n            new_solution = [shuffled] + [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n\n    return new_solution\n\n",
        "score": [
            -0.7264549021504108,
            2.0354791283607483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] - 0.5 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: merge two shortest routes and shuffle segments\n    if len(new_solution) > 1:\n        # Merge two routes with the smallest total distance\n        route_dists = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        i, j = np.argsort(route_dists)[:2]\n        merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n\n        # Check capacity feasibility\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            # Shuffle segments of the merged route\n            segments = np.split(merged_route[1:-1], np.random.randint(1, len(merged_route)-2))\n            np.random.shuffle(segments)\n            shuffled = np.concatenate([np.array([0]), *segments, np.array([0])])\n\n            # Replace the two routes with the new shuffled route\n            new_solution = [shuffled] + [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search operator that combines route segment reversal with customer reinsertion to balance distance and makespan, while ensuring feasibility through capacity checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Weight for distance and makespan, respectively\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route segment reversal with customer reinsertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Reverse a random segment of the route\n        if len(selected_route) > 4:  # Ensure enough nodes to reverse\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            selected_route[start:end] = selected_route[start:end][::-1]\n\n        # Step 3: Reinsert a random customer to another route\n        if len(new_solution) > 1:\n            target_route_idx = (route_idx + 1) % len(new_solution)\n            target_route = new_solution[target_route_idx]\n\n            # Select a random customer to move\n            if len(selected_route) > 3:\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert at a random position in target route\n                    insert_pos = np.random.randint(1, len(target_route))\n                    target_route = np.insert(target_route, insert_pos, customer)\n                    selected_route = np.delete(selected_route, customer_pos)\n\n                    # Update the solution\n                    new_solution[route_idx] = selected_route\n                    new_solution[target_route_idx] = target_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.5160685780734564,
            0.8227669298648834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # Weight for distance and makespan, respectively\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine route segment reversal with customer reinsertion\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Reverse a random segment of the route\n        if len(selected_route) > 4:  # Ensure enough nodes to reverse\n            start = np.random.randint(1, len(selected_route) - 2)\n            end = np.random.randint(start + 1, len(selected_route) - 1)\n            selected_route[start:end] = selected_route[start:end][::-1]\n\n        # Step 3: Reinsert a random customer to another route\n        if len(new_solution) > 1:\n            target_route_idx = (route_idx + 1) % len(new_solution)\n            target_route = new_solution[target_route_idx]\n\n            # Select a random customer to move\n            if len(selected_route) > 3:\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Check capacity constraint\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert at a random position in target route\n                    insert_pos = np.random.randint(1, len(target_route))\n                    target_route = np.insert(target_route, insert_pos, customer)\n                    selected_route = np.delete(selected_route, customer_pos)\n\n                    # Update the solution\n                    new_solution[route_idx] = selected_route\n                    new_solution[target_route_idx] = target_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with the longest makespan or high total distance, then applies a hybrid local search combining route fragmentation and inter-route insertion to balance the two objectives while ensuring feasible capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Prioritize by makespan then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragment longest route and redistribute customers\n    longest_route_idx = np.argmax([np.sum([distance_matrix[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)]) for selected_solution in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n    customers_in_route = longest_route[1:-1]  # Exclude depot\n\n    # Split the longest route into two parts\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:-1]\n    part2 = np.concatenate([[0], part2, [0]])\n\n    # Check capacity feasibility for both parts\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(part1) and is_feasible(part2):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.extend([part1, part2])\n    else:\n        # If splitting is infeasible, try inter-route insertion\n        # Select a random customer from the longest route\n        customer_to_move = random.choice(customers_in_route)\n        # Find the route where inserting this customer doesn't violate capacity\n        candidate_routes = []\n        for i, route in enumerate(selected_solution):\n            if i == longest_route_idx:\n                continue\n            if np.sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity:\n                candidate_routes.append((i, route))\n\n        if candidate_routes:\n            # Insert the customer into a feasible route\n            target_route_idx, target_route = random.choice(candidate_routes)\n            # Find the best insertion position (minimizing additional distance)\n            best_insert_pos = 0\n            min_additional_distance = float('inf')\n            for i in range(len(target_route) - 1):\n                dist = distance_matrix[target_route[i], customer_to_move] + distance_matrix[customer_to_move, target_route[i+1]] - distance_matrix[target_route[i], target_route[i+1]]\n                if dist < min_additional_distance:\n                    min_additional_distance = dist\n                    best_insert_pos = i + 1\n\n            new_target_route = np.insert(target_route, best_insert_pos, customer_to_move)\n            new_solution = selected_solution.copy()\n            new_solution[target_route_idx] = new_target_route\n\n            # Remove the customer from the original route\n            original_route = selected_solution[longest_route_idx]\n            customer_pos = np.where(original_route == customer_to_move)[0][0]\n            new_original_route = np.delete(original_route, customer_pos)\n            new_solution[longest_route_idx] = new_original_route\n        else:\n            # If no feasible insertion, return the original solution\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6464203860552101,
            0.8181952834129333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], -x[1][0]))  # Prioritize by makespan then distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragment longest route and redistribute customers\n    longest_route_idx = np.argmax([np.sum([distance_matrix[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)]) for selected_solution in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n    customers_in_route = longest_route[1:-1]  # Exclude depot\n\n    # Split the longest route into two parts\n    split_point = len(longest_route) // 2\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:-1]\n    part2 = np.concatenate([[0], part2, [0]])\n\n    # Check capacity feasibility for both parts\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(part1) and is_feasible(part2):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.extend([part1, part2])\n    else:\n        # If splitting is infeasible, try inter-route insertion\n        # Select a random customer from the longest route\n        customer_to_move = random.choice(customers_in_route)\n        # Find the route where inserting this customer doesn't violate capacity\n        candidate_routes = []\n        for i, route in enumerate(selected_solution):\n            if i == longest_route_idx:\n                continue\n            if np.sum(demand[route[1:-1]]) + demand[customer_to_move] <= capacity:\n                candidate_routes.append((i, route))\n\n        if candidate_routes:\n            # Insert the customer into a feasible route\n            target_route_idx, target_route = random.choice(candidate_routes)\n            # Find the best insertion position (minimizing additional distance)\n            best_insert_pos = 0\n            min_additional_distance = float('inf')\n            for i in range(len(target_route) - 1):\n                dist = distance_matrix[target_route[i], customer_to_move] + distance_matrix[customer_to_move, target_route[i+1]] - distance_matrix[target_route[i], target_route[i+1]]\n                if dist < min_additional_distance:\n                    min_additional_distance = dist\n                    best_insert_pos = i + 1\n\n            new_target_route = np.insert(target_route, best_insert_pos, customer_to_move)\n            new_solution = selected_solution.copy()\n            new_solution[target_route_idx] = new_target_route\n\n            # Remove the customer from the original route\n            original_route = selected_solution[longest_route_idx]\n            customer_pos = np.where(original_route == customer_to_move)[0][0]\n            new_original_route = np.delete(original_route, customer_pos)\n            new_solution[longest_route_idx] = new_original_route\n        else:\n            # If no feasible insertion, return the original solution\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with the longest makespan and highest total distance, then applies a hybrid local search operator combining route truncation and reinsertion with demand-aware customer reallocation to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Truncate the longest route and reinsert customers\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Truncate the longest route by removing some customers\n        truncation_point = len(longest_route) // 2\n        removed_customers = longest_route[truncation_point:-1]  # Exclude depot\n        truncated_route = np.concatenate([longest_route[:truncation_point], [0]])\n\n        # Update the solution\n        new_solution[longest_route_idx] = truncated_route\n\n        # Reinsert removed customers into other routes or new routes\n        for customer in removed_customers:\n            inserted = False\n            # Try to insert into existing routes first\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route = new_solution[i]\n                # Check capacity constraint\n                current_load = sum(demand[route[1:-1]])  # Exclude depots\n                if current_load + demand[customer] <= capacity:\n                    # Find the best insertion position (minimizing additional distance)\n                    best_pos = 1\n                    min_added_distance = float('inf')\n                    for pos in range(1, len(route)):\n                        added_distance = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if added_distance < min_added_distance:\n                            min_added_distance = added_distance\n                            best_pos = pos\n                    # Insert customer\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            # If not inserted, create a new route\n            if not inserted:\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.640405819248153,
            1.4795051217079163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Truncate the longest route and reinsert customers\n    if len(new_solution) > 1:\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Truncate the longest route by removing some customers\n        truncation_point = len(longest_route) // 2\n        removed_customers = longest_route[truncation_point:-1]  # Exclude depot\n        truncated_route = np.concatenate([longest_route[:truncation_point], [0]])\n\n        # Update the solution\n        new_solution[longest_route_idx] = truncated_route\n\n        # Reinsert removed customers into other routes or new routes\n        for customer in removed_customers:\n            inserted = False\n            # Try to insert into existing routes first\n            for i in range(len(new_solution)):\n                if i == longest_route_idx:\n                    continue\n                route = new_solution[i]\n                # Check capacity constraint\n                current_load = sum(demand[route[1:-1]])  # Exclude depots\n                if current_load + demand[customer] <= capacity:\n                    # Find the best insertion position (minimizing additional distance)\n                    best_pos = 1\n                    min_added_distance = float('inf')\n                    for pos in range(1, len(route)):\n                        added_distance = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if added_distance < min_added_distance:\n                            min_added_distance = added_distance\n                            best_pos = pos\n                    # Insert customer\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            # If not inserted, create a new route\n            if not inserted:\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))  # Prioritize high makespan, then lower total distance\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and insertion heuristic\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts at a random point, ensuring feasibility\n        if len(route) > 3:  # Only split if route has enough nodes\n            split_point = np.random.randint(1, len(route)-1)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Check capacity feasibility for both parts\n            demand1 = sum(demand[node] for node in part1[1:-1])\n            demand2 = sum(demand[node] for node in part2[1:-1])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Apply insertion heuristic to improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only apply if route has enough nodes\n            # Remove a random customer and try to reinsert it optimally\n            remove_idx = np.random.randint(1, len(route)-1)\n            customer = route[remove_idx]\n            route = np.delete(route, remove_idx)\n\n            # Find the best insertion position in the same route\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                cost = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Insert at the best position\n            new_solution[i] = np.insert(route, best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.8056992605987618,
            7.323803901672363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))  # Prioritize high makespan, then lower total distance\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine route splitting and insertion heuristic\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts at a random point, ensuring feasibility\n        if len(route) > 3:  # Only split if route has enough nodes\n            split_point = np.random.randint(1, len(route)-1)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Check capacity feasibility for both parts\n            demand1 = sum(demand[node] for node in part1[1:-1])\n            demand2 = sum(demand[node] for node in part2[1:-1])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution.append(part1)\n                new_solution.append(part2)\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Apply insertion heuristic to improve the solution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only apply if route has enough nodes\n            # Remove a random customer and try to reinsert it optimally\n            remove_idx = np.random.randint(1, len(route)-1)\n            customer = route[remove_idx]\n            route = np.delete(route, remove_idx)\n\n            # Find the best insertion position in the same route\n            best_pos = 1\n            min_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, customer)\n                cost = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            # Insert at the best position\n            new_solution[i] = np.insert(route, best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This function selects a promising solution from the archive using a hybrid local search strategy that combines route splitting, customer reallocation, and adaptive 2-opt, ensuring feasibility and exploring trade-offs between total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(1, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        new_route = route.copy()\n        # Randomly select a segment to modify\n        if len(new_route) > 3:  # Ensure there's space to modify\n            start_idx = random.randint(1, len(new_route) - 3)\n            end_idx = random.randint(start_idx + 1, len(new_route) - 2)\n\n            # Extract the segment\n            segment = new_route[start_idx:end_idx]\n            segment_demand = np.sum(demand[segment])\n\n            # Try to reallocate the segment to another route or split it\n            if random.random() < 0.5:  # 50% chance to reallocate\n                # Find a route with enough capacity\n                for candidate_route in selected_solution:\n                    if candidate_route is not route:\n                        candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                        if candidate_demand + segment_demand <= capacity:\n                            # Insert the segment into the candidate route\n                            insert_pos = random.randint(1, len(candidate_route) - 1)\n                            new_candidate_route = np.concatenate([\n                                candidate_route[:insert_pos],\n                                segment,\n                                candidate_route[insert_pos:]\n                            ])\n                            # Update the routes\n                            new_solution.append(new_candidate_route)\n                            new_route = np.concatenate([new_route[:start_idx], new_route[end_idx:]])\n                            break\n                else:\n                    new_solution.append(new_route)\n            else:  # Split the segment into a new route\n                if segment_demand <= capacity:\n                    new_solution.append(np.concatenate([[0], segment, [0]]))\n                    new_route = np.concatenate([new_route[:start_idx], new_route[end_idx:]])\n                    new_solution.append(new_route)\n                else:\n                    new_solution.append(new_route)\n        else:\n            new_solution.append(new_route)\n\n    # Perform adaptive 2-opt on the modified routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Randomly select two edges to swap\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            c, d = a + 1, b + 1\n\n            # Check capacity constraints for the new route\n            new_route = np.concatenate([route[:a+1], route[b:d], route[a+1:b+1], route[d:]])\n            new_demand = np.sum(demand[new_route[1:-1]])\n            if new_demand <= capacity:\n                new_solution[i] = new_route\n\n    # Ensure all customers are covered\n    all_customers = set(range(1, len(coords)))\n    covered_customers = set()\n    for route in new_solution:\n        covered_customers.update(route[1:-1])\n    missing_customers = all_customers - covered_customers\n\n    if missing_customers:\n        # Reassign missing customers to routes with capacity\n        for customer in missing_customers:\n            for i, route in enumerate(new_solution):\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    # Insert the customer at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6906780557801198,
            5.383373349905014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(1, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        new_route = route.copy()\n        # Randomly select a segment to modify\n        if len(new_route) > 3:  # Ensure there's space to modify\n            start_idx = random.randint(1, len(new_route) - 3)\n            end_idx = random.randint(start_idx + 1, len(new_route) - 2)\n\n            # Extract the segment\n            segment = new_route[start_idx:end_idx]\n            segment_demand = np.sum(demand[segment])\n\n            # Try to reallocate the segment to another route or split it\n            if random.random() < 0.5:  # 50% chance to reallocate\n                # Find a route with enough capacity\n                for candidate_route in selected_solution:\n                    if candidate_route is not route:\n                        candidate_demand = np.sum(demand[candidate_route[1:-1]])\n                        if candidate_demand + segment_demand <= capacity:\n                            # Insert the segment into the candidate route\n                            insert_pos = random.randint(1, len(candidate_route) - 1)\n                            new_candidate_route = np.concatenate([\n                                candidate_route[:insert_pos],\n                                segment,\n                                candidate_route[insert_pos:]\n                            ])\n                            # Update the routes\n                            new_solution.append(new_candidate_route)\n                            new_route = np.concatenate([new_route[:start_idx], new_route[end_idx:]])\n                            break\n                else:\n                    new_solution.append(new_route)\n            else:  # Split the segment into a new route\n                if segment_demand <= capacity:\n                    new_solution.append(np.concatenate([[0], segment, [0]]))\n                    new_route = np.concatenate([new_route[:start_idx], new_route[end_idx:]])\n                    new_solution.append(new_route)\n                else:\n                    new_solution.append(new_route)\n        else:\n            new_solution.append(new_route)\n\n    # Perform adaptive 2-opt on the modified routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            # Randomly select two edges to swap\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            c, d = a + 1, b + 1\n\n            # Check capacity constraints for the new route\n            new_route = np.concatenate([route[:a+1], route[b:d], route[a+1:b+1], route[d:]])\n            new_demand = np.sum(demand[new_route[1:-1]])\n            if new_demand <= capacity:\n                new_solution[i] = new_route\n\n    # Ensure all customers are covered\n    all_customers = set(range(1, len(coords)))\n    covered_customers = set()\n    for route in new_solution:\n        covered_customers.update(route[1:-1])\n    missing_customers = all_customers - covered_customers\n\n    if missing_customers:\n        # Reassign missing customers to routes with capacity\n        for customer in missing_customers:\n            for i, route in enumerate(new_solution):\n                route_demand = np.sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    # Insert the customer at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This function selects a promising solution from the archive, applies a hybrid local search strategy combining route splitting, merging, and intra-route segment swaps to balance travel distance and makespan, ensuring feasibility by checking vehicle capacity constraints at each step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Prioritize solutions with lower combined objectives\n    selected_solution = random.choices(archive_sorted[:min(5, len(archive_sorted))], weights=[1/(i+1) for i in range(min(5, len(archive_sorted)))])[0][0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search strategy\n    if len(new_solution) > 1:\n        # Route splitting: Split the longest route into two parts\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_point = len(longest_route) // 2\n        route1 = longest_route[:split_point+1]\n        route2 = np.concatenate([[0], longest_route[split_point:]])\n\n        # Check capacity constraints\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Intra-route segment swap: Swap segments between different routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 3 and len(route2) > 3:\n            start1, end1 = sorted(random.sample(range(1, len(route1)-1), 2))\n            start2, end2 = sorted(random.sample(range(1, len(route2)-1), 2))\n\n            # Swap segments\n            new_route1 = np.concatenate([route1[:start1], route2[start2:end2+1], route1[end1+1:]])\n            new_route2 = np.concatenate([route2[:start2], route1[start1:end1+1], route2[end2+1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route merging: Merge two shortest routes if they fit capacity\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        second_shortest_idx = np.argsort(route_lengths)[1]\n\n        route1 = new_solution[shortest_idx]\n        route2 = new_solution[second_shortest_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(shortest_idx, second_shortest_idx))\n            new_solution.pop(min(shortest_idx, second_shortest_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.5808368960431011,
            1.2582421600818634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Prioritize solutions with lower combined objectives\n    selected_solution = random.choices(archive_sorted[:min(5, len(archive_sorted))], weights=[1/(i+1) for i in range(min(5, len(archive_sorted)))])[0][0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search strategy\n    if len(new_solution) > 1:\n        # Route splitting: Split the longest route into two parts\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n        split_point = len(longest_route) // 2\n        route1 = longest_route[:split_point+1]\n        route2 = np.concatenate([[0], longest_route[split_point:]])\n\n        # Check capacity constraints\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n    # Intra-route segment swap: Swap segments between different routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 3 and len(route2) > 3:\n            start1, end1 = sorted(random.sample(range(1, len(route1)-1), 2))\n            start2, end2 = sorted(random.sample(range(1, len(route2)-1), 2))\n\n            # Swap segments\n            new_route1 = np.concatenate([route1[:start1], route2[start2:end2+1], route1[end1+1:]])\n            new_route2 = np.concatenate([route2[:start2], route1[start1:end1+1], route2[end2+1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route merging: Merge two shortest routes if they fit capacity\n    if len(new_solution) > 2:\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        second_shortest_idx = np.argsort(route_lengths)[1]\n\n        route1 = new_solution[shortest_idx]\n        route2 = new_solution[second_shortest_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(shortest_idx, second_shortest_idx))\n            new_solution.pop(min(shortest_idx, second_shortest_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: (1) Segment routes, (2) Reassign customers, (3) Swap customers between routes\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Segment route into two parts and attempt reassignment\n        split_pos = len(route) // 2\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Check if reassignment improves makespan or distance\n        def is_valid_reassignment(segment, target_route):\n            total_demand = sum(demand[node] for node in segment if node != 0)\n            return total_demand <= capacity\n\n        # Try to reassign segment1 to another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n            if is_valid_reassignment(segment1, other_route):\n                # Reassign segment1 to other_route by merging\n                new_other_route = np.concatenate([other_route[:-1], segment1[1:]])\n                if sum(demand[node] for node in new_other_route if node != 0) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n                    new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n                    break\n\n        # Step 2: Swap customers between routes to balance makespan\n        if len(new_solution) > 1:\n            other_route_idx = (route_idx + 1) % len(new_solution)\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                # Try swapping a customer from route to other_route\n                for i in range(1, len(route) - 1):\n                    candidate = route[i]\n                    if demand[candidate] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                        # Temporarily remove candidate from route\n                        new_route = np.concatenate([route[:i], route[i+1:]])\n                        # Insert candidate into other_route (greedy position)\n                        best_pos = 1\n                        min_dist = float('inf')\n                        for pos in range(1, len(other_route)):\n                            dist = distance_matrix[other_route[pos-1], candidate] + distance_matrix[candidate, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = pos\n                        new_other_route = np.concatenate([other_route[:best_pos], [candidate], other_route[best_pos:]])\n                        # Update solutions\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = new_other_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7939264833203725,
            10.184300512075424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: (1) Segment routes, (2) Reassign customers, (3) Swap customers between routes\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Step 1: Segment route into two parts and attempt reassignment\n        split_pos = len(route) // 2\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Check if reassignment improves makespan or distance\n        def is_valid_reassignment(segment, target_route):\n            total_demand = sum(demand[node] for node in segment if node != 0)\n            return total_demand <= capacity\n\n        # Try to reassign segment1 to another route\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n            if is_valid_reassignment(segment1, other_route):\n                # Reassign segment1 to other_route by merging\n                new_other_route = np.concatenate([other_route[:-1], segment1[1:]])\n                if sum(demand[node] for node in new_other_route if node != 0) <= capacity:\n                    new_solution[other_route_idx] = new_other_route\n                    new_solution[route_idx] = np.concatenate([route[:split_pos], route[-1:]])\n                    break\n\n        # Step 2: Swap customers between routes to balance makespan\n        if len(new_solution) > 1:\n            other_route_idx = (route_idx + 1) % len(new_solution)\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                # Try swapping a customer from route to other_route\n                for i in range(1, len(route) - 1):\n                    candidate = route[i]\n                    if demand[candidate] + sum(demand[node] for node in other_route if node != 0) <= capacity:\n                        # Temporarily remove candidate from route\n                        new_route = np.concatenate([route[:i], route[i+1:]])\n                        # Insert candidate into other_route (greedy position)\n                        best_pos = 1\n                        min_dist = float('inf')\n                        for pos in range(1, len(other_route)):\n                            dist = distance_matrix[other_route[pos-1], candidate] + distance_matrix[candidate, other_route[pos]] - distance_matrix[other_route[pos-1], other_route[pos]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = pos\n                        new_other_route = np.concatenate([other_route[:best_pos], [candidate], other_route[best_pos:]])\n                        # Update solutions\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = new_other_route\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The algorithm selects a solution from the archive with high total distance and low makespan, then applies a hybrid local search combining route splitting and cross-exchange operations to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting and cross-exchange\n    for _ in range(5):  # Number of iterations\n        # Select a random route to split or exchange\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            # Try route splitting\n            if len(route) > 4:  # Ensure route can be split\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n\n                # Check feasibility\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution.pop(route_idx)\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                    continue\n\n            # Try cross-exchange with another route\n            if len(new_solution) > 1:\n                other_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_idx]\n\n                # Find feasible cross-exchange points\n                feasible_pairs = []\n                for i in range(1, len(route) - 1):\n                    for j in range(1, len(other_route) - 1):\n                        # Check capacity constraints\n                        if (np.sum(demand[route[1:i]]) + np.sum(demand[other_route[j:-1]]) <= capacity and\n                            np.sum(demand[route[i:-1]]) + np.sum(demand[other_route[1:j]]) <= capacity):\n                            feasible_pairs.append((i, j))\n\n                if feasible_pairs:\n                    i, j = random.choice(feasible_pairs)\n                    # Perform cross-exchange\n                    new_route1 = np.concatenate((route[:i], other_route[j:-1], route[i:-1]))\n                    new_route2 = np.concatenate((other_route[:j], route[i:-1], other_route[j:-1]))\n\n                    # Update solution\n                    new_solution[route_idx] = new_route1\n                    new_solution[other_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7481666027974863,
            1.335505336523056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting and cross-exchange\n    for _ in range(5):  # Number of iterations\n        # Select a random route to split or exchange\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            # Try route splitting\n            if len(route) > 4:  # Ensure route can be split\n                split_pos = random.randint(2, len(route) - 3)\n                new_route1 = np.concatenate((route[:split_pos], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos:]))\n\n                # Check feasibility\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution.pop(route_idx)\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                    continue\n\n            # Try cross-exchange with another route\n            if len(new_solution) > 1:\n                other_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_idx]\n\n                # Find feasible cross-exchange points\n                feasible_pairs = []\n                for i in range(1, len(route) - 1):\n                    for j in range(1, len(other_route) - 1):\n                        # Check capacity constraints\n                        if (np.sum(demand[route[1:i]]) + np.sum(demand[other_route[j:-1]]) <= capacity and\n                            np.sum(demand[route[i:-1]]) + np.sum(demand[other_route[1:j]]) <= capacity):\n                            feasible_pairs.append((i, j))\n\n                if feasible_pairs:\n                    i, j = random.choice(feasible_pairs)\n                    # Perform cross-exchange\n                    new_route1 = np.concatenate((route[:i], other_route[j:-1], route[i:-1]))\n                    new_route2 = np.concatenate((other_route[:j], route[i:-1], other_route[j:-1]))\n\n                    # Update solution\n                    new_solution[route_idx] = new_route1\n                    new_solution[other_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm combines a route-splitting heuristic with a demand-aware 2-opt* move to balance distance and makespan objectives, while ensuring capacity constraints are met by dynamically adjusting route segments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)  # Select from top 25%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify (bias toward longer routes)\n    route_probs = np.array([len(route) for route in new_solution])\n    route_probs = route_probs / np.sum(route_probs)\n    selected_route_idx = np.random.choice(len(new_solution), p=route_probs)\n    selected_route = new_solution[selected_route_idx]\n\n    # Split the route at a random point and attempt to reinsert segments\n    if len(selected_route) > 4:  # Ensure route has enough nodes to split\n        split_pos = random.randint(2, len(selected_route) - 3)\n        segment1 = selected_route[:split_pos]\n        segment2 = selected_route[split_pos:-1]\n\n        # Calculate demands for segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        # Check if segments can be valid routes (demand <= capacity)\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new segments\n            new_solution[selected_route_idx] = np.concatenate([segment1, [0]])\n            new_solution.append(np.concatenate([[0], segment2, [0]]))\n        else:\n            # Attempt demand-aware 2-opt* move: swap segments between routes\n            for i in range(len(new_solution)):\n                if i == selected_route_idx:\n                    continue\n                other_route = new_solution[i]\n                if len(other_route) < 3:\n                    continue\n\n                # Try swapping segments between routes while respecting capacity\n                for j in range(1, len(segment1) - 1):\n                    for k in range(1, len(other_route) - 1):\n                        # Check capacity constraints\n                        if (demand1 - demand[segment1[j]] + demand[other_route[k]] <= capacity and\n                            demand2 + demand[segment1[j]] - demand[other_route[k]] <= capacity):\n                            # Perform the swap\n                            temp = segment1[j]\n                            segment1[j] = other_route[k]\n                            other_route[k] = temp\n                            break\n\n    # Ensure all routes are feasible (demand <= capacity)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7255697979095436,
            1.1513109803199768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)  # Select from top 25%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Randomly select a route to modify (bias toward longer routes)\n    route_probs = np.array([len(route) for route in new_solution])\n    route_probs = route_probs / np.sum(route_probs)\n    selected_route_idx = np.random.choice(len(new_solution), p=route_probs)\n    selected_route = new_solution[selected_route_idx]\n\n    # Split the route at a random point and attempt to reinsert segments\n    if len(selected_route) > 4:  # Ensure route has enough nodes to split\n        split_pos = random.randint(2, len(selected_route) - 3)\n        segment1 = selected_route[:split_pos]\n        segment2 = selected_route[split_pos:-1]\n\n        # Calculate demands for segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        # Check if segments can be valid routes (demand <= capacity)\n        if demand1 <= capacity and demand2 <= capacity:\n            # Replace the original route with the two new segments\n            new_solution[selected_route_idx] = np.concatenate([segment1, [0]])\n            new_solution.append(np.concatenate([[0], segment2, [0]]))\n        else:\n            # Attempt demand-aware 2-opt* move: swap segments between routes\n            for i in range(len(new_solution)):\n                if i == selected_route_idx:\n                    continue\n                other_route = new_solution[i]\n                if len(other_route) < 3:\n                    continue\n\n                # Try swapping segments between routes while respecting capacity\n                for j in range(1, len(segment1) - 1):\n                    for k in range(1, len(other_route) - 1):\n                        # Check capacity constraints\n                        if (demand1 - demand[segment1[j]] + demand[other_route[k]] <= capacity and\n                            demand2 + demand[segment1[j]] - demand[other_route[k]] <= capacity):\n                            # Perform the swap\n                            temp = segment1[j]\n                            segment1[j] = other_route[k]\n                            other_route[k] = temp\n                            break\n\n    # Ensure all routes are feasible (demand <= capacity)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of total distance and makespan, then applies a hybrid local search operator that combines route splitting, customer reinsertion with demand-aware placement, and a makespan-aware 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reinsertion, and makespan-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split a long route into two)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(longest_route)-2)\n            new_route1 = longest_route[:split_pos+1]\n            new_route2 = [0] + longest_route[split_pos+1:]\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Customer reinsertion with demand-aware placement\n    for route in new_solution:\n        if len(route) > 3:  # Only process routes with customers\n            # Remove a random customer (not depot)\n            remove_pos = random.randint(1, len(route)-2)\n            removed_customer = route[remove_pos]\n            route = np.delete(route, remove_pos)\n\n            # Find best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route)):\n                new_route = np.insert(route, i, removed_customer)\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[new_route[i-1]][removed_customer] + distance_matrix[removed_customer][new_route[i]] - distance_matrix[new_route[i-1]][new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            route = np.insert(route, best_pos, removed_customer)\n\n    # Step 3: Makespan-aware 2-opt (focus on reducing longest routes)\n    for route in new_solution:\n        if len(route) > 3:\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n            if (sum(demand[new_route[1:-1]]) <= capacity and\n                sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1)) <\n                sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))):\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7879323470146513,
            10.269379407167435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer reinsertion, and makespan-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Route splitting (split a long route into two)\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(longest_route)-2)\n            new_route1 = longest_route[:split_pos+1]\n            new_route2 = [0] + longest_route[split_pos+1:]\n\n            # Check capacity feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 2: Customer reinsertion with demand-aware placement\n    for route in new_solution:\n        if len(route) > 3:  # Only process routes with customers\n            # Remove a random customer (not depot)\n            remove_pos = random.randint(1, len(route)-2)\n            removed_customer = route[remove_pos]\n            route = np.delete(route, remove_pos)\n\n            # Find best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(route)):\n                new_route = np.insert(route, i, removed_customer)\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[new_route[i-1]][removed_customer] + distance_matrix[removed_customer][new_route[i]] - distance_matrix[new_route[i-1]][new_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            route = np.insert(route, best_pos, removed_customer)\n\n    # Step 3: Makespan-aware 2-opt (focus on reducing longest routes)\n    for route in new_solution:\n        if len(route) > 3:\n            i, j = sorted(random.sample(range(1, len(route)-1), 2))\n            new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n            if (sum(demand[new_route[1:-1]]) <= capacity and\n                sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1)) <\n                sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))):\n                route[:] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel hybrid local search strategy combines route segment swaps with adaptive capacity-aware relocations, where segments are intelligently selected based on the trade-off between distance and makespan reduction, and relocations are constrained by vehicle capacity to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segment swap + adaptive relocation\n    if len(new_solution) >= 2:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Split points (not including depot)\n            split_i = np.random.randint(1, len(route_i) - 1)\n            split_j = np.random.randint(1, len(route_j) - 1)\n\n            # Extract segments\n            segment_i = route_i[split_i:-1]\n            segment_j = route_j[split_j:-1]\n\n            # Check capacity constraints for swaps\n            demand_i = np.sum(demand[segment_i])\n            demand_j = np.sum(demand[segment_j])\n            if (np.sum(demand[route_i]) - demand_i + demand_j <= capacity and\n                np.sum(demand[route_j]) - demand_j + demand_i <= capacity):\n\n                # Perform segment swap\n                new_route_i = np.concatenate([route_i[:split_i], segment_j, route_i[-1:]])\n                new_route_j = np.concatenate([route_j[:split_j], segment_i, route_j[-1:]])\n\n                # Update routes\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Adaptive relocation: Move a customer to a different route if beneficial\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 2:\n            # Select a random customer (not depot)\n            customer = np.random.choice(route[1:-1])\n            customer_idx = np.where(route == customer)[0][0]\n\n            # Try to relocate to another route\n            for m in range(len(new_solution)):\n                if m != k:\n                    candidate_route = new_solution[m]\n                    if np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                        # Insert customer into candidate route (greedy position)\n                        best_pos = 1  # Default insert after depot\n                        best_dist = float('inf')\n                        for pos in range(1, len(candidate_route)):\n                            # Try inserting at position pos\n                            temp_route = np.concatenate([\n                                candidate_route[:pos],\n                                [customer],\n                                candidate_route[pos:]\n                            ])\n                            # Calculate distance change\n                            dist_change = (distance_matrix[temp_route[pos-1], customer] +\n                                          distance_matrix[customer, temp_route[pos+1]] -\n                                          distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n                            if dist_change < best_dist:\n                                best_dist = dist_change\n                                best_pos = pos\n\n                        # Perform insertion\n                        new_route = np.concatenate([\n                            candidate_route[:best_pos],\n                            [customer],\n                            candidate_route[best_pos:]\n                        ])\n                        new_solution[m] = new_route\n\n                        # Remove from original route\n                        new_solution[k] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n                        # Break after successful relocation\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6573512776146109,
            4.78740006685257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route segment swap + adaptive relocation\n    if len(new_solution) >= 2:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Select a random segment from each route (excluding depot)\n        if len(route_i) > 2 and len(route_j) > 2:\n            # Split points (not including depot)\n            split_i = np.random.randint(1, len(route_i) - 1)\n            split_j = np.random.randint(1, len(route_j) - 1)\n\n            # Extract segments\n            segment_i = route_i[split_i:-1]\n            segment_j = route_j[split_j:-1]\n\n            # Check capacity constraints for swaps\n            demand_i = np.sum(demand[segment_i])\n            demand_j = np.sum(demand[segment_j])\n            if (np.sum(demand[route_i]) - demand_i + demand_j <= capacity and\n                np.sum(demand[route_j]) - demand_j + demand_i <= capacity):\n\n                # Perform segment swap\n                new_route_i = np.concatenate([route_i[:split_i], segment_j, route_i[-1:]])\n                new_route_j = np.concatenate([route_j[:split_j], segment_i, route_j[-1:]])\n\n                # Update routes\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    # Adaptive relocation: Move a customer to a different route if beneficial\n    for k in range(len(new_solution)):\n        route = new_solution[k]\n        if len(route) > 2:\n            # Select a random customer (not depot)\n            customer = np.random.choice(route[1:-1])\n            customer_idx = np.where(route == customer)[0][0]\n\n            # Try to relocate to another route\n            for m in range(len(new_solution)):\n                if m != k:\n                    candidate_route = new_solution[m]\n                    if np.sum(demand[candidate_route]) + demand[customer] <= capacity:\n                        # Insert customer into candidate route (greedy position)\n                        best_pos = 1  # Default insert after depot\n                        best_dist = float('inf')\n                        for pos in range(1, len(candidate_route)):\n                            # Try inserting at position pos\n                            temp_route = np.concatenate([\n                                candidate_route[:pos],\n                                [customer],\n                                candidate_route[pos:]\n                            ])\n                            # Calculate distance change\n                            dist_change = (distance_matrix[temp_route[pos-1], customer] +\n                                          distance_matrix[customer, temp_route[pos+1]] -\n                                          distance_matrix[temp_route[pos-1], temp_route[pos+1]])\n                            if dist_change < best_dist:\n                                best_dist = dist_change\n                                best_pos = pos\n\n                        # Perform insertion\n                        new_route = np.concatenate([\n                            candidate_route[:best_pos],\n                            [customer],\n                            candidate_route[best_pos:]\n                        ])\n                        new_solution[m] = new_route\n\n                        # Remove from original route\n                        new_solution[k] = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n                        # Break after successful relocation\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The algorithm selects a promising solution from the archive, then applies a hybrid local search operator that combines route splitting and demand-based cluster merging to balance travel distance and makespan, ensuring feasibility by verifying capacity constraints at each step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: split long routes and merge small routes based on demand proximity\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes (only depot or one customer)\n            continue\n\n        # Split route if it's too long (potential for distance reduction)\n        if np.sum([distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1)]) > np.mean([np.sum([distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)]) for r in new_solution]):\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.insert(new_route2, 0, 0)  # Ensure new route starts at depot\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Merge small routes if possible (to reduce makespan)\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible (demand and capacity)\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand > capacity:\n                continue\n\n            # Calculate merged route distance\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            merged_distance = np.sum([distance_matrix[merged_route[k]][merged_route[k+1]] for k in range(len(merged_route)-1)])\n\n            # Compare with original distances\n            original_distance = (np.sum([distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)]) +\n                                np.sum([distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1)]))\n\n            if merged_distance < original_distance:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.85316862752494,
            3.866989314556122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: split long routes and merge small routes based on demand proximity\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes (only depot or one customer)\n            continue\n\n        # Split route if it's too long (potential for distance reduction)\n        if np.sum([distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1)]) > np.mean([np.sum([distance_matrix[r[j]][r[j+1]] for j in range(len(r)-1)]) for r in new_solution]):\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos+1]\n            new_route2 = route[split_pos:]\n            new_route2 = np.insert(new_route2, 0, 0)  # Ensure new route starts at depot\n\n            # Check capacity feasibility\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break\n\n    # Merge small routes if possible (to reduce makespan)\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible (demand and capacity)\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand > capacity:\n                continue\n\n            # Calculate merged route distance\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            merged_distance = np.sum([distance_matrix[merged_route[k]][merged_route[k+1]] for k in range(len(merged_route)-1)])\n\n            # Compare with original distances\n            original_distance = (np.sum([distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1)]) +\n                                np.sum([distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1)]))\n\n            if merged_distance < original_distance:\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{A novel hybrid local search operator combines route fragmentation and segment reinsertion with capacity-aware crossover, intelligently selecting and recombining route segments to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Prioritize solutions with lower combined objectives\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)  # Select from top half to avoid too good solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route fragmentation and segment reinsertion with capacity-aware crossover\n    if len(new_solution) > 1:\n        # Step 1: Select a target route to modify\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        # Step 2: Fragment the route into segments\n        if len(target_route) > 4:  # Need at least 4 nodes to fragment (start, end, and two customers)\n            # Select a random segment to extract\n            start_idx = random.randint(1, len(target_route) - 3)\n            end_idx = random.randint(start_idx + 1, len(target_route) - 2)\n            segment = target_route[start_idx:end_idx]\n\n            # Calculate segment demand\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Step 3: Find a suitable insertion point in another route\n            for i in range(len(new_solution)):\n                if i != target_route_idx:\n                    candidate_route = new_solution[i]\n                    candidate_demand = sum(demand[node] for node in candidate_route[1:-1])\n\n                    # Check if adding segment doesn't exceed capacity\n                    if candidate_demand + segment_demand <= capacity:\n                        # Find best insertion position in candidate route\n                        best_pos = 1  # Default to after depot\n                        best_cost = float('inf')\n\n                        for pos in range(1, len(candidate_route)):\n                            # Insert segment at position pos\n                            new_route = np.concatenate([candidate_route[:pos], segment, candidate_route[pos:]])\n                            # Calculate new route distance\n                            route_distance = 0\n                            for j in range(len(new_route) - 1):\n                                route_distance += distance_matrix[new_route[j], new_route[j+1]]\n\n                            # Consider both distance increase and makespan impact\n                            current_makespan = max(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route) - 1))\n                            cost = route_distance + current_makespan\n\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform the best insertion\n                        new_solution[i] = np.concatenate([candidate_route[:best_pos], segment, candidate_route[best_pos:]])\n                        # Remove segment from original route\n                        new_solution[target_route_idx] = np.concatenate([target_route[:start_idx], target_route[end_idx:]])\n\n                        # If original route becomes empty (only depot-depot), remove it\n                        if len(new_solution[target_route_idx]) <= 2:\n                            new_solution.pop(target_route_idx)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5826793726676525,
            1.0377392768859863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Prioritize solutions with lower combined objectives\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)  # Select from top half to avoid too good solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route fragmentation and segment reinsertion with capacity-aware crossover\n    if len(new_solution) > 1:\n        # Step 1: Select a target route to modify\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        # Step 2: Fragment the route into segments\n        if len(target_route) > 4:  # Need at least 4 nodes to fragment (start, end, and two customers)\n            # Select a random segment to extract\n            start_idx = random.randint(1, len(target_route) - 3)\n            end_idx = random.randint(start_idx + 1, len(target_route) - 2)\n            segment = target_route[start_idx:end_idx]\n\n            # Calculate segment demand\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Step 3: Find a suitable insertion point in another route\n            for i in range(len(new_solution)):\n                if i != target_route_idx:\n                    candidate_route = new_solution[i]\n                    candidate_demand = sum(demand[node] for node in candidate_route[1:-1])\n\n                    # Check if adding segment doesn't exceed capacity\n                    if candidate_demand + segment_demand <= capacity:\n                        # Find best insertion position in candidate route\n                        best_pos = 1  # Default to after depot\n                        best_cost = float('inf')\n\n                        for pos in range(1, len(candidate_route)):\n                            # Insert segment at position pos\n                            new_route = np.concatenate([candidate_route[:pos], segment, candidate_route[pos:]])\n                            # Calculate new route distance\n                            route_distance = 0\n                            for j in range(len(new_route) - 1):\n                                route_distance += distance_matrix[new_route[j], new_route[j+1]]\n\n                            # Consider both distance increase and makespan impact\n                            current_makespan = max(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route) - 1))\n                            cost = route_distance + current_makespan\n\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform the best insertion\n                        new_solution[i] = np.concatenate([candidate_route[:best_pos], segment, candidate_route[best_pos:]])\n                        # Remove segment from original route\n                        new_solution[target_route_idx] = np.concatenate([target_route[:start_idx], target_route[end_idx:]])\n\n                        # If original route becomes empty (only depot-depot), remove it\n                        if len(new_solution[target_route_idx]) <= 2:\n                            new_solution.pop(target_route_idx)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted random choice favoring lower makespan and total distance, then applies a hybrid local search combining route-splitting and demand-based insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting and demand-based insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraint for the split parts\n        demand_part1 = sum(demand[part1])\n        demand_part2 = sum(demand[part2])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two split parts\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Demand-based insertion: move nodes between routes if it improves makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            # Try to move a random node from route i to route j\n            route_i = new_solution[i]\n            if len(route_i) <= 2:  # Skip if only depot nodes\n                continue\n\n            node_pos = np.random.randint(1, len(route_i) - 1)\n            node = route_i[node_pos]\n\n            # Check if adding the node to route j would exceed capacity\n            if sum(demand[new_solution[j]]) + demand[node] <= capacity:\n                # Insert the node into route j at a random position\n                insert_pos = np.random.randint(1, len(new_solution[j]))\n                new_route_j = new_solution[j].copy()\n                new_route_j = np.insert(new_route_j, insert_pos, node)\n\n                # Update the routes\n                new_solution[j] = new_route_j\n                new_solution[i] = np.delete(route_i, node_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.72024006405808,
            8.666736334562302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-splitting and demand-based insertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraint for the split parts\n        demand_part1 = sum(demand[part1])\n        demand_part2 = sum(demand[part2])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Replace the original route with the two split parts\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Demand-based insertion: move nodes between routes if it improves makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n\n            # Try to move a random node from route i to route j\n            route_i = new_solution[i]\n            if len(route_i) <= 2:  # Skip if only depot nodes\n                continue\n\n            node_pos = np.random.randint(1, len(route_i) - 1)\n            node = route_i[node_pos]\n\n            # Check if adding the node to route j would exceed capacity\n            if sum(demand[new_solution[j]]) + demand[node] <= capacity:\n                # Insert the node into route j at a random position\n                insert_pos = np.random.randint(1, len(new_solution[j]))\n                new_route_j = new_solution[j].copy()\n                new_route_j = np.insert(new_route_j, insert_pos, node)\n\n                # Update the routes\n                new_solution[j] = new_route_j\n                new_solution[i] = np.delete(route_i, node_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with large makespan\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Route Merging + Customer Reallocation + Route Splitting\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if their combined demand fits in a vehicle\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argmin([l if i != shortest_route_idx else float('inf') for i, l in enumerate(route_lengths)])\n\n        route1 = new_solution[shortest_route_idx]\n        route2 = new_solution[second_shortest_route_idx]\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if combined_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if i == shortest_route_idx else route for i, route in enumerate(new_solution) if i != second_shortest_route_idx]\n\n            # Step 2: Reallocate customers from the merged route to other routes if possible\n            for i in range(len(new_solution)):\n                if i != shortest_route_idx:\n                    for j in range(1, len(merged_route)-1):\n                        customer = merged_route[j]\n                        if sum(demand[new_solution[i][1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into the route\n                            insert_pos = np.argmin([distance_matrix[new_solution[i][k]][customer] + distance_matrix[customer][new_solution[i][k+1]] - distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)])\n                            new_solution[i] = np.insert(new_solution[i], insert_pos+1, customer)\n                            merged_route = np.delete(merged_route, j)\n                            break\n\n            # Step 3: Split the merged route if it exceeds capacity\n            current_load = 0\n            split_positions = [0]\n            for j in range(1, len(merged_route)-1):\n                current_load += demand[merged_route[j]]\n                if current_load > capacity:\n                    split_positions.append(j)\n                    current_load = demand[merged_route[j]]\n            split_positions.append(len(merged_route)-1)\n\n            if len(split_positions) > 2:\n                split_routes = [np.concatenate([[0], merged_route[split_positions[i]:split_positions[i+1]], [0]]) for i in range(len(split_positions)-1)]\n                new_solution = [route for route in new_solution if route is not merged_route] + split_routes\n\n    return new_solution\n\n",
        "score": [
            -0.7760262870150093,
            2.1599916517734528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])  # Prioritize solutions with large makespan\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Route Merging + Customer Reallocation + Route Splitting\n    if len(new_solution) > 1:\n        # Step 1: Merge two shortest routes if their combined demand fits in a vehicle\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_route_idx = np.argmin(route_lengths)\n        second_shortest_route_idx = np.argmin([l if i != shortest_route_idx else float('inf') for i, l in enumerate(route_lengths)])\n\n        route1 = new_solution[shortest_route_idx]\n        route2 = new_solution[second_shortest_route_idx]\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n        if combined_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if i == shortest_route_idx else route for i, route in enumerate(new_solution) if i != second_shortest_route_idx]\n\n            # Step 2: Reallocate customers from the merged route to other routes if possible\n            for i in range(len(new_solution)):\n                if i != shortest_route_idx:\n                    for j in range(1, len(merged_route)-1):\n                        customer = merged_route[j]\n                        if sum(demand[new_solution[i][1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into the route\n                            insert_pos = np.argmin([distance_matrix[new_solution[i][k]][customer] + distance_matrix[customer][new_solution[i][k+1]] - distance_matrix[new_solution[i][k]][new_solution[i][k+1]] for k in range(len(new_solution[i])-1)])\n                            new_solution[i] = np.insert(new_solution[i], insert_pos+1, customer)\n                            merged_route = np.delete(merged_route, j)\n                            break\n\n            # Step 3: Split the merged route if it exceeds capacity\n            current_load = 0\n            split_positions = [0]\n            for j in range(1, len(merged_route)-1):\n                current_load += demand[merged_route[j]]\n                if current_load > capacity:\n                    split_positions.append(j)\n                    current_load = demand[merged_route[j]]\n            split_positions.append(len(merged_route)-1)\n\n            if len(split_positions) > 2:\n                split_routes = [np.concatenate([[0], merged_route[split_positions[i]:split_positions[i+1]], [0]]) for i in range(len(split_positions)-1)]\n                new_solution = [route for route in new_solution if route is not merged_route] + split_routes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with lower total distance and makespan, then applies a hybrid local search operator that combines route segment swaps with demand-aware route splitting to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route segment swaps and demand-aware route splitting\n    if len(new_solution) > 1:\n        # Step 1: Select two random routes\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[:2]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Select a random segment from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start + 1, len(route1) - 1)\n        segment1 = route1[segment1_start:segment1_end]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start + 1, len(route2) - 1)\n        segment2 = route2[segment2_start:segment2_end]\n\n        # Step 3: Check demand feasibility for swapping segments\n        demand1 = sum(demand[node] for node in segment1)\n        demand2 = sum(demand[node] for node in segment2)\n\n        if (sum(demand[node] for node in route1) - demand1 + demand2 <= capacity and\n            sum(demand[node] for node in route2) - demand2 + demand1 <= capacity):\n\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 4: Demand-aware route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_load = 0\n            split_positions = [0]\n\n            for j in range(1, len(route) - 1):\n                current_load += demand[route[j]]\n                if current_load > capacity * 0.7:  # Split if load exceeds 70% of capacity\n                    split_positions.append(j)\n                    current_load = demand[route[j]]\n\n            if len(split_positions) > 1:\n                split_routes = []\n                for k in range(len(split_positions) - 1):\n                    start, end = split_positions[k], split_positions[k + 1]\n                    split_routes.append(np.concatenate([[0], route[start:end], [0]]))\n\n                if len(split_routes) > 1:\n                    new_solution[i] = split_routes[0]\n                    new_solution.extend(split_routes[1:])\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.330577823845655,
            1.7092495560646057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route segment swaps and demand-aware route splitting\n    if len(new_solution) > 1:\n        # Step 1: Select two random routes\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[:2]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Select a random segment from each route (excluding depot)\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start + 1, len(route1) - 1)\n        segment1 = route1[segment1_start:segment1_end]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start + 1, len(route2) - 1)\n        segment2 = route2[segment2_start:segment2_end]\n\n        # Step 3: Check demand feasibility for swapping segments\n        demand1 = sum(demand[node] for node in segment1)\n        demand2 = sum(demand[node] for node in segment2)\n\n        if (sum(demand[node] for node in route1) - demand1 + demand2 <= capacity and\n            sum(demand[node] for node in route2) - demand2 + demand1 <= capacity):\n\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 4: Demand-aware route splitting (if a route is too long)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_load = 0\n            split_positions = [0]\n\n            for j in range(1, len(route) - 1):\n                current_load += demand[route[j]]\n                if current_load > capacity * 0.7:  # Split if load exceeds 70% of capacity\n                    split_positions.append(j)\n                    current_load = demand[route[j]]\n\n            if len(split_positions) > 1:\n                split_routes = []\n                for k in range(len(split_positions) - 1):\n                    start, end = split_positions[k], split_positions[k + 1]\n                    split_routes.append(np.concatenate([[0], route[start:end], [0]]))\n\n                if len(split_routes) > 1:\n                    new_solution[i] = split_routes[0]\n                    new_solution.extend(split_routes[1:])\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a weighted combination of its objective values, then applies a hybrid local search operator combining route splitting, customer reallocation, and cross-route 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for distance and makespan\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting: split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Ensure we can split\n            split_pos = len(long_route) // 2\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Customer reallocation: move a customer from one route to another\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            while route2_idx == route1_idx and len(new_solution) > 1:\n                route2_idx = random.randint(0, len(new_solution)-1)\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # At least one customer to move\n                # Select a random customer from route1\n                customer_pos = random.randint(1, len(route1)-2)\n                customer = route1[customer_pos]\n\n                # Check if moving to route2 is feasible\n                if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route2\n                    best_insert_pos = 1\n                    min_insert_cost = float('inf')\n                    for i in range(1, len(route2)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[route2[i-1], customer] +\n                                distance_matrix[customer, route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Update routes\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_insert_pos], [customer], route2[best_insert_pos:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Cross-route 2-opt: improve the solution further\n    for _ in range(5):  # Perform multiple iterations\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx and len(new_solution) > 1:\n            route2_idx = (route1_idx + 1) % len(new_solution)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select two edges from each route\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Calculate potential new routes\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                # Check if this improves the solution (simplified check)\n                current_cost = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                                distance_matrix[route2[pos2-1], route2[pos2]])\n                new_cost = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                            distance_matrix[route2[pos2-1], route1[pos1]])\n\n                if new_cost < current_cost:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.5483280680754596,
            1.134119838476181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for distance and makespan\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Route splitting: split a long route into two\n        long_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        long_route = new_solution[long_route_idx]\n        if len(long_route) > 3:  # Ensure we can split\n            split_pos = len(long_route) // 2\n            new_route1 = np.concatenate([long_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], long_route[split_pos:]])\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[long_route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Customer reallocation: move a customer from one route to another\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            while route2_idx == route1_idx and len(new_solution) > 1:\n                route2_idx = random.randint(0, len(new_solution)-1)\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:  # At least one customer to move\n                # Select a random customer from route1\n                customer_pos = random.randint(1, len(route1)-2)\n                customer = route1[customer_pos]\n\n                # Check if moving to route2 is feasible\n                if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route2\n                    best_insert_pos = 1\n                    min_insert_cost = float('inf')\n                    for i in range(1, len(route2)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[route2[i-1], customer] +\n                                distance_matrix[customer, route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < min_insert_cost:\n                            min_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Update routes\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_route2 = np.concatenate([route2[:best_insert_pos], [customer], route2[best_insert_pos:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Cross-route 2-opt: improve the solution further\n    for _ in range(5):  # Perform multiple iterations\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx == route2_idx and len(new_solution) > 1:\n            route2_idx = (route1_idx + 1) % len(new_solution)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select two edges from each route\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Calculate potential new routes\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                # Check if this improves the solution (simplified check)\n                current_cost = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                                distance_matrix[route2[pos2-1], route2[pos2]])\n                new_cost = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                            distance_matrix[route2[pos2-1], route1[pos1]])\n\n                if new_cost < current_cost:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in new_solution]\n\n    # Step 1: Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in routes])\n    longest_route = routes[longest_route_idx]\n\n    # Step 2: Split the longest route into two parts at a random customer\n    split_pos = np.random.randint(1, len(longest_route)-1)\n    new_route1 = longest_route[:split_pos+1]\n    new_route2 = longest_route[split_pos:]\n\n    # Ensure both new routes are feasible\n    if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n        routes[longest_route_idx] = new_route1\n        routes.insert(longest_route_idx+1, new_route2)\n    else:\n        # If splitting fails, try reallocating a random customer to another route\n        if len(routes) > 1:\n            target_route_idx = np.random.choice([i for i in range(len(routes)) if i != longest_route_idx])\n            target_route = routes[target_route_idx]\n            customer_pos = np.random.randint(1, len(longest_route)-1)\n            customer = longest_route[customer_pos]\n\n            # Check if adding the customer to the target route is feasible\n            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into the middle of the target route\n                insert_pos = np.random.randint(1, len(target_route)-1)\n                target_route = np.insert(target_route, insert_pos, customer)\n                routes[target_route_idx] = target_route\n\n                # Remove customer from the original route\n                longest_route = np.delete(longest_route, customer_pos)\n                routes[longest_route_idx] = longest_route\n\n    return np.array(routes, dtype=object)\n\n",
        "score": [
            -0.7870892703107285,
            0.2746043801307678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in new_solution]\n\n    # Step 1: Identify the longest route (highest makespan)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in routes])\n    longest_route = routes[longest_route_idx]\n\n    # Step 2: Split the longest route into two parts at a random customer\n    split_pos = np.random.randint(1, len(longest_route)-1)\n    new_route1 = longest_route[:split_pos+1]\n    new_route2 = longest_route[split_pos:]\n\n    # Ensure both new routes are feasible\n    if (sum(demand[new_route1[1:-1]]) <= capacity) and (sum(demand[new_route2[1:-1]]) <= capacity):\n        routes[longest_route_idx] = new_route1\n        routes.insert(longest_route_idx+1, new_route2)\n    else:\n        # If splitting fails, try reallocating a random customer to another route\n        if len(routes) > 1:\n            target_route_idx = np.random.choice([i for i in range(len(routes)) if i != longest_route_idx])\n            target_route = routes[target_route_idx]\n            customer_pos = np.random.randint(1, len(longest_route)-1)\n            customer = longest_route[customer_pos]\n\n            # Check if adding the customer to the target route is feasible\n            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into the middle of the target route\n                insert_pos = np.random.randint(1, len(target_route)-1)\n                target_route = np.insert(target_route, insert_pos, customer)\n                routes[target_route_idx] = target_route\n\n                # Remove customer from the original route\n                longest_route = np.delete(longest_route, customer_pos)\n                routes[longest_route_idx] = longest_route\n\n    return np.array(routes, dtype=object)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection favoring better non-dominated solutions, then applies a hybrid local search combining route splitting, customer insertion, and demand-aware swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer insertion + demand-aware swapping\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n\n        # Find a split point that balances load\n        total_demand = sum(demand[split_route[1:-1]])\n        split_point = 1\n        current_demand = 0\n        for i in range(1, len(split_route) - 1):\n            current_demand += demand[split_route[i]]\n            if current_demand > total_demand / 2:\n                split_point = i\n                break\n\n        # Split the route into two parts\n        new_route1 = np.concatenate([split_route[:split_point+1], [0]])\n        new_route2 = np.concatenate([[0], split_route[split_point+1:]])\n\n        # Replace the original route with the two new routes\n        new_solution.pop(split_route_idx)\n        new_solution.insert(split_route_idx, new_route1)\n        new_solution.insert(split_route_idx, new_route2)\n\n    # Step 2: Customer insertion from one route to another\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Select a customer from route1 to move to route2\n        if len(route1) > 2:\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if moving the customer to route2 is feasible\n            if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                new_solution[route_indices[0]] = new_route1\n\n                # Insert customer into route2 (find best position)\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Insert customer between route2[i-1] and route2[i]\n                    new_route = np.concatenate([route2[:i], [customer], route2[i:]])\n                    cost = (distance_matrix[route2[i-1], customer] +\n                            distance_matrix[customer, route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert customer at best position\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route_indices[1]] = new_route2\n\n    # Step 3: Demand-aware swapping between routes\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find pairs of customers where swapping balances demand\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                customer1, customer2 = route1[i], route2[j]\n                demand1, demand2 = demand[customer1], demand[customer2]\n\n                # Check if swapping balances demand\n                if abs((sum(demand[route1[1:-1]]) - demand1 + demand2) -\n                       (sum(demand[route2[1:-1]]) - demand2 + demand1)) <= 1:\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:-1]]) - demand1 + demand2 <= capacity and\n                        sum(demand[route2[1:-1]]) - demand2 + demand1 <= capacity):\n                        # Perform the swap\n                        new_route1 = route1.copy()\n                        new_route2 = route2.copy()\n                        new_route1[i], new_route2[j] = new_route2[j], new_route1[i]\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.741703552327672,
            1.1276395916938782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + customer insertion + demand-aware swapping\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n\n        # Find a split point that balances load\n        total_demand = sum(demand[split_route[1:-1]])\n        split_point = 1\n        current_demand = 0\n        for i in range(1, len(split_route) - 1):\n            current_demand += demand[split_route[i]]\n            if current_demand > total_demand / 2:\n                split_point = i\n                break\n\n        # Split the route into two parts\n        new_route1 = np.concatenate([split_route[:split_point+1], [0]])\n        new_route2 = np.concatenate([[0], split_route[split_point+1:]])\n\n        # Replace the original route with the two new routes\n        new_solution.pop(split_route_idx)\n        new_solution.insert(split_route_idx, new_route1)\n        new_solution.insert(split_route_idx, new_route2)\n\n    # Step 2: Customer insertion from one route to another\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Select a customer from route1 to move to route2\n        if len(route1) > 2:\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if moving the customer to route2 is feasible\n            if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                new_solution[route_indices[0]] = new_route1\n\n                # Insert customer into route2 (find best position)\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    # Insert customer between route2[i-1] and route2[i]\n                    new_route = np.concatenate([route2[:i], [customer], route2[i:]])\n                    cost = (distance_matrix[route2[i-1], customer] +\n                            distance_matrix[customer, route2[i]] -\n                            distance_matrix[route2[i-1], route2[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Insert customer at best position\n                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                new_solution[route_indices[1]] = new_route2\n\n    # Step 3: Demand-aware swapping between routes\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Find pairs of customers where swapping balances demand\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                customer1, customer2 = route1[i], route2[j]\n                demand1, demand2 = demand[customer1], demand[customer2]\n\n                # Check if swapping balances demand\n                if abs((sum(demand[route1[1:-1]]) - demand1 + demand2) -\n                       (sum(demand[route2[1:-1]]) - demand2 + demand1)) <= 1:\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:-1]]) - demand1 + demand2 <= capacity and\n                        sum(demand[route2[1:-1]]) - demand2 + demand1 <= capacity):\n                        # Perform the swap\n                        new_route1 = route1.copy()\n                        new_route2 = route2.copy()\n                        new_route1[i], new_route2[j] = new_route2[j], new_route1[i]\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection based on Pareto dominance and objective values, then applies a hybrid local search combining route-splitting and demand-aware relocations to improve both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1) for _, obj in archive]  # Inverse sum of objectives\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware relocations\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Route-splitting: split long routes into two\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([route1, route2])\n            continue\n\n        # If splitting violates capacity, apply demand-aware relocations\n        if demand1 > capacity:\n            # Sort customers by distance to depot to prioritize relocations\n            customers = route1[1:-1]\n            customers_sorted = sorted(customers, key=lambda x: distance_matrix[x][0], reverse=True)\n            for customer in customers_sorted:\n                # Try to relocate customer to another route\n                relocated = False\n                for other_route in new_solution:\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into other_route at the cheapest position\n                        min_insert_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(other_route)):\n                            insert_cost = (distance_matrix[other_route[i-1]][customer] +\n                                         distance_matrix[customer][other_route[i]] -\n                                         distance_matrix[other_route[i-1]][other_route[i]])\n                            if insert_cost < min_insert_cost:\n                                min_insert_cost = insert_cost\n                                best_pos = i\n                        if best_pos != -1:\n                            other_route = np.insert(other_route, best_pos, customer)\n                            route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                            relocated = True\n                            break\n                if not relocated:\n                    # If relocation fails, keep original route\n                    new_solution.append(route1)\n                    break\n        else:\n            new_solution.append(route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7743609734158692,
            0.4407157599925995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1) for _, obj in archive]  # Inverse sum of objectives\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware relocations\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Route-splitting: split long routes into two\n        split_pos = len(route) // 2\n        route1 = route[:split_pos + 1]\n        route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity constraints\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution.extend([route1, route2])\n            continue\n\n        # If splitting violates capacity, apply demand-aware relocations\n        if demand1 > capacity:\n            # Sort customers by distance to depot to prioritize relocations\n            customers = route1[1:-1]\n            customers_sorted = sorted(customers, key=lambda x: distance_matrix[x][0], reverse=True)\n            for customer in customers_sorted:\n                # Try to relocate customer to another route\n                relocated = False\n                for other_route in new_solution:\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into other_route at the cheapest position\n                        min_insert_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(other_route)):\n                            insert_cost = (distance_matrix[other_route[i-1]][customer] +\n                                         distance_matrix[customer][other_route[i]] -\n                                         distance_matrix[other_route[i-1]][other_route[i]])\n                            if insert_cost < min_insert_cost:\n                                min_insert_cost = insert_cost\n                                best_pos = i\n                        if best_pos != -1:\n                            other_route = np.insert(other_route, best_pos, customer)\n                            route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                            relocated = True\n                            break\n                if not relocated:\n                    # If relocation fails, keep original route\n                    new_solution.append(route1)\n                    break\n        else:\n            new_solution.append(route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel hybrid local search: \"Route Shuffling and Segment Reallocation\"\n    # 1. Shuffle the order of routes to break initial structure\n    np.random.shuffle(new_solution)\n\n    # 2. For each route, try to reallocate segments to other routes if it improves makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Try splitting the route into two segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate demands for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        # Try to merge segment1 with another route if feasible\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j].copy()\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            # Check if merging segment1 with other_route is feasible\n            if demand1 + other_demand <= capacity:\n                # Create new route by merging\n                merged_route = np.concatenate([other_route[:-1], segment1[1:]])\n                new_solution[j] = merged_route\n                new_solution[i] = segment2\n                break\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # If infeasible, split the route into smaller parts\n            current_route = route.copy()\n            while np.sum(demand[current_route[1:-1]]) > capacity:\n                # Find the last customer that can be kept without exceeding capacity\n                cumulative_demand = 0\n                split_pos = len(current_route) - 1\n                for k in range(1, len(current_route) - 1):\n                    cumulative_demand += demand[current_route[k]]\n                    if cumulative_demand > capacity:\n                        split_pos = k\n                        break\n                # Create a new route with the split segment\n                new_route = np.concatenate([current_route[:split_pos + 1], [0]])\n                new_solution.append(new_route)\n                current_route = np.concatenate([[0], current_route[split_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8599808627442489,
            1.749063640832901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel hybrid local search: \"Route Shuffling and Segment Reallocation\"\n    # 1. Shuffle the order of routes to break initial structure\n    np.random.shuffle(new_solution)\n\n    # 2. For each route, try to reallocate segments to other routes if it improves makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i].copy()\n        if len(route) <= 3:  # Skip routes with only depot and one customer\n            continue\n\n        # Try splitting the route into two segments\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Calculate demands for both segments\n        demand1 = np.sum(demand[segment1[1:-1]])\n        demand2 = np.sum(demand[segment2[1:-1]])\n\n        # Try to merge segment1 with another route if feasible\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j].copy()\n            other_demand = np.sum(demand[other_route[1:-1]])\n\n            # Check if merging segment1 with other_route is feasible\n            if demand1 + other_demand <= capacity:\n                # Create new route by merging\n                merged_route = np.concatenate([other_route[:-1], segment1[1:]])\n                new_solution[j] = merged_route\n                new_solution[i] = segment2\n                break\n\n    # Ensure all routes are feasible (capacity constraint)\n    for route in new_solution:\n        route_demand = np.sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # If infeasible, split the route into smaller parts\n            current_route = route.copy()\n            while np.sum(demand[current_route[1:-1]]) > capacity:\n                # Find the last customer that can be kept without exceeding capacity\n                cumulative_demand = 0\n                split_pos = len(current_route) - 1\n                for k in range(1, len(current_route) - 1):\n                    cumulative_demand += demand[current_route[k]]\n                    if cumulative_demand > capacity:\n                        split_pos = k\n                        break\n                # Create a new route with the split segment\n                new_route = np.concatenate([current_route[:split_pos + 1], [0]])\n                new_solution.append(new_route)\n                current_route = np.concatenate([[0], current_route[split_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route-segment swaps and demand-balanced route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: route-segment swap + demand-balanced route merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments and attempt swaps\n        split_pos = random.randint(1, len(route) - 2)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Try to merge with another route or swap segments\n        merged = False\n        for i, other_route in enumerate(selected_solution):\n            if other_route is route:\n                continue\n\n            # Check if merging segments is feasible\n            total_demand = sum(demand[node] for node in segment2[1:-1])\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n            if other_demand + total_demand <= capacity:\n                # Merge segments\n                new_route = np.concatenate([segment1, other_route[1:-1], [0]])\n                if len(new_route) > 2:  # Ensure non-trivial route\n                    new_solution.append(new_route)\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n\n    missing_nodes = [i for i in range(1, len(demand)) if i not in served_nodes]\n    if missing_nodes:\n        # Create new routes for missing nodes\n        remaining_capacity = capacity\n        current_route = [0]\n        for node in missing_nodes:\n            if demand[node] <= remaining_capacity:\n                current_route.append(node)\n                remaining_capacity -= demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                remaining_capacity = capacity - demand[node]\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "score": [
            -0.8476990402763709,
            1.9377987384796143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: route-segment swap + demand-balanced route merging\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments and attempt swaps\n        split_pos = random.randint(1, len(route) - 2)\n        segment1 = route[:split_pos + 1]\n        segment2 = route[split_pos:]\n\n        # Try to merge with another route or swap segments\n        merged = False\n        for i, other_route in enumerate(selected_solution):\n            if other_route is route:\n                continue\n\n            # Check if merging segments is feasible\n            total_demand = sum(demand[node] for node in segment2[1:-1])\n            other_demand = sum(demand[node] for node in other_route[1:-1])\n            if other_demand + total_demand <= capacity:\n                # Merge segments\n                new_route = np.concatenate([segment1, other_route[1:-1], [0]])\n                if len(new_route) > 2:  # Ensure non-trivial route\n                    new_solution.append(new_route)\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    served_nodes = set()\n    for route in new_solution:\n        served_nodes.update(route[1:-1])\n\n    missing_nodes = [i for i in range(1, len(demand)) if i not in served_nodes]\n    if missing_nodes:\n        # Create new routes for missing nodes\n        remaining_capacity = capacity\n        current_route = [0]\n        for node in missing_nodes:\n            if demand[node] <= remaining_capacity:\n                current_route.append(node)\n                remaining_capacity -= demand[node]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, node]\n                remaining_capacity = capacity - demand[node]\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted ranking of objectives, then applies a hybrid local search combining route segmentation, customer reinsertion with capacity checks, and a novel \"route merging\" operator to balance distance and makespan, ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_makespans = sum(obj[1] for _, obj in archive)\n    probabilities = [1 - (obj[1] / total_makespans) for _, obj in archive]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Route segmentation and reinsertion\n        split_point = np.random.randint(1, len(route)-1)\n        segment = route[split_point:-1]\n        remaining_route = np.concatenate([[0], route[1:split_point], [0]])\n        new_route = remaining_route.copy()\n\n        # Try reinserting segment into another route or new route\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if sum(demand[segment]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Insert segment into this route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    cost = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(len(temp_route)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n                inserted = True\n                break\n\n        if not inserted:\n            # Create new route with segment if capacity allows\n            if sum(demand[segment]) <= capacity:\n                new_route = np.concatenate([[0], segment, [0]])\n\n        new_solution.append(new_route)\n\n    # Route merging operator\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Try merging routes in both possible orders\n            merged1 = np.concatenate([route1[:-1], route2[1:]])\n            merged2 = np.concatenate([route2[:-1], route1[1:]])\n            cost1 = sum(distance_matrix[merged1[k], merged1[k+1]] for k in range(len(merged1)-1))\n            cost2 = sum(distance_matrix[merged2[k], merged2[k+1]] for k in range(len(merged2)-1))\n            if min(cost1, cost2) < sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)):\n                new_solution = [merged1 if cost1 < cost2 else merged2] + [r for k, r in enumerate(new_solution) if k not in {i, j}]\n\n    # Ensure all customers are served (in case of failed insertions)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        # Create new routes for missing customers\n        missing_demands = demand[list(missing)]\n        for i, node in enumerate(missing):\n            new_route = np.array([0, node, 0])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7622703273515448,
            3.076933741569519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_makespans = sum(obj[1] for _, obj in archive)\n    probabilities = [1 - (obj[1] / total_makespans) for _, obj in archive]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Route segmentation and reinsertion\n        split_point = np.random.randint(1, len(route)-1)\n        segment = route[split_point:-1]\n        remaining_route = np.concatenate([[0], route[1:split_point], [0]])\n        new_route = remaining_route.copy()\n\n        # Try reinserting segment into another route or new route\n        inserted = False\n        for i, other_route in enumerate(new_solution):\n            if sum(demand[segment]) + sum(demand[other_route[1:-1]]) <= capacity:\n                # Insert segment into this route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    cost = sum(distance_matrix[temp_route[k], temp_route[k+1]] for k in range(len(temp_route)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n                inserted = True\n                break\n\n        if not inserted:\n            # Create new route with segment if capacity allows\n            if sum(demand[segment]) <= capacity:\n                new_route = np.concatenate([[0], segment, [0]])\n\n        new_solution.append(new_route)\n\n    # Route merging operator\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Try merging routes in both possible orders\n            merged1 = np.concatenate([route1[:-1], route2[1:]])\n            merged2 = np.concatenate([route2[:-1], route1[1:]])\n            cost1 = sum(distance_matrix[merged1[k], merged1[k+1]] for k in range(len(merged1)-1))\n            cost2 = sum(distance_matrix[merged2[k], merged2[k+1]] for k in range(len(merged2)-1))\n            if min(cost1, cost2) < sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)):\n                new_solution = [merged1 if cost1 < cost2 else merged2] + [r for k, r in enumerate(new_solution) if k not in {i, j}]\n\n    # Ensure all customers are served (in case of failed insertions)\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(demand))) - served\n    if missing:\n        # Create new routes for missing customers\n        missing_demands = demand[list(missing)]\n        for i, node in enumerate(missing):\n            new_route = np.array([0, node, 0])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a long route and reallocate customers to shorter routes\n    new_solution = base_solution.copy()\n\n    # Find the longest route in the solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random customer\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints for both parts)\n    part1_demand = sum(demand[part1[1:-1]])\n    part2_demand = sum(demand[part2[1:-1]])\n\n    if part1_demand <= capacity and part2_demand <= capacity:\n        # Replace the original route with the two split routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try reallocating customers to existing routes\n        for customer in longest_route[1:-1]:\n            # Find a route with enough remaining capacity\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    route.insert(-1, customer)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7736064401034535,
            0.3347918689250946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a long route and reallocate customers to shorter routes\n    new_solution = base_solution.copy()\n\n    # Find the longest route in the solution\n    longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random customer\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    part1 = longest_route[:split_point + 1]\n    part2 = longest_route[split_point:]\n\n    # Check if splitting is feasible (capacity constraints for both parts)\n    part1_demand = sum(demand[part1[1:-1]])\n    part2_demand = sum(demand[part2[1:-1]])\n\n    if part1_demand <= capacity and part2_demand <= capacity:\n        # Replace the original route with the two split routes\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n    else:\n        # If splitting violates capacity, try reallocating customers to existing routes\n        for customer in longest_route[1:-1]:\n            # Find a route with enough remaining capacity\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    route.insert(-1, customer)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with low makespan and high total distance, then applies a hybrid local search combining route splitting, customer reinsertion with demand-aware optimization, and route merging to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by makespan (ascending) and total distance (descending) to prioritize those with low makespan and high distance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # Step 1: Route splitting with demand-aware optimization\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for j in range(1, len(route)-1):\n            # Calculate the increase in distance if we split here\n            dist_before = distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n            dist_after = distance_matrix[route[j-1], 0] + distance_matrix[0, route[j+1]]\n            increase = dist_after - dist_before\n\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate((route[:best_split+1], [0]))\n            new_route2 = np.concatenate(([0], route[best_split+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion with demand-aware optimization\n    # Select a random route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Only consider routes with customers\n            # Remove a random customer from the route\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n            updated_route = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n\n            # Try to reinsert the customer into another route or create a new route\n            best_position = None\n            best_route_idx = None\n            min_increase = float('inf')\n\n            # Check all other routes for possible insertion\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i]\n\n                # Check all possible insertion positions\n                for j in range(1, len(candidate_route)):\n                    # Create the new route with the customer inserted\n                    new_candidate_route = np.concatenate((candidate_route[:j], [customer], candidate_route[j:]))\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_candidate_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate the increase in distance\n                    if j == 1:\n                        increase = (distance_matrix[0, customer] + distance_matrix[customer, candidate_route[j]] -\n                                   distance_matrix[0, candidate_route[j]])\n                    elif j == len(candidate_route)-1:\n                        increase = (distance_matrix[candidate_route[j-1], customer] + distance_matrix[customer, 0] -\n                                   distance_matrix[candidate_route[j-1], 0])\n                    else:\n                        increase = (distance_matrix[candidate_route[j-1], customer] + distance_matrix[customer, candidate_route[j]] -\n                                   distance_matrix[candidate_route[j-1], candidate_route[j]])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_position = j\n                        best_route_idx = i\n\n            # If a good position was found, perform the insertion\n            if best_route_idx is not None:\n                candidate_route = new_solution[best_route_idx]\n                new_candidate_route = np.concatenate((candidate_route[:best_position], [customer], candidate_route[best_position:]))\n                new_solution[best_route_idx] = new_candidate_route\n                new_solution[route_idx] = updated_route\n\n    # Step 3: Route merging to reduce makespan\n    if len(new_solution) > 1:\n        # Find the two routes with the smallest distance between their end points\n        min_distance = float('inf')\n        best_pair = None\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate distance between the last customer of route1 and first customer of route2\n                dist = distance_matrix[route1[-2], route2[1]]\n\n                if dist < min_distance:\n                    min_distance = dist\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check capacity constraint\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Replace the two routes with the merged one\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.5109937839111439,
            3.0778090059757233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by makespan (ascending) and total distance (descending) to prioritize those with low makespan and high distance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive_sorted[0][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # Step 1: Route splitting with demand-aware optimization\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for j in range(1, len(route)-1):\n            # Calculate the increase in distance if we split here\n            dist_before = distance_matrix[route[j-1], route[j]] + distance_matrix[route[j], route[j+1]]\n            dist_after = distance_matrix[route[j-1], 0] + distance_matrix[0, route[j+1]]\n            increase = dist_after - dist_before\n\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate((route[:best_split+1], [0]))\n            new_route2 = np.concatenate(([0], route[best_split+1:]))\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion with demand-aware optimization\n    # Select a random route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Only consider routes with customers\n            # Remove a random customer from the route\n            customer_idx = random.randint(1, len(route)-2)\n            customer = route[customer_idx]\n            updated_route = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n\n            # Try to reinsert the customer into another route or create a new route\n            best_position = None\n            best_route_idx = None\n            min_increase = float('inf')\n\n            # Check all other routes for possible insertion\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n                candidate_route = new_solution[i]\n\n                # Check all possible insertion positions\n                for j in range(1, len(candidate_route)):\n                    # Create the new route with the customer inserted\n                    new_candidate_route = np.concatenate((candidate_route[:j], [customer], candidate_route[j:]))\n\n                    # Check capacity constraint\n                    if np.sum(demand[new_candidate_route[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate the increase in distance\n                    if j == 1:\n                        increase = (distance_matrix[0, customer] + distance_matrix[customer, candidate_route[j]] -\n                                   distance_matrix[0, candidate_route[j]])\n                    elif j == len(candidate_route)-1:\n                        increase = (distance_matrix[candidate_route[j-1], customer] + distance_matrix[customer, 0] -\n                                   distance_matrix[candidate_route[j-1], 0])\n                    else:\n                        increase = (distance_matrix[candidate_route[j-1], customer] + distance_matrix[customer, candidate_route[j]] -\n                                   distance_matrix[candidate_route[j-1], candidate_route[j]])\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_position = j\n                        best_route_idx = i\n\n            # If a good position was found, perform the insertion\n            if best_route_idx is not None:\n                candidate_route = new_solution[best_route_idx]\n                new_candidate_route = np.concatenate((candidate_route[:best_position], [customer], candidate_route[best_position:]))\n                new_solution[best_route_idx] = new_candidate_route\n                new_solution[route_idx] = updated_route\n\n    # Step 3: Route merging to reduce makespan\n    if len(new_solution) > 1:\n        # Find the two routes with the smallest distance between their end points\n        min_distance = float('inf')\n        best_pair = None\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate distance between the last customer of route1 and first customer of route2\n                dist = distance_matrix[route1[-2], route2[1]]\n\n                if dist < min_distance:\n                    min_distance = dist\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check capacity constraint\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge the two routes\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Replace the two routes with the merged one\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    if len(selected_route) > 3:  # Ensure route can be split\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints\n        load1 = np.sum(demand[new_route1[1:-1]])\n        load2 = np.sum(demand[new_route2[1:-1]])\n\n        if load1 <= capacity and load2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n        else:\n            # If split is invalid, try reallocating a random customer to another route\n            if len(base_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != route_idx])\n                other_route = base_solution[other_route_idx].copy()\n\n                # Select a random customer from the selected route\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Check if adding the customer to the other route violates capacity\n                other_load = np.sum(demand[other_route[1:-1]])\n                if other_load + demand[customer] <= capacity:\n                    # Update routes\n                    new_route1 = np.delete(selected_route, customer_pos)\n                    new_route2 = np.insert(other_route, -1, customer)\n\n                    new_solution = [r for r in base_solution if not np.array_equal(r, selected_route) and not np.array_equal(r, other_route)]\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                else:\n                    new_solution = base_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6722980540767636,
            0.3086094260215759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    if len(selected_route) > 3:  # Ensure route can be split\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        new_route1 = selected_route[:split_pos + 1]\n        new_route2 = selected_route[split_pos:]\n\n        # Check capacity constraints\n        load1 = np.sum(demand[new_route1[1:-1]])\n        load2 = np.sum(demand[new_route2[1:-1]])\n\n        if load1 <= capacity and load2 <= capacity:\n            # Replace the original route with the two new routes\n            new_solution = [r for r in base_solution if not np.array_equal(r, selected_route)]\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n        else:\n            # If split is invalid, try reallocating a random customer to another route\n            if len(base_solution) > 1:\n                other_route_idx = np.random.choice([i for i in range(len(base_solution)) if i != route_idx])\n                other_route = base_solution[other_route_idx].copy()\n\n                # Select a random customer from the selected route\n                customer_pos = np.random.randint(1, len(selected_route) - 1)\n                customer = selected_route[customer_pos]\n\n                # Check if adding the customer to the other route violates capacity\n                other_load = np.sum(demand[other_route[1:-1]])\n                if other_load + demand[customer] <= capacity:\n                    # Update routes\n                    new_route1 = np.delete(selected_route, customer_pos)\n                    new_route2 = np.insert(other_route, -1, customer)\n\n                    new_solution = [r for r in base_solution if not np.array_equal(r, selected_route) and not np.array_equal(r, other_route)]\n                    new_solution.append(new_route1)\n                    new_solution.append(new_route2)\n                else:\n                    new_solution = base_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route-shaking and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Skip if route has only depot and one customer\n            # Route-shaking: randomly perturb a segment of the route\n            start_idx = np.random.randint(1, len(route)-2)\n            end_idx = np.random.randint(start_idx+1, len(route)-1)\n            perturbed_segment = route[start_idx:end_idx+1]\n\n            # Reverse the segment for diversification\n            perturbed_segment = np.concatenate([route[:start_idx], perturbed_segment[::-1], route[end_idx+1:]])\n\n            # Check capacity feasibility\n            if np.sum(demand[perturbed_segment[1:-1]]) <= capacity:\n                new_solution.append(perturbed_segment)\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Cross-route insertion: move a customer from one route to another\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            # Randomly select a customer from route i\n            if len(new_solution[i]) > 3:\n                customer_idx = np.random.randint(1, len(new_solution[i])-1)\n                customer = new_solution[i][customer_idx]\n\n                # Check if moving this customer to route j is feasible\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route j at a random position\n                    insert_pos = np.random.randint(1, len(new_solution[j]))\n                    new_route_j = np.concatenate([\n                        new_solution[j][:insert_pos],\n                        [customer],\n                        new_solution[j][insert_pos:]\n                    ])\n                    new_solution[j] = new_route_j\n\n                    # Remove customer from route i\n                    new_route_i = np.concatenate([\n                        new_solution[i][:customer_idx],\n                        new_solution[i][customer_idx+1:]\n                    ])\n                    new_solution[i] = new_route_i\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5953579401450513,
            3.0258151590824127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine route-shaking and cross-route insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) > 3:  # Skip if route has only depot and one customer\n            # Route-shaking: randomly perturb a segment of the route\n            start_idx = np.random.randint(1, len(route)-2)\n            end_idx = np.random.randint(start_idx+1, len(route)-1)\n            perturbed_segment = route[start_idx:end_idx+1]\n\n            # Reverse the segment for diversification\n            perturbed_segment = np.concatenate([route[:start_idx], perturbed_segment[::-1], route[end_idx+1:]])\n\n            # Check capacity feasibility\n            if np.sum(demand[perturbed_segment[1:-1]]) <= capacity:\n                new_solution.append(perturbed_segment)\n            else:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Cross-route insertion: move a customer from one route to another\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            # Randomly select a customer from route i\n            if len(new_solution[i]) > 3:\n                customer_idx = np.random.randint(1, len(new_solution[i])-1)\n                customer = new_solution[i][customer_idx]\n\n                # Check if moving this customer to route j is feasible\n                if np.sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route j at a random position\n                    insert_pos = np.random.randint(1, len(new_solution[j]))\n                    new_route_j = np.concatenate([\n                        new_solution[j][:insert_pos],\n                        [customer],\n                        new_solution[j][insert_pos:]\n                    ])\n                    new_solution[j] = new_route_j\n\n                    # Remove customer from route i\n                    new_route_i = np.concatenate([\n                        new_solution[i][:customer_idx],\n                        new_solution[i][customer_idx+1:]\n                    ])\n                    new_solution[i] = new_route_i\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    max_ratio = -1\n    for sol, (dist, span) in archive:\n        ratio = dist / span  # Higher ratio means potential for improvement\n        if ratio > max_ratio:\n            max_ratio = ratio\n            selected_solution = sol.copy()\n\n    if not selected_solution:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    # Hybrid operator: split a long route and reinsert customers into shorter routes\n    if n_routes > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If split is infeasible, try reinserting customers into other routes\n            customers_to_reinsert = longest_route[1:-1]\n            for customer in customers_to_reinsert:\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_cost_increase = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx:\n                        continue\n                    for j in range(1, len(route)):\n                        # Try inserting customer at position j in route i\n                        insert_pos = j\n                        new_route = np.insert(route, insert_pos, customer)\n                        if np.sum(demand[new_route[1:-1]]) > capacity:\n                            continue\n                        # Calculate the cost increase\n                        cost_increase = (\n                            distance_matrix[new_route[insert_pos - 1], customer] +\n                            distance_matrix[customer, new_route[insert_pos + 1]] -\n                            distance_matrix[new_route[insert_pos - 1], new_route[insert_pos + 1]]\n                        )\n                        if cost_increase < best_cost_increase:\n                            best_cost_increase = cost_increase\n                            best_route_idx = i\n                            best_insert_pos = insert_pos\n\n                if best_route_idx != -1:\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n\n            # Remove the original longest route if it's now empty\n            if len(new_solution[longest_route_idx]) <= 2:\n                new_solution.pop(longest_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.6169388287622983,
            0.14793068170547485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    max_ratio = -1\n    for sol, (dist, span) in archive:\n        ratio = dist / span  # Higher ratio means potential for improvement\n        if ratio > max_ratio:\n            max_ratio = ratio\n            selected_solution = sol.copy()\n\n    if not selected_solution:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_routes = len(new_solution)\n\n    # Hybrid operator: split a long route and reinsert customers into shorter routes\n    if n_routes > 1:\n        # Find the longest route\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos + 1]\n        part2 = longest_route[split_pos:]\n\n        # Check if the split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = part1\n            new_solution.append(part2)\n        else:\n            # If split is infeasible, try reinserting customers into other routes\n            customers_to_reinsert = longest_route[1:-1]\n            for customer in customers_to_reinsert:\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_cost_increase = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx:\n                        continue\n                    for j in range(1, len(route)):\n                        # Try inserting customer at position j in route i\n                        insert_pos = j\n                        new_route = np.insert(route, insert_pos, customer)\n                        if np.sum(demand[new_route[1:-1]]) > capacity:\n                            continue\n                        # Calculate the cost increase\n                        cost_increase = (\n                            distance_matrix[new_route[insert_pos - 1], customer] +\n                            distance_matrix[customer, new_route[insert_pos + 1]] -\n                            distance_matrix[new_route[insert_pos - 1], new_route[insert_pos + 1]]\n                        )\n                        if cost_increase < best_cost_increase:\n                            best_cost_increase = cost_increase\n                            best_route_idx = i\n                            best_insert_pos = insert_pos\n\n                if best_route_idx != -1:\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n\n            # Remove the original longest route if it's now empty\n            if len(new_solution[longest_route_idx]) <= 2:\n                new_solution.pop(longest_route_idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining route splitting and customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer solutions with better makespan\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        first_part = route[:split_pos + 1]\n        second_part = np.concatenate([[0], route[split_pos:-1]])\n\n        # Check capacity constraints\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            new_solution.extend([first_part, second_part])\n        else:\n            # If splitting violates capacity, try reallocating customers\n            route_list = list(route[1:-1])\n            np.random.shuffle(route_list)\n            temp_route = [0]\n            current_load = 0\n            for node in route_list:\n                if current_load + demand[node] <= capacity:\n                    temp_route.append(node)\n                    current_load += demand[node]\n                else:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0, node]\n                    current_load = demand[node]\n            if len(temp_route) > 1:\n                temp_route.append(0)\n                new_solution.append(np.array(temp_route))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    if missing_customers:\n        # Create new routes for missing customers\n        remaining_demand = {node: demand[node] for node in missing_customers}\n        while remaining_demand:\n            new_route = [0]\n            current_load = 0\n            for node in list(remaining_demand.keys()):\n                if current_load + remaining_demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += remaining_demand[node]\n                    del remaining_demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
        "score": [
            -0.8114630319609903,
            0.6943664848804474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer solutions with better makespan\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_pos = len(route) // 2\n        first_part = route[:split_pos + 1]\n        second_part = np.concatenate([[0], route[split_pos:-1]])\n\n        # Check capacity constraints\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            new_solution.extend([first_part, second_part])\n        else:\n            # If splitting violates capacity, try reallocating customers\n            route_list = list(route[1:-1])\n            np.random.shuffle(route_list)\n            temp_route = [0]\n            current_load = 0\n            for node in route_list:\n                if current_load + demand[node] <= capacity:\n                    temp_route.append(node)\n                    current_load += demand[node]\n                else:\n                    temp_route.append(0)\n                    new_solution.append(np.array(temp_route))\n                    temp_route = [0, node]\n                    current_load = demand[node]\n            if len(temp_route) > 1:\n                temp_route.append(0)\n                new_solution.append(np.array(temp_route))\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    if missing_customers:\n        # Create new routes for missing customers\n        remaining_demand = {node: demand[node] for node in missing_customers}\n        while remaining_demand:\n            new_route = [0]\n            current_load = 0\n            for node in list(remaining_demand.keys()):\n                if current_load + remaining_demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += remaining_demand[node]\n                    del remaining_demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to split or reallocate customers\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints for the new routes\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.pop(route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Step 3: Reallocate a random customer to another route if possible\n    if len(new_solution) > 1 and random.random() < 0.5:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx].copy()\n        if len(from_route) > 3:\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx != from_route_idx:\n                to_route = new_solution[to_route_idx].copy()\n\n                # Find the best insertion position in the target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    new_to_route = np.concatenate((to_route[:pos], [customer], to_route[pos:]))\n                    if sum(demand[new_to_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[to_route[pos-1], to_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_to_route = np.concatenate((to_route[:best_pos], [customer], to_route[best_pos:]))\n                    new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos+1:]))\n\n                    # Update the solution\n                    new_solution[to_route_idx] = new_to_route\n                    new_solution[from_route_idx] = new_from_route\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 4: Apply adaptive 2-opt on a random route\n    if len(new_solution) > 0 and random.random() < 0.5:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Select two random edges to swap\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Create the new route by reversing the segment between i and j\n            new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n\n            # Verify capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7733948579594206,
            1.61832657456398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a route to split or reallocate customers\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Step 2: Split the route at a random point if it's long enough\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos:]))\n\n            # Check capacity constraints for the new routes\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.pop(route_idx)\n                new_solution.append(new_route1)\n                new_solution.append(new_route2)\n\n    # Step 3: Reallocate a random customer to another route if possible\n    if len(new_solution) > 1 and random.random() < 0.5:\n        from_route_idx = random.randint(0, len(new_solution) - 1)\n        from_route = new_solution[from_route_idx].copy()\n        if len(from_route) > 3:\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx != from_route_idx:\n                to_route = new_solution[to_route_idx].copy()\n\n                # Find the best insertion position in the target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(to_route)):\n                    new_to_route = np.concatenate((to_route[:pos], [customer], to_route[pos:]))\n                    if sum(demand[new_to_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[to_route[pos-1], customer] + distance_matrix[customer, to_route[pos]] - distance_matrix[to_route[pos-1], to_route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_cost < float('inf'):\n                    new_to_route = np.concatenate((to_route[:best_pos], [customer], to_route[best_pos:]))\n                    new_from_route = np.concatenate((from_route[:customer_pos], from_route[customer_pos+1:]))\n\n                    # Update the solution\n                    new_solution[to_route_idx] = new_to_route\n                    new_solution[from_route_idx] = new_from_route\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 4: Apply adaptive 2-opt on a random route\n    if len(new_solution) > 0 and random.random() < 0.5:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Select two random edges to swap\n        if len(route) > 4:\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n\n            # Create the new route by reversing the segment between i and j\n            new_route = np.concatenate((route[:i], route[i:j+1][::-1], route[j+1:]))\n\n            # Verify capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Identify the most distant pair of nodes in the route (excluding depot)\n    max_dist = -1\n    best_i, best_j = -1, -1\n    for i in range(1, len(selected_route) - 1):\n        for j in range(i + 1, len(selected_route) - 1):\n            dist = distance_matrix[selected_route[i]][selected_route[j]]\n            if dist > max_dist:\n                max_dist = dist\n                best_i, best_j = i, j\n\n    # Split the route at the most distant pair and redistribute nodes to other routes\n    if best_i != -1 and best_j != -1:\n        # Create a new route with the split segment\n        new_route = np.concatenate([selected_route[:best_i], selected_route[best_j:]])\n        new_route = np.insert(new_route, len(new_route) - 1, selected_route[best_j])\n\n        # Check feasibility of the new route\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            # Update the base solution\n            base_solution[route_idx] = new_route\n            # Try to redistribute the split segment to other routes\n            for other_route_idx in range(len(base_solution)):\n                if other_route_idx != route_idx:\n                    other_route = base_solution[other_route_idx].copy()\n                    # Insert the split segment into the other route\n                    temp_route = np.insert(other_route, len(other_route) - 1, selected_route[best_i:best_j + 1])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        base_solution[other_route_idx] = temp_route\n                        break\n\n    return base_solution\n\n",
        "score": [
            -0.744396545580331,
            1.1420209407806396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Randomly select a route from the solution\n    route_idx = np.random.randint(0, len(base_solution))\n    selected_route = base_solution[route_idx].copy()\n\n    # Identify the most distant pair of nodes in the route (excluding depot)\n    max_dist = -1\n    best_i, best_j = -1, -1\n    for i in range(1, len(selected_route) - 1):\n        for j in range(i + 1, len(selected_route) - 1):\n            dist = distance_matrix[selected_route[i]][selected_route[j]]\n            if dist > max_dist:\n                max_dist = dist\n                best_i, best_j = i, j\n\n    # Split the route at the most distant pair and redistribute nodes to other routes\n    if best_i != -1 and best_j != -1:\n        # Create a new route with the split segment\n        new_route = np.concatenate([selected_route[:best_i], selected_route[best_j:]])\n        new_route = np.insert(new_route, len(new_route) - 1, selected_route[best_j])\n\n        # Check feasibility of the new route\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            # Update the base solution\n            base_solution[route_idx] = new_route\n            # Try to redistribute the split segment to other routes\n            for other_route_idx in range(len(base_solution)):\n                if other_route_idx != route_idx:\n                    other_route = base_solution[other_route_idx].copy()\n                    # Insert the split segment into the other route\n                    temp_route = np.insert(other_route, len(other_route) - 1, selected_route[best_i:best_j + 1])\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        base_solution[other_route_idx] = temp_route\n                        break\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: x[1][1])\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Identify the longest route (potential candidate for splitting)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random feasible point\n    if len(longest_route) > 3:  # Ensure the route has at least one customer to split\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                remaining_capacity = capacity - sum(demand[new_solution[longest_route_idx][1:i]])\n                if demand[customer] <= remaining_capacity:\n                    # Find the best route to insert the customer\n                    best_route_idx = -1\n                    best_insert_cost = float('inf')\n                    for j in range(len(new_solution)):\n                        if j == longest_route_idx:\n                            continue\n                        route = new_solution[j]\n                        for k in range(len(route) - 1):\n                            insert_cost = (distance_matrix[route[k], customer] +\n                                         distance_matrix[customer, route[k+1]] -\n                                         distance_matrix[route[k], route[k+1]])\n                            if (sum(demand[route[1:-1]]) + demand[customer] <= capacity and\n                                insert_cost < best_insert_cost):\n                                best_insert_cost = insert_cost\n                                best_route_idx = j\n                                best_pos = k + 1\n                    if best_route_idx != -1:\n                        new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                        break\n\n    # Ensure all routes are feasible (fallback if splitting/reallocation fails)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Rebuild the route if capacity is violated (simplified for brevity)\n            customers = route[1:-1]\n            new_route = [0]\n            current_load = 0\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(new_route)\n            new_solution.remove(route)\n\n    return new_solution\n\n",
        "score": [
            -0.6131877418171721,
            0.26315420866012573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: x[1][1])\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Identify the longest route (potential candidate for splitting)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two parts at a random feasible point\n    if len(longest_route) > 3:  # Ensure the route has at least one customer to split\n        split_pos = random.randint(1, len(longest_route) - 2)\n        first_part = longest_route[:split_pos + 1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity feasibility for both parts\n        if (sum(demand[first_part[1:-1]]) <= capacity and\n            sum(demand[second_part[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n        else:\n            # If splitting violates capacity, try reallocating customers to other routes\n            for i in range(1, len(longest_route) - 1):\n                customer = longest_route[i]\n                remaining_capacity = capacity - sum(demand[new_solution[longest_route_idx][1:i]])\n                if demand[customer] <= remaining_capacity:\n                    # Find the best route to insert the customer\n                    best_route_idx = -1\n                    best_insert_cost = float('inf')\n                    for j in range(len(new_solution)):\n                        if j == longest_route_idx:\n                            continue\n                        route = new_solution[j]\n                        for k in range(len(route) - 1):\n                            insert_cost = (distance_matrix[route[k], customer] +\n                                         distance_matrix[customer, route[k+1]] -\n                                         distance_matrix[route[k], route[k+1]])\n                            if (sum(demand[route[1:-1]]) + demand[customer] <= capacity and\n                                insert_cost < best_insert_cost):\n                                best_insert_cost = insert_cost\n                                best_route_idx = j\n                                best_pos = k + 1\n                    if best_route_idx != -1:\n                        new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], i)\n                        break\n\n    # Ensure all routes are feasible (fallback if splitting/reallocation fails)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Rebuild the route if capacity is violated (simplified for brevity)\n            customers = route[1:-1]\n            new_route = [0]\n            current_load = 0\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    new_route.append(0)\n                    new_solution.append(new_route)\n                    new_route = [0, customer]\n                    current_load = demand[customer]\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(new_route)\n            new_solution.remove(route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The novel local search algorithm combines route segment swapping with adaptive capacity-aware insertion, dynamically balancing distance and makespan reduction by prioritizing high-demand or long-segment exchanges while ensuring feasibility through demand checks and distance recalculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))  # Prefer solutions with high (makespan - distance)\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//3)])[0].copy()\n\n    # Hybrid local search: Route segment swapping + adaptive insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Select a random segment to move\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        segment = route[start:end+1]\n\n        # Find target route for insertion\n        target_route = random.choice(selected_solution)\n        if len(target_route) <= 2:  # Skip empty routes\n            new_solution.append(route.copy())\n            continue\n\n        # Try adaptive insertion positions\n        best_insert_pos = -1\n        best_score = float('inf')\n        for pos in range(1, len(target_route)):\n            # Check capacity constraint\n            if np.sum(demand[target_route[pos-1:pos+1]]) + np.sum(demand[segment]) <= capacity:\n                # Calculate insertion cost (distance improvement)\n                cost = (distance_matrix[target_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], target_route[pos]] -\n                        distance_matrix[target_route[pos-1], target_route[pos]])\n                if cost < best_score:\n                    best_score = cost\n                    best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            new_route = np.concatenate([\n                target_route[:best_insert_pos],\n                segment,\n                target_route[best_insert_pos:]\n            ])\n            new_solution.append(new_route)\n            # Remove the segment from original route\n            modified_route = np.concatenate([route[:start], route[end+1:]])\n            new_solution.append(modified_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Insert missing customers into shortest routes\n        for customer in missing:\n            best_route_idx = np.argmin([len(route) for route in new_solution])\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_solution[best_route_idx])):\n                if demand[customer] + np.sum(demand[new_solution[best_route_idx][pos-1:pos+1]]) <= capacity:\n                    cost = (distance_matrix[new_solution[best_route_idx][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route_idx][pos]] -\n                            distance_matrix[new_solution[best_route_idx][pos-1], new_solution[best_route_idx][pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7500558231923773,
            5.241409510374069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1] - x[1][0]))  # Prefer solutions with high (makespan - distance)\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//3)])[0].copy()\n\n    # Hybrid local search: Route segment swapping + adaptive insertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Select a random segment to move\n        start = random.randint(1, len(route)-3)\n        end = random.randint(start+1, len(route)-2)\n        segment = route[start:end+1]\n\n        # Find target route for insertion\n        target_route = random.choice(selected_solution)\n        if len(target_route) <= 2:  # Skip empty routes\n            new_solution.append(route.copy())\n            continue\n\n        # Try adaptive insertion positions\n        best_insert_pos = -1\n        best_score = float('inf')\n        for pos in range(1, len(target_route)):\n            # Check capacity constraint\n            if np.sum(demand[target_route[pos-1:pos+1]]) + np.sum(demand[segment]) <= capacity:\n                # Calculate insertion cost (distance improvement)\n                cost = (distance_matrix[target_route[pos-1], segment[0]] +\n                        distance_matrix[segment[-1], target_route[pos]] -\n                        distance_matrix[target_route[pos-1], target_route[pos]])\n                if cost < best_score:\n                    best_score = cost\n                    best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            new_route = np.concatenate([\n                target_route[:best_insert_pos],\n                segment,\n                target_route[best_insert_pos:]\n            ])\n            new_solution.append(new_route)\n            # Remove the segment from original route\n            modified_route = np.concatenate([route[:start], route[end+1:]])\n            new_solution.append(modified_route)\n        else:\n            new_solution.append(route.copy())\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    missing = set(range(1, len(coords))) - served\n    if missing:\n        # Insert missing customers into shortest routes\n        for customer in missing:\n            best_route_idx = np.argmin([len(route) for route in new_solution])\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_solution[best_route_idx])):\n                if demand[customer] + np.sum(demand[new_solution[best_route_idx][pos-1:pos+1]]) <= capacity:\n                    cost = (distance_matrix[new_solution[best_route_idx][pos-1], customer] +\n                            distance_matrix[customer, new_solution[best_route_idx][pos]] -\n                            distance_matrix[new_solution[best_route_idx][pos-1], new_solution[best_route_idx][pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            new_solution[best_route_idx] = np.concatenate([\n                new_solution[best_route_idx][:best_pos],\n                [customer],\n                new_solution[best_route_idx][best_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive, then applies a hybrid local search combining route merging and customer reallocation, ensuring feasibility by verifying capacity constraints at each step, and prioritizing solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge routes and reallocate customers\n    if len(new_solution) > 1:\n        # Step 1: Merge two routes if possible\n        route1_idx = np.random.randint(0, len(new_solution))\n        route2_idx = np.random.randint(0, len(new_solution))\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = np.sum(demand[merged_route[1:-1]])\n            if total_demand <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution = np.delete(new_solution, route2_idx, axis=0)\n\n        # Step 2: Reallocate a customer from a long route to a short route\n        if len(new_solution) > 1:\n            # Find the longest and shortest routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                # Try to move a customer from the longest to the shortest route\n                for i in range(1, len(longest_route) - 1):\n                    customer = longest_route[i]\n                    # Check if moving this customer to the shortest route is feasible\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the shortest route\n                        insert_pos = np.random.randint(1, len(shortest_route))\n                        new_shortest = np.insert(shortest_route, insert_pos, customer)\n                        # Remove the customer from the longest route\n                        new_longest = np.delete(longest_route, i)\n                        # Update the solution\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.770487529502251,
            3.470149129629135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge routes and reallocate customers\n    if len(new_solution) > 1:\n        # Step 1: Merge two routes if possible\n        route1_idx = np.random.randint(0, len(new_solution))\n        route2_idx = np.random.randint(0, len(new_solution))\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = np.sum(demand[merged_route[1:-1]])\n            if total_demand <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution = np.delete(new_solution, route2_idx, axis=0)\n\n        # Step 2: Reallocate a customer from a long route to a short route\n        if len(new_solution) > 1:\n            # Find the longest and shortest routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                # Try to move a customer from the longest to the shortest route\n                for i in range(1, len(longest_route) - 1):\n                    customer = longest_route[i]\n                    # Check if moving this customer to the shortest route is feasible\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the shortest route\n                        insert_pos = np.random.randint(1, len(shortest_route))\n                        new_shortest = np.insert(shortest_route, insert_pos, customer)\n                        # Remove the customer from the longest route\n                        new_longest = np.delete(longest_route, i)\n                        # Update the solution\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive, then applies a hybrid local search combining route splitting and intra-route 2-opt with capacity-aware swaps to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or (len(sol) > len(selected_solution)):\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + capacity-aware 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = np.random.randint(1, len(route)-1)\n        route1 = route[:split_pos+1]\n        route2 = np.array([0] + list(route[split_pos:]))\n\n        # Check capacity constraints\n        if np.sum(demand[route1]) <= capacity and np.sum(demand[route2]) <= capacity:\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break\n\n    # Apply capacity-aware 2-opt within routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        c, d = a+1, b+1\n\n        # Create new route by reversing the segment\n        new_route = np.concatenate([route[:a], route[b:c][::-1], route[d:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            # Check if this improves the route length\n            old_dist = np.sum(distance_matrix[route[:-1], route[1:]])\n            new_dist = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n            if new_dist < old_dist:\n                new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7193559844068529,
            2.1314819157123566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or (len(sol) > len(selected_solution)):\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route splitting + capacity-aware 2-opt\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip too short routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = np.random.randint(1, len(route)-1)\n        route1 = route[:split_pos+1]\n        route2 = np.array([0] + list(route[split_pos:]))\n\n        # Check capacity constraints\n        if np.sum(demand[route1]) <= capacity and np.sum(demand[route2]) <= capacity:\n            new_solution[i] = route1\n            new_solution.append(route2)\n            break\n\n    # Apply capacity-aware 2-opt within routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Select two random edges to swap\n        a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n        c, d = a+1, b+1\n\n        # Create new route by reversing the segment\n        new_route = np.concatenate([route[:a], route[b:c][::-1], route[d:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            # Check if this improves the route length\n            old_dist = np.sum(distance_matrix[route[:-1], route[1:]])\n            new_dist = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n            if new_dist < old_dist:\n                new_solution[i] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel hybrid local search operator combines route segmentation, demand-aware node reinsertion, and makespan-balancing swaps to generate high-quality neighbors by simultaneously optimizing both distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])  # Prefer solutions with lower makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware reinsertion + makespan balancing\n    if len(new_solution) > 1:\n        # Step 1: Route segmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find split point that balances demands\n        total_demand = sum(demand[node] for node in longest_route[1:-1])\n        half_demand = total_demand / 2\n        current_demand = 0\n        split_pos = 1\n        for i in range(1, len(longest_route)-1):\n            current_demand += demand[longest_route[i]]\n            if current_demand >= half_demand:\n                split_pos = i\n                break\n\n        # Create two new routes\n        route1 = np.concatenate(([0], longest_route[1:split_pos+1], [0]))\n        route2 = np.concatenate(([0], longest_route[split_pos+1:-1], [0]))\n\n        # Step 2: Demand-aware reinsertion - move nodes between routes if feasible\n        for i in range(len(route1)-2, 0, -1):\n            node = route1[i]\n            temp_route1 = np.concatenate((route1[:i], route1[i+1:]))\n            if sum(demand[n] for n in temp_route1[1:-1]) <= capacity:\n                # Try to insert into route2\n                for j in range(1, len(route2)):\n                    temp_route2 = np.insert(route2, j, node)\n                    if sum(demand[n] for n in temp_route2[1:-1]) <= capacity:\n                        route1 = temp_route1\n                        route2 = temp_route2\n                        break\n\n        # Step 3: Makespan balancing - swap nodes between routes to balance lengths\n        route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n        route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n\n        if abs(route1_length - route2_length) > 0.1 * max(route1_length, route2_length):\n            # Find nodes that can be swapped to balance lengths\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check if swap improves balance\n                    new_route1 = np.concatenate((route1[:i], [route2[j]], route1[i+1:]))\n                    new_route2 = np.concatenate((route2[:j], [route1[i]], route2[j+1:]))\n\n                    new_route1_length = sum(distance_matrix[new_route1[k], new_route1[k+1]] for k in range(len(new_route1)-1))\n                    new_route2_length = sum(distance_matrix[new_route2[k], new_route2[k+1]] for k in range(len(new_route2)-1))\n\n                    if max(new_route1_length, new_route2_length) < max(route1_length, route2_length):\n                        route1 = new_route1\n                        route2 = new_route2\n                        break\n\n        # Replace the original routes\n        new_solution[longest_route_idx] = route1\n        new_solution.append(route2)\n\n    # Ensure all customers are served\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(demand) - 1:  # -1 to exclude depot\n        # Recover missing nodes by inserting into shortest route\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        missing_nodes = [i for i in range(1, len(demand)) if i not in all_nodes]\n        for node in missing_nodes:\n            best_pos = 1\n            min_increase = float('inf')\n            for i in range(1, len(new_solution[shortest_route_idx])):\n                temp_route = np.insert(new_solution[shortest_route_idx], i, node)\n                if sum(demand[n] for n in temp_route[1:-1]) <= capacity:\n                    increase = distance_matrix[temp_route[i-1], node] + distance_matrix[node, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n            new_solution[shortest_route_idx] = np.insert(new_solution[shortest_route_idx], best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7462186615170285,
            10.035543948411942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[1] for _, obj in archive])  # Prefer solutions with lower makespan\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route segmentation + demand-aware reinsertion + makespan balancing\n    if len(new_solution) > 1:\n        # Step 1: Route segmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find split point that balances demands\n        total_demand = sum(demand[node] for node in longest_route[1:-1])\n        half_demand = total_demand / 2\n        current_demand = 0\n        split_pos = 1\n        for i in range(1, len(longest_route)-1):\n            current_demand += demand[longest_route[i]]\n            if current_demand >= half_demand:\n                split_pos = i\n                break\n\n        # Create two new routes\n        route1 = np.concatenate(([0], longest_route[1:split_pos+1], [0]))\n        route2 = np.concatenate(([0], longest_route[split_pos+1:-1], [0]))\n\n        # Step 2: Demand-aware reinsertion - move nodes between routes if feasible\n        for i in range(len(route1)-2, 0, -1):\n            node = route1[i]\n            temp_route1 = np.concatenate((route1[:i], route1[i+1:]))\n            if sum(demand[n] for n in temp_route1[1:-1]) <= capacity:\n                # Try to insert into route2\n                for j in range(1, len(route2)):\n                    temp_route2 = np.insert(route2, j, node)\n                    if sum(demand[n] for n in temp_route2[1:-1]) <= capacity:\n                        route1 = temp_route1\n                        route2 = temp_route2\n                        break\n\n        # Step 3: Makespan balancing - swap nodes between routes to balance lengths\n        route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n        route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n\n        if abs(route1_length - route2_length) > 0.1 * max(route1_length, route2_length):\n            # Find nodes that can be swapped to balance lengths\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check if swap improves balance\n                    new_route1 = np.concatenate((route1[:i], [route2[j]], route1[i+1:]))\n                    new_route2 = np.concatenate((route2[:j], [route1[i]], route2[j+1:]))\n\n                    new_route1_length = sum(distance_matrix[new_route1[k], new_route1[k+1]] for k in range(len(new_route1)-1))\n                    new_route2_length = sum(distance_matrix[new_route2[k], new_route2[k+1]] for k in range(len(new_route2)-1))\n\n                    if max(new_route1_length, new_route2_length) < max(route1_length, route2_length):\n                        route1 = new_route1\n                        route2 = new_route2\n                        break\n\n        # Replace the original routes\n        new_solution[longest_route_idx] = route1\n        new_solution.append(route2)\n\n    # Ensure all customers are served\n    all_nodes = set()\n    for route in new_solution:\n        all_nodes.update(route[1:-1])\n    if len(all_nodes) != len(demand) - 1:  # -1 to exclude depot\n        # Recover missing nodes by inserting into shortest route\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        missing_nodes = [i for i in range(1, len(demand)) if i not in all_nodes]\n        for node in missing_nodes:\n            best_pos = 1\n            min_increase = float('inf')\n            for i in range(1, len(new_solution[shortest_route_idx])):\n                temp_route = np.insert(new_solution[shortest_route_idx], i, node)\n                if sum(demand[n] for n in temp_route[1:-1]) <= capacity:\n                    increase = distance_matrix[temp_route[i-1], node] + distance_matrix[node, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = i\n            new_solution[shortest_route_idx] = np.insert(new_solution[shortest_route_idx], best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n            # Reallocate customers to reduce makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than 2 customers\n                    # Randomly select a customer to move\n                    customer_idx = np.random.randint(1, len(route)-1)\n                    customer = route[customer_idx]\n\n                    # Try to insert into another route without violating capacity\n                    for other_route in new_solution:\n                        if other_route is not route and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into other_route and remove from original route\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_idx)\n                            break\n    else:\n        # If only one route, apply 2-opt with demand constraints\n        route = new_solution[0]\n        i, j = np.random.choice(range(1, len(route)-1), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if reversing the segment is feasible\n        segment = route[i:j+1][::-1]\n        if sum(demand[segment[1:-1]]) <= capacity:\n            route[i:j+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6456246039138214,
            10.814545392990112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n            # Reallocate customers to reduce makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than 2 customers\n                    # Randomly select a customer to move\n                    customer_idx = np.random.randint(1, len(route)-1)\n                    customer = route[customer_idx]\n\n                    # Try to insert into another route without violating capacity\n                    for other_route in new_solution:\n                        if other_route is not route and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Insert customer into other_route and remove from original route\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_idx)\n                            break\n    else:\n        # If only one route, apply 2-opt with demand constraints\n        route = new_solution[0]\n        i, j = np.random.choice(range(1, len(route)-1), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if reversing the segment is feasible\n        segment = route[i:j+1][::-1]\n        if sum(demand[segment[1:-1]]) <= capacity:\n            route[i:j+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement (lowest makespan or shortest total distance) and applies a hybrid local search combining route splitting, customer swapping, and demand-aware insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer swapping, and demand-aware insertion\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos + 1]\n        new_route2 = [longest_route[0]] + longest_route[split_pos:-1] + [longest_route[-1]]\n\n        # Check feasibility for new routes\n        if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n            sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n        # 2. Customer swapping: Swap customers between two routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route (excluding depot)\n                cust1 = random.choice(route1[1:-1])\n                cust2 = random.choice(route2[1:-1])\n\n                # Find positions in routes\n                pos1 = np.where(route1 == cust1)[0][0]\n                pos2 = np.where(route2 == cust2)[0][0]\n\n                # Create new routes after swapping\n                new_route1 = np.concatenate([route1[:pos1], [cust2], route1[pos1+1:]])\n                new_route2 = np.concatenate([route2[:pos2], [cust1], route2[pos2+1:]])\n\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # 3. Demand-aware insertion: Insert customers from one route to another if demand allows\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 2:\n                # Select a random customer from route1 (excluding depot)\n                cust = random.choice(route1[1:-1])\n                cust_demand = demand[cust]\n\n                # Check if route2 can accommodate this customer\n                if sum(demand[node] for node in route2[1:-1]) + cust_demand <= capacity:\n                    # Find best insertion position in route2 (minimizing additional distance)\n                    min_insert_cost = float('inf')\n                    best_pos = -1\n\n                    for i in range(1, len(route2)):\n                        insert_cost = (distance_matrix[route2[i-1], cust] +\n                                      distance_matrix[cust, route2[i]] -\n                                      distance_matrix[route2[i-1], route2[i]])\n                        if insert_cost < min_insert_cost:\n                            min_insert_cost = insert_cost\n                            best_pos = i\n\n                    if best_pos != -1:\n                        # Insert customer into route2\n                        new_route2 = np.concatenate([route2[:best_pos], [cust], route2[best_pos:]])\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove customer from route1\n                        pos_in_route1 = np.where(route1 == cust)[0][0]\n                        new_route1 = np.concatenate([route1[:pos_in_route1], route1[pos_in_route1+1:]])\n                        new_solution[route1_idx] = new_route1\n\n    return new_solution\n\n",
        "score": [
            -0.7879184430589926,
            0.8282923996448517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer swapping, and demand-aware insertion\n    if len(new_solution) > 1:\n        # 1. Route splitting: Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx].copy()\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos + 1]\n        new_route2 = [longest_route[0]] + longest_route[split_pos:-1] + [longest_route[-1]]\n\n        # Check feasibility for new routes\n        if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n            sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n        # 2. Customer swapping: Swap customers between two routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random customers from each route (excluding depot)\n                cust1 = random.choice(route1[1:-1])\n                cust2 = random.choice(route2[1:-1])\n\n                # Find positions in routes\n                pos1 = np.where(route1 == cust1)[0][0]\n                pos2 = np.where(route2 == cust2)[0][0]\n\n                # Create new routes after swapping\n                new_route1 = np.concatenate([route1[:pos1], [cust2], route1[pos1+1:]])\n                new_route2 = np.concatenate([route2[:pos2], [cust1], route2[pos2+1:]])\n\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # 3. Demand-aware insertion: Insert customers from one route to another if demand allows\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx].copy()\n            route2 = new_solution[route2_idx].copy()\n\n            if len(route1) > 2:\n                # Select a random customer from route1 (excluding depot)\n                cust = random.choice(route1[1:-1])\n                cust_demand = demand[cust]\n\n                # Check if route2 can accommodate this customer\n                if sum(demand[node] for node in route2[1:-1]) + cust_demand <= capacity:\n                    # Find best insertion position in route2 (minimizing additional distance)\n                    min_insert_cost = float('inf')\n                    best_pos = -1\n\n                    for i in range(1, len(route2)):\n                        insert_cost = (distance_matrix[route2[i-1], cust] +\n                                      distance_matrix[cust, route2[i]] -\n                                      distance_matrix[route2[i-1], route2[i]])\n                        if insert_cost < min_insert_cost:\n                            min_insert_cost = insert_cost\n                            best_pos = i\n\n                    if best_pos != -1:\n                        # Insert customer into route2\n                        new_route2 = np.concatenate([route2[:best_pos], [cust], route2[best_pos:]])\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove customer from route1\n                        pos_in_route1 = np.where(route1 == cust)[0][0]\n                        new_route1 = np.concatenate([route1[:pos_in_route1], route1[pos_in_route1+1:]])\n                        new_solution[route1_idx] = new_route1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route balancing and 3-opt-like moves\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Ensure route is long enough for meaningful transformation\n            # Randomly select a segment to reverse (3-opt-like move)\n            start = np.random.randint(1, len(route) - 3)\n            end = np.random.randint(start + 1, len(route) - 1)\n            segment = route[start:end]\n            reversed_segment = segment[::-1]\n\n            # Check feasibility of the reversed segment\n            total_demand = sum(demand[node] for node in reversed_segment)\n            if total_demand <= capacity:\n                new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n                new_solution[i] = new_route\n\n        # Attempt to balance routes by moving a customer between routes\n        if len(new_solution) > 1 and len(route) > 3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                other_route = new_solution[j]\n                node_to_move = route[np.random.randint(1, len(route) - 1)]\n                if sum(demand[node] for node in other_route) + demand[node_to_move] <= capacity:\n                    new_route = np.delete(route, np.where(route == node_to_move)[0])\n                    new_other_route = np.insert(other_route, -1, node_to_move)\n                    new_solution[i] = new_route\n                    new_solution[j] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.6287268540836785,
            1.7663046419620514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route balancing and 3-opt-like moves\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Ensure route is long enough for meaningful transformation\n            # Randomly select a segment to reverse (3-opt-like move)\n            start = np.random.randint(1, len(route) - 3)\n            end = np.random.randint(start + 1, len(route) - 1)\n            segment = route[start:end]\n            reversed_segment = segment[::-1]\n\n            # Check feasibility of the reversed segment\n            total_demand = sum(demand[node] for node in reversed_segment)\n            if total_demand <= capacity:\n                new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n                new_solution[i] = new_route\n\n        # Attempt to balance routes by moving a customer between routes\n        if len(new_solution) > 1 and len(route) > 3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                other_route = new_solution[j]\n                node_to_move = route[np.random.randint(1, len(route) - 1)]\n                if sum(demand[node] for node in other_route) + demand[node_to_move] <= capacity:\n                    new_route = np.delete(route, np.where(route == node_to_move)[0])\n                    new_other_route = np.insert(other_route, -1, node_to_move)\n                    new_solution[i] = new_route\n                    new_solution[j] = new_other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route merging and route splitting with demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the routes by concatenating and removing duplicates (except depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove duplicate customers (keep first occurrence)\n            unique_nodes = []\n            seen = set()\n            for node in merged_route:\n                if node not in seen or node == 0:\n                    unique_nodes.append(node)\n                    seen.add(node)\n            merged_route = np.array(unique_nodes)\n\n            # Replace the two routes with the merged route\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n            # Apply demand-aware 2-opt on the merged route\n            improved_route = demand_aware_2opt(merged_route, distance_matrix, demand, capacity)\n            new_solution[-1] = improved_route\n\n    # Randomly select a route to split if it has more than 2 customers\n    if len(new_solution) < len(selected_solution) * 2:  # Limit the number of routes\n        for route in new_solution[:]:\n            if len(route) > 4:  # At least 2 customers + depot\n                # Find the split point with minimal additional distance\n                best_split = None\n                min_additional_distance = float('inf')\n                for k in range(2, len(route)-2):\n                    # Split into route[:k+1] and route[k:]\n                    split1 = route[:k+1]\n                    split2 = np.concatenate([[0], route[k+1:]])\n                    # Check demand feasibility for both splits\n                    demand1 = sum(demand[node] for node in split1[1:-1])\n                    demand2 = sum(demand[node] for node in split2[1:-1])\n                    if demand1 <= capacity and demand2 <= capacity:\n                        # Calculate additional distance\n                        additional_distance = (\n                            distance_matrix[split1[-2]][0] + distance_matrix[0][split2[1]] -\n                            distance_matrix[split1[-2]][split1[-1]]\n                        )\n                        if additional_distance < min_additional_distance:\n                            min_additional_distance = additional_distance\n                            best_split = (split1, split2)\n\n                if best_split:\n                    new_solution.remove(route)\n                    new_solution.extend(best_split)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6994318121754433,
            0.6464071869850159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Combine route merging and route splitting with demand-aware insertion\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the routes by concatenating and removing duplicates (except depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove duplicate customers (keep first occurrence)\n            unique_nodes = []\n            seen = set()\n            for node in merged_route:\n                if node not in seen or node == 0:\n                    unique_nodes.append(node)\n                    seen.add(node)\n            merged_route = np.array(unique_nodes)\n\n            # Replace the two routes with the merged route\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n            # Apply demand-aware 2-opt on the merged route\n            improved_route = demand_aware_2opt(merged_route, distance_matrix, demand, capacity)\n            new_solution[-1] = improved_route\n\n    # Randomly select a route to split if it has more than 2 customers\n    if len(new_solution) < len(selected_solution) * 2:  # Limit the number of routes\n        for route in new_solution[:]:\n            if len(route) > 4:  # At least 2 customers + depot\n                # Find the split point with minimal additional distance\n                best_split = None\n                min_additional_distance = float('inf')\n                for k in range(2, len(route)-2):\n                    # Split into route[:k+1] and route[k:]\n                    split1 = route[:k+1]\n                    split2 = np.concatenate([[0], route[k+1:]])\n                    # Check demand feasibility for both splits\n                    demand1 = sum(demand[node] for node in split1[1:-1])\n                    demand2 = sum(demand[node] for node in split2[1:-1])\n                    if demand1 <= capacity and demand2 <= capacity:\n                        # Calculate additional distance\n                        additional_distance = (\n                            distance_matrix[split1[-2]][0] + distance_matrix[0][split2[1]] -\n                            distance_matrix[split1[-2]][split1[-1]]\n                        )\n                        if additional_distance < min_additional_distance:\n                            min_additional_distance = additional_distance\n                            best_split = (split1, split2)\n\n                if best_split:\n                    new_solution.remove(route)\n                    new_solution.extend(best_split)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest total distance and makespan)\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    # Randomly choose a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Randomly select a segment of the route to fragment\n    if len(selected_route) > 3:\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        segment = selected_route[split_point:-1]  # Exclude the depot at the end\n        selected_route = selected_route[:split_point + 1]  # Keep the segment up to the split point\n\n        # Attempt to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i == route_idx:\n                continue\n\n            candidate_route = selected_solution[i].copy()\n            # Check if inserting the segment into this route is feasible\n            if sum(demand[segment]) + sum(demand[candidate_route[1:-1]]) <= capacity:\n                # Insert the segment into the candidate route\n                insert_pos = np.random.randint(1, len(candidate_route))\n                new_route = np.concatenate([candidate_route[:insert_pos], segment, candidate_route[insert_pos:]])\n                selected_solution[i] = new_route\n                break\n        else:\n            # If no feasible insertion found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            selected_solution.append(new_route)\n\n    # Further adjust the selected route by swapping nodes between routes if capacity allows\n    for i in range(len(selected_solution)):\n        if i == route_idx:\n            continue\n\n        candidate_route = selected_solution[i].copy()\n        for j in range(1, len(selected_route) - 1):\n            for k in range(1, len(candidate_route) - 1):\n                # Check if swapping nodes between routes is feasible\n                if (sum(demand[selected_route[1:-1]]) - demand[selected_route[j]] + demand[candidate_route[k]] <= capacity and\n                    sum(demand[candidate_route[1:-1]]) - demand[candidate_route[k]] + demand[selected_route[j]] <= capacity):\n\n                    # Perform the swap\n                    selected_route[j], candidate_route[k] = candidate_route[k], selected_route[j]\n                    selected_solution[route_idx] = selected_route\n                    selected_solution[i] = candidate_route\n                    break\n\n    # Ensure the solution remains feasible\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route exceeds capacity, revert to the original solution\n            return archive[0][0].copy()\n\n    return selected_solution\n\n",
        "score": [
            -0.6512888446992008,
            2.361530154943466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest total distance and makespan)\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    # Randomly choose a route to modify\n    route_idx = np.random.randint(0, len(selected_solution))\n    selected_route = selected_solution[route_idx].copy()\n\n    # Randomly select a segment of the route to fragment\n    if len(selected_route) > 3:\n        split_point = np.random.randint(1, len(selected_route) - 1)\n        segment = selected_route[split_point:-1]  # Exclude the depot at the end\n        selected_route = selected_route[:split_point + 1]  # Keep the segment up to the split point\n\n        # Attempt to insert the segment into another route or create a new route\n        for i in range(len(selected_solution)):\n            if i == route_idx:\n                continue\n\n            candidate_route = selected_solution[i].copy()\n            # Check if inserting the segment into this route is feasible\n            if sum(demand[segment]) + sum(demand[candidate_route[1:-1]]) <= capacity:\n                # Insert the segment into the candidate route\n                insert_pos = np.random.randint(1, len(candidate_route))\n                new_route = np.concatenate([candidate_route[:insert_pos], segment, candidate_route[insert_pos:]])\n                selected_solution[i] = new_route\n                break\n        else:\n            # If no feasible insertion found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            selected_solution.append(new_route)\n\n    # Further adjust the selected route by swapping nodes between routes if capacity allows\n    for i in range(len(selected_solution)):\n        if i == route_idx:\n            continue\n\n        candidate_route = selected_solution[i].copy()\n        for j in range(1, len(selected_route) - 1):\n            for k in range(1, len(candidate_route) - 1):\n                # Check if swapping nodes between routes is feasible\n                if (sum(demand[selected_route[1:-1]]) - demand[selected_route[j]] + demand[candidate_route[k]] <= capacity and\n                    sum(demand[candidate_route[1:-1]]) - demand[candidate_route[k]] + demand[selected_route[j]] <= capacity):\n\n                    # Perform the swap\n                    selected_route[j], candidate_route[k] = candidate_route[k], selected_route[j]\n                    selected_solution[route_idx] = selected_route\n                    selected_solution[i] = candidate_route\n                    break\n\n    # Ensure the solution remains feasible\n    for route in selected_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If a route exceeds capacity, revert to the original solution\n            return archive[0][0].copy()\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            candidate_node = route[split_pos]\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                temp_route = new_solution[j].tolist()\n                temp_route.insert(-1, candidate_node)\n                temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                if temp_demand <= capacity:\n                    new_solution[j] = np.array(temp_route)\n                    new_solution[i] = np.array(route.tolist()[:split_pos] + route.tolist()[split_pos + 1:])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8057167035703066,
            0.5102717578411102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            candidate_node = route[split_pos]\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                temp_route = new_solution[j].tolist()\n                temp_route.insert(-1, candidate_node)\n                temp_demand = sum(demand[node] for node in temp_route[1:-1])\n                if temp_demand <= capacity:\n                    new_solution[j] = np.array(temp_route)\n                    new_solution[i] = np.array(route.tolist()[:split_pos] + route.tolist()[split_pos + 1:])\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -x[1][1] * (1 + 0.1 * np.random.rand()))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting + adaptive 2-opt\n    for _ in range(3):  # Iterate a few times for improvement\n        # Step 1: Route splitting - split long routes into two\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only consider routes with enough customers\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Adaptive 2-opt with capacity-aware swaps\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only consider routes with enough customers\n                a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                new_route = np.concatenate([route[:a], route[b:b+1], route[a+1:b], route[a:a+1], route[b+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    # Step 3: Customer reallocation - move customers between routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer from route1 and try to insert into route2\n            customer = np.random.choice(route1[1:-1])\n            new_route2 = np.concatenate([[0], [customer], route2[1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route2_idx] = new_route2\n                new_solution[route1_idx] = np.concatenate([route1[:np.where(route1 == customer)[0][0]],\n                                                           route1[np.where(route1 == customer)[0][0]+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9095892136952074,
            10.593066722154617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -x[1][1] * (1 + 0.1 * np.random.rand()))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route splitting + adaptive 2-opt\n    for _ in range(3):  # Iterate a few times for improvement\n        # Step 1: Route splitting - split long routes into two\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:  # Only consider routes with enough customers\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Adaptive 2-opt with capacity-aware swaps\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only consider routes with enough customers\n                a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                new_route = np.concatenate([route[:a], route[b:b+1], route[a+1:b], route[a:a+1], route[b+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    # Step 3: Customer reallocation - move customers between routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select a customer from route1 and try to insert into route2\n            customer = np.random.choice(route1[1:-1])\n            new_route2 = np.concatenate([[0], [customer], route2[1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[route2_idx] = new_route2\n                new_solution[route1_idx] = np.concatenate([route1[:np.where(route1 == customer)[0][0]],\n                                                           route1[np.where(route1 == customer)[0][0]+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by considering both the total distance and makespan, then applies a hybrid local search operator that combines route-splitting, customer reassignment, and adaptive 2-opt to generate a feasible neighbor solution while balancing the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route-splitting - Split long routes to potentially reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_point + 1]\n            new_route2 = [0] + route[split_point:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route at a time\n\n    # Step 2: Customer reassignment - Move customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) > 3:  # Only consider routes with more than 2 customers\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if moving this customer would violate capacity\n                if (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity):\n                    # Create new routes\n                    new_route1 = np.delete(route1, customer_idx)\n                    new_route2 = np.insert(route2, -1, customer)\n\n                    # Update solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break  # Only move one customer at a time\n\n    # Step 3: Adaptive 2-opt - Apply 2-opt to the longest route to improve distance\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only consider routes with more than 3 customers\n            # Select two random edges to reverse\n            i = random.randint(1, len(longest_route) - 3)\n            j = random.randint(i + 1, len(longest_route) - 2)\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([\n                longest_route[:i],\n                longest_route[i:j][::-1],\n                longest_route[j:]\n            ])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8124573004836271,
            2.1696689128875732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route-splitting - Split long routes to potentially reduce makespan\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            split_point = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_point + 1]\n            new_route2 = [0] + route[split_point:]\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n                break  # Only split one route at a time\n\n    # Step 2: Customer reassignment - Move customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try moving a random customer from route1 to route2\n            if len(route1) > 3:  # Only consider routes with more than 2 customers\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                # Check if moving this customer would violate capacity\n                if (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity):\n                    # Create new routes\n                    new_route1 = np.delete(route1, customer_idx)\n                    new_route2 = np.insert(route2, -1, customer)\n\n                    # Update solution\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n                    break  # Only move one customer at a time\n\n    # Step 3: Adaptive 2-opt - Apply 2-opt to the longest route to improve distance\n    if len(new_solution) > 0:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Only consider routes with more than 3 customers\n            # Select two random edges to reverse\n            i = random.randint(1, len(longest_route) - 3)\n            j = random.randint(i + 1, len(longest_route) - 2)\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([\n                longest_route[:i],\n                longest_route[i:j][::-1],\n                longest_route[j:]\n            ])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{A novel hybrid local search strategy combines route merging, customer reinsertion with demand-aware swaps, and adaptive route splitting to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route merging + demand-aware reinsertion + adaptive splitting\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Step 2: Demand-aware reinsertion (move a customer to a better position considering demand and distance)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has at least one customer\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            new_solution[route_idx] = np.delete(route, customer_idx)\n\n            # Find best insertion point in the same route or another route (if feasible)\n            best_cost = float('inf')\n            best_insert_pos = (route_idx, customer_idx)\n            for target_route_idx in range(len(new_solution)):\n                target_route = new_solution[target_route_idx]\n                for insert_pos in range(1, len(target_route)):\n                    # Check if insertion is feasible\n                    temp_route = np.insert(target_route, insert_pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Evaluate insertion cost (distance + makespan impact)\n                        cost = (distance_matrix[temp_route[insert_pos-1], customer] +\n                                distance_matrix[customer, temp_route[insert_pos+1]] -\n                                distance_matrix[temp_route[insert_pos-1], temp_route[insert_pos+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_insert_pos = (target_route_idx, insert_pos)\n\n            # Perform the best insertion\n            target_route_idx, insert_pos = best_insert_pos\n            new_solution[target_route_idx] = np.insert(new_solution[target_route_idx], insert_pos, customer)\n\n    # Step 3: Adaptive route splitting (if a route is too long, split it)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # If route has more than 2 customers\n            split_pos = random.randint(2, len(route) - 3)\n            first_part = route[:split_pos+1]\n            second_part = np.concatenate([[0], route[split_pos+1:]])\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.insert(i+1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.7409384982475146,
            7.96427246928215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route merging + demand-aware reinsertion + adaptive splitting\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Step 2: Demand-aware reinsertion (move a customer to a better position considering demand and distance)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has at least one customer\n            customer_idx = random.randint(1, len(route) - 2)\n            customer = route[customer_idx]\n            new_solution[route_idx] = np.delete(route, customer_idx)\n\n            # Find best insertion point in the same route or another route (if feasible)\n            best_cost = float('inf')\n            best_insert_pos = (route_idx, customer_idx)\n            for target_route_idx in range(len(new_solution)):\n                target_route = new_solution[target_route_idx]\n                for insert_pos in range(1, len(target_route)):\n                    # Check if insertion is feasible\n                    temp_route = np.insert(target_route, insert_pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Evaluate insertion cost (distance + makespan impact)\n                        cost = (distance_matrix[temp_route[insert_pos-1], customer] +\n                                distance_matrix[customer, temp_route[insert_pos+1]] -\n                                distance_matrix[temp_route[insert_pos-1], temp_route[insert_pos+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_insert_pos = (target_route_idx, insert_pos)\n\n            # Perform the best insertion\n            target_route_idx, insert_pos = best_insert_pos\n            new_solution[target_route_idx] = np.insert(new_solution[target_route_idx], insert_pos, customer)\n\n    # Step 3: Adaptive route splitting (if a route is too long, split it)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # If route has more than 2 customers\n            split_pos = random.randint(2, len(route) - 3)\n            first_part = route[:split_pos+1]\n            second_part = np.concatenate([[0], route[split_pos+1:]])\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[i] = first_part\n                new_solution.insert(i+1, second_part)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Step 3: Apply a hybrid local search: Combine route splitting with customer reassignment\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    route1 = longest_route[:split_point + 1]\n    route2 = longest_route[split_point:]\n\n    # Ensure routes are valid (start and end at depot)\n    route1[-1] = 0\n    route2[0] = 0\n\n    # Check capacity constraints for both new routes\n    def is_valid(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_valid(route1) and is_valid(route2):\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = route1\n        new_solution.insert(longest_route_idx + 1, route2)\n    else:\n        # If splitting fails due to capacity, try reassigning a customer to another route\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx:\n                for j in range(1, len(longest_route) - 1):\n                    customer = longest_route[j]\n                    if demand[customer] + sum(demand[route[1:-1]]) <= capacity:\n                        # Insert customer into this route at the best position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            new_route = np.insert(route, pos, customer)\n                            cost = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        # Remove customer from original route\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], j)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8456220934409335,
            0.465777724981308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]  # Select solution with lowest makespan\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 2: Identify the longest route (highest makespan) for targeted improvement\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Step 3: Apply a hybrid local search: Combine route splitting with customer reassignment\n    # Split the longest route into two parts at a random point\n    split_point = np.random.randint(1, len(longest_route) - 1)\n    route1 = longest_route[:split_point + 1]\n    route2 = longest_route[split_point:]\n\n    # Ensure routes are valid (start and end at depot)\n    route1[-1] = 0\n    route2[0] = 0\n\n    # Check capacity constraints for both new routes\n    def is_valid(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_valid(route1) and is_valid(route2):\n        # Replace the original route with the two new routes\n        new_solution[longest_route_idx] = route1\n        new_solution.insert(longest_route_idx + 1, route2)\n    else:\n        # If splitting fails due to capacity, try reassigning a customer to another route\n        for i, route in enumerate(new_solution):\n            if i != longest_route_idx:\n                for j in range(1, len(longest_route) - 1):\n                    customer = longest_route[j]\n                    if demand[customer] + sum(demand[route[1:-1]]) <= capacity:\n                        # Insert customer into this route at the best position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(route)):\n                            new_route = np.insert(route, pos, customer)\n                            cost = sum(distance_matrix[new_route[:-1], new_route[1:]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        # Remove customer from original route\n                        new_solution[longest_route_idx] = np.delete(new_solution[longest_route_idx], j)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_point + 1]\n        second_part = route[split_point:]\n\n        # Check capacity constraint for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Try to move a customer to another route\n        for i in range(1, len(route) - 1):\n            customer = route[i]\n            current_load = np.sum(demand[route[1:-1]])\n\n            # Find a target route that can accommodate the customer\n            for target_idx in range(len(new_solution)):\n                if target_idx == route_idx:\n                    continue\n                target_route = new_solution[target_idx]\n                target_load = np.sum(demand[target_route[1:-1]])\n\n                if target_load + demand[customer] <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1], customer] +\n                                distance_matrix[customer, target_route[pos]] -\n                                distance_matrix[target_route[pos-1], target_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform the move\n                    new_route = np.insert(target_route, best_pos, customer)\n                    new_solution[target_idx] = new_route\n                    new_solution[route_idx] = np.delete(route, i)\n\n                    # Check capacity constraint after move\n                    if (np.sum(demand[new_solution[route_idx][1:-1]]) <= capacity and\n                        np.sum(demand[new_solution[target_idx][1:-1]]) <= capacity):\n                        break\n                    else:\n                        # Revert if capacity is violated\n                        new_solution[target_idx] = target_route\n                        new_solution[route_idx] = route\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7589605806468047,
            2.5705167949199677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Split the route into two parts at a random point\n        split_point = np.random.randint(1, len(route) - 1)\n        first_part = route[:split_point + 1]\n        second_part = route[split_point:]\n\n        # Check capacity constraint for both parts\n        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n            np.sum(demand[second_part[1:-1]]) <= capacity):\n            # Replace the original route with the two new routes\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n            break\n\n    # Reallocate customers between routes to balance makespan\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Try to move a customer to another route\n        for i in range(1, len(route) - 1):\n            customer = route[i]\n            current_load = np.sum(demand[route[1:-1]])\n\n            # Find a target route that can accommodate the customer\n            for target_idx in range(len(new_solution)):\n                if target_idx == route_idx:\n                    continue\n                target_route = new_solution[target_idx]\n                target_load = np.sum(demand[target_route[1:-1]])\n\n                if target_load + demand[customer] <= capacity:\n                    # Insert the customer into the target route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1], customer] +\n                                distance_matrix[customer, target_route[pos]] -\n                                distance_matrix[target_route[pos-1], target_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform the move\n                    new_route = np.insert(target_route, best_pos, customer)\n                    new_solution[target_idx] = new_route\n                    new_solution[route_idx] = np.delete(route, i)\n\n                    # Check capacity constraint after move\n                    if (np.sum(demand[new_solution[route_idx][1:-1]]) <= capacity and\n                        np.sum(demand[new_solution[target_idx][1:-1]]) <= capacity):\n                        break\n                    else:\n                        # Revert if capacity is violated\n                        new_solution[target_idx] = target_route\n                        new_solution[route_idx] = route\n            else:\n                continue\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with low total distance and high makespan, then applies a hybrid local search combining route segmentation and demand-based reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - x[1][0] * 0.1)[0].copy()\n\n    # Hybrid local search: Segment routes and reinsert nodes based on demand\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        segment1 = route[:split_point]\n        segment2 = route[split_point:-1] + [0]\n\n        # Reinsert nodes from segment2 into segment1 based on demand\n        remaining_nodes = segment2[1:-1].copy()\n        random.shuffle(remaining_nodes)\n        current_load = np.sum(demand[segment1[1:-1]])\n\n        for node in remaining_nodes:\n            if current_load + demand[node] <= capacity:\n                # Find best insertion position in segment1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(segment1)):\n                    insert_cost = distance_matrix[segment1[i-1], node] + distance_matrix[node, segment1[i]] - distance_matrix[segment1[i-1], segment1[i]]\n                    if insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = i\n                segment1 = np.insert(segment1, best_pos, node)\n                current_load += demand[node]\n\n        # Reconstruct the route\n        new_route = np.concatenate([segment1, segment2[1:]])\n        new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7594630510260589,
            4.128955066204071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1] - x[1][0] * 0.1)[0].copy()\n\n    # Hybrid local search: Segment routes and reinsert nodes based on demand\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Segment route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        segment1 = route[:split_point]\n        segment2 = route[split_point:-1] + [0]\n\n        # Reinsert nodes from segment2 into segment1 based on demand\n        remaining_nodes = segment2[1:-1].copy()\n        random.shuffle(remaining_nodes)\n        current_load = np.sum(demand[segment1[1:-1]])\n\n        for node in remaining_nodes:\n            if current_load + demand[node] <= capacity:\n                # Find best insertion position in segment1\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(segment1)):\n                    insert_cost = distance_matrix[segment1[i-1], node] + distance_matrix[node, segment1[i]] - distance_matrix[segment1[i-1], segment1[i]]\n                    if insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = i\n                segment1 = np.insert(segment1, best_pos, node)\n                current_load += demand[node]\n\n        # Reconstruct the route\n        new_route = np.concatenate([segment1, segment2[1:]])\n        new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with low total distance and high makespan (indicating imbalance), then applies a hybrid local search combining route splitting and cross-route insertion to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))  # Sort by total distance, then by negative makespan\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        def check_capacity(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if check_capacity(part1) and check_capacity(part2):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try cross-route insertion\n            for i in range(len(new_solution)):\n                for j in range(1, len(new_solution[i]) - 1):\n                    candidate = new_solution[i].copy()\n                    candidate.insert(j, route[split_point])\n                    if check_capacity(candidate):\n                        new_solution[i] = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7477185525581294,
            0.3704289495944977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], -x[1][1]))  # Sort by total distance, then by negative makespan\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Check capacity constraints for both parts\n        def check_capacity(r):\n            total_demand = sum(demand[node] for node in r[1:-1])\n            return total_demand <= capacity\n\n        if check_capacity(part1) and check_capacity(part2):\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try cross-route insertion\n            for i in range(len(new_solution)):\n                for j in range(1, len(new_solution[i]) - 1):\n                    candidate = new_solution[i].copy()\n                    candidate.insert(j, route[split_point])\n                    if check_capacity(candidate):\n                        new_solution[i] = candidate\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a promising solution from the archive using a combination of Pareto dominance and proximity to the ideal point, then applies a hybrid local search operator that intelligently combines route segment swaps and insertions while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or (len(sol) < len(selected_solution)):\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route segment swaps and insertions\n    for _ in range(3):  # Number of attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from each route (excluding depots)\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select segment from route1\n        seg1_start = random.randint(1, len(route1)-2)\n        seg1_end = random.randint(seg1_start, len(route1)-2)\n        seg1 = route1[seg1_start:seg1_end+1]\n\n        # Check if segment can be moved to route2\n        route2_demand = sum(demand[node] for node in route2 if node != 0)\n        seg1_demand = sum(demand[node] for node in seg1)\n        if route2_demand + seg1_demand > capacity:\n            continue\n\n        # Select insertion point in route2\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n        for i in range(1, len(route2)):\n            # Calculate cost of inserting seg1 between i-1 and i\n            prev_node = route2[i-1]\n            next_node = route2[i]\n            cost = distance_matrix[prev_node][seg1[0]] + distance_matrix[seg1[-1]][next_node] - distance_matrix[prev_node][next_node]\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_pos = i\n\n        if best_insert_cost < 0:  # Only proceed if insertion improves cost\n            # Insert seg1 into route2\n            new_route2 = np.concatenate([route2[:best_insert_pos], seg1, route2[best_insert_pos:]])\n            # Remove seg1 from route1\n            new_route1 = np.concatenate([route1[:seg1_start], route1[seg1_end+1:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.639495920211651,
            0.7719539999961853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or (len(sol) < len(selected_solution)):\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        return archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route segment swaps and insertions\n    for _ in range(3):  # Number of attempts\n        # Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from each route (excluding depots)\n        if len(route1) <= 2 or len(route2) <= 2:\n            continue\n\n        # Select segment from route1\n        seg1_start = random.randint(1, len(route1)-2)\n        seg1_end = random.randint(seg1_start, len(route1)-2)\n        seg1 = route1[seg1_start:seg1_end+1]\n\n        # Check if segment can be moved to route2\n        route2_demand = sum(demand[node] for node in route2 if node != 0)\n        seg1_demand = sum(demand[node] for node in seg1)\n        if route2_demand + seg1_demand > capacity:\n            continue\n\n        # Select insertion point in route2\n        best_insert_pos = -1\n        best_insert_cost = float('inf')\n        for i in range(1, len(route2)):\n            # Calculate cost of inserting seg1 between i-1 and i\n            prev_node = route2[i-1]\n            next_node = route2[i]\n            cost = distance_matrix[prev_node][seg1[0]] + distance_matrix[seg1[-1]][next_node] - distance_matrix[prev_node][next_node]\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_pos = i\n\n        if best_insert_cost < 0:  # Only proceed if insertion improves cost\n            # Insert seg1 into route2\n            new_route2 = np.concatenate([route2[:best_insert_pos], seg1, route2[best_insert_pos:]])\n            # Remove seg1 from route1\n            new_route1 = np.concatenate([route1[:seg1_start], route1[seg1_end+1:]])\n\n            # Update solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers to balance load\n    if len(selected_solution) > 1:\n        # Select two routes with the smallest and largest makespan\n        route_makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n        route_indices = np.argsort(route_makespans)\n        short_route_idx, long_route_idx = route_indices[0], route_indices[-1]\n\n        # Merge the shortest and longest routes\n        merged_route = np.concatenate([selected_solution[short_route_idx][:-1], selected_solution[long_route_idx][1:]])\n\n        # Reallocate customers to balance load while respecting capacity\n        new_routes = []\n        current_route = [0]\n        current_load = 0\n\n        for node in merged_route[1:]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n\n        # Replace the original routes with the new ones\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in {short_route_idx, long_route_idx}]\n        new_solution.extend(new_routes)\n    else:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7120191197797419,
            0.6205753087997437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: merge two routes and reallocate customers to balance load\n    if len(selected_solution) > 1:\n        # Select two routes with the smallest and largest makespan\n        route_makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in selected_solution]\n        route_indices = np.argsort(route_makespans)\n        short_route_idx, long_route_idx = route_indices[0], route_indices[-1]\n\n        # Merge the shortest and longest routes\n        merged_route = np.concatenate([selected_solution[short_route_idx][:-1], selected_solution[long_route_idx][1:]])\n\n        # Reallocate customers to balance load while respecting capacity\n        new_routes = []\n        current_route = [0]\n        current_load = 0\n\n        for node in merged_route[1:]:\n            if current_load + demand[node] <= capacity:\n                current_route.append(node)\n                current_load += demand[node]\n            else:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n                current_route = [0, node]\n                current_load = demand[node]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_routes.append(np.array(current_route))\n\n        # Replace the original routes with the new ones\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in {short_route_idx, long_route_idx}]\n        new_solution.extend(new_routes)\n    else:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Step 2: Hybrid Local Search: Route Shuffling + Cross-Route Insertion\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Shuffle routes to explore different configurations\n    random.shuffle(new_solution)\n\n    # Step 2.2: Cross-Route Insertion with Capacity Check\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find feasible insertions from route_i to route_j and vice versa\n            for k in range(1, len(route_i) - 1):\n                customer = route_i[k]\n                if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route_j\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route_j)):\n                        # Calculate cost of inserting customer at pos\n                        cost = distance_matrix[route_j[pos-1], customer] + distance_matrix[customer, route_j[pos]] - distance_matrix[route_j[pos-1], route_j[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform insertion\n                    new_route_j = np.insert(route_j, best_pos, customer)\n                    new_route_i = np.delete(route_i, k)\n\n                    # Check feasibility and update\n                    if len(new_route_i) > 2 and len(new_route_j) > 2:\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        break\n\n    # Step 3: Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 4: Ensure all customers are served (fallback if any are missing)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to the route with the least increase in distance\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                for pos in range(1, len(route)):\n                    if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            -0.5688156238350275,
            9.353595525026321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Step 2: Hybrid Local Search: Route Shuffling + Cross-Route Insertion\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Shuffle routes to explore different configurations\n    random.shuffle(new_solution)\n\n    # Step 2.2: Cross-Route Insertion with Capacity Check\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find feasible insertions from route_i to route_j and vice versa\n            for k in range(1, len(route_i) - 1):\n                customer = route_i[k]\n                if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route_j\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route_j)):\n                        # Calculate cost of inserting customer at pos\n                        cost = distance_matrix[route_j[pos-1], customer] + distance_matrix[customer, route_j[pos]] - distance_matrix[route_j[pos-1], route_j[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform insertion\n                    new_route_j = np.insert(route_j, best_pos, customer)\n                    new_route_i = np.delete(route_i, k)\n\n                    # Check feasibility and update\n                    if len(new_route_i) > 2 and len(new_route_j) > 2:\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n                        break\n\n    # Step 3: Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 4: Ensure all customers are served (fallback if any are missing)\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to the route with the least increase in distance\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                route = new_solution[i]\n                for pos in range(1, len(route)):\n                    if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        cost = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = i\n                            best_pos = pos\n\n            if best_route is not None:\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, then applies a hybrid local search combining route splitting, customer reallocation, and a modified 3-opt operator to generate a feasible neighbor solution while balancing distance and makespan reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive using weighted random selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-6)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform multiple iterations\n        # Step 1: Route splitting (split long routes)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only split if route has enough customers\n                split_pos = np.random.randint(2, len(route)-1)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try multiple reallocations\n            if len(new_solution) < 2:\n                break\n\n            # Select two different routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Select a customer from route_i to move to route_j\n            cust_pos = np.random.randint(1, len(route_i)-1)\n            customer = route_i[cust_pos]\n\n            # Check if moving this customer violates capacity\n            if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route_j\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([\n                    route_j[:insert_pos],\n                    [customer],\n                    route_j[insert_pos:]\n                ])\n\n                # Remove customer from route_i\n                new_route_i = np.concatenate([\n                    route_i[:cust_pos],\n                    route_i[cust_pos+1:]\n                ])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Modified 3-opt (focus on reducing makespan)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only perform if route has enough customers\n                # Select three segments to reverse\n                a, b, c = sorted(np.random.choice(range(1, len(route)-1), 3, replace=False))\n\n                # Create three possible variants\n                variant1 = np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]])\n                variant2 = np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]])\n                variant3 = np.concatenate([route[:a], route[a:b][::-1], route[b:c][::-1], route[c:]])\n\n                # Evaluate variants\n                variants = [variant1, variant2, variant3]\n                best_variant = None\n                best_makespan = float('inf')\n\n                for variant in variants:\n                    # Check capacity constraint\n                    if np.sum(demand[variant[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate makespan (route distance)\n                    route_dist = sum(distance_matrix[variant[k], variant[k+1]] for k in range(len(variant)-1))\n                    if route_dist < best_makespan:\n                        best_makespan = route_dist\n                        best_variant = variant\n\n                if best_variant is not None:\n                    new_solution[i] = best_variant\n\n    return new_solution\n\n",
        "score": [
            -0.7034266541949981,
            7.48851352930069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive using weighted random selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-6)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform multiple iterations\n        # Step 1: Route splitting (split long routes)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:  # Only split if route has enough customers\n                split_pos = np.random.randint(2, len(route)-1)\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Step 2: Customer reallocation (move customers between routes)\n        for _ in range(3):  # Try multiple reallocations\n            if len(new_solution) < 2:\n                break\n\n            # Select two different routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) <= 2 or len(route_j) <= 2:\n                continue\n\n            # Select a customer from route_i to move to route_j\n            cust_pos = np.random.randint(1, len(route_i)-1)\n            customer = route_i[cust_pos]\n\n            # Check if moving this customer violates capacity\n            if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route_j\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.concatenate([\n                    route_j[:insert_pos],\n                    [customer],\n                    route_j[insert_pos:]\n                ])\n\n                # Remove customer from route_i\n                new_route_i = np.concatenate([\n                    route_i[:cust_pos],\n                    route_i[cust_pos+1:]\n                ])\n\n                # Update the solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Modified 3-opt (focus on reducing makespan)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:  # Only perform if route has enough customers\n                # Select three segments to reverse\n                a, b, c = sorted(np.random.choice(range(1, len(route)-1), 3, replace=False))\n\n                # Create three possible variants\n                variant1 = np.concatenate([route[:a], route[b:c][::-1], route[a:b], route[c:]])\n                variant2 = np.concatenate([route[:a], route[b:c], route[a:b][::-1], route[c:]])\n                variant3 = np.concatenate([route[:a], route[a:b][::-1], route[b:c][::-1], route[c:]])\n\n                # Evaluate variants\n                variants = [variant1, variant2, variant3]\n                best_variant = None\n                best_makespan = float('inf')\n\n                for variant in variants:\n                    # Check capacity constraint\n                    if np.sum(demand[variant[1:-1]]) > capacity:\n                        continue\n\n                    # Calculate makespan (route distance)\n                    route_dist = sum(distance_matrix[variant[k], variant[k+1]] for k in range(len(variant)-1))\n                    if route_dist < best_makespan:\n                        best_makespan = route_dist\n                        best_variant = variant\n\n                if best_variant is not None:\n                    new_solution[i] = best_variant\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: 2-opt with route merging and splitting\n    # Step 1: Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting the closest endpoints\n            start1, end1 = route1[1], route1[-2]\n            start2, end2 = route2[1], route2[-2]\n\n            # Try all possible connections (start1-start2, start1-end2, end1-start2, end1-end2)\n            candidates = [\n                (np.concatenate([route1[:-1], route2[1:]]), distance_matrix[end1, start2]),\n                (np.concatenate([route1[:-1], route2[::-1][:-1]]), distance_matrix[end1, end2]),\n                (np.concatenate([route1[::-1][:-1], route2[1:]]), distance_matrix[start1, start2]),\n                (np.concatenate([route1[::-1][:-1], route2[::-1][:-1]]), distance_matrix[start1, end2])\n            ]\n\n            # Select the best merge option\n            best_merge, best_cost = None, float('inf')\n            for merged, cost in candidates:\n                if cost < best_cost:\n                    best_merge, best_cost = merged, cost\n\n            # Apply the best merge\n            new_solution[i] = best_merge\n            del new_solution[j]\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        n = len(route) - 1  # Exclude depot\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create new route by reversing the segment between a and b\n        new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n        # Check feasibility (capacity constraint)\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Step 3: Split a long route if possible\n    if len(new_solution) < len(archive[0][0]) and len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point (minimizing the increase in total distance)\n        min_cost = float('inf')\n        best_split = None\n\n        for k in range(1, len(longest_route)-1):\n            # Split into two parts: route1 = [0, ..., k, 0], route2 = [0, k+1, ..., 0]\n            route1 = np.concatenate([longest_route[:k+1], [0]])\n            route2 = np.concatenate([[0], longest_route[k+1:]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate cost increase\n                cost = (sum(distance_matrix[route1[:-1], route1[1:]]) +\n                        sum(distance_matrix[route2[:-1], route2[1:]]) -\n                        sum(distance_matrix[longest_route[:-1], longest_route[1:]]))\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            new_solution[longest_route_idx] = best_split[0]\n            new_solution.insert(longest_route_idx + 1, best_split[1])\n\n    return new_solution\n\n",
        "score": [
            -0.9715704092188657,
            0.7019793093204498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: 2-opt with route merging and splitting\n    # Step 1: Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting the closest endpoints\n            start1, end1 = route1[1], route1[-2]\n            start2, end2 = route2[1], route2[-2]\n\n            # Try all possible connections (start1-start2, start1-end2, end1-start2, end1-end2)\n            candidates = [\n                (np.concatenate([route1[:-1], route2[1:]]), distance_matrix[end1, start2]),\n                (np.concatenate([route1[:-1], route2[::-1][:-1]]), distance_matrix[end1, end2]),\n                (np.concatenate([route1[::-1][:-1], route2[1:]]), distance_matrix[start1, start2]),\n                (np.concatenate([route1[::-1][:-1], route2[::-1][:-1]]), distance_matrix[start1, end2])\n            ]\n\n            # Select the best merge option\n            best_merge, best_cost = None, float('inf')\n            for merged, cost in candidates:\n                if cost < best_cost:\n                    best_merge, best_cost = merged, cost\n\n            # Apply the best merge\n            new_solution[i] = best_merge\n            del new_solution[j]\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        n = len(route) - 1  # Exclude depot\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create new route by reversing the segment between a and b\n        new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n        # Check feasibility (capacity constraint)\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Step 3: Split a long route if possible\n    if len(new_solution) < len(archive[0][0]) and len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point (minimizing the increase in total distance)\n        min_cost = float('inf')\n        best_split = None\n\n        for k in range(1, len(longest_route)-1):\n            # Split into two parts: route1 = [0, ..., k, 0], route2 = [0, k+1, ..., 0]\n            route1 = np.concatenate([longest_route[:k+1], [0]])\n            route2 = np.concatenate([[0], longest_route[k+1:]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate cost increase\n                cost = (sum(distance_matrix[route1[:-1], route1[1:]]) +\n                        sum(distance_matrix[route2[:-1], route2[1:]]) -\n                        sum(distance_matrix[longest_route[:-1], longest_route[1:]]))\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            new_solution[longest_route_idx] = best_split[0]\n            new_solution.insert(longest_route_idx + 1, best_split[1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: 2-opt with route merging and splitting\n    # Step 1: Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting the closest endpoints\n            start1, end1 = route1[1], route1[-2]\n            start2, end2 = route2[1], route2[-2]\n\n            # Try all possible connections (start1-start2, start1-end2, end1-start2, end1-end2)\n            candidates = [\n                (np.concatenate([route1[:-1], route2[1:]]), distance_matrix[end1, start2]),\n                (np.concatenate([route1[:-1], route2[::-1][:-1]]), distance_matrix[end1, end2]),\n                (np.concatenate([route1[::-1][:-1], route2[1:]]), distance_matrix[start1, start2]),\n                (np.concatenate([route1[::-1][:-1], route2[::-1][:-1]]), distance_matrix[start1, end2])\n            ]\n\n            # Select the best merge option\n            best_merge, best_cost = None, float('inf')\n            for merged, cost in candidates:\n                if cost < best_cost:\n                    best_merge, best_cost = merged, cost\n\n            # Apply the best merge\n            new_solution[i] = best_merge\n            del new_solution[j]\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        n = len(route) - 1  # Exclude depot\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create new route by reversing the segment between a and b\n        new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n        # Check feasibility (capacity constraint)\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Step 3: Split a long route if possible\n    if len(new_solution) < len(archive[0][0]) and len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point (minimizing the increase in total distance)\n        min_cost = float('inf')\n        best_split = None\n\n        for k in range(1, len(longest_route)-1):\n            # Split into two parts: route1 = [0, ..., k, 0], route2 = [0, k+1, ..., 0]\n            route1 = np.concatenate([longest_route[:k+1], [0]])\n            route2 = np.concatenate([[0], longest_route[k+1:]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate cost increase\n                cost = (sum(distance_matrix[route1[:-1], route1[1:]]) +\n                        sum(distance_matrix[route2[:-1], route2[1:]]) -\n                        sum(distance_matrix[longest_route[:-1], longest_route[1:]]))\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            new_solution[longest_route_idx] = best_split[0]\n            new_solution.insert(longest_route_idx + 1, best_split[1])\n\n    return new_solution\n\n",
        "score": [
            -0.9715704092188657,
            0.7019793093204498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] - obj[0] for _, obj in archive])  # Prefer solutions with high makespan relative to distance\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply a hybrid local search: 2-opt with route merging and splitting\n    # Step 1: Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting the closest endpoints\n            start1, end1 = route1[1], route1[-2]\n            start2, end2 = route2[1], route2[-2]\n\n            # Try all possible connections (start1-start2, start1-end2, end1-start2, end1-end2)\n            candidates = [\n                (np.concatenate([route1[:-1], route2[1:]]), distance_matrix[end1, start2]),\n                (np.concatenate([route1[:-1], route2[::-1][:-1]]), distance_matrix[end1, end2]),\n                (np.concatenate([route1[::-1][:-1], route2[1:]]), distance_matrix[start1, start2]),\n                (np.concatenate([route1[::-1][:-1], route2[::-1][:-1]]), distance_matrix[start1, end2])\n            ]\n\n            # Select the best merge option\n            best_merge, best_cost = None, float('inf')\n            for merged, cost in candidates:\n                if cost < best_cost:\n                    best_merge, best_cost = merged, cost\n\n            # Apply the best merge\n            new_solution[i] = best_merge\n            del new_solution[j]\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        n = len(route) - 1  # Exclude depot\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create new route by reversing the segment between a and b\n        new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n        # Check feasibility (capacity constraint)\n        if sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n\n    # Step 3: Split a long route if possible\n    if len(new_solution) < len(archive[0][0]) and len(new_solution) > 0:\n        longest_route_idx = np.argmax([sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point (minimizing the increase in total distance)\n        min_cost = float('inf')\n        best_split = None\n\n        for k in range(1, len(longest_route)-1):\n            # Split into two parts: route1 = [0, ..., k, 0], route2 = [0, k+1, ..., 0]\n            route1 = np.concatenate([longest_route[:k+1], [0]])\n            route2 = np.concatenate([[0], longest_route[k+1:]])\n\n            # Check capacity constraints\n            if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                # Calculate cost increase\n                cost = (sum(distance_matrix[route1[:-1], route1[1:]]) +\n                        sum(distance_matrix[route2[:-1], route2[1:]]) -\n                        sum(distance_matrix[longest_route[:-1], longest_route[1:]]))\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_split = (route1, route2)\n\n        if best_split is not None:\n            new_solution[longest_route_idx] = best_split[0]\n            new_solution.insert(longest_route_idx + 1, best_split[1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Step 1: Select a solution with high potential for improvement (lowest makespan or lowest distance)\n    selected_solution = min(archive, key=lambda x: x[1][1] if random.random() < 0.5 else x[1][0])[0].copy()\n\n    # Step 2: Apply a hybrid local search: combination of route splitting and merging\n    new_solution = selected_solution.copy()\n\n    # Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at a random position\n            merge_pos = random.randint(1, len(route1) - 1)\n            merged_route = np.concatenate([route1[:merge_pos], route2[1:-1], route1[merge_pos:]])\n            new_solution[route_indices[0]] = merged_route\n            del new_solution[route_indices[1]]\n\n    # Step 3: Apply route splitting if merging didn't happen or with a probability\n    if random.random() < 0.3 or len(new_solution) == 1:\n        # Select a long route for splitting\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure the route is long enough to split\n            # Find a feasible split point (where demand up to that point <= capacity)\n            feasible_splits = []\n            current_demand = 0\n            for i, node in enumerate(longest_route[1:-1]):  # Exclude depots\n                current_demand += demand[node]\n                if current_demand <= capacity:\n                    feasible_splits.append(i + 1)  # +1 to account for depot\n\n            if feasible_splits:\n                split_pos = random.choice(feasible_splits)\n                # Split the route into two parts\n                route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n                new_solution[longest_route_idx] = route1\n                new_solution.insert(longest_route_idx + 1, route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4543052207679123,
            5.559264361858368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Step 1: Select a solution with high potential for improvement (lowest makespan or lowest distance)\n    selected_solution = min(archive, key=lambda x: x[1][1] if random.random() < 0.5 else x[1][0])[0].copy()\n\n    # Step 2: Apply a hybrid local search: combination of route splitting and merging\n    new_solution = selected_solution.copy()\n\n    # Randomly select two routes for potential merging\n    if len(new_solution) > 1:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if total_demand <= capacity:\n            # Merge the two routes by inserting route2 into route1 at a random position\n            merge_pos = random.randint(1, len(route1) - 1)\n            merged_route = np.concatenate([route1[:merge_pos], route2[1:-1], route1[merge_pos:]])\n            new_solution[route_indices[0]] = merged_route\n            del new_solution[route_indices[1]]\n\n    # Step 3: Apply route splitting if merging didn't happen or with a probability\n    if random.random() < 0.3 or len(new_solution) == 1:\n        # Select a long route for splitting\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:  # Ensure the route is long enough to split\n            # Find a feasible split point (where demand up to that point <= capacity)\n            feasible_splits = []\n            current_demand = 0\n            for i, node in enumerate(longest_route[1:-1]):  # Exclude depots\n                current_demand += demand[node]\n                if current_demand <= capacity:\n                    feasible_splits.append(i + 1)  # +1 to account for depot\n\n            if feasible_splits:\n                split_pos = random.choice(feasible_splits)\n                # Split the route into two parts\n                route1 = np.concatenate([longest_route[:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], longest_route[split_pos + 1:]])\n                new_solution[longest_route_idx] = route1\n                new_solution.insert(longest_route_idx + 1, route2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive with a high potential for improvement by prioritizing those with low total distance and high makespan, then applies a hybrid local search combining route splitting and cross-exchange to reduce makespan while maintaining feasibility and exploring solutions with better trade-offs between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting and cross-exchange\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If split violates capacity, try cross-exchange with another route\n            other_route_idx = random.randint(0, len(selected_solution) - 1)\n            if other_route_idx != selected_solution.index(route):\n                other_route = selected_solution[other_route_idx]\n                if len(other_route) > 3:\n                    # Find exchange points\n                    exchange_pos1 = random.randint(1, len(part1) - 2)\n                    exchange_pos2 = random.randint(1, len(other_route) - 2)\n\n                    # Create new routes\n                    new_part1 = np.concatenate([part1[:exchange_pos1], other_route[exchange_pos2:]])\n                    new_part2 = np.concatenate([other_route[:exchange_pos2], part1[exchange_pos1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_part1[1:-1]]) <= capacity and\n                        np.sum(demand[new_part2[1:-1]]) <= capacity):\n                        new_solution.append(new_part1)\n                        new_solution.append(new_part2)\n                    else:\n                        new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.790537102591873,
            0.4371751546859741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: route splitting and cross-exchange\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If split violates capacity, try cross-exchange with another route\n            other_route_idx = random.randint(0, len(selected_solution) - 1)\n            if other_route_idx != selected_solution.index(route):\n                other_route = selected_solution[other_route_idx]\n                if len(other_route) > 3:\n                    # Find exchange points\n                    exchange_pos1 = random.randint(1, len(part1) - 2)\n                    exchange_pos2 = random.randint(1, len(other_route) - 2)\n\n                    # Create new routes\n                    new_part1 = np.concatenate([part1[:exchange_pos1], other_route[exchange_pos2:]])\n                    new_part2 = np.concatenate([other_route[:exchange_pos2], part1[exchange_pos1:]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_part1[1:-1]]) <= capacity and\n                        np.sum(demand[new_part2[1:-1]]) <= capacity):\n                        new_solution.append(new_part1)\n                        new_solution.append(new_part2)\n                    else:\n                        new_solution.append(route.copy())\n            else:\n                new_solution.append(route.copy())\n\n    # Remove empty routes if any\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The algorithm selects a solution from the archive based on the Pareto front's knee point (or a randomly chosen non-dominated solution) and applies a hybrid local search combining route splitting, demand-based node reinsertion, and a novel \"demand-aware 2-opt\" to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by total distance (primary) and makespan (secondary)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution near the knee of the Pareto front or randomly\n        if len(sorted_archive) > 2:\n            # Randomly select between 20% and 80% of the archive for selection\n            candidate_idx = random.randint(int(0.2 * len(sorted_archive)), int(0.8 * len(sorted_archive)))\n            base_solution = sorted_archive[candidate_idx][0].copy()\n        else:\n            base_solution = sorted_archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Route Splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 2:  # Not just depot-depot\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand > capacity:\n                # Split the route at the point where demand is closest to half\n                split_pos = 1\n                current_demand = 0\n                for j in range(1, len(route)-1):\n                    current_demand += demand[route[j]]\n                    if current_demand > capacity / 2:\n                        split_pos = j\n                        break\n                # Create two new routes\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n\n    # Step 2.2: Demand-Aware Node Reinsertion\n    # Randomly select a route and a node to reinsert\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least one customer\n            node_pos = random.randint(1, len(route)-2)\n            node = route[node_pos]\n            # Remove the node from the route\n            new_route = np.concatenate((route[:node_pos], route[node_pos+1:]))\n            new_solution[route_idx] = new_route\n            # Find the best position to reinsert the node in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_increase = float('inf')\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    r = new_solution[i]\n                    for pos in range(1, len(r)):\n                        # Check if inserting the node here keeps capacity feasible\n                        if sum(demand[n] for n in r[1:pos]) + demand[node] <= capacity:\n                            # Calculate the increase in distance\n                            prev_node = r[pos-1]\n                            next_node = r[pos]\n                            increase = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n                            if increase < best_increase:\n                                best_increase = increase\n                                best_route_idx = i\n                                best_pos = pos\n            if best_route_idx != -1:\n                # Insert the node into the best position\n                r = new_solution[best_route_idx]\n                new_r = np.concatenate((r[:best_pos], [node], r[best_pos:]))\n                new_solution[best_route_idx] = new_r\n\n    # Step 2.3: Demand-Aware 2-Opt\n    # Randomly select a route and apply 2-opt with demand awareness\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # At least two customers\n            # Select two non-adjacent edges to reverse\n            i = random.randint(1, len(route)-4)\n            j = random.randint(i+2, len(route)-2)\n            # Check if reversing the segment keeps capacity feasible\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            # Check capacity for the new segment\n            if sum(demand[n] for n in reversed_segment[1:-1]) <= capacity:\n                # Check if the reversal improves the distance\n                old_dist = (distance_matrix[route[i-1]][route[i]] +\n                            distance_matrix[route[j]][route[j+1]])\n                new_dist = (distance_matrix[route[i-1]][reversed_segment[0]] +\n                            distance_matrix[reversed_segment[-1]][route[j+1]])\n                if new_dist < old_dist:\n                    # Apply the reversal\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.47526818064693505,
            1.6696462035179138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by total distance (primary) and makespan (secondary)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution near the knee of the Pareto front or randomly\n        if len(sorted_archive) > 2:\n            # Randomly select between 20% and 80% of the archive for selection\n            candidate_idx = random.randint(int(0.2 * len(sorted_archive)), int(0.8 * len(sorted_archive)))\n            base_solution = sorted_archive[candidate_idx][0].copy()\n        else:\n            base_solution = sorted_archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Route Splitting (if any route exceeds capacity)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 2:  # Not just depot-depot\n            route_demand = sum(demand[node] for node in route[1:-1])\n            if route_demand > capacity:\n                # Split the route at the point where demand is closest to half\n                split_pos = 1\n                current_demand = 0\n                for j in range(1, len(route)-1):\n                    current_demand += demand[route[j]]\n                    if current_demand > capacity / 2:\n                        split_pos = j\n                        break\n                # Create two new routes\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                # Replace the original route with the two new routes\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n\n    # Step 2.2: Demand-Aware Node Reinsertion\n    # Randomly select a route and a node to reinsert\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # At least one customer\n            node_pos = random.randint(1, len(route)-2)\n            node = route[node_pos]\n            # Remove the node from the route\n            new_route = np.concatenate((route[:node_pos], route[node_pos+1:]))\n            new_solution[route_idx] = new_route\n            # Find the best position to reinsert the node in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_increase = float('inf')\n            for i in range(len(new_solution)):\n                if i != route_idx:\n                    r = new_solution[i]\n                    for pos in range(1, len(r)):\n                        # Check if inserting the node here keeps capacity feasible\n                        if sum(demand[n] for n in r[1:pos]) + demand[node] <= capacity:\n                            # Calculate the increase in distance\n                            prev_node = r[pos-1]\n                            next_node = r[pos]\n                            increase = distance_matrix[prev_node][node] + distance_matrix[node][next_node] - distance_matrix[prev_node][next_node]\n                            if increase < best_increase:\n                                best_increase = increase\n                                best_route_idx = i\n                                best_pos = pos\n            if best_route_idx != -1:\n                # Insert the node into the best position\n                r = new_solution[best_route_idx]\n                new_r = np.concatenate((r[:best_pos], [node], r[best_pos:]))\n                new_solution[best_route_idx] = new_r\n\n    # Step 2.3: Demand-Aware 2-Opt\n    # Randomly select a route and apply 2-opt with demand awareness\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # At least two customers\n            # Select two non-adjacent edges to reverse\n            i = random.randint(1, len(route)-4)\n            j = random.randint(i+2, len(route)-2)\n            # Check if reversing the segment keeps capacity feasible\n            segment = route[i:j+1]\n            reversed_segment = segment[::-1]\n            # Check capacity for the new segment\n            if sum(demand[n] for n in reversed_segment[1:-1]) <= capacity:\n                # Check if the reversal improves the distance\n                old_dist = (distance_matrix[route[i-1]][route[i]] +\n                            distance_matrix[route[j]][route[j+1]])\n                new_dist = (distance_matrix[route[i-1]][reversed_segment[0]] +\n                            distance_matrix[reversed_segment[-1]][route[j+1]])\n                if new_dist < old_dist:\n                    # Apply the reversal\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx - 1:]\n\n        # Reallocate customers between the two parts\n        for i in range(1, len(part1) - 1):\n            if demand[part1[i]] + demand[part2[1]] <= capacity:\n                part2 = np.insert(part2, 1, part1[i])\n                part1 = np.delete(part1, i)\n                break\n\n        # Ensure feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route.copy())\n\n    # Check for empty routes and merge if necessary\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only keep non-empty routes\n            final_solution.append(route)\n\n    # If no valid split, perform a random 2-opt within a route\n    if not final_solution:\n        final_solution = base_solution.copy()\n        route_idx = np.random.randint(len(final_solution))\n        route = final_solution[route_idx]\n        if len(route) > 3:\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                final_solution[route_idx] = new_route\n\n    return final_solution\n\n",
        "score": [
            -0.6581901558197424,
            1.4821346700191498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx - 1:]\n\n        # Reallocate customers between the two parts\n        for i in range(1, len(part1) - 1):\n            if demand[part1[i]] + demand[part2[1]] <= capacity:\n                part2 = np.insert(part2, 1, part1[i])\n                part1 = np.delete(part1, i)\n                break\n\n        # Ensure feasibility\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route.copy())\n\n    # Check for empty routes and merge if necessary\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only keep non-empty routes\n            final_solution.append(route)\n\n    # If no valid split, perform a random 2-opt within a route\n    if not final_solution:\n        final_solution = base_solution.copy()\n        route_idx = np.random.randint(len(final_solution))\n        route = final_solution[route_idx]\n        if len(route) > 3:\n            i, j = np.random.choice(range(1, len(route) - 1), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_route = np.concatenate([route[:i], route[j:i-1:-1], route[j+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                final_solution[route_idx] = new_route\n\n    return final_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined objective score (weighted sum of normalized total distance and makespan), then applies a hybrid local search operator that combines route merging, partial route reversal, and demand-balanced relocation to generate a feasible neighbor solution while improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def combined_score(obj):\n        # Normalize objectives and combine with weights (adjust weights as needed)\n        total_dist, makespan = obj\n        max_dist = max(o[0] for o in [x[1] for x in archive])\n        max_makespan = max(o[1] for o in [x[1] for x in archive])\n        if max_dist == 0 or max_makespan == 0:\n            return 0.5 * total_dist + 0.5 * makespan\n        return 0.5 * (total_dist / max_dist) + 0.5 * (makespan / max_makespan)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge routes (simplified: concatenate and remove duplicates)\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            merged_route = np.unique(merged_route, axis=0)  # Remove duplicates\n            new_solution = [merged_route] + [r for k, r in enumerate(new_solution) if k not in {i, j}]\n\n    # Step 2: Partial route reversal (reverse a segment of a route)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's a segment to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            reversed_segment = route[a:b+1][::-1]\n            new_route = np.concatenate((route[:a], reversed_segment, route[b+1:]))\n            new_solution[route_idx] = new_route\n\n    # Step 3: Demand-balanced relocation (move a customer to another route if it improves balance)\n    if len(new_solution) > 1:\n        route_idx_from = random.randint(0, len(new_solution) - 1)\n        route_from = new_solution[route_idx_from]\n        if len(route_from) > 2:  # Ensure there's a customer to move\n            customer_idx = random.randint(1, len(route_from) - 2)\n            customer = route_from[customer_idx]\n\n            # Try to place in another route\n            for route_idx_to in range(len(new_solution)):\n                if route_idx_to == route_idx_from:\n                    continue\n                route_to = new_solution[route_idx_to]\n                if np.sum(demand[route_to[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route_to (simplified: append)\n                    new_route_to = np.concatenate((route_to[:-1], [customer], [0]))\n                    new_route_from = np.concatenate((route_from[:customer_idx], route_from[customer_idx+1:]))\n\n                    # Update solution\n                    new_solution[route_idx_to] = new_route_to\n                    new_solution[route_idx_from] = new_route_from\n                    break\n\n    # Ensure feasibility (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5711954225613611,
            0.535738617181778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def combined_score(obj):\n        # Normalize objectives and combine with weights (adjust weights as needed)\n        total_dist, makespan = obj\n        max_dist = max(o[0] for o in [x[1] for x in archive])\n        max_makespan = max(o[1] for o in [x[1] for x in archive])\n        if max_dist == 0 or max_makespan == 0:\n            return 0.5 * total_dist + 0.5 * makespan\n        return 0.5 * (total_dist / max_dist) + 0.5 * (makespan / max_makespan)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n            # Merge routes (simplified: concatenate and remove duplicates)\n            merged_route = np.concatenate((route_i[:-1], route_j[1:]))\n            merged_route = np.unique(merged_route, axis=0)  # Remove duplicates\n            new_solution = [merged_route] + [r for k, r in enumerate(new_solution) if k not in {i, j}]\n\n    # Step 2: Partial route reversal (reverse a segment of a route)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure there's a segment to reverse\n            a, b = sorted(random.sample(range(1, len(route) - 1), 2))\n            reversed_segment = route[a:b+1][::-1]\n            new_route = np.concatenate((route[:a], reversed_segment, route[b+1:]))\n            new_solution[route_idx] = new_route\n\n    # Step 3: Demand-balanced relocation (move a customer to another route if it improves balance)\n    if len(new_solution) > 1:\n        route_idx_from = random.randint(0, len(new_solution) - 1)\n        route_from = new_solution[route_idx_from]\n        if len(route_from) > 2:  # Ensure there's a customer to move\n            customer_idx = random.randint(1, len(route_from) - 2)\n            customer = route_from[customer_idx]\n\n            # Try to place in another route\n            for route_idx_to in range(len(new_solution)):\n                if route_idx_to == route_idx_from:\n                    continue\n                route_to = new_solution[route_idx_to]\n                if np.sum(demand[route_to[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into route_to (simplified: append)\n                    new_route_to = np.concatenate((route_to[:-1], [customer], [0]))\n                    new_route_from = np.concatenate((route_from[:customer_idx], route_from[customer_idx+1:]))\n\n                    # Update solution\n                    new_solution[route_idx_to] = new_route_to\n                    new_solution[route_idx_from] = new_route_from\n                    break\n\n    # Ensure feasibility (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its objective values and applies a hybrid local search operator that combines route swapping, route merging, and demand-aware node reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping, merging, and reinsertion\n    if len(new_solution) > 1:\n        # Route swapping: swap two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swapping\n    feasible = all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution)\n    if not feasible:\n        new_solution = selected_solution.copy()\n\n    # Route merging: merge two routes if their total demand <= capacity\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in (i, j)]\n            new_solution.append(merged_route)\n\n    # Demand-aware reinsertion: move a random node from a random route to another route\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has nodes to remove\n            node_pos = np.random.choice(len(route) - 2) + 1  # Avoid depot\n            node = route[node_pos]\n            # Find feasible insertion positions in other routes\n            feasible_insertions = []\n            for other_route_idx, other_route in enumerate(new_solution):\n                if other_route_idx == route_idx:\n                    continue\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        feasible_insertions.append((other_route_idx, pos, temp_route))\n            if feasible_insertions:\n                other_route_idx, pos, new_route = feasible_insertions[np.random.choice(len(feasible_insertions))]\n                # Update routes\n                new_solution[route_idx] = np.delete(route, node_pos)\n                new_solution[other_route_idx] = new_route\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4141842110852804,
            4.400372385978699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route swapping, merging, and reinsertion\n    if len(new_solution) > 1:\n        # Route swapping: swap two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Check feasibility after swapping\n    feasible = all(np.sum(demand[route[1:-1]]) <= capacity for route in new_solution)\n    if not feasible:\n        new_solution = selected_solution.copy()\n\n    # Route merging: merge two routes if their total demand <= capacity\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        merged_route = np.concatenate((new_solution[i][:-1], new_solution[j][1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in (i, j)]\n            new_solution.append(merged_route)\n\n    # Demand-aware reinsertion: move a random node from a random route to another route\n    if len(new_solution) > 1 and np.random.rand() < 0.5:\n        route_idx = np.random.choice(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route has nodes to remove\n            node_pos = np.random.choice(len(route) - 2) + 1  # Avoid depot\n            node = route[node_pos]\n            # Find feasible insertion positions in other routes\n            feasible_insertions = []\n            for other_route_idx, other_route in enumerate(new_solution):\n                if other_route_idx == route_idx:\n                    continue\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        feasible_insertions.append((other_route_idx, pos, temp_route))\n            if feasible_insertions:\n                other_route_idx, pos, new_route = feasible_insertions[np.random.choice(len(feasible_insertions))]\n                # Update routes\n                new_solution[route_idx] = np.delete(route, node_pos)\n                new_solution[other_route_idx] = new_route\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route truncation, customer reinsertion, and 2-opt with capacity checks to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Choose a route to modify\n    if len(selected_solution) > 1:\n        route_indices = list(range(len(selected_solution)))\n        selected_route_idx = random.choice(route_indices)\n        selected_route = selected_solution[selected_route_idx].copy()\n    else:\n        selected_route_idx = 0\n        selected_route = selected_solution[0].copy()\n\n    # Hybrid local search: route truncation + reinsertion + 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Truncate a random segment from the route\n    if len(selected_route) > 4:  # Ensure we can truncate without making the route invalid\n        start = random.randint(1, len(selected_route) - 3)\n        end = random.randint(start + 1, len(selected_route) - 2)\n        truncated_segment = selected_route[start:end]\n        remaining_route = np.concatenate([selected_route[:start], selected_route[end:]])\n\n        # Step 2: Reinsert customers from the truncated segment into other routes\n        for customer in truncated_segment:\n            if customer == 0:\n                continue\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if i == selected_route_idx:\n                    continue\n                # Check if adding the customer exceeds capacity\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n        # Step 3: Apply 2-opt within the remaining route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(remaining_route) - 2):\n                for j in range(i + 1, len(remaining_route) - 1):\n                    # Check if reversing the segment is feasible\n                    segment = remaining_route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_segment = np.concatenate([[remaining_route[i-1]], reversed_segment, [remaining_route[j+1]]])\n                    # Check capacity constraint\n                    if sum(demand[new_segment[1:-1]]) <= capacity:\n                        # Check if the reversal reduces the distance\n                        old_dist = distance_matrix[remaining_route[i-1], remaining_route[i]] + distance_matrix[remaining_route[j], remaining_route[j+1]]\n                        new_dist = distance_matrix[remaining_route[i-1], remaining_route[j]] + distance_matrix[remaining_route[i], remaining_route[j+1]]\n                        if new_dist < old_dist:\n                            remaining_route[i:j+1] = reversed_segment\n                            improved = True\n                            break\n                if improved:\n                    break\n        new_solution[selected_route_idx] = remaining_route\n\n    return new_solution\n\n",
        "score": [
            -0.4399620455337953,
            1.8753981292247772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Choose a route to modify\n    if len(selected_solution) > 1:\n        route_indices = list(range(len(selected_solution)))\n        selected_route_idx = random.choice(route_indices)\n        selected_route = selected_solution[selected_route_idx].copy()\n    else:\n        selected_route_idx = 0\n        selected_route = selected_solution[0].copy()\n\n    # Hybrid local search: route truncation + reinsertion + 2-opt\n    new_solution = selected_solution.copy()\n\n    # Step 1: Truncate a random segment from the route\n    if len(selected_route) > 4:  # Ensure we can truncate without making the route invalid\n        start = random.randint(1, len(selected_route) - 3)\n        end = random.randint(start + 1, len(selected_route) - 2)\n        truncated_segment = selected_route[start:end]\n        remaining_route = np.concatenate([selected_route[:start], selected_route[end:]])\n\n        # Step 2: Reinsert customers from the truncated segment into other routes\n        for customer in truncated_segment:\n            if customer == 0:\n                continue\n            inserted = False\n            for i, route in enumerate(new_solution):\n                if i == selected_route_idx:\n                    continue\n                # Check if adding the customer exceeds capacity\n                route_demand = sum(demand[route[1:-1]])\n                if route_demand + demand[customer] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(route)):\n                        increase = distance_matrix[route[pos-1], customer] + distance_matrix[customer, route[pos]] - distance_matrix[route[pos-1], route[pos]]\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.insert(route, best_pos, customer)\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                # If not inserted, create a new route\n                new_route = np.array([0, customer, 0])\n                new_solution.append(new_route)\n\n        # Step 3: Apply 2-opt within the remaining route\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(remaining_route) - 2):\n                for j in range(i + 1, len(remaining_route) - 1):\n                    # Check if reversing the segment is feasible\n                    segment = remaining_route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_segment = np.concatenate([[remaining_route[i-1]], reversed_segment, [remaining_route[j+1]]])\n                    # Check capacity constraint\n                    if sum(demand[new_segment[1:-1]]) <= capacity:\n                        # Check if the reversal reduces the distance\n                        old_dist = distance_matrix[remaining_route[i-1], remaining_route[i]] + distance_matrix[remaining_route[j], remaining_route[j+1]]\n                        new_dist = distance_matrix[remaining_route[i-1], remaining_route[j]] + distance_matrix[remaining_route[i], remaining_route[j+1]]\n                        if new_dist < old_dist:\n                            remaining_route[i:j+1] = reversed_segment\n                            improved = True\n                            break\n                if improved:\n                    break\n        new_solution[selected_route_idx] = remaining_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = []\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly split the route into two parts\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                for other_route in new_solution:\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into the other route at the nearest feasible position\n                        for j in range(1, len(other_route)):\n                            if distance_matrix[other_route[j-1], customer] + distance_matrix[customer, other_route[j]] <= \\\n                               distance_matrix[other_route[j-1], other_route[j]]:\n                                other_route.insert(j, customer)\n                                break\n                        break\n            new_solution.append(route.copy())\n\n    return new_solution\n\n",
        "score": [
            -0.7742534409146569,
            0.6890870034694672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = []\n\n    # Apply a hybrid local search: combine route splitting and customer reallocation\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly split the route into two parts\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n        else:\n            # If splitting violates capacity, try reallocating a customer to another route\n            for i in range(1, len(route) - 1):\n                customer = route[i]\n                for other_route in new_solution:\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert customer into the other route at the nearest feasible position\n                        for j in range(1, len(other_route)):\n                            if distance_matrix[other_route[j-1], customer] + distance_matrix[customer, other_route[j]] <= \\\n                               distance_matrix[other_route[j-1], other_route[j]]:\n                                other_route.insert(j, customer)\n                                break\n                        break\n            new_solution.append(route.copy())\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{A novel local search strategy combines route segmentation with demand-aware customer reallocation, followed by a bidirectional swap to balance distance and makespan objectives, while ensuring capacity constraints are preserved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 1: Route Segmentation and Demand-Aware Reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments based on demand thresholds\n        segment_start = 0\n        current_load = 0\n        segments = []\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load >= capacity * 0.7:  # Threshold for segmentation\n                segments.append(route[segment_start:i+1])\n                segment_start = i\n                current_load = demand[route[i]]\n\n        if segment_start < len(route) - 1:\n            segments.append(route[segment_start:])\n\n        # Reallocate customers between segments while preserving order\n        for i in range(len(segments) - 1):\n            seg1, seg2 = segments[i], segments[i+1]\n            if len(seg1) > 2 and len(seg2) > 2:\n                # Swap last customer of seg1 with first customer of seg2 if beneficial\n                cust1, cust2 = seg1[-2], seg2[1]\n                if demand[cust1] + sum(demand[seg2[1:-1]]) <= capacity and demand[cust2] + sum(demand[seg1[1:-1]]) <= capacity:\n                    seg1[-2], seg2[1] = seg2[1], seg1[-2]\n                    segments[i], segments[i+1] = seg1, seg2\n\n        # Reconstruct route from segments\n        new_route = [route[0]]\n        for seg in segments:\n            new_route.extend(seg[1:-1])\n        new_route.append(route[-1])\n        new_solution.append(np.array(new_route))\n\n    # Step 2: Bidirectional Swap for Makespan Reduction\n    if len(new_solution) > 1:\n        # Identify longest and shortest routes\n        longest_route = max(new_solution, key=lambda x: distance_matrix[x[:-1], x[1:]].sum())\n        shortest_route = min(new_solution, key=lambda x: distance_matrix[x[:-1], x[1:]].sum())\n\n        if len(longest_route) > 3 and len(shortest_route) > 3:\n            # Find best customer to transfer from longest to shortest route\n            best_improvement = 0\n            best_cust = None\n            best_pos = None\n\n            for i in range(1, len(longest_route) - 1):\n                cust = longest_route[i]\n                # Check if adding cust to shortest route is feasible\n                if sum(demand[shortest_route[1:-1]]) + demand[cust] <= capacity:\n                    # Find best insertion position in shortest route\n                    for j in range(1, len(shortest_route)):\n                        new_shortest = np.concatenate([shortest_route[:j], [cust], shortest_route[j:]])\n                        new_longest = np.concatenate([longest_route[:i], longest_route[i+1:]])\n\n                        # Calculate new distances\n                        old_dist = distance_matrix[shortest_route[j-1], shortest_route[j]] + distance_matrix[longest_route[i-1], longest_route[i]] + distance_matrix[longest_route[i], longest_route[i+1]]\n                        new_dist = distance_matrix[shortest_route[j-1], cust] + distance_matrix[cust, shortest_route[j]] + distance_matrix[new_longest[i-1], new_longest[i]]\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_cust = cust\n                            best_pos = j\n\n            if best_cust is not None:\n                # Perform the swap\n                for i, route in enumerate(new_solution):\n                    if np.array_equal(route, longest_route):\n                        new_solution[i] = np.concatenate([route[:np.where(route == best_cust)[0][0]], route[np.where(route == best_cust)[0][0]+1:]])\n                    elif np.array_equal(route, shortest_route):\n                        new_solution[i] = np.concatenate([route[:best_pos], [best_cust], route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7725475383548721,
            3.3950426876544952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)  # Sort by makespan descending\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 1: Route Segmentation and Demand-Aware Reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip too short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments based on demand thresholds\n        segment_start = 0\n        current_load = 0\n        segments = []\n        for i in range(1, len(route) - 1):\n            current_load += demand[route[i]]\n            if current_load >= capacity * 0.7:  # Threshold for segmentation\n                segments.append(route[segment_start:i+1])\n                segment_start = i\n                current_load = demand[route[i]]\n\n        if segment_start < len(route) - 1:\n            segments.append(route[segment_start:])\n\n        # Reallocate customers between segments while preserving order\n        for i in range(len(segments) - 1):\n            seg1, seg2 = segments[i], segments[i+1]\n            if len(seg1) > 2 and len(seg2) > 2:\n                # Swap last customer of seg1 with first customer of seg2 if beneficial\n                cust1, cust2 = seg1[-2], seg2[1]\n                if demand[cust1] + sum(demand[seg2[1:-1]]) <= capacity and demand[cust2] + sum(demand[seg1[1:-1]]) <= capacity:\n                    seg1[-2], seg2[1] = seg2[1], seg1[-2]\n                    segments[i], segments[i+1] = seg1, seg2\n\n        # Reconstruct route from segments\n        new_route = [route[0]]\n        for seg in segments:\n            new_route.extend(seg[1:-1])\n        new_route.append(route[-1])\n        new_solution.append(np.array(new_route))\n\n    # Step 2: Bidirectional Swap for Makespan Reduction\n    if len(new_solution) > 1:\n        # Identify longest and shortest routes\n        longest_route = max(new_solution, key=lambda x: distance_matrix[x[:-1], x[1:]].sum())\n        shortest_route = min(new_solution, key=lambda x: distance_matrix[x[:-1], x[1:]].sum())\n\n        if len(longest_route) > 3 and len(shortest_route) > 3:\n            # Find best customer to transfer from longest to shortest route\n            best_improvement = 0\n            best_cust = None\n            best_pos = None\n\n            for i in range(1, len(longest_route) - 1):\n                cust = longest_route[i]\n                # Check if adding cust to shortest route is feasible\n                if sum(demand[shortest_route[1:-1]]) + demand[cust] <= capacity:\n                    # Find best insertion position in shortest route\n                    for j in range(1, len(shortest_route)):\n                        new_shortest = np.concatenate([shortest_route[:j], [cust], shortest_route[j:]])\n                        new_longest = np.concatenate([longest_route[:i], longest_route[i+1:]])\n\n                        # Calculate new distances\n                        old_dist = distance_matrix[shortest_route[j-1], shortest_route[j]] + distance_matrix[longest_route[i-1], longest_route[i]] + distance_matrix[longest_route[i], longest_route[i+1]]\n                        new_dist = distance_matrix[shortest_route[j-1], cust] + distance_matrix[cust, shortest_route[j]] + distance_matrix[new_longest[i-1], new_longest[i]]\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_cust = cust\n                            best_pos = j\n\n            if best_cust is not None:\n                # Perform the swap\n                for i, route in enumerate(new_solution):\n                    if np.array_equal(route, longest_route):\n                        new_solution[i] = np.concatenate([route[:np.where(route == best_cust)[0][0]], route[np.where(route == best_cust)[0][0]+1:]])\n                    elif np.array_equal(route, shortest_route):\n                        new_solution[i] = np.concatenate([route[:best_pos], [best_cust], route[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with low total distance or high makespan, then applies a hybrid local search combining route fragmentation and customer reinsertion with capacity checks to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragment and Reinsert with Capacity Check\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly fragment the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Attempt to reinsert customers from part2 into part1 with capacity check\n        reinserted_part1 = part1.copy()\n        remaining_customers = []\n        current_load = sum(demand[part1[1:-1]])\n\n        for customer in part2[1:-1]:\n            if current_load + demand[customer] <= capacity:\n                reinserted_part1 = np.insert(reinserted_part1, -1, customer)\n                current_load += demand[customer]\n            else:\n                remaining_customers.append(customer)\n\n        # If reinserted_part1 is not full, try to insert from remaining_customers\n        if len(remaining_customers) > 0:\n            temp_route = reinserted_part1.copy()\n            for customer in remaining_customers:\n                if current_load + demand[customer] <= capacity:\n                    temp_route = np.insert(temp_route, -1, customer)\n                    current_load += demand[customer]\n                else:\n                    # If still cannot insert, create a new route\n                    new_solution.append(np.array([0, customer, 0]))\n            reinserted_part1 = temp_route\n\n        new_solution.append(reinserted_part1)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        new_solution.append(np.array([0] + list(missing_customers) + [0]))\n\n    return new_solution\n\n",
        "score": [
            -0.877307681652709,
            3.0284199118614197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Fragment and Reinsert with Capacity Check\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Randomly fragment the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Attempt to reinsert customers from part2 into part1 with capacity check\n        reinserted_part1 = part1.copy()\n        remaining_customers = []\n        current_load = sum(demand[part1[1:-1]])\n\n        for customer in part2[1:-1]:\n            if current_load + demand[customer] <= capacity:\n                reinserted_part1 = np.insert(reinserted_part1, -1, customer)\n                current_load += demand[customer]\n            else:\n                remaining_customers.append(customer)\n\n        # If reinserted_part1 is not full, try to insert from remaining_customers\n        if len(remaining_customers) > 0:\n            temp_route = reinserted_part1.copy()\n            for customer in remaining_customers:\n                if current_load + demand[customer] <= capacity:\n                    temp_route = np.insert(temp_route, -1, customer)\n                    current_load += demand[customer]\n                else:\n                    # If still cannot insert, create a new route\n                    new_solution.append(np.array([0, customer, 0]))\n            reinserted_part1 = temp_route\n\n        new_solution.append(reinserted_part1)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        new_solution.append(np.array([0] + list(missing_customers) + [0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route segment reversal and customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment reversal and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Segment reversal\n        if len(route) > 4:\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            route[start:end] = route[start:end][::-1]\n\n        # Customer reallocation\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n            if len(route) > 2 and len(other_route) > 2:\n                # Move a random customer from route to other_route\n                customer_idx = random.randint(1, len(route) - 2)\n                customer = route[customer_idx]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    other_route = np.insert(other_route, -1, customer)\n                    route = np.delete(route, customer_idx)\n\n        # Update the solution\n        new_solution[route_idx] = route\n        if len(new_solution) > 1:\n            new_solution[other_route_idx] = other_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.45710951827778223,
            0.70094433426857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment reversal and customer reallocation\n    new_solution = selected_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        # Segment reversal\n        if len(route) > 4:\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n            route[start:end] = route[start:end][::-1]\n\n        # Customer reallocation\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx].copy()\n            if len(route) > 2 and len(other_route) > 2:\n                # Move a random customer from route to other_route\n                customer_idx = random.randint(1, len(route) - 2)\n                customer = route[customer_idx]\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    other_route = np.insert(other_route, -1, customer)\n                    route = np.delete(route, customer_idx)\n\n        # Update the solution\n        new_solution[route_idx] = route\n        if len(new_solution) > 1:\n            new_solution[other_route_idx] = other_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original solution\n            return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Skip empty routes\n        if len(route) <= 2:\n            continue\n\n        # Split the route into two parts and try to reallocate customers\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Try merging routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i]\n        merged = False\n\n        for j in range(i + 1, len(new_solution)):\n            other_route = new_solution[j]\n            combined_route = np.concatenate([current_route[:-1], other_route[1:]])\n\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                merged_solution.append(combined_route)\n                merged = True\n                i = j + 1\n                break\n\n        if not merged:\n            merged_solution.append(current_route)\n            i += 1\n\n    # Ensure all customers are served (fallback to original if merging fails)\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n\n    if len(served_customers) != len(demand) - 1:\n        merged_solution = selected_solution.copy()\n\n    return merged_solution\n\n",
        "score": [
            -0.7311557160967435,
            1.1588452458381653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Hybrid local search: Combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Skip empty routes\n        if len(route) <= 2:\n            continue\n\n        # Split the route into two parts and try to reallocate customers\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Try merging routes if possible\n    merged_solution = []\n    i = 0\n    while i < len(new_solution):\n        current_route = new_solution[i]\n        merged = False\n\n        for j in range(i + 1, len(new_solution)):\n            other_route = new_solution[j]\n            combined_route = np.concatenate([current_route[:-1], other_route[1:]])\n\n            if np.sum(demand[combined_route[1:-1]]) <= capacity:\n                merged_solution.append(combined_route)\n                merged = True\n                i = j + 1\n                break\n\n        if not merged:\n            merged_solution.append(current_route)\n            i += 1\n\n    # Ensure all customers are served (fallback to original if merging fails)\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n\n    if len(served_customers) != len(demand) - 1:\n        merged_solution = selected_solution.copy()\n\n    return merged_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search combining route merging and relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to relocate or merge\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]  # Exclude the last depot\n\n        # Check if merging with another route is feasible\n        feasible_merge = False\n        for i, other_route in enumerate(selected_solution):\n            if len(other_route) <= 2:  # Skip empty or trivial routes\n                continue\n            if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                # Merge the segment into the other route\n                new_route = np.concatenate([other_route[:-1], segment, [0]])\n                new_solution.append(new_route)\n                feasible_merge = True\n                break\n\n        if not feasible_merge:\n            # If no merge, try relocating the segment to a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_route = np.concatenate([[0], segment, [0]])\n                new_solution.append(new_route)\n\n        # Remove the original route (excluding the segment)\n        new_solution.append(np.concatenate([route[:split_pos], [0]]))\n\n    # Step 3: Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is exceeded, split the route\n            current_load = 0\n            split_positions = [0]\n            for i in range(1, len(route) - 1):\n                if current_load + demand[route[i]] > capacity:\n                    split_positions.append(i)\n                    current_load = 0\n                current_load += demand[route[i]]\n            split_positions.append(len(route) - 1)\n\n            # Create split routes\n            split_routes = []\n            for i in range(len(split_positions) - 1):\n                split_route = np.concatenate([[0], route[split_positions[i]:split_positions[i+1]], [0]])\n                split_routes.append(split_route)\n            new_solution.remove(route)\n            new_solution.extend(split_routes)\n\n    return new_solution\n\n",
        "score": [
            -0.7652103537693103,
            3.7132609486579895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search combining route merging and relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Randomly select a segment to relocate or merge\n        split_pos = np.random.randint(1, len(route) - 1)\n        segment = route[split_pos:-1]  # Exclude the last depot\n\n        # Check if merging with another route is feasible\n        feasible_merge = False\n        for i, other_route in enumerate(selected_solution):\n            if len(other_route) <= 2:  # Skip empty or trivial routes\n                continue\n            if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                # Merge the segment into the other route\n                new_route = np.concatenate([other_route[:-1], segment, [0]])\n                new_solution.append(new_route)\n                feasible_merge = True\n                break\n\n        if not feasible_merge:\n            # If no merge, try relocating the segment to a new route\n            if np.sum(demand[segment]) <= capacity:\n                new_route = np.concatenate([[0], segment, [0]])\n                new_solution.append(new_route)\n\n        # Remove the original route (excluding the segment)\n        new_solution.append(np.concatenate([route[:split_pos], [0]]))\n\n    # Step 3: Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If capacity is exceeded, split the route\n            current_load = 0\n            split_positions = [0]\n            for i in range(1, len(route) - 1):\n                if current_load + demand[route[i]] > capacity:\n                    split_positions.append(i)\n                    current_load = 0\n                current_load += demand[route[i]]\n            split_positions.append(len(route) - 1)\n\n            # Create split routes\n            split_routes = []\n            for i in range(len(split_positions) - 1):\n                split_route = np.concatenate([[0], route[split_positions[i]:split_positions[i+1]], [0]])\n                split_routes.append(split_route)\n            new_solution.remove(route)\n            new_solution.extend(split_routes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of its objective values, then applies a hybrid local search combining route segment reshuffling, depot insertion, and demand-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Number of attempts\n        # Step 1: Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Extract a random segment from route1\n        if len(route1) < 4:  # Need at least 3 nodes (depot + customer + depot)\n            continue\n        start_pos = random.randint(1, len(route1) - 3)\n        end_pos = random.randint(start_pos + 1, len(route1) - 2)\n        segment = route1[start_pos:end_pos]\n\n        # Step 3: Check if segment can be moved to route2\n        current_demand_route2 = sum(demand[node] for node in route2 if node != 0)\n        segment_demand = sum(demand[node] for node in segment)\n        if current_demand_route2 + segment_demand > capacity:\n            continue\n\n        # Step 4: Insert segment into route2\n        insert_pos = random.randint(1, len(route2) - 1)\n        new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n        # Step 5: Remove segment from route1\n        new_route1 = np.concatenate([route1[:start_pos], route1[end_pos:]])\n\n        # Step 6: Update solution if feasible\n        if len(new_route1) > 2 and len(new_route2) > 2:\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 7: Optional: Apply demand-aware swap within a route\n        for route in new_solution:\n            if len(route) > 3:\n                i, j = random.sample(range(1, len(route) - 1), 2)\n                total_demand = sum(demand[node] for node in route if node != 0)\n                if total_demand <= capacity:  # Ensure feasibility\n                    route[i], route[j] = route[j], route[i]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7015866494024158,
            2.8219360411167145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on total distance\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    for _ in range(3):  # Number of attempts\n        # Step 1: Randomly select two routes\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Step 2: Extract a random segment from route1\n        if len(route1) < 4:  # Need at least 3 nodes (depot + customer + depot)\n            continue\n        start_pos = random.randint(1, len(route1) - 3)\n        end_pos = random.randint(start_pos + 1, len(route1) - 2)\n        segment = route1[start_pos:end_pos]\n\n        # Step 3: Check if segment can be moved to route2\n        current_demand_route2 = sum(demand[node] for node in route2 if node != 0)\n        segment_demand = sum(demand[node] for node in segment)\n        if current_demand_route2 + segment_demand > capacity:\n            continue\n\n        # Step 4: Insert segment into route2\n        insert_pos = random.randint(1, len(route2) - 1)\n        new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n\n        # Step 5: Remove segment from route1\n        new_route1 = np.concatenate([route1[:start_pos], route1[end_pos:]])\n\n        # Step 6: Update solution if feasible\n        if len(new_route1) > 2 and len(new_route2) > 2:\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Step 7: Optional: Apply demand-aware swap within a route\n        for route in new_solution:\n            if len(route) > 3:\n                i, j = random.sample(range(1, len(route) - 1), 2)\n                total_demand = sum(demand[node] for node in route if node != 0)\n                if total_demand <= capacity:  # Ensure feasibility\n                    route[i], route[j] = route[j], route[i]\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) and the shortest route\n    longest_route_idx = max(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n    shortest_route_idx = min(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n\n    # Step 3: Attempt to merge the shortest route into the longest route if feasible\n    if len(selected_solution) > 1:\n        shortest_route = selected_solution[shortest_route_idx].copy()\n        longest_route = selected_solution[longest_route_idx].copy()\n\n        # Remove depot from the shortest route (already present in longest route)\n        customers = shortest_route[1:-1]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[customer] for customer in customers)\n        if total_demand <= capacity:\n            # Insert customers into the longest route using a greedy approach\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                # Try inserting all customers at position i\n                temp_route = np.insert(longest_route, i, customers)\n                cost = sum(distance_matrix[temp_route[j-1], temp_route[j]] for j in range(1, len(temp_route)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Update the longest route\n            selected_solution[longest_route_idx] = np.insert(longest_route, best_pos, customers)\n            # Remove the now-empty shortest route\n            selected_solution.pop(shortest_route_idx)\n\n    # Step 4: Apply adaptive 2-opt on the longest route\n    longest_route = selected_solution[longest_route_idx].copy()\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(longest_route) - 2):\n            for j in range(i + 2, len(longest_route) - 1):\n                # Create a new route by reversing the segment between i and j\n                new_route = np.concatenate([\n                    longest_route[:i],\n                    longest_route[i:j+1][::-1],\n                    longest_route[j+1:]\n                ])\n\n                # Check capacity constraint\n                current_demand = 0\n                feasible = True\n                for node in new_route[1:-1]:  # Skip depot\n                    current_demand += demand[node]\n                    if current_demand > capacity:\n                        feasible = False\n                        break\n\n                if feasible:\n                    # Calculate the change in distance\n                    old_distance = (distance_matrix[longest_route[i-1], longest_route[i]] +\n                                  distance_matrix[longest_route[j], longest_route[j+1]])\n                    new_distance = (distance_matrix[new_route[i-1], new_route[i]] +\n                                  distance_matrix[new_route[j], new_route[j+1]])\n\n                    if new_distance < old_distance:\n                        longest_route = new_route.copy()\n                        improved = True\n                        break\n            if improved:\n                break\n\n    # Update the longest route in the solution\n    selected_solution[longest_route_idx] = longest_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7067837485887404,
            4.6136550307273865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Step 2: Identify the longest route (highest makespan) and the shortest route\n    longest_route_idx = max(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n    shortest_route_idx = min(range(len(selected_solution)), key=lambda i: len(selected_solution[i]))\n\n    # Step 3: Attempt to merge the shortest route into the longest route if feasible\n    if len(selected_solution) > 1:\n        shortest_route = selected_solution[shortest_route_idx].copy()\n        longest_route = selected_solution[longest_route_idx].copy()\n\n        # Remove depot from the shortest route (already present in longest route)\n        customers = shortest_route[1:-1]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[customer] for customer in customers)\n        if total_demand <= capacity:\n            # Insert customers into the longest route using a greedy approach\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                # Try inserting all customers at position i\n                temp_route = np.insert(longest_route, i, customers)\n                cost = sum(distance_matrix[temp_route[j-1], temp_route[j]] for j in range(1, len(temp_route)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n            # Update the longest route\n            selected_solution[longest_route_idx] = np.insert(longest_route, best_pos, customers)\n            # Remove the now-empty shortest route\n            selected_solution.pop(shortest_route_idx)\n\n    # Step 4: Apply adaptive 2-opt on the longest route\n    longest_route = selected_solution[longest_route_idx].copy()\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(longest_route) - 2):\n            for j in range(i + 2, len(longest_route) - 1):\n                # Create a new route by reversing the segment between i and j\n                new_route = np.concatenate([\n                    longest_route[:i],\n                    longest_route[i:j+1][::-1],\n                    longest_route[j+1:]\n                ])\n\n                # Check capacity constraint\n                current_demand = 0\n                feasible = True\n                for node in new_route[1:-1]:  # Skip depot\n                    current_demand += demand[node]\n                    if current_demand > capacity:\n                        feasible = False\n                        break\n\n                if feasible:\n                    # Calculate the change in distance\n                    old_distance = (distance_matrix[longest_route[i-1], longest_route[i]] +\n                                  distance_matrix[longest_route[j], longest_route[j+1]])\n                    new_distance = (distance_matrix[new_route[i-1], new_route[i]] +\n                                  distance_matrix[new_route[j], new_route[j+1]])\n\n                    if new_distance < old_distance:\n                        longest_route = new_route.copy()\n                        improved = True\n                        break\n            if improved:\n                break\n\n    # Update the longest route in the solution\n    selected_solution[longest_route_idx] = longest_route\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection favoring solutions with lower total distance and makespan, then applies a hybrid local search combining route reversal and cross-route insertion to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=normalized_weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route reversal and cross-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route for reversal\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depot\n\n        # Reverse the route if it improves makespan\n        reversed_route = np.concatenate([[0], np.flip(route), [0]])\n        if np.sum(distance_matrix[reversed_route[:-1], reversed_route[1:]]) <= np.sum(distance_matrix[new_solution[route_idx][:-1], new_solution[route_idx][1:]]):\n            new_solution[route_idx] = reversed_route\n\n        # Cross-route insertion: move a random customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n\n            from_route = new_solution[from_route_idx][1:-1]\n            to_route = new_solution[to_route_idx][1:-1]\n\n            if len(from_route) > 0:\n                customer_idx = random.randint(0, len(from_route) - 1)\n                customer = from_route[customer_idx]\n\n                # Check capacity constraint for the target route\n                if np.sum(demand[to_route]) + demand[customer] <= capacity:\n                    # Insert the customer into the target route\n                    insert_pos = random.randint(0, len(to_route))\n                    new_to_route = np.insert(to_route, insert_pos, customer)\n                    new_to_route = np.concatenate([[0], new_to_route, [0]])\n\n                    # Update the routes\n                    new_from_route = np.delete(from_route, customer_idx)\n                    new_from_route = np.concatenate([[0], new_from_route, [0]])\n\n                    new_solution[from_route_idx] = new_from_route\n                    new_solution[to_route_idx] = new_to_route\n\n    return new_solution\n\n",
        "score": [
            -0.5879747567733014,
            0.8726060092449188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for (_, obj) in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=normalized_weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route reversal and cross-route insertion\n    if len(new_solution) > 1:\n        # Randomly select a route for reversal\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depot\n\n        # Reverse the route if it improves makespan\n        reversed_route = np.concatenate([[0], np.flip(route), [0]])\n        if np.sum(distance_matrix[reversed_route[:-1], reversed_route[1:]]) <= np.sum(distance_matrix[new_solution[route_idx][:-1], new_solution[route_idx][1:]]):\n            new_solution[route_idx] = reversed_route\n\n        # Cross-route insertion: move a random customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            to_route_idx = random.choice([i for i in range(len(new_solution)) if i != from_route_idx])\n\n            from_route = new_solution[from_route_idx][1:-1]\n            to_route = new_solution[to_route_idx][1:-1]\n\n            if len(from_route) > 0:\n                customer_idx = random.randint(0, len(from_route) - 1)\n                customer = from_route[customer_idx]\n\n                # Check capacity constraint for the target route\n                if np.sum(demand[to_route]) + demand[customer] <= capacity:\n                    # Insert the customer into the target route\n                    insert_pos = random.randint(0, len(to_route))\n                    new_to_route = np.insert(to_route, insert_pos, customer)\n                    new_to_route = np.concatenate([[0], new_to_route, [0]])\n\n                    # Update the routes\n                    new_from_route = np.delete(from_route, customer_idx)\n                    new_from_route = np.concatenate([[0], new_from_route, [0]])\n\n                    new_solution[from_route_idx] = new_from_route\n                    new_solution[to_route_idx] = new_to_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and attempt to reallocate customers\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if merging part2 into another route is beneficial\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part2) - 2 > 20:  # Avoid overly long routes\n                continue\n            if sum(demand[part2[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                new_route = np.concatenate([other_route[:-1], part2[1:]])\n                new_solution[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n\n    # Verify feasibility and fix if necessary\n    for i, route in enumerate(new_solution):\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split the route into two if capacity is exceeded\n            total_demand = sum(demand[route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for j in range(1, len(route)-1):\n                current_demand += demand[route[j]]\n                if current_demand > capacity / 2:\n                    split_pos = j\n                    break\n            new_solution[i] = np.concatenate([route[:split_pos+1], [0]])\n            new_solution.insert(i+1, np.concatenate([[0], route[split_pos+1:]]))\n\n    return new_solution\n\n",
        "score": [
            -0.7379868028174894,
            0.8473407924175262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combine route merging and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts and attempt to reallocate customers\n        split_idx = len(route) // 2\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check if merging part2 into another route is beneficial\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) + len(part2) - 2 > 20:  # Avoid overly long routes\n                continue\n            if sum(demand[part2[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                new_route = np.concatenate([other_route[:-1], part2[1:]])\n                new_solution[i] = new_route\n                merged = True\n                break\n\n        if not merged:\n            new_solution.append(part1.copy())\n            new_solution.append(part2.copy())\n\n    # Verify feasibility and fix if necessary\n    for i, route in enumerate(new_solution):\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split the route into two if capacity is exceeded\n            total_demand = sum(demand[route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for j in range(1, len(route)-1):\n                current_demand += demand[route[j]]\n                if current_demand > capacity / 2:\n                    split_pos = j\n                    break\n            new_solution[i] = np.concatenate([route[:split_pos+1], [0]])\n            new_solution.insert(i+1, np.concatenate([[0], route[split_pos+1:]]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2)\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = route1[:-1] + route2[1:]  # Skip depots\n            new_solution[i] = np.array(merged_route)\n            del new_solution[j]\n\n    # Customer reallocation: Move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # If route has customers\n            # Randomly select a customer to move\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Find feasible routes to place the customer\n            feasible_routes = []\n            for i, other_route in enumerate(new_solution):\n                if other_route is route:\n                    continue\n                if sum(demand[node] for node in other_route) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                # Move customer to a random feasible route\n                target_route_idx = np.random.choice(feasible_routes)\n                new_solution[target_route_idx] = np.concatenate([\n                    new_solution[target_route_idx][:-1], [customer], [0]\n                ])\n                route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7741505780690618,
            3.439472407102585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2)\n        if total_demand <= capacity:\n            # Merge routes by inserting route2 into route1\n            merged_route = route1[:-1] + route2[1:]  # Skip depots\n            new_solution[i] = np.array(merged_route)\n            del new_solution[j]\n\n    # Customer reallocation: Move customers between routes to balance makespan\n    for route in new_solution:\n        if len(route) > 3:  # If route has customers\n            # Randomly select a customer to move\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Find feasible routes to place the customer\n            feasible_routes = []\n            for i, other_route in enumerate(new_solution):\n                if other_route is route:\n                    continue\n                if sum(demand[node] for node in other_route) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                # Move customer to a random feasible route\n                target_route_idx = np.random.choice(feasible_routes)\n                new_solution[target_route_idx] = np.concatenate([\n                    new_solution[target_route_idx][:-1], [customer], [0]\n                ])\n                route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm uses a hybrid local search strategy combining route fragmentation and reinsertion with demand-aware route merging to balance distance and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + demand-aware merging\n    for _ in range(2):  # Number of iterations\n        # Step 1: Randomly fragment a route\n        if len(new_solution) > 1:\n            frag_route_idx = np.random.randint(len(new_solution))\n            frag_route = new_solution[frag_route_idx]\n            if len(frag_route) > 4:  # Ensure we can split meaningfully\n                split_pos = np.random.randint(2, len(frag_route)-2)\n                new_route1 = frag_route[:split_pos+1]\n                new_route2 = frag_route[split_pos:]\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[frag_route_idx] = new_route1\n                    new_solution.insert(frag_route_idx+1, new_route2)\n\n        # Step 2: Demand-aware merging of routes\n        if len(new_solution) > 1:\n            # Find routes with complementary demands\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n\n                    if total_demand <= capacity:\n                        # Try to merge by connecting closest nodes\n                        last_node1 = route1[-2]\n                        first_node2 = route2[1]\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                        # Check distance improvement\n                        original_dist = (distance_matrix[last_node1, 0] +\n                                       distance_matrix[0, first_node2])\n                        new_dist = distance_matrix[last_node1, first_node2]\n\n                        if new_dist < original_dist:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7835178191876178,
            4.225071281194687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan descending\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + demand-aware merging\n    for _ in range(2):  # Number of iterations\n        # Step 1: Randomly fragment a route\n        if len(new_solution) > 1:\n            frag_route_idx = np.random.randint(len(new_solution))\n            frag_route = new_solution[frag_route_idx]\n            if len(frag_route) > 4:  # Ensure we can split meaningfully\n                split_pos = np.random.randint(2, len(frag_route)-2)\n                new_route1 = frag_route[:split_pos+1]\n                new_route2 = frag_route[split_pos:]\n\n                # Check capacity constraints\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[frag_route_idx] = new_route1\n                    new_solution.insert(frag_route_idx+1, new_route2)\n\n        # Step 2: Demand-aware merging of routes\n        if len(new_solution) > 1:\n            # Find routes with complementary demands\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n\n                    if total_demand <= capacity:\n                        # Try to merge by connecting closest nodes\n                        last_node1 = route1[-2]\n                        first_node2 = route2[1]\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                        # Check distance improvement\n                        original_dist = (distance_matrix[last_node1, 0] +\n                                       distance_matrix[0, first_node2])\n                        new_dist = distance_matrix[last_node1, first_node2]\n\n                        if new_dist < original_dist:\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original\n            return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{My novel algorithm performs a hybrid local search by first selecting a route with high makespan and then applying a demand-aware route splitting and merging operator to reduce the longest route while balancing demand constraints across vehicles.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high makespan (promising for improvement)\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Find the longest route (highest makespan)\n    longest_route_idx = 0\n    max_length = 0\n    for i, route in enumerate(selected_solution):\n        route_length = sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1))\n        if route_length > max_length:\n            max_length = route_length\n            longest_route_idx = i\n\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try to split the longest route into two routes\n    for split_pos in range(2, len(longest_route)-1):\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity constraints\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n            break\n\n    # Try to merge two routes if the split didn't help\n    if len(new_solution) == len(selected_solution):\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is possible\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n                if merged_demand <= capacity:\n                    # Replace the two routes with the merged one\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6733247297376598,
            0.4413949251174927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high makespan (promising for improvement)\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Find the longest route (highest makespan)\n    longest_route_idx = 0\n    max_length = 0\n    for i, route in enumerate(selected_solution):\n        route_length = sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1))\n        if route_length > max_length:\n            max_length = route_length\n            longest_route_idx = i\n\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try to split the longest route into two routes\n    for split_pos in range(2, len(longest_route)-1):\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Check capacity constraints\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Replace the original route with the two new routes\n            new_solution[longest_route_idx] = first_part\n            new_solution.append(second_part)\n            break\n\n    # Try to merge two routes if the split didn't help\n    if len(new_solution) == len(selected_solution):\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is possible\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                merged_demand = sum(demand[node] for node in merged_route[1:-1])\n\n                if merged_demand <= capacity:\n                    # Replace the two routes with the merged one\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n            else:\n                continue\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This function selects a solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route swapping and intra-route insertion to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[min(3, len(archive) - 1)][0].copy()\n\n    # Hybrid local search: combine route swapping and intra-route insertion\n    new_solution = selected_solution.copy()\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Step 1: Randomly select two routes\n    route_indices = list(range(len(new_solution)))\n    i, j = random.sample(route_indices, 2)\n    route_i = new_solution[i].copy()\n    route_j = new_solution[j].copy()\n\n    # Step 2: Try to swap a segment between routes\n    max_attempts = 3\n    for _ in range(max_attempts):\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            break\n\n        # Select a segment from route_i\n        start_i = random.randint(1, len(route_i) - 2)\n        end_i = random.randint(start_i, len(route_i) - 2)\n        segment_i = route_i[start_i:end_i + 1]\n        segment_demand_i = np.sum(demand[segment_i])\n\n        # Find a position in route_j where segment_i can be inserted\n        for pos_j in range(1, len(route_j)):\n            # Check capacity constraint\n            if np.sum(demand[np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])]) <= capacity:\n                # Insert segment_i into route_j\n                new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])\n                # Remove segment_i from route_i\n                new_route_i = np.concatenate([route_i[:start_i], route_i[end_i + 1:]])\n\n                # Check if routes are still valid (non-empty and depot-connected)\n                if len(new_route_i) >= 2 and len(new_route_j) >= 2:\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    return new_solution\n\n    # Step 3: If swapping fails, try intra-route insertion\n    for route_idx in random.sample(range(len(new_solution)), min(3, len(new_solution))):\n        route = new_solution[route_idx].copy()\n        if len(route) <= 3:\n            continue\n\n        # Select a segment to move\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end + 1]\n        segment_demand = np.sum(demand[segment])\n\n        # Try to insert the segment at a different position\n        for new_pos in range(1, len(route)):\n            if new_pos >= start and new_pos <= end + 1:\n                continue  # Skip if inserting at the same position\n\n            # Check capacity constraint\n            if np.sum(demand[np.concatenate([route[:new_pos], segment, route[new_pos:]])]) <= capacity:\n                # Remove the segment from the original position\n                new_route = np.concatenate([route[:start], route[end + 1:]])\n                # Insert the segment at the new position\n                new_route = np.concatenate([new_route[:new_pos], segment, new_route[new_pos:]])\n\n                # Check if route is still valid\n                if len(new_route) >= 2:\n                    new_solution[route_idx] = new_route\n                    return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5038200911628641,
            1.886724442243576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[min(3, len(archive) - 1)][0].copy()\n\n    # Hybrid local search: combine route swapping and intra-route insertion\n    new_solution = selected_solution.copy()\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Step 1: Randomly select two routes\n    route_indices = list(range(len(new_solution)))\n    i, j = random.sample(route_indices, 2)\n    route_i = new_solution[i].copy()\n    route_j = new_solution[j].copy()\n\n    # Step 2: Try to swap a segment between routes\n    max_attempts = 3\n    for _ in range(max_attempts):\n        if len(route_i) <= 2 or len(route_j) <= 2:\n            break\n\n        # Select a segment from route_i\n        start_i = random.randint(1, len(route_i) - 2)\n        end_i = random.randint(start_i, len(route_i) - 2)\n        segment_i = route_i[start_i:end_i + 1]\n        segment_demand_i = np.sum(demand[segment_i])\n\n        # Find a position in route_j where segment_i can be inserted\n        for pos_j in range(1, len(route_j)):\n            # Check capacity constraint\n            if np.sum(demand[np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])]) <= capacity:\n                # Insert segment_i into route_j\n                new_route_j = np.concatenate([route_j[:pos_j], segment_i, route_j[pos_j:]])\n                # Remove segment_i from route_i\n                new_route_i = np.concatenate([route_i[:start_i], route_i[end_i + 1:]])\n\n                # Check if routes are still valid (non-empty and depot-connected)\n                if len(new_route_i) >= 2 and len(new_route_j) >= 2:\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    return new_solution\n\n    # Step 3: If swapping fails, try intra-route insertion\n    for route_idx in random.sample(range(len(new_solution)), min(3, len(new_solution))):\n        route = new_solution[route_idx].copy()\n        if len(route) <= 3:\n            continue\n\n        # Select a segment to move\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start, len(route) - 2)\n        segment = route[start:end + 1]\n        segment_demand = np.sum(demand[segment])\n\n        # Try to insert the segment at a different position\n        for new_pos in range(1, len(route)):\n            if new_pos >= start and new_pos <= end + 1:\n                continue  # Skip if inserting at the same position\n\n            # Check capacity constraint\n            if np.sum(demand[np.concatenate([route[:new_pos], segment, route[new_pos:]])]) <= capacity:\n                # Remove the segment from the original position\n                new_route = np.concatenate([route[:start], route[end + 1:]])\n                # Insert the segment at the new position\n                new_route = np.concatenate([new_route[:new_pos], segment, new_route[new_pos:]])\n\n                # Check if route is still valid\n                if len(new_route) >= 2:\n                    new_solution[route_idx] = new_route\n                    return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Merge two shortest routes if demand allows, then optimize\n    if len(new_solution) > 1:\n        # Find two routes with the smallest total demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Check if merging is feasible\n        if route_demands[i] + route_demands[j] <= capacity:\n            # Merge routes i and j\n            merged_route = new_solution[i][:-1] + new_solution[j][1:]\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n            # Optimize the merged route using a modified 2-opt with demand constraints\n            improved = True\n            while improved:\n                improved = False\n                route = new_solution[-1]\n                n = len(route)\n                for a in range(1, n-2):\n                    for b in range(a+1, n-1):\n                        # Check demand constraint for the new segment\n                        segment_demand = sum(demand[route[a:b+1]])\n                        if segment_demand > capacity:\n                            continue\n                        # Create candidate route\n                        candidate = route[:a] + route[a:b+1][::-1] + route[b+1:]\n                        # Check if candidate is better\n                        if sum(distance_matrix[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) < sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route))):\n                            new_solution[-1] = candidate\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8334425169109372,
            0.4337930977344513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Merge two shortest routes if demand allows, then optimize\n    if len(new_solution) > 1:\n        # Find two routes with the smallest total demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Check if merging is feasible\n        if route_demands[i] + route_demands[j] <= capacity:\n            # Merge routes i and j\n            merged_route = new_solution[i][:-1] + new_solution[j][1:]\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n            # Optimize the merged route using a modified 2-opt with demand constraints\n            improved = True\n            while improved:\n                improved = False\n                route = new_solution[-1]\n                n = len(route)\n                for a in range(1, n-2):\n                    for b in range(a+1, n-1):\n                        # Check demand constraint for the new segment\n                        segment_demand = sum(demand[route[a:b+1]])\n                        if segment_demand > capacity:\n                            continue\n                        # Create candidate route\n                        candidate = route[:a] + route[a:b+1][::-1] + route[b+1:]\n                        # Check if candidate is better\n                        if sum(distance_matrix[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) < sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route))):\n                            new_solution[-1] = candidate\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reinsert customers into shorter routes\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip trivial routes (depot-depot or depot-customer-depot)\n            # Find the longest segment in the route (excluding depot)\n            max_dist = 0\n            split_pos = 1\n            for j in range(1, len(route)-1):\n                dist = distance_matrix[route[j-1]][route[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = j\n\n            # Split the route at the longest segment\n            first_part = route[:split_pos+1]\n            second_part = [0] + route[split_pos+1:]\n\n            # Check capacity feasibility for both parts\n            def check_capacity(r):\n                return sum(demand[r[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n            else:\n                # If splitting violates capacity, try inter-route insertion\n                customer = route[split_pos]\n                new_solution[i] = np.delete(route, split_pos)\n                inserted = False\n\n                # Find the best route to insert the customer into\n                for j, candidate_route in enumerate(new_solution):\n                    if j == i:\n                        continue\n                    for k in range(1, len(candidate_route)):\n                        # Try inserting customer at position k\n                        candidate_route_new = np.insert(candidate_route, k, customer)\n                        if sum(demand[candidate_route_new[1:-1]]) <= capacity:\n                            new_solution[j] = candidate_route_new\n                            inserted = True\n                            break\n                    if inserted:\n                        break\n\n                if not inserted:\n                    # If no feasible insertion found, revert to original route\n                    new_solution[i] = route\n\n    # Remove empty routes that may have been created\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6934760596946926,
            0.35716143250465393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Split long routes and reinsert customers into shorter routes\n    for i, route in enumerate(base_solution):\n        if len(route) > 3:  # Skip trivial routes (depot-depot or depot-customer-depot)\n            # Find the longest segment in the route (excluding depot)\n            max_dist = 0\n            split_pos = 1\n            for j in range(1, len(route)-1):\n                dist = distance_matrix[route[j-1]][route[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = j\n\n            # Split the route at the longest segment\n            first_part = route[:split_pos+1]\n            second_part = [0] + route[split_pos+1:]\n\n            # Check capacity feasibility for both parts\n            def check_capacity(r):\n                return sum(demand[r[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[i] = first_part\n                new_solution.append(second_part)\n            else:\n                # If splitting violates capacity, try inter-route insertion\n                customer = route[split_pos]\n                new_solution[i] = np.delete(route, split_pos)\n                inserted = False\n\n                # Find the best route to insert the customer into\n                for j, candidate_route in enumerate(new_solution):\n                    if j == i:\n                        continue\n                    for k in range(1, len(candidate_route)):\n                        # Try inserting customer at position k\n                        candidate_route_new = np.insert(candidate_route, k, customer)\n                        if sum(demand[candidate_route_new[1:-1]]) <= capacity:\n                            new_solution[j] = candidate_route_new\n                            inserted = True\n                            break\n                    if inserted:\n                        break\n\n                if not inserted:\n                    # If no feasible insertion found, revert to original route\n                    new_solution[i] = route\n\n    # Remove empty routes that may have been created\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A novel hybrid local search operator combines route segment swaps with demand-aware route merging and splitting to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1] / x[1][0], -x[1][0]))  # Prioritize high makespan/distance ratio, then higher distance\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap + demand-aware merging/splitting\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split routes at random points\n        split1 = np.random.randint(1, len(route1) - 1)\n        split2 = np.random.randint(1, len(route2) - 1)\n\n        # Create segments\n        seg1_a = route1[:split1 + 1]\n        seg1_b = route1[split1 + 1:]\n        seg2_a = route2[:split2 + 1]\n        seg2_b = route2[split2 + 1:]\n\n        # Check capacity constraints for new routes\n        def is_feasible(seg):\n            return np.sum(demand[seg]) <= capacity\n\n        # Generate candidate routes\n        candidates = [\n            [seg1_a, seg1_b],\n            [seg2_a, seg2_b],\n            [np.concatenate([seg1_a, seg2_b]), seg1_b],\n            [seg1_a, np.concatenate([seg2_a, seg1_b])],\n            [np.concatenate([seg1_a, seg2_b]), np.concatenate([seg2_a, seg1_b])]\n        ]\n\n        # Filter feasible candidates\n        feasible_candidates = []\n        for candidate in candidates:\n            if all(is_feasible(route) for route in candidate):\n                feasible_candidates.append(candidate)\n\n        if feasible_candidates:\n            # Select the candidate that most improves makespan/distance balance\n            best_candidate = min(feasible_candidates, key=lambda x: max(distance_matrix[np.roll(route, -1)][:, np.arange(len(route))].sum() for route in x))\n\n            # Replace the selected routes\n            new_solution[route1_idx] = best_candidate[0]\n            new_solution[route2_idx] = best_candidate[1]\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # If no improvement, try demand-aware merging\n    if len(new_solution) > 1:\n        # Find routes with complementary demands\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                total_demand = np.sum(demand[new_solution[i]]) + np.sum(demand[new_solution[j]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.862780976122347,
            2.2775617241859436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1] / x[1][0], -x[1][0]))  # Prioritize high makespan/distance ratio, then higher distance\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap + demand-aware merging/splitting\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split routes at random points\n        split1 = np.random.randint(1, len(route1) - 1)\n        split2 = np.random.randint(1, len(route2) - 1)\n\n        # Create segments\n        seg1_a = route1[:split1 + 1]\n        seg1_b = route1[split1 + 1:]\n        seg2_a = route2[:split2 + 1]\n        seg2_b = route2[split2 + 1:]\n\n        # Check capacity constraints for new routes\n        def is_feasible(seg):\n            return np.sum(demand[seg]) <= capacity\n\n        # Generate candidate routes\n        candidates = [\n            [seg1_a, seg1_b],\n            [seg2_a, seg2_b],\n            [np.concatenate([seg1_a, seg2_b]), seg1_b],\n            [seg1_a, np.concatenate([seg2_a, seg1_b])],\n            [np.concatenate([seg1_a, seg2_b]), np.concatenate([seg2_a, seg1_b])]\n        ]\n\n        # Filter feasible candidates\n        feasible_candidates = []\n        for candidate in candidates:\n            if all(is_feasible(route) for route in candidate):\n                feasible_candidates.append(candidate)\n\n        if feasible_candidates:\n            # Select the candidate that most improves makespan/distance balance\n            best_candidate = min(feasible_candidates, key=lambda x: max(distance_matrix[np.roll(route, -1)][:, np.arange(len(route))].sum() for route in x))\n\n            # Replace the selected routes\n            new_solution[route1_idx] = best_candidate[0]\n            new_solution[route2_idx] = best_candidate[1]\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # If no improvement, try demand-aware merging\n    if len(new_solution) > 1:\n        # Find routes with complementary demands\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                total_demand = np.sum(demand[new_solution[i]]) + np.sum(demand[new_solution[j]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low makespan and total distance, then applies a hybrid local search combining route splitting, customer reinsertion, and route merging to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route splitting, customer reinsertion, and route merging\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion - move customers between routes intelligently\n    for _ in range(2):  # Try to reinsert 2 customers\n        if len(new_solution) < 2:\n            break  # Need at least 2 routes to reinsert\n\n        # Select a random route and customer (excluding depot)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 2:\n            continue  # Skip empty or single-customer routes\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n            other_route = new_solution[other_idx]\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                prev_node = other_route[pos - 1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform insertion\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_idx] = new_route\n\n                # Remove from original route\n                new_route_original = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n                new_solution[route_idx] = new_route_original\n                break  # Only reinsert one customer per iteration\n\n    # Step 3: Route merging - merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        shortest_indices = np.argsort(route_lengths)[:2]\n\n        route1_idx, route2_idx = shortest_indices[0], shortest_indices[1]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Try to merge routes\n            # Find best connection between routes\n            best_cost = float('inf')\n            best_merge = None\n\n            # Try all possible connections (end of route1 to start of route2)\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Calculate merge cost\n                    cost = distance_matrix[route1[i - 1]][route2[j]] - distance_matrix[route1[i - 1]][route1[i]] - distance_matrix[route2[j - 1]][route2[j]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_merge = (i, j)\n\n            if best_merge:\n                i, j = best_merge\n                merged_route = np.concatenate([route1[:i], route2[j:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4823627067745994,
            0.4429720640182495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then by total distance\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route splitting, customer reinsertion, and route merging\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Route splitting - split long routes into two\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only split if route has more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only split one route per iteration\n\n    # Step 2: Customer reinsertion - move customers between routes intelligently\n    for _ in range(2):  # Try to reinsert 2 customers\n        if len(new_solution) < 2:\n            break  # Need at least 2 routes to reinsert\n\n        # Select a random route and customer (excluding depot)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 2:\n            continue  # Skip empty or single-customer routes\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Try to insert into another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n            other_route = new_solution[other_idx]\n\n            # Find best insertion position in other route\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                prev_node = other_route[pos - 1]\n                next_node = other_route[pos]\n                cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Check capacity constraint\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Perform insertion\n                new_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_idx] = new_route\n\n                # Remove from original route\n                new_route_original = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n                new_solution[route_idx] = new_route_original\n                break  # Only reinsert one customer per iteration\n\n    # Step 3: Route merging - merge short routes if possible\n    if len(new_solution) > 1:\n        # Find the two shortest routes\n        route_lengths = [len(route) for route in new_solution]\n        shortest_indices = np.argsort(route_lengths)[:2]\n\n        route1_idx, route2_idx = shortest_indices[0], shortest_indices[1]\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is possible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Try to merge routes\n            # Find best connection between routes\n            best_cost = float('inf')\n            best_merge = None\n\n            # Try all possible connections (end of route1 to start of route2)\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Calculate merge cost\n                    cost = distance_matrix[route1[i - 1]][route2[j]] - distance_matrix[route1[i - 1]][route1[i]] - distance_matrix[route2[j - 1]][route2[j]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_merge = (i, j)\n\n            if best_merge:\n                i, j = best_merge\n                merged_route = np.concatenate([route1[:i], route2[j:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined score of normalized total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and capacity-aware route merging to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = []\n    for sol, (dist, span) in archive:\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(s[1][0] for s in archive)\n        max_span = max(s[1][1] for s in archive)\n        normalized_dist = dist / max_dist if max_dist > 0 else 0\n        normalized_span = span / max_span if max_span > 0 else 0\n        score = 0.7 * normalized_dist + 0.3 * normalized_span  # Weighted sum\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, reinsertion, and merging\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Ensure route can be split\n            # Find split point (avoid splitting at depot)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Reinsert customers from new_route2 into existing routes or create new route\n            customers = new_route2[1:-1]\n            for customer in customers:\n                best_route = None\n                best_cost = float('inf')\n\n                # Try inserting into existing routes\n                for i, r in enumerate(new_solution):\n                    if i == route_idx:\n                        continue\n                    for pos in range(1, len(r)):\n                        # Check capacity constraint\n                        route_demand = sum(demand[c] for c in r)\n                        if route_demand + demand[customer] > capacity:\n                            continue\n                        # Calculate insertion cost\n                        cost = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = (i, pos)\n\n                if best_route:\n                    i, pos = best_route\n                    new_solution[i] = np.insert(new_solution[i], pos, customer)\n                else:\n                    # Create new route if no feasible insertion\n                    new_solution.append(np.array([0, customer, 0]))\n\n            # Remove the original split route if it's now empty\n            if len(new_route1) == 2:\n                del new_solution[route_idx]\n            else:\n                new_solution[route_idx] = new_route1\n\n    # Capacity-aware route merging\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route_idx1, route_idx2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[c] for c in route1) + sum(demand[c] for c in route2)\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_idx1] = merged_route\n            del new_solution[route_idx2]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.699779881320967,
            8.748525112867355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = []\n    for sol, (dist, span) in archive:\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(s[1][0] for s in archive)\n        max_span = max(s[1][1] for s in archive)\n        normalized_dist = dist / max_dist if max_dist > 0 else 0\n        normalized_span = span / max_span if max_span > 0 else 0\n        score = 0.7 * normalized_dist + 0.3 * normalized_span  # Weighted sum\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, reinsertion, and merging\n    if len(new_solution) > 1:\n        # Select a random route to split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Ensure route can be split\n            # Find split point (avoid splitting at depot)\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Reinsert customers from new_route2 into existing routes or create new route\n            customers = new_route2[1:-1]\n            for customer in customers:\n                best_route = None\n                best_cost = float('inf')\n\n                # Try inserting into existing routes\n                for i, r in enumerate(new_solution):\n                    if i == route_idx:\n                        continue\n                    for pos in range(1, len(r)):\n                        # Check capacity constraint\n                        route_demand = sum(demand[c] for c in r)\n                        if route_demand + demand[customer] > capacity:\n                            continue\n                        # Calculate insertion cost\n                        cost = distance_matrix[r[pos-1], customer] + distance_matrix[customer, r[pos]] - distance_matrix[r[pos-1], r[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = (i, pos)\n\n                if best_route:\n                    i, pos = best_route\n                    new_solution[i] = np.insert(new_solution[i], pos, customer)\n                else:\n                    # Create new route if no feasible insertion\n                    new_solution.append(np.array([0, customer, 0]))\n\n            # Remove the original split route if it's now empty\n            if len(new_route1) == 2:\n                del new_solution[route_idx]\n            else:\n                new_solution[route_idx] = new_route1\n\n    # Capacity-aware route merging\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route_idx1, route_idx2 = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route_idx1]\n        route2 = new_solution[route_idx2]\n\n        # Check if merging is feasible\n        total_demand = sum(demand[c] for c in route1) + sum(demand[c] for c in route2)\n        if total_demand <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_idx1] = merged_route\n            del new_solution[route_idx2]\n\n    # Ensure all routes start and end with depot\n    for route in new_solution:\n        if route[0] != 0 or route[-1] != 0:\n            route[0] = 0\n            route[-1] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{A novel hybrid local search strategy that combines route segment swapping with demand-aware route balancing to reduce both total distance and makespan while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)  # Balance between makespan and distance\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: route segment swapping with demand-aware balancing\n    new_solution = base_solution.copy()\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes\n    route_idx1, route_idx2 = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route_idx1]\n    route2 = new_solution[route_idx2]\n\n    # Find feasible segments to swap\n    def get_feasible_segments(route, other_route_demand):\n        segments = []\n        for i in range(1, len(route)-1):\n            for j in range(i+1, len(route)):\n                segment_demand = sum(demand[route[i:j+1]])\n                if segment_demand + other_route_demand <= capacity:\n                    segments.append((i, j))\n        return segments\n\n    segments1 = get_feasible_segments(route1, sum(demand[route2[1:-1]]))\n    segments2 = get_feasible_segments(route2, sum(demand[route1[1:-1]]))\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Select random segments\n    i1, j1 = random.choice(segments1)\n    i2, j2 = random.choice(segments2)\n\n    # Create new routes by swapping segments\n    new_route1 = np.concatenate([route1[:i1], route2[i2:j2+1], route1[j1+1:]])\n    new_route2 = np.concatenate([route2[:i2], route1[i1:j1+1], route2[j2+1:]])\n\n    # Update solution\n    new_solution[route_idx1] = new_route1\n    new_solution[route_idx2] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8023449201739972,
            1.2412676811218262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1] * 0.7 + x[1][0] * 0.3)  # Balance between makespan and distance\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: route segment swapping with demand-aware balancing\n    new_solution = base_solution.copy()\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes\n    route_idx1, route_idx2 = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route_idx1]\n    route2 = new_solution[route_idx2]\n\n    # Find feasible segments to swap\n    def get_feasible_segments(route, other_route_demand):\n        segments = []\n        for i in range(1, len(route)-1):\n            for j in range(i+1, len(route)):\n                segment_demand = sum(demand[route[i:j+1]])\n                if segment_demand + other_route_demand <= capacity:\n                    segments.append((i, j))\n        return segments\n\n    segments1 = get_feasible_segments(route1, sum(demand[route2[1:-1]]))\n    segments2 = get_feasible_segments(route2, sum(demand[route1[1:-1]]))\n\n    if not segments1 or not segments2:\n        return new_solution\n\n    # Select random segments\n    i1, j1 = random.choice(segments1)\n    i2, j2 = random.choice(segments2)\n\n    # Create new routes by swapping segments\n    new_route1 = np.concatenate([route1[:i1], route2[i2:j2+1], route1[j1+1:]])\n    new_route2 = np.concatenate([route2[:i2], route1[i1:j1+1], route2[j2+1:]])\n\n    # Update solution\n    new_solution[route_idx1] = new_route1\n    new_solution[route_idx2] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    }
]